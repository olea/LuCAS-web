<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Artículo para la revista Linux Actual número 17: Bases de datos en WWW con Perl embedido: ¿Cómo se programa con Perl embebido?</TITLE>
 <LINK HREF="bd4-6.html" REL=next>
 <LINK HREF="bd4-4.html" REL=previous>
 <LINK HREF="bd4.html#toc5" REL=contents>
</HEAD>
<BODY>
<A HREF="bd4-6.html">Next</A>
<A HREF="bd4-4.html">Previous</A>
<A HREF="bd4.html#toc5">Contents</A>
<HR>
<H2><A NAME="s5">5. ¿Cómo se programa con Perl embebido?</A></H2>

<P>
<P>El primer ejemplo que aquí se muestra, servirá para introducir la
sintaxis básica del lenguaje y al mismo tiempo para comprobar que
nuestro sistema está funcionando y procesa nuestros ficheros
.epl. Pero antes necesitamos tener el esqueleto de un archivo escrito
en HTML corriente en el que podamos empotrar nuestro código Perl.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Pruebas de Embperl&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Este es nuestro fichero de pruebas&lt;/H1&gt;

En este fichero todavía no hay nada que tenga que ver con Perl embebido.

&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>El lector que todavía no tenga claro si su servidor web está
funcionando puede comprobarlo copiando este código en un fichero y
poniendo en las localizaciones típicas (pruebe a ponerlo en
<CODE>/var/www/</CODE> aunque debería mirar la variable DocumentRoot en su configuración de Apache).
<P>
<P>Ahora comenzaremos a añadir capacidad de proceso a este archivo. En
primer lugar parece bastante lógico que cuando insertemos nuestro Perl
en el html tendremos que separarlo de alguna manera, para que el
intérprete reconozca lo que tiene que procesar y lo que no (el resto
del html). Esto en Perl embebido se hace con corchetes. Una sentencia
típica podría tener el siguiente aspecto.
<P>
<BLOCKQUOTE><CODE>
<PRE>
        [- $variable1 = "Hola"; -]
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>El grupo de caracteres &quot;[-&quot; y &quot;-]&quot; delimitan
bloques de código perl dentro del HTML. Cualquier cosa que esté
incluida entre estos símbolos será interpretada como código Perl. Tan
sólo hay que preocuparse de terminar las sentencias con
&quot;;&quot; tal y cómo haríamos en un archivo de Perl corriente.
Lo que hemos hecho en la línea anterior es una simple asignación, la
variable &quot;$variable1&quot; contendrá ahora la cadena de texto
&quot;Hola&quot;. Al programador Perl que vea esto lo más probable
es que se le ocurra introducir sentencias con la instrucción
&quot;print&quot; dentro de los delimitadores que acabamos de
aprender. Sin embargo, Perl no sabría dónde tiene que imprimir el
resultado de la variable. El siguiente trozo de código es incorrecto
sólo por la declaración en la que aparece la instrucción
<EM>print</EM>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        [- 
           $variable1 = "Hola";
           $suma = 1 + 2;
           if ($suma > 0) {
             $texto = "Mayor que cero";
             print $texto; # Esta es la línea incorrecta
           } 
           $variable2 = $variable1
         -] 
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Pero entonces ¿cómo imprimimos el resultado de nuestros cálculos (o de
nuestras operaciones interactivas) en la página web? Muy fácil,
usaremos otros delimitadores: &quot;[+&quot; y &quot;+]&quot;. El
siguiente listado muestra un ejemplo muy sencillo de cómo podemos
imprimir el resultado de una variable asignada previamente en nuestro
código, ya incluido dentro de nuestra página de prueba:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        
  &lt;HTML&gt;
   &lt;HEAD&gt;
    &lt;TITLE&gt;Pruebas de Embperl&lt;/TITLE&gt;
   &lt;/HEAD&gt;
   &lt;BODY&gt;
    &lt;H1&gt;Este es nuestro fichero de pruebas&lt;/H1&gt;

     [- $variable1 = "hola";
        $variable2 = ", ¿qué tal?" -]

     [+ $variable1 +]

   &lt;/BODY&gt;
  &lt;/HTML&gt;
</PRE>
</CODE></BLOCKQUOTE>
<P>Con este ejemplo, ya podemos comprobar que Embperl está procesando
nuestro fichero. Si nombramos al archivo que contiene el código
anterior &quot;prueba.epl&quot;, lo situamos en el mismo lugar donde ya tengamos
páginas funcionando e intentamos acceder a él desde el exterior,
deberíamos ver algo como la figura nº 1.
<P>****** IMAGEN 1 ****************************
<P>
<P>En este punto hay que aclarar algunas cuestiones que se pueden
plantear habiendo visto los ejemplos anteriores. En primer lugar, como
ya aparece implícito en los ejemplos anteriores, dentro de los
delimitadores &quot;[-&quot; y &quot;-]&quot; podemos escribir
código en varias líneas, e incluso poner comentarios. El último
&quot;;&quot; que pongamos dentro de este código es opcional, ya que
Embperl lo cierra por nosotros en caso de que no nos demos cuenta.
<P>
<P>Podemos incluir cuantos grupos de código queramos, y todos
<EM>comparten el mismo espacio de variables dentro de una misma página
y una misma llamada</EM>. Esto quiere decir por un lado que podemos
dotar a las variables de un valor en un grupo de código y luego usar
esa variable (que ya contiene el valor que le hemos asignado
previamente) en otro grupo, y por otra parte que si un usuario desde
Internet decide hacer una recarga de nuestra página, los valores de
las variables no se conservarán.
<P>
<P>Dentro de los delimitadores de impresión en la página ([+ +]) podemos
poner cualquier cosa que pudiera ser argumento de la función
print. Por ejemplo, si queremos que la página descrita unos párrafos
más arriba sea un poco más educada, podemos sustituir la línea &quot;[+
$variable1 +]&quot; por esta otra &quot;[+ &quot;$variable1.$variable2&quot; +]&quot;
<P>
<P>Cuando decimos que podemos incluir código dentro de nuestra página,
también quiere decir que puede haber bucles, condiciones y cualquiera
de las posibilidades de control de flujo de un programa que perl nos
brinda (que no son pocas). Pero el verdadero poder que nos brinda Perl
en una página web es la posibilidad de iterar y condicionar no sólo la
ejecución de una parte programada, sino <EM>también las etiquetas HTML
y sus contenidos</EM>. Para explicar mejor esto, ponemos un ejemplo:
<P>
<P>Necesitamos que nuestra página enseñe una imagen si el resultado de un
cálculo anterior es mayor que 5, y en caso contrario, que muestre un
texto de cabecera de primer nivel (&lt;H1&gt;). Para hacer esto utilizaremos
lo que se denomina en Embperl <EM>Meta-comandos</EM>; aunque el nombre
asusta un poco, tan sólo se trata de separar las sentencias Perl de
bifurcación e iteración en bloques separados. Por ejemplo [$ if
(condición) $] que hay que terminar con [$ endif $]. A continuación
listamos el código que implementa el problema enunciado al principio
del párrafo.
<P>
<BLOCKQUOTE><CODE>
<PRE>
  &lt;HTML&gt;
    &lt;HEAD&gt;
      &lt;TITLE&gt;Pruebas de Embperl&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;
      &lt;H1&gt;Este es nuestro fichero de pruebas&lt;/H1&gt;
       [- 
         $variable=7;   #aquí podría haber algo más complicado.
       -]
       [$ if ($condicion&gt;5) $]
         &lt;IMG SRC=imagen.gif&gt;
       [$ else $]
         &lt;H1&gt;La variable es menor o igual a 5, mis disculpas.&lt;/H1&gt;
       [$ endif $]
   &lt;/BODY&gt;
  &lt;/HTML&gt;
</PRE>
</CODE></BLOCKQUOTE>
<P>Desde el punto de vista de la programación Perl choca un poco el hecho
de que haya que cerrar cada una de las sentencias, pero con un poco de
detenimiento podrá el lector observar que si no se le indicara al
intérprete la finalización del bucle o la condición éste no podría
determinar sobre que trozo de código iterar o decidir.  Además del
meta-comando que acabamos de utilizar existe uno para cada sentencia
de control de flujo de Perl. A continuación listamos unos cuantos con
sus sentencias de cierre como referencia.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        [$ if (condicion) $]            
        [$ elseif (condicion) $]                
            ...                        
        [$ else $]      
        [$ endif $]     
        
        [$ do $]
        [$ until $]

        [$ while (condicion) $]
        [$ endwhile $]         

        [$ foreach $var (lista) $]
        [$ endforeach $]
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Pero el ejemplo descrito anteriormente no resulta de mucha utilidad,
en primer lugar porque siempre producirá la misma salida. Nuestra
próxima tarea será interactuar con el usuario.
<P>
<P>La manera más directa y usual para interactuar con el usuario a través
de una página web es un formulario. Embperl nos permite acceder
fácilmente a la información proveniente de los formularios que se ha
enviado a nuestra pagina-Embperl_script. Para eso existe una
estructura de tipo &quot;hash&quot; (tambien llamada array
asociativo) con la cual podemos acceder directamente a estos
datos. Este &quot;hash&quot; se llama %fdat contiene la información
enviada de la siguiente forma:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        %fdat = (
                  nombre_del_campo  => información_del_campo,
                  nombre_otro_campo => información_del_otro_campo
                )
</PRE>
</CODE></BLOCKQUOTE>
<P>Para verlo más claro supongamos que una página web que hemos hecho de
antemano (que no tiene porqué tener nada que ver con Embperl) contiene
las siguientes líneas:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        &lt;FORM METHOD="POST" ACTION="prueba.epl"&gt;
        Ponga su comentario:&lt;INPUT TYPE="text" NAME="comentario"&gt;&lt;BR&gt;
        Y su nombre:    &lt;INPUT TYPE="text" NAME="nombre"&gt;&lt;BR&gt;
        &lt;INPUT TYPE="submit" NAME="enviar" VALUE="enviar"&gt;
        &lt;/FORM&gt;
</PRE>
</CODE></BLOCKQUOTE>
<P>Cuando el usuario de esta página pulsa el botón en el que pone
&quot;enviar&quot;, el navegador envía una petición http de la
página-script &quot;prueba.epl&quot; (la que ahora nos ocupa)
incluyendo la información del formulario que hemos descrito un poco
antes. Para saber si el usuario que lo ha mandado ha tecleado en el
campo de nombre la información &quot;pepe&quot;, y obrar en
consecuencia, podríamos incluir en nuestra página el siguiente código:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        [$ if ($fdat{nombre} eq "Pepe") $]
        [+ "¡Qué alegría Pepe, cuanto tiempo sin saber nada de tí!" +]
        [$ else $]
        Lo siento, [+ $fdat{nombre} +], pero no nos han presentado.&lt;br&gt;
        [$ endif $]
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Ahora tenemos una visión más amplia de lo que puede hacer Embperl por
la interactividad de nuestras páginas. Pero todavía no hemos abierto
la caja de Pandora, o mejor dicho CPAN, el archivo de módulos Perl.
<P>
<P>
<HR>
<A HREF="bd4-6.html">Next</A>
<A HREF="bd4-4.html">Previous</A>
<A HREF="bd4.html#toc5">Contents</A>
</BODY>
</HTML>
