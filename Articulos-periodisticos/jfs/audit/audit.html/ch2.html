<!doctype html public "-//W3C//DTD HTML 4.0//EN">

<html>

<head>

<title>Auditorías de Seguridad en GNU/Linux. - Auditores de seguridad</title>

<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">

</head>

<body>

<hr>

[ <a href="ch1.html">anterior</a> ]
[ <a href="index.html#abstract">Resumen</a> ]
[ <a href="index.html#copyright">Nota de Copyright</a> ]
[ <a href="index.html#contents">Contenidos</a> ]
[ <a href="ch3.html">siguiente</a> ]

<hr>

<h1>
Auditorías de Seguridad en GNU/Linux.<br>
Capítulo 2 Auditores de seguridad
</h1>

<hr>

<h2>
<a name="s2.1">2.1 ¿Qué son los programas auditores de seguridad?</a>
</h2>

<p>
Los programas auditores de seguridad son herramientas tremendamente útiles para
la administración de un sistema, ya que permiten detectar, de forma rutinaria,
problemas de seguridad para los que pudieran existir ataques conocidos.

<p>
Un programa auditor de seguridad debería ser capaz de detectarlos sin vulnerar
la integridad del sistema, es decir, no debería, por ejemplo, detectar que un
sistema es vulnerable a un ataque del tipo DoS (Denial of Service), dejando al
sistema &quot;colgado&quot;.  Este tipo de programas no sustituyen al sentido
común ni a la experiencia de un buen administrador, sino que suponen una ayuda
para realizar algunas tareas rutinarias que pueden llevar mucho tiempo a un
administrador normal.

<p>
Estos programas pueden operar a muchos niveles, desde la comprobación de la
pertenencia de archivos a usuarios y grupos del sistema hasta pruebas sobre
aplicaciones instaladas para verificar si éstas tienen agujeros conocidos.  Una
forma sencilla de demonstrarlo sería, por ejemplo, mirar la versión de ésta
última, y ver si se trata de una versión que tuviera un problema especialmente
grave.
</p>

<hr>

<h2>
<a name="s2.2">2.2 Los precursores: COPS, Tiger, Tripwire e ISS</a>
</h2>

<p>
Llamamos a estos programas precursores porque fueron los primeros que empezaron
a desarrollarse en la línea de automatizar las tareas del administrador para
vigilar la seguridad de la máquina.  Todos estos sugieron en el mundo UNIX al
principio de la decada de los 90, aunque algunos se mantienen aún hoy vigentes
o han sido &quot;remozados&quot; para adaptarlos a los nuevos tiempos.

<p>
COPS (Computer Oracle and Password System) es un paquete de herramientas de
seguridad disponible de forma pública.  Están diseñadas para ayudar a la tarea
de un administrador identificando problemas de seguridad en un sistema UNIX,
aunque no pretende arreglar las discrepancias que encuentra sino que
simplemente produce un informe de lo que ha encontrado y lo almacena o lo envía
por correo.  COPS fue realizado por Dan Farmer, uno de los creadores de SATAN y
distribuido el 31 de enero de 1989.

<p>
El paquete se divide en dos partes: un conjunto de programas que automatizan
comprobaciones rutinarias y la documentación para manejarlo e interpretar su
salida.  COPS requiere ser ejecutado en cada máquina a chequear y es
multiplataforma.  El programa inicialmente fue escrito en base a shell scripts
(en el intento de asegurar la portabilidad de éste) y en programas en C (para
aquellas acciones que necesitan ejecutarse rápidamente), la última versión de
este paquete (1.0.4, 6 de marzo de 1992) está realizada, además, en Perl.

<p>
COPS realiza un buen número de comprobaciones, con la intención de buscar
vulnerabilidades:

<ul>

<p>
<li>
chequeo de permisos de ficheros, directorios y dispositivos.
</li>

<p>
<li>
cracker de passwords a dos niveles, que de hecho ha sido realizado usando el
notorio <em>Crack</em> (ver más abajo).
</li>

<p>
<li>
comprobación del contenido, formato y seguridad de los ficheros de passwords y
ge grupo.
</li>

<p>
<li>
chequeo de programas que se ejecutan en /etc/rc* y en el cron.
</li>

<p>
<li>
búsqueda de programas setuid root, con permiso de escritura y avisa si son
shell scripts.
</li>

<p>
<li>
comprobación a través CRC de binarios y ficheros importantes para evitar
modificaciones.
</li>

<p>
<li>
comprobación de permisos de escritura en los directorios de los usuarios y de
sus ficheros de configuración.
</li>

<p>
<li>
comprobacion automática de avisos del CERT, descargándolos previamente y
comprobando si existe algún aviso nuevo para el tipo de máquina sobre el que se
ejecuta.
</li>

<p>
<li>
un sistema experto llamado Kuang que en base a una serie de reglas indica si el
sistema ha sido o no comprometido.
</li>

<p>
<li>
chequeos varios: directorios en el patg, hosts.equiv, exportaciones por NFS...
</li>

</ul>

<p>
Dado que no realiza ninguna modificación, no necesita ser ejecutado con
privilegios de superusuario (como &quot;root&quot;) sino que lo puede ejecutar
cualquier usuario.  Eso sí, para descubir parte de la información, como por
ejemplo analizar todos los ficheros con el bit setuid, puede que sea necesario
ejecutarlo como superusuario ya que puede que algunos ficheros (o directorios)
no tengan permisos de lectura para todo el mundo.

<p>
Junto con COPS se distribuye CARP (COPS Analysis and Reporting Program),
programa que realiza informes gráficos en base a los resultados de COPS.

<p>
Tiger es similar a COPS, pues se dedica a conseguir información que pueda
descubrir problemas de seguridad en máquinas UNIX pero está más actualizado que
COPS y más configurable.  La última versión disponible es de marzo de 1994.

<p>
Tiger, que toma el nombre de un equipo de futbol americano, es un conjunto de
Bourne shell scripts, programas en C y ficheros de datos que se usan para
realizar una auditoría de seguridad de sistemas UNIX.  Es multiplataforma,
entre ellas SunOS 4.x y 5.x.

<p>
Se desarrolló para escanear sistemas que se querían fueran accesibles desde el
exterior de un campus, y se ejecuta localmente.

<p>
El objetivo primordial de Tiger es analizar el sistema para tratar de encontrar
maneras de obtener privilegios de superusuario.  Su diseño parte de la
hipótesis de que cualquier otro uid o gid puede ser obtenido por personas no
autorizadas, es decir, que cualquie persona puede hacerse pasar por un usuario
cualquiera de la máquina, excepto, por supuesto, por el superusuario.

<p>
Algunos de los chequeos que reliza Tiger son:

<ul>

<p>
<li>
aliases de mail.
</li>

<p>
<li>
exportación por NFS.
</li>

<p>
<li>
variables de inetd.
</li>

<p>
<li>
variables del PATH.
</li>

<p>
<li>
ficheros .rhosts y .netrc.
</li>

<p>
<li>
permisos de ficheros y directorios.
</li>

<p>
<li>
avisa de la existencia de parches de mantenimiento.
</li>

<p>
<li>
paths que se encuentren en ficheros que den algún warning.
</li>

<p>
<li>
ofrece ayuda sobre todos los temas.
</li>

<p>
<li>
lanza automáticamente el CRACK.
</li>

</ul>

<p>
Tiger está disponible para Linux 2.x, gracias al trabajo realizado por Robert
L.  Ziegler, aunque la versión distribuida originalmente tenía soporte para
Linux 0.99.  Tiger tiene soporte para muchas arquitecturas, en función de la
arquitectura sobre la que se ejecuta se define las comprobaciones que va a
realizar.

<p>
Por otro lado tenemos a Tripwire, un programa que comprueba la integridad de
ficheros y directorios.  Genera, en su primera pasada información sobre éstos
en una base de datos, y posteriormente los comprueba y avisa de cualquier
diferencia (incluso borrados y añadidos).  Ejecutado de manera regular permite
encontrar cambios en ficheros críticos que podrían haber tenido lugar por la
entrada de un &quot;intruso&quot;.

<p>
Lo que Tripwire hace es marcar en la base de datos tanto los permisos y
usuarios de los ficheros como un código de redundancia cíclica (CRC) con el que
luego comprueba si ha sido modificado un determinado fichero.  El paquete
<code>tripwire</code> está disponible para Debian GNU/Linux.

<p>
Finalmente dentro de este tipo de programas y en la misma época, se encuentra
el ISS (Internet Security Scanner), de Christoper Klaus.  En un principio el
programa fue realizado por un interés, por parte del autor, de conocer los
problemas de seguridad en Internet en 1993.  Posteriormente, el autor creó una
compañía alrededor de este producto, y distinguió la versión comercial de la
versión de prueba, que carece de interfaz gráfico y de parte de la
funcionalidad que tiene la primera.

<p>
En cualquier caso ISS se trata de una de las primeras herramientas que, a pesar
de carecer del interfaz gráfico que luego proveerá SATAN y otras herramientas
posteriores, pone en marcha el desarrollo de herramientas auditoras de
seguridad de redes automatizadas.  COPS, TIGER y Tripwire constituyen el primer
paso ya que se tratan de herramientas que sólo ven el sistema sobre el que se
ejecutan y comprueban las vulnerabilidades en éste.  ISS es capaz de comprobar
vulnerabilidades comunes en una o varias subrededes (en la línea de comandos se
le dará un rango de una red que indica las máquinas que debe comprobar)

<p>
ISS es un programa monolítico escrito en C, que realiza comprobaciones sobre
los puertos abiertos en el servidor y de los servicios RPC ofrecidos, estudio
de las particiones exportadas por NFS, observación del servidor de correo,
comprobaciones sobre el NIS (antes llamado YP - Yellow Pages) y accesos
mediante telnet haciendo uso de pares de usuario/password comunes (que en
algunos casos venían de fábrica y no se modificaban).

<p>
ISS se convierte así en uno de los primeros programas que implementan estas
baterías de pruebas, de forma que para un administrador resulta más sencillo
comprobar todas las máquinas a su cargo de un sólo vistazo.  Más tarde, aunque
muy cercano en el tiempo, llegaría SATAN, causando una auténtica revolución.
</p>

<hr>

<h2>
<a name="s2.3">2.3 SATAN</a>
</h2>

<p>
SATAN es el acrónimo de Security Administrator Tool for Analyzing Networks (ver
listado <a href="apA.html#s-satan-curiosidad">Curiosidades de SATAN, Sección
A.1</a>).  Se trata, más que de un programa, de un conjunto de programas unidos
en un interfaz común.  Cuando éste fue escrito por Dan Farmen (programador de
COPS) y Wietse Venema de la Universidad de Tecnología de Eindhoven, lo que se
hizo fue poner una interfaz gráfica que ya se preveía poderosa, y al mismo
tiempo &quot;amigable&quot;, como es el WWW a un conjunto de programas, algunos
ya existentes y otros creados de cero por sus autores, que probaban
vulnerabilidades conocidas.

<p>
SATAN no es una herramienta novedosa en el aspecto técnico, pero causó una
auténtica revolución.  Las herramientas de este tipo, pueden convertirse, como
todas las herramientas, en utensilios útiles o en armas mortíferas.  Los
autores tuvieron la &quot;osadía&quot;, entonces, de poner el resultado de su
trabajo en Internet y permitiendo la distribución libre de binarios y fuentes.
Había otros programas disponibles libremente como COPS, para probar
vulnerabilidades en un sólo sistema, o el ISS, para probarlas en sistemas
remotos, pero este último, por ejemplo, carecía de suficiente funcionalidad y
de un interfaz gráfico en la versión pública, aunque sí en la versión
comercial.  Los autores decidieron distribuirlo de forma libre ya que su
experiencia les indicaba que los esfuerzos de limitar la distribución de
información de seguridad y herramientas para este fin no había mejorado las
cosas, dado que los elementos &quot;no deseables&quot; los conseguían de todas
formas y las personas que deberían haber tenido acceso a ellas no lo habían
tenido debido a limitaciones arbitrarias o injustas.

<p>
Esto tuvo como consecuencia una grave polémica, por la cual incluso uno de los
creadores fue despedido de su trabajo.  SATAN fue concebida como una
herramienta para admininistradores, pero también podía ser usada como un arma
por crackers.  Incluso se diseñaron programas para detectar &quot;ataques&quot;
de SATAN, como por ejemplo Courtney (desarollado por CIAC) o Gabriel.

<p>
El problema entonces, y también ahora, es que la mayor parte de los
administradores de sistemas no eran capaces de estar al tanto del conjunto de
agujeros de seguridad que salían en programas de uso frecuente en muchos
sistemas UNIX.  Un cracker, bien informado, podía hacer uso de estas
vulnerabilidades reconocidas (pero aún no resueltas), para atacar a sistemas
que aún no se habían actualizado a una versión del programa que resolviera los
fallos.

<p>
En un sistema concurren muchos servicios que se &quot;ven&quot; en el exterior,
como por ejemplo: servidores de WWW, de correo o de FTP, gestores de bases de
datos, exportación de discos via NFS, etc...  Estar al tanto de actualizaciones
de todos estos y de la forma en que pueden ser usados para obtener información
de un servidor que puede servir e intentar acceder a éste puede ocupar gran
parte del tiempo de un administrador de sistemas.

<p>
Estar al tanto de listas de distribución como bugtrack, los avisos del CERT
(ver listado <a href="apA.html#s-mas-info">Dónde buscar información relativa a
la seguridad, Sección A.4.1</a>) no es fácil y, además, si no se hace de forma
contínua se puede dejar un &quot;agujero&quot; que un intruso puede intentar
aprovechar.

<p>
SATAN abrió la polémica al poner en manos de todo el mundo un programa, de
fácil uso, que descubriera todas estas vulnerabilidades a un tiempo, a la vez
que ponía al descubierto información sobre las relaciones entre máquinas, lo
que los autores denominaron &quot;relación de Confianza&quot;.

<p>
SATAN obtiene tanta información como le es posible de servicios de red como
finger, NFS, NIS, ftp y tftp, rexd, y otros.  La información extraída no sólo
indica las fuentes por las que un intruso podría ganar información del sistema,
sino también fallos potenciales de seguridad generalmente debidos a una mala
configuración de estos servicios, problemas conocidos en herramientas de red o
malas políticas de seguridad.

<p>
Pero el concepto novedoso de SATAN es el extraer, de la información inicial y
con un conjunto de reglas configurables por el usuario, las relaciones de
dependencia entre máquinas o servicios dados de una a otra.  Esto hace posible
el análisis de todos los servidores de una red para analizar las implicaciones
de la política de confianza y servicios ofrecidos que, en palabras de los
autores &quot;les permitarán hacer decisiones razonables sobre el nivel de
seguridad de los sistemas involucrados&quot;.  Los autores de SATAN hablan de
confianza cuando recursos locales de un servidor (discos duros, acceso de
usuarios, servidores de X...) son usados por un cliente con o sin la
autorización debida.  Si el sistema X confía en el Y, un intruso que pueda
poner en peligro Y podrá también poner en peligro X.  Los autores indican que
cualquier tipo de confianza puede ser subvertida, no sólo porque se pueda
acceder a Y, sino porque el sistema que valida el acceso de Y pueda estar fuera
del control del administrador.  Por ejemplo, si se identifica a Y por el nombre
de la máquina y se subvierte el servidor de nombres (el DNS), o si se hace uso
de la técnica de IP spoofing para hacerle creer a X que otra máquina es Y.

<p>
A este respecto los autores de SATAN escribieron un excelente ensayo sobre
seguridad en sistemas UNIX y en Internet en general que se titula
&quot;Improving the Security of Your Site by Breaking Into It&quot;
(&quot;Mejorar la seguridad de su servidor entrando a la fuerza en él&quot;),
lectura recomendable para todos aquellos interesados en seguridad (ver listado
<a href="apA.html#s-mas-info">Dónde buscar información relativa a la seguridad,
Sección A.4.1</a>)

<p>
Hay que decir que SATAN es una herramienta que podría considerarse ya obsoleta,
las vulnerabilidades que intenta descubrir, eran comunes (y conocidas) cuando
fue diseñada, pero se tratan de &quot;agujeros&quot; que, hoy por hoy, deberían
estar &quot;tapados&quot;, si se detecta algunos de estos es debido a una
incompetencia por parte del administrador de la máquina.  Sin embargo, donde
aún sí resulta útil SATAN es en la función de recopilación de información y en
la aplicabilidad del concepto de confianza.
</p>

<hr>

<h3>
<a name="s2.3.1">2.3.1 Ejecución de SATAN</a>
</h3>

<p>
SATAN debe ser ejecutado como usuario <em>root</em> (superusuario) ya que
algunos de los tests que realiza necesita los requisitos de este usuario para
funcionar (ver listado <a href="apA.html#s-ejecutar-root">El problema de
ejecución de binarios como root, Sección A.2</a>).  Hace uso, por ejemplo, de
sockets abriéndolos como SOCK_RAW, para hacer accesos a bajo nivel de éstos.
Es posible ejecutar SATAN como cualquier otro usuario, pero algunos de los
tests, no funcionarán en absoluto.

<p>
Han existido algunos problemas a este respecto en la distribución de SATAN, ya
que si el programa se ejecuta como superusuario, y el código fuente está
disponible, es posible que algún desaprensivo distribuya una versión de SATAN
&quot;modificada&quot; de forma que, al ejecutarla, se introduciría un troyano
en el sistema, es decir, la copia modificada realiza más de lo que debería,
enviando información, por ejemplo, de nuestro sistema al exterior.  Por ello es
una buena medida obtener SATAN directamente de la fuente original y comprobar
que no ha sido modificado (mediante la suma MD5 del fichero recibido)

<p>
Para ejecutar SATAN hace falta Perl 5 (en este lenguaje están programados los
scripts que generan las páginas automáticamente y algunos de los tests) y un
navegador de WWW, bien sea textual (Lynx) o gráfico (Netscape Navigator o
similares).  Los programas que realizan las tareas de prueba sobre los diversos
sistemas se escribieron en C, perl o lenguaje de la shell, utilizando código
disponible en los grupos de noticias (comp.sources.misc.*), y de hecho es
posible añadir nuevos programas a todo el conjunto de la herramienta.  Otras
herramientas posteriores, como <a href="ch2.html#s-saint">SAINT, Sección
2.3.3</a>, que se comentarán más adelante, o <a
href="ch2.html#s-nessus">NESSUS, Sección 2.4</a>, hacen más fácil el introducir
nuevos programas mediante la descripción de reglas.

<p>
Cuando se arranca el programa, éste obtiene la configuración de los ficheros
localizados en el directorio <em>config/</em>.  Estos ficheros indican dónde se
encuentran herramientas habituales en entornos UNIX (como <em>finger</em> o
<em>ping</em>) así como el navegador de WWW que se utilizará (almacenado en la
variable <em>$MOSAIC</em>).  Estas herramientas serán utilizados por los
diversos programas de los que está compuesto SATAN, y se pueden configurar a
mano o bien utilizando el <em>script</em> proporcionado por los autores
(reconfig), que busca la localización de estas utilidades en el servidor en el
que se instale SATAN.

<p>
Seguidamente, lanzará un servidor de WWW y el navegador de WWW que se haya
configurado para acceder directamente a la página principal de SATAN.  Desde
ésta se seleccionará 'Run SATAN', posteriormente el servidor al que va a
acceder, se podrá limitar si se va a probar sobre el servidor o sobre su
subred, el nivel del escáner y finalmente 'Start the scan'.  El acceso al
servidor de WWW creado por SATAN (y que se encuentra en un puerto dedicado, en
el espacio de usuario, esto es, por encima del 1024), se realiza mediante una
llave de un sólo uso que SATAN genera para cada ejecución.  Dado que esta llave
se guarda en los ficheros HTML generados por SATAN, es importante que estos
ficheros tengan permisos de lectura sólo para el superusuario y no para otros.
Si no fuera así, cualquier usuario podría acceder al servidor de WWW con la
clave proporcionada en ellos y acceder a toda la información disponible sobre
los escáners realizados por el superusuario mientras SATAN está siendo
ejecutado.

<p>
En la selección de Objetivos el usuario puede seleccionar el nivel de ataque:
Ligero, Normal o Duro.  Un ataque &quot;Ligero&quot; sólo indicará los
servidores que existen y qué servicios de RPC (llamada remota a procedimiento)
ofrecen.  Un ataque &quot;Normal&quot; escaneará los objetivos probando
conexiones telnet, FTP, WWW, gopher y SMTP.  Se utilizará para establecer qué
sistema operativo es (aunque para esto es mejor QueSO, ver listado <a
href="apA.html#s-queso">QueSO, un programa que indica el SO, Sección
A.2.1</a>).  Un ataque &quot;Duro&quot; buscará otras vulnerabilidades, como
servidores de FTP que permiten escribir a todos los usuarios o servidores de
confianza.

<p>
SATAN puede ejecutarse con diversas opciones que indiquen qué servidor/es
probar y el nivel de ataque a utilizar, así como limitaciones en el número de
servidores a probar.  Además muestra de forma gráfica los resultados ordenando
las vulnerabilidades por tipos, organizadas de muy diversas maneras (por nivel
de riesgo, por sistema operativo...), aunque los autores indican que un trabajo
a realizar sería mostrar de forma más gráfica (quizás a través de un grafo) las
interrelaciones entre los servidores.  Existen además tutoriales que dan
información más en detalle de los problemas concretos de algunas de las
vulnerabilidades, que son útiles para que el administrador busque más
información antes de tomar una decisión sobre cómo arreglar el problema.

<p>
Toda la información recopilada sobre las distintas máquinas se almacena en una
base de datos (se puede tener más de una base de datos sobre máquinas), que se
mantiene entre ejecuciones del programa, y es útil para inferir relaciones
entre máquinas que las pueda hacer vulnerables.

<p>
Además SATAN es configurable con reglas (en el directorio <em>facts/</em>) que
le permiten inferir nueva información y detonar nuevos tests en función de los
servicios que se ofrezcan.  Estas reglas están escritas en Perl y, a través de
ellas se puede extender el programa con nuevos tests.  De hecho la decisión de
qué test realizar en función de la información recibida se encuentra en estas
reglas.
</p>

<hr>

<h3>
<a name="s2.3.2">2.3.2 Compilar SATAN para Linux</a>
</h3>

<p>
SATAN no fue desarrollado originalmente para GNU/Linux, sino que su
documentación indica que funciona en una gran variedad de sistemas UNIX: SunOS
4.x y 5.x, AIX, IRIX5, HP-UX 9.x, SYSV-R4 y Ultrix 4.x.  Sus autores destacan
que hace falta modificarlo para hacerlo funcionar bajo GNU/Linux.

<p>
De hecho es así, siendo necesario modificar los ficheros que se incluyen al
compilar el código fuente para hacerlo funcionar con la versión de la librería
de C de GNU/Linux.  Aunque los cambios difieren para libc5 y para libc6,
básicamente debido a la redefinición de la implementación de los formatos de
paquete de IP e ICMP en la librería estándar.  Esto se puede arreglar
modificando el fichero <code>lcompat.h</code> (que funciona para libc5) y
comentando toda la definición del paquete ip e icmp, para dejar que sea la
librería de C (viene definido en el fichero
<code>/usr/include/netinet/ip.h</code>) la que los defina.  Asimismo se puede
eliminar las referencias en el código fuente a la librería proporcionada en el
paquete, si se dispone de las cabeceras de la librería de C (en Debian las
proporciona el paquete <code>libc6-dev</code>) para compilar el programa.

<p>
Finalmente, para adaptarse a los &quot;nuevos tiempos&quot; y usar los módulos
de Perl instalados en el sistema en lugar de los proporcionados por el programa
(como es el caso del módulo que proporciona en Perl la función <em>getopts</em>
o <em>ctime</em>), es necesario cambiar ligeramente el programa principal
(<code>satan</code>) y algunos de los tests, que están escritos en Perl.

<p>
También los autores asumen el comportamiento de la llamada al sistema
<em>select</em> (que sirve para quedarse a la espera de recibir datos en
diversos descriptores) y se ha de modificar el fichero <code>tcp_scan.c</code>
que es el responsable de escanear todos los puertos TCP disponibles en un
servidor.

<p>
Todos estos cambios se han realizado en la versión de SATAN distribuida junto
con Debian.  Aunque para beneficio de los usuarios de GNU/Linux se puede usar
el fichero de diferencias (satan-1.1.1.diff.linux).  Utilizando este fichero,
realizado con el programa <code>diff</code>) se podrían modificar las fuentes
originales (haciendo uso del programa <code>patch</code>, ver página de manual
<code>patch(1)</code>).

<p>
En general, un usuario que instale SATAN dentro de una distribución de
GNU/Linux no tendrá que resolver estos problemas, dado que los responsables de
la distribución, presumiblemente, los habrán resuelto para que se integre
dentro de ésta.  Sin embargo no está de más conocerlo, caso de que se desee
obtener SATAN de la fuente original y recompilarlo antes de usarlo, algo
bastante aconsejable dado el hecho de que va a ser el usuario con los máximos
privilegios el que va a hacer uso de éste.

<p>
Para compilar SATAN para Linux, una vez realizados los cambios arriba
indicados, es necesario, desde el directorio raíz, ejecutar <em>make linux</em>
seguido de <em>perl reconfig</em>.  Posteriormente se puede configurar los
valores que ha obtenido automáticamente editando directamente, como ya se ha
dicho antes, los ficheros en el subdirectorio <code>config/</code>.
</p>

<hr>

<h3>
<a name="s-saint">2.3.3 SAINT</a>
</h3>

<p>
SAINT (Security Administrator's Integrated Network Tool) es un producto de
World Wide Digital Solutions Inc.  (WWDSI) derivado de SATAN, realizado en
1998.  En versiones previas no se distribuía bajo la misma licencia que SATAN,
aunque versiones posteriores se han distribuido bajo una licencia <em>Open
Source</em> (aunque no es la GPL).  Esta nueva licencia permite su distribución
por parte de aquellos que lo obtienen así como modificaciones, sin embargo no
se puede cobrar su uso más allá de los costes de distribución.  Las diferencias
con SATAN en cuanto a interfaz son mínimas, ambos hacen uso de un navegador de
WWW, y los pasos a dar para poner en marcha el programa son los mismos.

<p>
SAINT añade a SATAN lo que éste ahora mismo no tiene y es actualidad.  El
programa no sólo prueba las vulnerabilidades que contemplaba SATAN, sino que
añade comprobaciones de las vulnerabilidades conocidas hasta la fecha de su
creación.  Los tests incluyen comprobaciones sobre servidores de WWW, POP o
SMB, y nuevas reglas para dirigir el funcionamiento de éste.  Además, la
compañía que lo diseñó lo actualiza con cierta regularidad.

<p>
A todo esto hay que añadir muchos nuevos tutoriales, hasta un total de 43,
sobre las distintas vulnerabilidades que se puedan encontrar, que ayudan al
administrador dándole más información sobre el peligro de ésta y sobre cómo
eliminarlo.  Las vulnerabilidades están clasificadas en tres categorías:
Peligrosas (rojo), Proceder con Cautela (amarillo) o de Categoría Desconocida
(marrones), no en dos como en SATAN.

<p>
SAINT demuestra que es posible realizar un producto comercial sobre un producto
que se distribuye de forma gratuita, y con excelentes resultados.  Además se
trata de un programa que está siendo aún mantenido por la compañía que lo creo,
que acepta envíos de nuevos módulos para su inclusión en el programa.
</p>

<hr>

<h2>
<a name="s-nessus">2.4 NESSUS</a>
</h2>

<p>
Se han visto previamente herramientas, quizás ya algo antiguas, para intentar
introducir el concepto de auditores de seguridad.  Ahora toca el turno de
hablar de una herramienta de última generación para GNU/Linux, y este es el
caso de NESSUS (ver <code><a
href="http://www.nessus.org">http://www.nessus.org</a></code>).

<p>
NESSUS da un paso más alla en el diseño de herramientas de seguridad.  Con
SATAN (y SAINT) se vió que se podía introducir una gran capacidad para detectar
fallos comunes haciendo uso de un sencillo interfaz.  Pero el uso de un
interfaz WWW, aunque bueno por su facilidad de manejo (y porque quizás sea el
interfaz genérico más usado actualmente) plantea un problema respecto a la
autentificación de los administradores que hagan uso de SATAN en una máquina.

<p>
Por un lado obliga a que SATAN sea ejecutado localmente por parte del
administrador y a que luego éste lanze el navegador en la misma máquina, de
hecho es el primer paso que realiza SATAN.  El problema puede darse cuando se
quiera instalar SATAN en una máquina que carece de interfaz gráfico, es
necesario exportar la aplicación (el cliente de WWW) a través de la red a otra
que sí lo tenga.  Esto no es problema si el administrador usa <em>lynx</em> ya
que puede seguir utilizando un interfaz textual para la aplicación y ejecutar
el navegador en la conexión remota.

<p>
Si se desea también acceder desde un servidor a otro para ejecutar SATAN en
aquél, es necesario que el navegador de WWW envíe en todas las peticiones al
servidor de WWW que SATAN lanza, el número mágico que ha generado al arrancar y
se encuentra almacenado en los ficheros HTML.  Por ello la primera petición del
navegador es a un fichero (su URL es file://) y posteriormente al servidor (con
el URL http://).  Este número es la única prueba para SATAN de que el cliente
es quien dice ser, si cualquier otro intercepta este número y accede al
servidor de SATAN podrá acceder a toda la información almacenada en este, e
incluso ¡hacer sus propias pruebas de seguridad sobre otros servidores!  Esto
se podría evitar haciendo uso del protocolo seguro de conexión a servidores de
WWW, <em>https</em> (que usa el SSL de Netscape).

<p>
Esta situación no es del todo insospechada, ya que si el cliente y el servidor
están separados, los paquetes enviados de uno a otro, las solicitudes mediante
el protocolo HTTP y las respuestas mediante páginas en HTML, no están cifradas
ni van por un canal cifrado.  Cualquier &quot;espía&quot; en el camino de estos
datos podría sacar fácilmente el número utilizado como prueba de
autentificación del administrador.

<p>
NESSUS es una herramienta que consta de dos módulos separados.  De un lado el
servidor, que debe ser ejecutado como superusuario, que es el encargado de
realizar los tests y que funciona como un demonio en la máquina en la que se
lanza, y en el otro el cliente, que puede estar en otra máquina distinta.  La
comunicación entre ambos se hace a través de un protocolo (que los autores han
llamado NTP: Nessus Transfer Protocol) que, en su última versión (1 de febrero
de 1999: 990201) puede llevarse a cabo de forma cifrada (con clave
pública/privada), de forma que el servidor no podría ser usado por alguien que
&quot;espiara&quot; la red y fuera capaz de obtener la palabra clave utilizada.
Esta funcionalidad no estaba presente en la anterior versión estable del
programa (16 de octubre de 1998: 981016).

<p>
Si no se compila NESSUS con la opción de encriptación (<samp>./configure
--enable-cipher</samp>), sin embargo, la autenticación entre el cliente y el
servidor se realiza mediante un nombre de usuario y una palabra clave cuyo
intercambio debe darse antes de solicitarle ninguna acción al servidor.  Las
palabras clave están almacenadas en un fichero en el servidor, y es posible
limitar sobre qué máquinas puede realizar pruebas de seguridad a un usuario
dado.

<p>
Existen clientes para GNU/Linux, usando la librería gráfica <code>gtk</code>
(la última versión de NESSUS utiliza la versión 1.1), con la que se ha diseñado
el famoso programa <code>Gimp</code> y el entorno <code>GNOME</code> (ver
<code><a href="http://www.gnome.org">http://www.gnome.org</a></code>, pero
también los hay escritos en Java y para Windows NT.  El servidor, sin embargo,
ha de ejecutarse en un servidor Linux.  La interfaz gráfica con gtk (es
expléndida, con un buen aspecto y muy sencilla de manejar.  Además de todo
esto, y algo a destacar por su tremenda importancia, NESSUS está siendo
desarrollado bajo la licencia GPL, lo que significa que su modelo de desarrollo
es abierto (cualquiera puede colaborar) y que el código fuente del programa
está disponible para su revisión.

<p>
El diseño de NESSUS, como se puede ver en el código fuente, es muy modular.
Todos los tests (algunos los llamarían &quot;ataques&quot;) están escritos por
separado, y es fácil insertar nuevos programas.  Actualmente tiene más de 180
pruebas de seguridad de diversa índole, que el interfaz agrupa por tipos según
sean, por ejemplo: agujeros de sendmail, problemas con servidores de FTP,
problemas con servidores de WWW...  Aunque las vulnerabilidades no están tan
detalladas como en otras herramientas (veáse las anteriores), si se da una
breve descripción del problema y una ayuda de cómo solucionarlas.

<p>
Al igual que SATAN o SAINT, NESSUS puede expandir los servidores que conoce de
varias maneras: vía subredes de un dominio, haciendo uso del DNS o cuando ve
nuevos servidores a los que se les da acceso mediante NFS.  Se pueden definir
reglas para limitar a los servidores que va a acceder, de una forma más
compleja que hacía SATAN (y por ende SAINT), en éste es posible definir la
&quot;profundidad&quot; de la prueba y servidores que nunca serán probados,
pero en NESSUS es posible limitar de tres formas: no probar ('n'), sí probar
('y') y no probar <em>nunca</em> ('N').  Por ejemplo la regla: &quot;n:*;
y:*.foo.org; N:ppp*.foo.org&quot; probaría sólo sobre las máquinas en el
dominio foo.org (y:*.foo.org), excepto todas las máquinas en este dominio cuyo
nombre empezara por ppp (N:ppp*.foo.org), otras máquinas que se puedan
encontrar no serán probadas (n:*).

<p>
Los usuarios puede definir sus propias reglas, aunque existen unas reglas
predefinidas por defecto.  Las reglas se almacenan en el fichero
<code>/usr/local/share</code> (aunque si se instala un paquete de una
distribución en lugar de las fuentes originales, seguramente lo instale en
<code>/usr/share</code>).
</p>

<hr>

<h3>
<a name="s2.4.1">2.4.1 Instalar NESSUS</a>
</h3>

<p>
Si la distribución que usa el lector provee el paquete NESSUS, la instalación
de éste se limitará a instalar dicho paquete y configurarlo apropiadamente.
Este es el caso de Debian.  Sin embargo, si éste no es su caso, será necesario
obtener las fuentes originales (ver listado <a
href="apA.html#s-programas">Programas relacionados con la seguridad y dónde
encontrarlos., Sección A.3</a>).

<p>
Una vez obtenidas, se deben seguir los siguientes pasos para instalar el
programa:

<ul>

<p>
<li>
ejecutar <code>autoconf</code> seguido de <code>configure</code>, que hará uso
de herramientas GNU para configurar el programa a nuestro sistema.  En la
documentación indica que debe ser el superusuario el que ejecute este programa,
ya que para probar el tipo de ordenación de los sockets, es necesario
privilegios especiales.
</li>

<p>
<li>
ejecutar <code>make</code> para que compile los programas.  Este es un proceso
largo ya que ha de compilar cada uno de los tests de seguridad que luego se
convertirán en librerías que cargará dinámicamente.  Para compilar el programa
es necesario tener la versión de desarrollo de <code>gtk</code>, que incluye
las cabeceras (ficheros .h) para compilar programas que utilizen esta librería.
En Debian
</li>

<p>
<li>
ejecutar <em>make install</em>.  Los programas (<code>nessus</code> y
<code>nessusd</code>) así como las librerías y las páginas de manual serán
instaladas en el sistema.
</li>

</ul>

<p>
Una vez hecho esto la configuración, según indica la página de manual
<code>nessus(1)</code> , será creada al arrancar el programa
<code>nessusd</code> en el directorio <code>/usr/local/share/nessus</code>.  La
forma de configurarlo está perfectamente documentada en el Manual que acompaña
el programa.
</p>

<hr>

<h2>
<a name="s2.5">2.5 Gate Security</a>
</h2>

<p>
NESSUS no es el único programa de este estilo diseñado para GNU/Linux, también
existe <code>Gate Security</code>, de Stan Lanford, con un interfaz del tipo
curses (en consola).  El autor indica que es muy modular y que sería fácil de
ampliar con nuevos tests, ya que actualmente cuenta con tan sólo tres sobre los
servicios de: finger, NFS y WWW.  Está aún en fase de desarrollo (la última
versión de mayo de 1998 es la 0.1.4), así que quizás en su versión final sea un
programa a valorar.
</p>

<hr>

<h2>
<a name="s-smb-nat">2.6 smb-nat</a>
</h2>

<p>
Con este programa se pueden realizar varias comprobaciones de seguridad sobre
servidores remotos que estén compartiendo servicios de ficheros a través de
NetBIOS.  Está basado en el paquete <code>samba</code> y se encuentra
disponible en la distribución Debian GNU/Linux.
</p>

<hr>

[ <a href="ch1.html">anterior</a> ]
[ <a href="index.html#abstract">Resumen</a> ]
[ <a href="index.html#copyright">Nota de Copyright</a> ]
[ <a href="index.html#contents">Contenidos</a> ]
[ <a href="ch3.html">siguiente</a> ]

<hr>

Auditorías de Seguridad en GNU/Linux.<br>

<address>
15 feb 1999<br>
Javier Fernández-Sanguino Peña <code><a href="mailto:jfs@computer.org">jfs@computer.org</a></code>
</address>

</body>

</html>

