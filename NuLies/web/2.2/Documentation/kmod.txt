Kmod: El cargador de modulos del Kernel (The Kernel Module Loader)
Kirk Petersen
Traducido por Santiago Romero

Kmod es un simple reemplazo para kernenld. Consite en un reemplazo
de la función request_module() y un hilo (thread) del kernel llamado
kmod. Cuando el kernel necesita un módulo, kmod se despierta y
ejecuta modprobe mediante execve(), pasándole el nombre pedido.

Si tiene el sistema de ficheros /proc montado, puede especificar el
path para modprobe (donde el kernel lo buscará) haciendo:

	echo "/sbin/modprobe" > /proc/sys/kernel/modprobe

Para descargar periódicamente los módulos no usados, ponga algo
como lo sigueinte en una entrada de crontab del usuario root:

	0-59/5 * * * * /sbin/rmmod -a

Kmod sólo carga módulos. Kerneld podía hacer más (aunque nada en el
kernel estándard usaba sus otras funcionalidades). Si usted requiere
características como request_route, le sugerimos que tome una
aproximación similar. Una simple función request_rout podría ser
llamada, y un hilo kroute en el kernel ser ejecutado para hacer el
trabajo. Pero probablemente deberíamos mantener esto al mínimo.

Kerneld tenía también un mecanismo para almacenar las características
o parámetros de los drivers de dispositivo. Esto puede hacerse fácilmente
con modprobe. Cuando un módulo es descargado, modprobe podría mirar
en algun lugar de configuración para cada driver (/proc/sys/drivers/blah)
para almacenar en un fichero los parámetros de configuración del
driver de dispositivo. Cuando un módulo es cargado, simplemente debería
volcar dicho fichero en el lugar adecuado del sistema de ficheros /proc.
O tal vez un script podría ser un parámetro en /etc/modules.conf.
Hay muchas maneras que podría funcionar (yo prefiero usar /proc).

Si kerneld funcionaba, ¿por qué reemplazarlo?

- kerneld usaba SysV IPC, que ahora puede ser creado como módulo.
  Aparte, SysV IPC es feo y debería ser evitado (al menos por las
  cosas a nivel de kernel).

- Ambos Kmod y Kerneld acaban haciendo la misma cosa (llamar a
  modprobe), así que... ¿porque no evitar el hombre intermedio?

- eliminar las cosas relacionadas con kerneld de ipc/msg.c lo
  hizo un 40% más pequeño en tamaño.

- kmod informa de los errores a través de los mecanismos normales
  del kernel, lo cual evita el problema entre kerneld y los socks
  modulares de dominios Unix.
