<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Bash Prompt COMO: bash y sus prompts</TITLE>
 <LINK HREF="Bash-Prompt-Como-3.html" REL=next>
 <LINK HREF="Bash-Prompt-Como-1.html" REL=previous>
 <LINK HREF="Bash-Prompt-Como.html#toc2" REL=contents>
</HEAD>
<BODY>
<A HREF="Bash-Prompt-Como-3.html">Página siguiente</A>
<A HREF="Bash-Prompt-Como-1.html">Página anterior</A>
<A HREF="Bash-Prompt-Como.html#toc2">Índice general</A>
<HR>
<H2><A NAME="s2">2. <CODE>bash</CODE> y sus prompts</A></H2>

<H2><A NAME="ss2.1">2.1 ¿Qu&eacute; es <CODE>bash</CODE>?</A>
</H2>

<P>
<P>Descendiente del <I>Bourne Shell</I>, <CODE>bash</CODE> es un producto GNU, el
<I>Bourne Again Shell</I>. Es el interfaz est&aacute;ndar de l&iacute;nea de comandos en
la mayor&iacute;a de las m&aacute;quinas LiNUX. Potencia la interactividad, soportando
edici&oacute;n en l&iacute;nea de comando, capacidad de completar o recordar
autom&aacute;ticamente un comando, etc. Tambi&eacute;n soporta prompts configurables -
la mayor&iacute;a de la gente se da cuenta de esto, pero no saben hasta qu&eacute;
punto. 
<P>
<H2><A NAME="ss2.2">2.2 ¿Qu&eacute; puede aportar la manipulaci&oacute;n del prompt ?</A>
</H2>

<P>
<P>La mayor&iacute;a de los sistemas LiNUX tienen un prompt por defecto en un solo
color (normalmente gris) que indica el nombre de usuario, el nombre de la
m&aacute;quina en la que se est&aacute; trabajando y alguna indicaci&oacute;n acerca del
directorio de trabajo actual. Toda esta informaci&oacute;n es &uacute;til, pero se puede
ir mucho m&aacute;s all&aacute;: se puede mostrar todo tipo de informaci&oacute;n (n&uacute;mero de
«tty», hora, fecha, carga, n&uacute;mero de usuarios, tiempo sin reiniciar ...) y
el prompt puede usar colores ANSI, ya sea por razones puramente est&eacute;ticas,
o para remarcar cierta informaci&oacute;n. Tambi&eacute;n se puede manipular la barra de
t&iacute;tulo de una <CODE>xterm</CODE> para reflejar parte de esta informaci&oacute;n. 
<P>
<H2><A NAME="ss2.3">2.3 ¿Por qu&eacute; molestarse ?</A>
</H2>

<P>
<P>Adem&aacute;s de una apariencia bonita, en ocasiones es &uacute;til seguir la pista de
cierta informaci&oacute;n del sistema. Una idea que s&eacute; que gusta a la gente es
que es posible poner los prompts de diferentes m&aacute;quinas en diferentes
colores. Si se tienen varias terminales X abiertas en diferentes m&aacute;quinas,
o si se tiende a olvidar en qu&eacute; m&aacute;quina se est&aacute; trabajando y se borran
ficheros equivocados, encontrar&aacute; en esta una buena forma de recordar en
qu&eacute; m&aacute;quina se encuentra.
<P>
<H2><A NAME="ss2.4">2.4 El primer paso</A>
</H2>

<P>
<P>La apariencia del prompt viene dada por la variable del <I>shell</I>
<CODE>PS1</CODE>.  Las continuaciones de comandos se indican mediante la cadena
<CODE>PS2</CODE>, que puede modificarse de la misma forma que aqu&iacute; se comentan
--ya que el manejo es exactamente el mismo, y que no es tan
«interesante»--, casi siempre se van a tratar modificaciones de la cadena
<CODE>PS1</CODE> (Tambi&eacute;n existen las cadenas <CODE>PS3</CODE> y <CODE>PS4</CODE>. Estas nunca
est&aacute;n a la vista del usuario medio (vea la p&aacute;gina del manual sobre
<CODE>bash</CODE> si est&aacute; interesado en su prop&oacute;sito).
<P>Para cambiar el aspecto del prompt, hay que cambiar la variable <CODE>PS1</CODE>. 
Para experimentar, se pueden introducir cadenas <CODE>PS1</CODE> directamente
desde el prompt, y ver los resultados inmediatamente (esto s&oacute;lo afecta a
la sesi&oacute;n actual, y los cambios desaparecen cuando termina).  Si se desea
hacer permanentes estos cambios, modifique su <CODE>~/.bashrc</CODE>, y a&ntilde;ada
la nueva definici&oacute;n de <CODE>PS1</CODE>. Si tiene permisos de <CODE>root</CODE>, puede
mirar en <CODE>/etc/profile</CODE> y modificar all&iacute; la l&iacute;nea <CODE>PS1=</CODE>. Tenga
en cuenta que en algunas distribuciones (al menos en la <I>RedHat 5.1</I>) 
<CODE>/etc/bashrc</CODE> redefine los valores de <CODE>PS1</CODE> y <CODE>PS2</CODE>. 
<P>Antes de comenzar, es importante recordar que la cadena <CODE>PS1</CODE> se
almacena en el entorno como cualquier otra variable de entorno. Si se
modifica en la l&iacute;nea de comando, su prompt cambiar&aacute;. Antes de hacer
cualquier cambio, puede salvar su prompt actual en otra variable de
entorno.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       [giles@nikola giles]$ SAVE=$PS1
       [giles@nikola giles]$
</PRE>
</CODE></BLOCKQUOTE>
<P>El prompt m&aacute;s sencillo ser&iacute;a el de un s&oacute;lo car&aacute;cter, como:
<P>
<BLOCKQUOTE><CODE>
<PRE>
       [giles@nikola giles]$ PS1=$
       $ls
       bin   mail
       $
</PRE>
</CODE></BLOCKQUOTE>
<P>Esto demuestra la mejor manera de experimentar con prompts b&aacute;sicos: 
introduci&eacute;ndolos en la l&iacute;nea de comando. N&oacute;tese que el texto introducido
por el usuario aparece inmeditamente despu&eacute;s del prompt. Yo prefiero usar
<P>
<BLOCKQUOTE><CODE>
<PRE>
       $PS1="$ "
       $ ls
       bin   mail
       $
</PRE>
</CODE></BLOCKQUOTE>
<P>que fuerza un espacio despu&eacute;s del prompt, haci&eacute;ndolo m&aacute;s legible. Para
restaurar el prompt original, basta con llamar a la variable almacenada: 
<P>
<BLOCKQUOTE><CODE>
<PRE>
       $ PS1=$SAVE
       [giles@nikola giles]$
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="ss2.5">2.5 Secuencias de escape del prompt <CODE>bash</CODE></A>
</H2>

<P>
<P>Hay numerosas secuencias de escape ofrecidas por el shell <CODE>bash</CODE> para
insertar en el prompt. De la p&aacute;gina del manual del <CODE>bash 2.02</CODE>:
<P>
<P>Cuando se ejecuta interactivamente, <CODE>bash</CODE> muestra el prompt primario
<CODE>PS1</CODE> cuando est&aacute; listo para leer un comando, y el prompt secundario
<CODE>PS2</CODE> cuando necesita m&aacute;s datos de entrada para completar un comando. 
<CODE>bash</CODE> permite que estas cadenas de prompt sean modificadas insertando
ciertos caracteres especiales escapados mediante contrabarra que se
decodifican de la manera siguiente: 
<P>
<UL>
<LI><CODE>\a</CODE> car&aacute;cter de campana ASCII (<CODE>07</CODE>)
</LI>
<LI><CODE>\d</CODE> la fecha en formato <I>d&iacute;a mes d&iacute;a</I> (p.ej., <CODE>mar may
26</CODE>)
         </LI>
<LI><CODE>\e</CODE> caracter de escape ASCII (<CODE>033</CODE>) 
</LI>
<LI><CODE>\h</CODE> el nombre del host hasta el primer «.»
</LI>
<LI><CODE>\H</CODE> el nombre del la m&aacute;quina completo (<I>FQDN</I>)
         </LI>
<LI><CODE>\n</CODE> caracter de nueva l&iacute;nea
</LI>
<LI><CODE>\r</CODE> retorno de carro
</LI>
<LI><CODE>\s</CODE> el nombre del shell, el nombre base de <CODE>$0</CODE> (el
fragmento que sigue a la &uacute;ltima barra)
</LI>
<LI><CODE>\t</CODE> la hora actual en formato 24-horas <CODE>HH:MM:SS</CODE>
</LI>
<LI><CODE>\T</CODE> la hora actual en formato 12-horas <CODE>HH:MM:SS</CODE>
</LI>
<LI><CODE>\@</CODE> la hora actual en formato 12-horas AM/PM
</LI>
<LI><CODE>\u</CODE> el nombre de usuario del usuario actual
</LI>
<LI><CODE>\v</CODE> la versi&oacute;n de <CODE>bash</CODE> (p.ej., <CODE>2.0</CODE>) 
</LI>
<LI><CODE>\V</CODE> la versi&oacute;n del paquete del <CODE>bash</CODE>, versi&oacute;n + <I>patch-level</I>
(p.ej., <CODE>2.00.0</CODE>) 
</LI>
<LI><CODE>\w</CODE> el directorio actual de trabajo
</LI>
<LI><CODE>\W</CODE> el nombre base del directorio actual de trabajo
</LI>
<LI><CODE>\!</CODE> el n&uacute;mero del comando actual en el hist&oacute;rico
</LI>
<LI><CODE>#</CODE> el n&uacute;mero de comando del comando actual
</LI>
<LI><CODE>\$</CODE> si el UID efectivo es <CODE>0</CODE>, un <CODE>#</CODE>; en otro caso,
<CODE>$</CODE>
</LI>
<LI><CODE>\nnn</CODE> el caracter correspondiente al n&uacute;mero en octal <CODE>nnn</CODE>
</LI>
<LI><CODE>\\</CODE> una contrabarra
</LI>
<LI><CODE>\[</CODE> inicio de una secuencia de caracteres no imprimibles que
pueden usarse para incrustar una secuencia de control del terminal en el
prompt. 
</LI>
<LI><CODE>\]</CODE> fin de una secuencia de caracteres no imprimibles
</LI>
</UL>
<P>Continuando donde lo hab&iacute;amos dejado:
<P>
<BLOCKQUOTE><CODE>
<PRE>
       [giles@nikola giles]$ PS1="\u@\h \W> "
       giles@nikola giles> ls
       bin   mail
       giles@nikola giles>
</PRE>
</CODE></BLOCKQUOTE>
<P>Este es similar al prompt por defecto de la mayor&iacute;a de las distribuciones
LiNUX. Pero yo quer&iacute;a una apariencia ligeramente diferente, as&iacute; que lo
cambi&eacute; a:
<P>
<BLOCKQUOTE><CODE>
<PRE>
       giles@nikola giles> PS1="[\t][\u@\h:\w]\$ "
       [21:52:01][giles@nikola:~]$ ls
       bin   mail
       [21:52:15][giles@nikola:~]$
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="Valor permanente de las cadenas PS?"></A> <A NAME="ss2.6">2.6 Valor permanente de las cadenas «<CODE>PS?</CODE>» </A>
</H2>

<P>
<P>
<P>Las cadenas <CODE>PS?</CODE> son establecidas, seg&uacute;n la persona o distribuci&oacute;n en
distintos lugares. Los m&aacute;s comunes son <CODE>/etc/profile</CODE>,
<CODE>/etc/bashrc</CODE>, <CODE>~/.bash_profile</CODE>, y <CODE>~/.bashrc</CODE>. 
Johan Kullstam, <CODE>
<A HREF="mailto:johan19@idt.net">johan19@idt.net</A></CODE> escribe: 
<P>
<P><I>La cadena</I> <CODE>PS1</CODE> <I>deber&iacute;a ponerse en el</I> <CODE>.bashrc</CODE> <I>debido
a que los</I> <CODE>bash</CODE> <I>no interactivos no tienen en cuenta este fichero,
y por tanto, no estableceremos</I> <CODE>PS1</CODE> <I>si se trata de una shell no
interactiva. La p&aacute;gina del manual de</I> <CODE>bash</CODE> <I>indica que la
presencia o ausencia de</I> <CODE>PS1</CODE> <I>es una buena manera de saber si
uno est&aacute; en una sesi&oacute;n interactiva o no interactiva de bash. </I>
<P><I> La forma en que me percat&eacute; de esto es que</I> <CODE>startx</CODE> <I>es un
script bash, lo que implica que pulverizar&aacute; el prompt. Cuando se pone</I>
<CODE>PS1</CODE> <I>en el</I> <CODE>.profile</CODE> <I>(o en el</I> <CODE>.bash_profile</CODE><I>, al
entrar en consola y lanzar las X v&iacute;a</I> <CODE>startx</CODE><I>, la variable</I>
<CODE>PS1</CODE> <I>se elimina en el proceso, dej&aacute;ndole con el prompt por
defecto.</I>
<P><I> Una soluci&oacute;n es lanzar las</I> <CODE>xterm</CODE> <I>y las</I> <CODE>rxvt</CODE>
<I>con la opci&oacute;n</I> <CODE>-ls</CODE> <I>para forzarles a leer el</I>
<CODE>.profile</CODE><I>, pero en el momento en que se llame un shell mediante un
shell-script no interactivo se perder&aacute;</I> <CODE>PS1</CODE>. <CODE>system(3)</CODE>
<I>usa</I> <CODE>sh -c</CODE> <I>que, si</I> <CODE>sh</CODE> <I>es</I> <CODE>bash</CODE><I>, eliminar&aacute;</I>
<CODE>PS1</CODE>. <I>Una forma mejor de hacer esto es situar la definici&oacute;n
de</I> <CODE>PS1</CODE> <I>en</I> <CODE>.bashrc</CODE>. <I>Este fichero se lee cada vez
que se inicia bash y es donde deber&iacute;an aparecer las cosas interactivas
(p.ej.</I> <CODE>PS1</CODE><I>) </I>
<P><I> Por lo tanto se llega a la conclusi&oacute;n de que</I> <CODE>PS1=
...(blah)...</CODE> <I>deber&iacute;a ir en</I> <CODE>.bashrc</CODE> <I>y no en</I>
<CODE>.profile</CODE>
<P>He intentado simular el problema que &eacute;l comenta, y he encontrado uno
diferente: mi variable <CODE>PROMPT_COMMAND</CODE> (de la que se hablar&aacute;
despu&eacute;s) era desintegrada. Mi conocimiento en este &aacute;rea es un poco
limitado, as&iacute; que seguir&eacute; lo que dice Johan. 
<P>
<HR>
<A HREF="Bash-Prompt-Como-3.html">Página siguiente</A>
<A HREF="Bash-Prompt-Como-1.html">Página anterior</A>
<A HREF="Bash-Prompt-Como.html#toc2">Índice general</A>
</BODY>
</HTML>
