<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Tutorial de Uso de CVS</title><meta name="generator" content="DocBook XSL Stylesheets V1.50.0"><meta name="keywords" content="CVS, ES-TLDP"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><h1 class="title"><a name="id2752800"></a>Tutorial de Uso de CVS</h1></div><div><div class="author"><h3 class="author">Ismael Olea</h3></div></div><div><div class="author"><h3 class="author">Ignacio  Arenaza</h3></div></div><div><p class="copyright">Copyright © 2002 Ismael Olea, Ignacio Arenaza</p></div><div><div class="legalnotice"><p>
      Permiso para copiar, distribuir o modificar este documento de
      acuerdo a los terminos de la Licencia de Documentacion Libre de
      GNU (GNU Free Documentation License), Version 1.1 o posterior,
      publicada por la Free Software Foundation. Este documento no
      contiene Secciones Invariantes (with no Invariant Sections), ni
      Textos de Portada (with no Front-Cover Texts) ni Textos de
      Contraportada (with no Back-Cover Texts).
    </p></div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Historial de revisiones</b></th></tr><tr><td align="left">Revisión $Revision: 1.1 $</td><td align="left">$Date: 2002/10/09 19:19:17 $</td></tr><tr><td align="left" colspan="2">Submitted.</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Resumen</b></p><p>
	Breve tutorial introductorio al uso de
	CVS, con especial énfasis en el uso
	de la parte cliente de CVS. Se
	añaden algunas referencias a frontales adicionales al cliente
	tradicional, así como enlaces a tutoriales más amplios y
	detallados. La parte servidora de
	CVS se trata también con una cierta
	profundidad.
      </p></div></div><hr></div><div class="toc"><p><b>Tabla de contenidos</b></p><dl><dt>1. <a href="#id2754680">Introducción</a></dt><dt>2. <a href="#id2754421">Terminología CVS</a></dt><dt>3. <a href="#id2755183">Invocar a CVS</a></dt><dt>4. <a href="#id2755241">Configuración</a></dt><dd><dl><dt>4.1. <a href="#id2755410">La autenticación</a></dt></dl></dd><dt>5. <a href="#id2755825">Uso</a></dt><dd><dl><dt>5.1. <a href="#id2755832">Modo de uso</a></dt><dt>5.2. <a href="#id2755888">Descarga por primera vez del módulo</a></dt><dt>5.3. <a href="#id2755965">Actualizar nuestra copia local desde el
	repositorio</a></dt><dt>5.4. <a href="#id2755992">Publicar nuestras modificaciones en el respositorio</a></dt><dt>5.5. <a href="#id2756039">Resolución de conflictos</a></dt><dt>5.6. <a href="#id2756154">Añadir ficheros al módulo</a></dt><dt>5.7. <a href="#id2756297">Eliminar ficheros del módulo
      CVS</a></dt></dl></dd><dt>6. <a href="#id2756348">
      Cómo configurar un servidor y cómo incorporar nuevos módulos al
      repositorio.
    </a></dt><dd><dl><dt>6.1. <a href="#id2756358">
	Configuración del servidor.
      </a></dt><dt>6.2. <a href="#id2756634">
	Clases de usuarios y tipo de acceso permitido.
      </a></dt><dt>6.3. <a href="#id2756746">
	Creacion inicial del repositorio
      </a></dt><dt>6.4. <a href="#id2757252">
	Alta de usuarios
      </a></dt><dt>6.5. <a href="#id2757687">
	Añadir nuevos módulos al repositorio
      </a></dt></dl></dd><dt>7. <a href="#id2757794">Bibliografía</a></dt><dt>8. <a href="#id2757837">Interfaces de usuario para CVS</a></dt><dt>9. <a href="#id2758162">Otros recursos CVS interesantes</a></dt><dt>10. <a href="#id2758219">Otros recursos CVS más avanzados</a></dt><dt>11. <a href="#id2758292">Licencia</a></dt></dl></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2754680"></a>1. Introducción</h2></div></div><p>
      CVS es un sistema de mantenimiento de
      código fuente (grupos de ficheros en general)
      extraordinariamente útil para grupos de desarrolladores que
      trabajan cooperativamente usando alguna clase de red.
    </p><p>
      Para ser más concreto, CVS permite a
      un grupo de desarrolladores trabajar y modificar
      concurrentemente ficheros organizados en proyectos. Esto
      significa que dos o más personas pueden modificar un mismo
      fichero sin que se pierdan los trabajos de ninguna. Además, las
      operaciones más habituales son muy sencillas de usar.
    </p><p>
      Como añadido a lo anterior, CVS
      guarda todas las versiones antiguas de los ficheros. Esto
      permite recuperar en cualquier momento versiones anteriores a la
      actual.
    </p><p>
      Dado que trabaja con ficheros ASCII es igual de útil para
      trabajar con código fuente de programas o con toda clase de
      documentos siempre que su formato sea completamente de texto,
      como pueden ser ficheros sgml/html/xml.
    </p><p>
      Este documento es una referencia inmediata para trabajar con
      CVS. A poco que le saque partido
      necesitará consultar otro más extenso y detallado. Sin embargo
      el 80% o más de las acciones que desarrollan los usuarios de
      CVS están documentadas en este
      artículo.
    </p><p>
      Con CVS puede trabajarse de forma
      local (repositorio y copias de trabajo en el mismo sistema) o
      remota (el repositorio está en un sistema servidor y la copia
      local en otro que es cliente del primero).
    </p><p>
      En este artículo sólo prestaré atención al modo de trabajo
      remoto, que es el mas utilizado habitualmente en los proyectos
      de software libre, por su <i>modus
	operandi</i> habitual.
    </p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2754421"></a>2. Terminología CVS</h2></div></div><p>
      Para que no se pierda, un brevísimo vocabulario:
    </p><div class="variablelist"><dl><dt><span class="term">repositorio</span></dt><dd><p>
	    Jerarquía de directorios alojada en el servidor
	    CVS que contiene diferentes
	    módulos a disposición de los usuarios.
	  </p></dd><dt><span class="term">módulo</span></dt><dd><p>
	    Árbol de directorios que forma parte del repositorio.
	    Cuenta con un nombre identificador gracias al cual
	    podremos trabajar con él de forma selectiva.
	  </p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2755183"></a>3. Invocar a CVS</h2></div></div><p>
      CVS es un programa que se invoca
      desde intérpretes de órdenes. Según cual sea su configuración
      (desde el punto de vista de las diferentes formas de
      autenticación, que veremos en un momento) lo podrá usar en
      procesos por lotes sin ningún problema.
    </p><p>
      Un aspecto que debe tener en cuenta (sobre todo si este es el
      primer documento que lee sobre CVS)
      es que CVS tiene parámetros para cada
      una de sus órdenes. Para conocerlas tiene dos métodos: invocar
      CVS como <b><tt>cvs
      help</tt></b> o consultar la ayuda de su página del manual.
    </p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2755241"></a>4. Configuración</h2></div></div><p>
      Puede usar varios ficheros de configuración que
      CVS reconocerá y usará.
    </p><p>
      Entre otros, tenemos los siguientes:
    </p><div class="variablelist"><dl><dt><span class="term">~/.cvsignore</span></dt><dd><p>
	    que contiene los sufijos de los ficheros que no nos
	    interesa que CVS controle. Por
	    ejemplo podemos tener:
	  </p><pre class="programlisting">
	    *.aux *.dvi *.ps *.log
	  </pre><p>
	    si los ficheros de este módulo son principalmente
	    documentos escritos en (La)TeX, ya que las extensiones
	    mostradas arriba corresponden a los diferentes ficheros
	    temporales creados durante el procesado del fichero fuente
	    original para obtener el fichero listo para impresión.
	  </p><p>
	    Así evitamos <span class="emphasis"><em>contaminar</em></span> el
	    repositorio con ficheros que realmente no es necesario que
	    estén controlados por CVS.
	  </p></dd><dt><span class="term">~/.cvsrc</span></dt><dd><p>
	    que contiene aquellos parámetros que
	    CVS usará cada vez que se
	    invoque una determinada orden, de forma automática. Por
	    ejemplo:
	  </p><pre class="programlisting">
	    update -Pd
	    diff -uw
	    cvs -z 3
	  </pre><p>
	    Significa que queremos que cuando usemos la orden
	    <b>update</b>, automáticamente y sin que
	    tengamos que escribir nada más, se añadan los parámetros
	    <i><tt>-Pd</tt></i> (borrar los directorios vacíos
	    tras la actualización y crear los directorios del
	    repositorio que no existan en la copia local). Algo
	    similar ocurre con la orden <b>diff</b>.
	  </p><p>
	    La última línea es especial, en el sentido de que no hay
	    una orden <b>cvs</b>. Se trata de la forma en
	    que se indican parámetros globales del propio
	    CVS, no específicos de ninguna
	    orden.
	  </p></dd></dl></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2755410"></a>4.1. La autenticación</h3></div></div><p>
	Al trabajar en remoto con CVS
	pueden elegirse varias alternativas de autenticación (es
	decir, de demostrar al servidor que somos quienes decimos
	ser).
      </p><p>
	Las más utilizadas son vía <b>pserver</b> y vía
	<b>ssh</b> (aunque existen otras dos formas al
	menos: vía <b>rsh</b>, totalmente desaconsejada
	por motivos de seguridad, y vía
	Kerberos, que no es habitual por
	necesitar toda la infraestructura de seguridad de
	Kerberos).
      </p><p>
	Deberá elegir alguna de estas técnicas en función de sus
	necesidades, en caso de que no vengan impuestas de forma
	externa (por ejemplo, porque el repositorio ya existe y el
	tipo de acceso ya ha sido elegido previamente).
      </p><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2755477"></a>4.1.1. ssh (OpenSSH)</h4></div></div><p>
	  Para que CVS use este modo de
	  autenticación se deben usar estas variables de entorno:
	</p><pre class="programlisting">
	  export CVSROOT=:ext:USUARIO@cvs.dominio.org:/var/lib/cvs
	  export CVS_RSH=/usr/bin/ssh
	</pre><p>
	  donde <b><tt>USUARIO</tt></b> es el nombre de usuario
	  que tiene acceso al repositorio,
	  <b><tt>cvs.dominio.org</tt></b>, es el nombre del
	  servidor donde se aloja el repositorio,
	  <b><tt>/var/lib/cvs</tt></b> es el directorio del
	  servidor en el que está el repositorio y
	  <b><tt>/usr/bin/ssh</tt></b> es la ruta completa al
	  ejecutable de <b>ssh</b>.
	</p><p>
	  Tenga en cuenta que, usando esta técnica, tendrá que
	  autenticarse (es decir, suministrar su contraseña) cada vez
	  que ejecute alguna orden de CVS
	  (a menos que use autenticación con clave pública RSA/DSA
	  para <b>ssh</b>).
	</p><p>
	  La ventaja de usar <b>ssh</b> como método de
	  autenticación es que las comunicaciones con el servidor
	  CVS van completamente cifradas,
	  tanto la autenticación como los datos que intercambiemos con
	  el servidor (cosa que no ocurre con el siguiente método).
	</p><p>
	  El inconveniente de este método de autenticación es que
	  deberá crear cuentas de usuarios locales en el servidor
	  CVS con posibilidad de inicio de
	  sesión (shell válido) para todos aquellos usuarios remotos
	  que necesiten acceso al servidor, lo cual implica un acceso
	  más amplio al equipo donde se ejecuta el servidor
	  CVS que el mero acceso al
	  servicio CVS.
        </p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2755606"></a>4.1.2. pserver</h4></div></div><p>
	  Si no necesitamos que los datos que se intercambian con el
	  servidor vayan cifrados y nos basta con una autenticacion
	  relativamente segura, podemos utilizar el método pserver.
	</p><p>
	  La ventaja de este método sobre el anterior es doble en este
	  caso:
	  </p><div class="itemizedlist"><ul type="disc"><li><p>
		No require cuentas de usuario en el servidor
		CVS para cada uno de los
		clientes, ni permite ningún tipo de acceso adicional
		en el servidor.
	      </p></li><li><p>
		Es un esquema facil de configurar y administrar de
		forma moderadamente segura (aunque es mucho menos
		segura que el método via <b>ssh</b>, desde
		el punto de vista de secuestro de contraseñas de
		usuario CVS).
	      </p></li></ul></div><p>
	</p><p>
	  Para poder usar este tipo de autenticación, deberá usar una
	  variable de entorno similar a esta:
	</p><pre class="programlisting">
	  export CVSROOT=:pserver:USUARIO@cvs.dominio.org:/var/lib/cvs
	</pre><p>
	  donde <b><tt>USUARIO</tt></b> es nuestro nombre de
	  usuario, <b><tt>cvs.dominio.org</tt></b> es el
	  servidor que aloja al repositorio y
	  <b><tt>/var/lib/cvs</tt></b> es el directorio del
	  servidor en el que está el repositorio.
	</p><p>
	  Si usa esta técnica, antes de poder trabajar con
	  CVS deberá autenticarse ante el
	  servidor. Eso se hace con la orden <b>cvs
	  login</b>:
	</p><pre class="programlisting">
	    $ cvs login
	</pre><p>
	  CVS le pedirá la contraseña del
	  usuario que haya configurado en la variable de entorno
	  mencionada arriba. Si la contraseña es correcta
	  CVS guardará la información que
	  necesita en el fichero <tt>~/.cvspass</tt> y no
	  tendrá que volver a autenticarse.
	</p><p>
	  Si por algún motivo quisiera «cerrar la sesión»
	  CVS (esto es, dejar de trabajar
	  con ese servidor CVS o con ese
	  repositorio) bastará con hacer:
	</p><pre class="programlisting">
	  $ cvs logout
	</pre></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2755781"></a>4.1.3. Métodos combinados</h4></div></div><p>
	  Por supuesto, nada impide usar ambos métodos para el acceso
	  al servidor (vía ssh y vía
	  pserver) de forma conjunta, de
	  forma que ciertos usuarios usen uno de los métodos y otros
	  usuarios el otro. Esto es especialmente interesanta para el
	  acceso adminisitrativo al servidor
	  CVS, dado que el método
	  pserver
	  no es lo suficientemente seguro en este caso.
	</p></div></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2755825"></a>5. Uso</h2></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2755832"></a>5.1. Modo de uso</h3></div></div><p>
	A continuación se propone una sencilla metodología de trabajo
	con CVS para evitar trabajos
	redundantes. Piense por ejemplo en la eliminación de erratas o
	errores en documentos o en código fuente.
      </p><p>
	Antes de cada sesión de trabajo es conveniente hacer
	<b>cvs update -Pd</b> para asegurarnos de que
	disponemos de las últimas modificaciones registradas en el
	repositorio.
      </p><p>
	Justo al acabar cada sesión de trabajo es conveniente hacer
	<b>cvs commit</b> (se puede abreviar en
	<b>cvs ci</b>) para que todas nuestras
	modificaciones se registren en el repositorio.
      </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2755888"></a>5.2. Descarga por primera vez del módulo</h3></div></div><p>
	Para crear una copia de trabajo local del módulo
	CVS deseado debemos usar la orden
	<i><tt>cvs checkout</tt></i>(abreviable como
	<b>cvs co</b>):
      </p><pre class="programlisting">
	$ cd padre-de-directorio-donde-se-alojará-el-módulo
	$ cvs checkout nombre-del-módulo
      </pre><p>
	Esto creará una jerarquía de directorios donde se almacenará
	la copia local de trabajo el módulo. Este paso sólo hay que
	hacerlo una vez por cada módulo.
      </p><p>
	A partir de este momento no es necesario configurar las
	variables de entorno porque CVS
	sabe a qué repositorio pertenece el módulo con sólo examinar
	los subdirectorios <tt>CVS</tt>. No se debe modificar nunca
	esos subdirectorios a mano. De lo contrario
	CVS perderá la pista de a que
	módulo pertenecen los ficheros, cuáles son las versiones de la
	copia local, etc.
      </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2755965"></a>5.3. Actualizar nuestra copia local desde el
	repositorio</h3></div></div><p>
	Cuando queramos actualizar la copia local de trabajo del
	módulo con los cambios que hayan podido hacer otros usuarios y
	que están recogidos en el repositorio deberemos hacer:
      </p><pre class="programlisting">
	$ cd directorio-del-módulo
	$ cvs update -Pd
      </pre></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2755992"></a>5.4. Publicar nuestras modificaciones en el respositorio</h3></div></div><p>
	Se usa la orden <b>commit</b> (o su equivalente
	<b>ci</b>):
      </p><pre class="programlisting">
	$ cd directorio-del-módulo
	$ cvs commit
      </pre><p>
	Tras lo cual el sistema mostrará la pantalla de un editor de
	textos (el que tengamos configurado como nuestro favorito en
	la variable de entorno EDITOR) para que introduzcamos una
	descripción, lo más significativa posible, del conjunto de
	cambios realizados en el módulo desde el último
	<b>commit</b>.
      </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2756039"></a>5.5. Resolución de conflictos</h3></div></div><p>
	Habrá ocasiones en las que tengamos que resolver los
	conflictos que surjan entre diferentes versiones de un módulo
	o fichero del mismo (recuerde que puede haber múltiples
	personas trabajando de forma concurrente sobre el mismo
	módulo) para que CVS continúe
	trabajando. Estos conflictos son normales y ocurren cuando dos
	o más personas modifican a la vez exactamente la mismas partes
	de un fichero.
      </p><p>
	El procedimiento es simple:
      </p><div class="orderedlist"><ol type="1"><li><p>
	    CVS se quejará de un
	    fichero al hacer un <b>update</b> o un
	    <b>commit</b>.
	  </p></li><li><p>
	    Editamos ese fichero y encontraremos marcas del tipo:
	  </p><pre class="programlisting">
	    [...]
	    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
	    texto-opción-1
	    ===========
	    texto-opción-2
	    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
	    [...]
	  </pre></li><li><p>
	    El texto entre marcas es el que produce el conflicto. Hay
	    que elegir qué modificación nos gusta y borramos todo lo
	    demás.
	  </p></li><li><p>
	    Si no quedan más conflictos volvemos a hacer el
            <b>commit</b> o <b>update</b>.
	  </p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2756154"></a>5.6. Añadir ficheros al módulo</h3></div></div><p>
	No olvide que CVS controlará sólo
	los ficheros que se hayan descargado inicialmente desde el
	repositorio. Cualquier otro fichero o directorio de la
	jerarquía del módulo CVS será
	ignorado.
      </p><p>
	Si quiere añadir un nuevo fichero o directorio al módulo
	CVS hay que seguir los siguientes
	pasos (ademas de crear o copiar el propio fichero al módulo,
	por supuesto):
      </p><pre class="programlisting">
	$ cd directorio-del-módulo
	$ cvs add fichero
      </pre><p>
	pero si el fichero es binario hay que tener la precaución de
	hacer:
      </p><pre class="programlisting">
	$ cd directorio-del-módulo
	$ cvs add -kb fichero
      </pre><p>
	¿Por qué?, se preguntará el lector más intrépido. Resulta que
	CVS usa varias variables (en
	realidad son de RCS, que funciona
	por debajo de CVS). Si el fichero
	es binario es posible que se dé una combinación de bytes que
	coincidan con alguna de estas variables. Si así fuera,
	RCS/CVS
	modificaría el contenido y lo corrompería. También se debe a
	que el sistema de cálculo de diferencias que usan estos
	sistemas no está diseñado para trabajar con información
	binaria. Si se obra equivocadamente es probable que
	corrompamos los datos.
      </p><p>
	También quiero señalar que si bien se pueden gestionar
	ficheros binarios, no se hará control de versiones de los
	mismos. Sólo se guardará la última versión (al no disponer
	CVS de la funcionalidad necesaria
	para calcular diferencias de ficheros binarios).
      </p><p>
	Tras la orden <b>cvs add</b> hay que hacer ejecutar de
	nuevo la orden <b>cvs commit</b> para incluir los
	nuevos ficheros en el repositorio
	CVS.
      </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2756297"></a>5.7. Eliminar ficheros del módulo
      CVS</h3></div></div><p>
	Para eliminar un fichero del módulo
	CVS hay que hacer lo siguiente una
	vez borrado el fichero de la copia local de trabajo (se puede
	usar <b>cvs rm</b> como abreviatura):
      </p><pre class="programlisting">
	$ cd directorio-del-módulo
	$ cvs remove fichero
      </pre><p>
	En cambio, si queremos borrar físicamente los ficheros a la
	vez que los eliminamos del módulo deberemos usar:
      </p><pre class="programlisting">
	$ cd directorio-del-módulo
	$ cvs remove -f fichero
      </pre></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2756348"></a>6. 
      Cómo configurar un servidor y cómo incorporar nuevos módulos al
      repositorio.
    </h2></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2756358"></a>6.1. 
	Configuración del servidor.
      </h3></div></div><p>
	Para configurar un servidor CVS con
	acceso remoto hay básicamente tres formas (cuatro en las
	versiones recientes, pero no conozco ningún cliente de
	autenticación por medio de GSSAPI en el momento de escribir
	esto, asi que nos quedamos con los tres originales).
      </p><div class="variablelist"><dl><dt><span class="term">
	    rsh/ssh
	  </span></dt><dd><p>
	      Esta primera opción implica tener una cuenta equivalente
	      en el servidor CVS y no hace
	      falta tocar ni <tt>inetd.conf</tt> ni
	      ejecutar el servicio
	      pserver. La seguridad de esta
	      solución es nula a menos que se use
	      ssh como sustituto de
	      rsh.
	    </p></dd><dt><span class="term">
	    pserver
	  </span></dt><dd><p>
	      La segunda opción usa una cuenta genérica (la misma para
	      todo el mundo o varias diferentes si se desean, pero no
	      son cuentas con acceso local al servidor), necesita
	      activar pserver desde
	      <tt>inetd.conf</tt> (o
	      <tt>xinetd.conf</tt>, si se usa este
	      último). La seguridad es superior al método precedente
	      en caso de usar rsh pero
	      inferior al uso de ssh. La
	      gran ventaja de este método es que los usuarios de
	      CVS no necesitan ningún tipo
	      de acceso local al servidor.
	    </p></dd><dt><span class="term">
	    Kerberos
	  </span></dt><dd><p>
	      Kerberos queda fuera de juego a mi modesto entender, ya
	      que la infraestructura necesaria para usar este método
	      de autenticación simplemente no tiene sentido para uso
	      de CVS fuera de un mismo
	      dominio administrativo (sin contar la complejidad de
	      instalación y operación de un dominio Kerberos).
	    </p></dd></dl></div><p>
	En la práctica, buena parte de los servidores
	CVS públicos usan la opción de
	pserver, al no ser necesario dar de
	alta cuentas de sistema a los usuarios en el servidor. Si el
	acceso va a ser mucho mas restringido (un pequeño grupo
	estable y de confianza), la opción de usar
	ssh es claramente preferible.
      </p><p>
	Si optamos por el método pserver,
	deberemos añadir una línea como la siguiente en el fichero
	<tt>inted.conf</tt>:
      </p><pre class="programlisting">
        cvspserver stream tcp nowait root /usr/sbin/tcpd /usr/bin/cvs
	     -b /usr/bin -f --allow-root=/var/lib/cvs pserver
      </pre><p>
	(todo en una sola línea, por supuesto; aquí se muestra partido
	en dos por cuestiones de espacio). El valor <tt>/var/lib/cvs</tt> corresponde al
	directorio donde ubicaremos el repositorio en el servidor
	CVS y que denotaremos de ahora en
	adelante por la variable de entorno <tt>$CVSROOT</tt>.
      </p><p>
	Hay que asegurse también, en caso de estar usando
	TCP Wrappers (como es el caso del
	ejemplo) de que permitimos el acceso al servicio
	CVS (en el fichero
	<tt>/etc/hosts.allow</tt> con una línea como la
	siguiente. De lo contrario se van a rechazar las conexiones.
      </p><pre class="programlisting">
	cvs: ALL
      </pre></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2756634"></a>6.2. 
	Clases de usuarios y tipo de acceso permitido.
      </h3></div></div><p>
	El segundo punto a tener en cuenta es quién tiene acceso a los
	repositorios CVS y qué tipo de
	operaciones se pueden realizar. Basicamente, una vez creado el
	repositorio, se suelen realizar dos grandes grupos de
	operaciones:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
	    Adición/actualización de ficheros del repositorio (implica
	    acceso en modo escritura). Aqui van los
	    <b>commit</b>, <b>add</b>,
	    <b>remove</b> y compañia.
	  </p></li><li><p>
	    Actualizaciones en el cliente/creación de
	    diferencias. Esto sólo implica acceso en modo
	    lectura. Aqui van los <b>checkout</b>,
	    <b>update</b>, <b>diff</b> y
	    compañia.
	  </p></li></ul></div><p>
	El acceso en modo escritura al respositorio sólo se debe
	otorgar a las personas estrictamente necesarias, ya que en
	teoría el acceso al sistema se abre potencialmente bastante.
      </p><p>
	El acceso en modo lectura no plantea problemas (salvo de carga
	de la maquina si los <b>checkout</b> /
	<b>diff</b> / <b>update</b> son masivos).
      </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2756746"></a>6.3. 
	Creacion inicial del repositorio
      </h3></div></div><p>
	A continuación se muestran los pasos a realizar para la
	creación inicial del repositorio CVS.
      </p><div class="orderedlist"><ol type="1"><li><p>
	    Configurar <tt>/etc/inetd.conf</tt> para que
	    lance el servidor pserver como
	    se ha comentado arriba, en caso de usar el método de
	    acceso pserver.
	  </p></li><li><p>
	    Definir una cuenta administrativa local para
	    CVS (en el ejemplo se llamará
	    <tt>cvsadm</tt>) que será quien administre
	    CVS. Esta cuenta será la
	    propietaria de los ficheros de control del repositorio y
	    quien pueda crear nuevos módulos en el
	    mismo. Aprovecharemos para crear un grupo llamado
	    <tt>cvs</tt> para gestionar más
	    cómodamente los permisos del repositorio y sus
	    módulos.
	  </p><p>
	    El usuario <tt>cvsadm</tt> deberá ser
	    parte del grupo <tt>cvs</tt>. Sin embargo
	    esta cuenta no tienen porque tener acceso local al sistema
	    en caso de usar el método de acceso
	    pserver.
	  </p></li><li><p>
	    Crear el repositorio en local en el servidor (en <tt>$CVSROOT</tt>), ejecutando las
	    ordenes (si queremos colocar el respositorio en <tt>/var/lib/cvs</tt>):
	  </p><pre class="programlisting">
	    CVSROOT=/var/lib/cvs; export CVSROOT
	    mkdir -p $CVSROOT
	    cvs init
	  </pre><p>
	    El repositorio conviene crearlo como
	    <tt>root</tt> y tratarlo, desde el punto
	    de vista de los permisos, como si fuera el directorio
	    <tt>/etc</tt>. Todos sus
	    ancestros sólo deberian ser escribibles por
	    <tt>root</tt>. El propio <tt>$CVSROOT</tt> debería ser
	    escribible por el administrador del servidor
	    CVS (cvsadm, como hemos
	    indicado más arriba). <span class="bold"><b>NADIE
	    MAS</b></span> debería tener permisos de escritura en
	    dicho directorio.
	  </p><p>
	    Esto se hace asignando su propiedad al usuario
	    <tt>cvsadm</tt> y haciendo al grupo
	    <tt>cvs</tt> el grupo de <tt>$CVSROOT</tt>. Además, sería
	    conveniente que <tt>$CVSROOT</tt> tuviera activado el
	    bit <tt>SGID</tt>, para que los
	    subdirectorios y ficheros que se creen debajo hereden el
	    grupo principal del fichero o directorio (e
	    indirectamente, por el ajuste del valor de umask que hace
	    el propio CVS en modo
	    pserver, el permiso de
	    escritura para el grupo cvs y que tenga así control sobre
	    todo lo que se introduzca allí). En resumen, <tt>$CVSROOT</tt> debería tener los
	    permisos:
	  </p><pre class="programlisting">
	    drwxr-s---  10 cvsadm   cvs     1024 Oct  2 12:31  $CVSROOT
	  </pre></li><li><p>
	    El usuario <tt>cvsadm&gt;</tt> será el
	    propietario de los ficheros que haya en <tt>$CVSROOT/CVSROOT</tt>. El único
	    fichero que es necesario que tenga permisos de escritura
	    para los usuarios de CVS es
	    <tt> $CVSROOT/CVSROOT/history</tt>. El resto,
	    <span class="bold"><b>deben tener sólo</b></span> permiso
	    de lectura. Esto es:
	  </p><pre class="programlisting">
	    $CVSROOT/CVSROOT:
	      drwxr-x---  2 cvsadm   cvs   1024 Oct  2 12:52 CVSROOT
	    $CVSROOT/CVSROOT/history:
	      -rw-rw----  1 cvsadm   cvs   9609 Oct  2 13:01 history
	    $CVSROOT/CVSROOT/commitlog:
	      -rw-rw----  1 cvsadm   cvs   9609 Oct  2 13:01 commitlog  (*)
	    $CVSROOT/CVSROOT/log.pl:
	      -r-xr-x---  1 cvsadm   cvs   9609 Oct  2 13:01 log.pl     (*)
	    $CVSROOT/CVSROOT/*:
	      -r--r-----  1 cvsadm   cvs   9609 Oct  2 13:01 (el resto
	                                                      de ficheros)
	  </pre><p>
	    (*) Esto sólo es necesario si se va a usar la
	    caracteristica <tt>loginfo</tt> con el script
	    <b>log.pl</b> o similares. En cualquier caso,
	    no deberia ser problemático.
	  </p></li><li><p>
	    Incorporar al grupo <tt>cvs</tt> los
	    diferentes usuarios locales que van a representar a los
	    usuarios remotos de pserver. En
	    concreto, en mi sistema, existen
	    <tt>cvsadm</tt>,
	    <tt>cvsuser</tt> y
	    <tt>anoncvs</tt>, que representan
	    respectivamente al administrador del servidor
	    CVS, a los usuarios
	    CVS con permiso de escritura en
	    el repositorio (previa autenticación) y a los usuarios con
	    acceso sólo lectura en modo anónimo.
	  </p><p>
	    La idea de este grupo (como se ha comentado arriba) es
	    poder asignar los permisos locales a los ficheros de forma
	    que tanto el administrador como los usuarios tengan acceso
	    a ellos.
	  </p></li><li><p>
	    Si se va a usar pserver, es muy
	    importante que los usuarios que tengan que ver con
	    CVS
	    (<tt>cvsadm</tt>,
	    <tt>anoncvs</tt> y
	    <tt>cvsuser</tt>) <span class="bold"><b>no
	    puedan</b></span> tener acceso local al servidor (esto es,
	    poner una contraseña no válida, un shell no válido, etc.)
	  </p></li><li><p>
	    Los módulos iniciales para cada proyecto (manual, como,
	    programa, etc.) los debe crear el administrador del
	    servidor CVS. Luego los puede
	    usar cualquiera. Así garantizamos que los permisos son los
	    adecuados, y que todo esta «controlado y en orden».
	  </p></li><li><p>
	    Para funcionalidades adicionales (envio de mensaje de
	    corre cada vez que se hace un <b>commit</b>,
	    actualizacion de un log de <b>commit</b> en el
	    repositorio, publicacion en el web del estado del
	    repositorio, etc.) el propio administrador del servidor
	    CVS se puede encargar de
	    todo. Todo lo necesario esta en la documentación oficial
	    de CVS.
	  </p></li></ol></div><p>
	Todo lo anterior (especialmente el tema de permisos, usuarios
	necesarios, etc.) son conclusiones mías despues de leer la
	documentacion de CVS y su FAQ. No
	está indicado en ningún sitio que se deba hacer exactamente
	así, ya que sólo se dan consejos muy generales y bastante
	dispersos por toda la documentación. Con esto quiero decir que
	habría que hacer un análisis un poco más profundo sobre el
	posible impacto de seguridad.
      </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2757252"></a>6.4. 
	Alta de usuarios
      </h3></div></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2757259"></a>6.4.1. 
	  Para el método de acceso ssh
	</h4></div></div><p>
	  En este caso, los usuarios de CVS
	  son directamente usuarios del sistema. Por tanto, el
	  administrador del sistema donde resida el servidor
	  CVS debe dar de alta los usuarios
	  normales y habilitar los permisos adecuados en el
	  repositorio (y sus diferentes ficheros) para que puedan
	  llevar a cabo el tipo de acceso deseado.
	</p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2757291"></a>6.4.2. 
	  Para el método de acceso pserver
	</h4></div></div><p>
	  En este caso, tenemos que usar los ficheros
	  <tt>$CVSROOT/CVSROOT/passwd</tt>
	  <tt>$CVSROOT/CVSROOT/readers</tt>
	  <tt>$CVSROOT/CVSROOT/writers</tt> . El primero
	  de ellos sirver para indicar que usuarios remotos tienen
	  acceso al repositorio y el segundo y tercero indican qué
	  usuarios de entre los anteriores tiene acceso en modo sólo
	  lectura y cuáles en modo lectura/escritura, respectivamente.
	</p><p>
	  El formato del primero de ellos es similar al de los
	  ficheros de contraseñas de Apache
	  y de hecho se puede crear y manipular con la herramienta
	  <b>htpasswd</b>. Decimos similar porque no es
	  exactamente igual, al diponer de un tercer campo opcional
	  que nosotros si usaremos. Veamos un ejemplo:
	</p><pre class="programlisting">
	  cvsadm:8BQYT0o1J7FI6:cvsadm
	  anoncvs:
	  hermes-team:8Ba2dFouJkxI6:cvsuser
	  lucasiano:gA7sdFouJk9X6:cvsuser
	</pre><p>
	  En el ejemplo anterior tenemos cuatro usuarios remotos, pero
	  en realidad sólo tres usuarios locales. Los usuarios
	  «remotos» son <tt>cvsadm</tt>,
	  <tt>anoncvs</tt>,
	  <tt>hermes-team</tt> y
	  <tt>lucasiano</tt>. Estos son los nombres de
	  usuario que se usarán durante el proceso de autenticación.
	</p><p>
	  Sin embargo, una vez superada la autenticación correctamente
	  (el segundo campo del fichero es la contraseña cifrada con
	  el método <b>crypt</b> estándar; si no existe,
	  como en el caso del usuario
	  <tt>anoncvs</tt>, valdrá cualquier
	  contraseña), se usarán los usuarios que se indican en el
	  tercer campo para el acceso local a los ficheros del
	  repositorio. Esto es, el usuario remoto
	  <tt>lucasiano</tt> en realidad será el
	  usuario local <tt>cvsuser</tt> en el
	  servidor y por tanto tendrá acceso a los ficheros y
	  directorios a los que pueda acceder dicho usuario. En caso
	  de no existir este tercer valor, el nombre de usuario remoto
	  y el local serán el mismo.
	</p><p>
	  Esta funcionalidad es muy interesante, ya que nos permite
	  crear únicamente una cuenta de usuario local en el servidor
	  por cada tipo de acceso diferente necesario, y agregar
	  después cuantas cuentas remotas queramos y mapearlas al
	  usuario local correspondiente. Como el fichero donde se
	  realiza el mapeo es
	  <tt>$CVSROOT/ROOT/passwd</tt> y este fichero
	  está disponible a través del propio
	  CVS, el administrador del
	  servidor CVS no necesita permisos
	  de administrador global de la máquina donde este ubicado el
	  repositorio para dar de alta nuevos usuarios de
	  CVS. Nótese que en este caso, el
	  fichero con las contraseñas viaja sin cifrar por la red, con
	  lo cual se recomienda usar el método de acceso
	  ssh para este tipo de
	  operaciones).
	</p><p>
	  Para crear nuevos usuarios CVS
	  podemos usar la orden <b>htpasswd</b> de
	  Apache:
	</p><pre class="programlisting">
	  export CVSROOT=:ext:cvsadm@cvs.servidor.org:/var/lib/cvs
	  export CVS_RSH=/usr/bin/ssh
	  cd directorio-temporal-de-trabajo
	  cvs checkout CVSROOT
	  cd CVSROOT
	  htpasswd passwd usuario-nuevo  (*)
	    New password: no-se-ve-mientras-se-escribe
	    Re-type new password: no-se-ve-mientras-se-escribe
	  vi passwd     (**)
	  cvs add passwd (*) y (***)
	  cvs commit
	</pre><p>
	  (*) Si fuese el primer usuario del repositorio, el fichero
	  <tt>passwd</tt> no existirá, y por tanto será
	  necesario usar la opción <i><tt>-c</tt></i> de la
	  orden <b>htpasswd</b>. De igual modo, habrá que
	  indicar a CVS que existe un nuevo
	  fichero llamado <tt>passwd</tt> para que lo
	  tenga en cuenta y lo añada al repositorio al hacer el
	  <b>commit</b>.
	</p><p>
	  (**) Si se desea la funcionalidad de mapear el usuario remoto
	  a un usuario local concreto, se puede editar el fichero a
	  mano y añadir el tercer campo, separándolo del segundo por
	  ':'.
	</p><p>
	  (***) Para que esto funcione es necesario haber incluido el
	  nombre del fichero <tt>passwd </tt> en el
	  fichero <tt>$CVSROOT/checkoutlist</tt>
	  previamente. (no se aconseja por motivos de seguridad a
	  menos que el acceso administrativo a
	  CVSse realice por medio de
	  ssh, como se ha comentado más
	  arriba y se ha hecho en el ejemplo mostrado).
	</p><p>
	  Hemos mencionado más arriba los ficheros
	  <tt>$CVSROOT/CVSROOT/writers</tt> y
	  <tt>$CVSROOT/CVSROOT/readers</tt>. El proposito
	  de ambos es poder delimitar aún más el tipo de acceso
	  permitido a los usuarios remotos. Si un nombre de usuario
	  aparece en el fichero
	  <tt>$CVSROOT/CVSROOT/writers</tt> este usuario
	  tendrá acceso a las operaciones que impliquen modificaciones
	  al repositorio. Este fichero contiene simplemente el nombre
	  de los usuarios <span class="bold"><b>«remotos»</b></span>,
	  uno por línea, que tienen este tipo de acceso:
	</p><pre class="programlisting">
	  cvsadm
	  hermes-team
	  lucasiano
	</pre><p>
	  Si por el contrario aparece en el fichero
	  <tt>$CVSROOT/CVSROOT/readers</tt>, sólo tendrá
	  acceso en modo lectura y no podrá hacer ningún cambio en el
	  repositorio. El formato es idéntico al fichero anterior.
	</p><p>
	  En caso de que aparezca en ambos ficheros, obtiene acceso de
	  sólo lectura. En caso de que no existan ninguno de los dos
	  ficheros, el usuario obtiene acceso de escritura, así que
	  asegúrese de crearlos durante la configuración inicial del
	  repositorio (no vienen creados de serie).
	</p><p>
	  Por último, hay que tener muy presente que el control de
	  acceso a los módulos se hace en base a los permisos de los
	  directorios y ficheros del repositorio. Por tanto, si se
	  quieren módulos con usuarios completamente independientes,
	  habrá que extender el esquema usuarios/grupos locales aquí
	  presentado y jugar con los permisos. Esto supone una cierta
	  complicacion para el administrador tanto del sistema como
	  del repositorio CVS.
	</p></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2757687"></a>6.5. 
	Añadir nuevos módulos al repositorio
      </h3></div></div><p>
	Para añadir nuevos modulos al respositorio, la operación debe
	ser llevada a cabo por el administrador del mismo. Para ello
	se usa la orden <b>cvs import</b> que le indica a
	CVS que debe crear una copia en el
	respositorio del conjunto de ficheros del directorio actual.
      </p><p>
	Por ello, para importar un nuevo módulo al respositorio
	debemos situarnos primero en el directorio raíz del módulo
	donde están los ficheros del mismo y ejecutar la orden:
      </p><pre class="programlisting">
	cvs import nombre-módulo etiqueta-vendedor etiqueta-versión
      </pre><p>
	Donde:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
	    nombre-módulo: es el nombre que le queremos dar al nuevo
	    módulo.
	  </p></li><li><p>
	    etiqueta-vendedor: es el nombre que usa
	    CVS para etiquetar la rama
	      que crea con la importación. Puede ser una cadena
	    cualquiera de letras, números y subrayados.
	  </p></li><li><p>
	    etiqueta-versión: es el nombre que usa
	    CVS para etiquetar la versión
	    concreta que se crea con esta importación. Puede ser una
	    cadena cualquiera de letras, números y subrayados.
	  </p></li></ul></div></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2757794"></a>7. Bibliografía</h2></div></div><p>
      Por un lado hay un completísimo fichero info dedicado a
      CVS, que es la documentación oficial
      de mismo. Si usa GNU/Linux es muy probable que ya lo tenga
      instalado en su sistema.
    </p><p>
      Por otro lado en <a href="http://cvsbook.red-bean.com/" target="_top">http://cvsbook.red-bean.com/</a>
	está disponible otro libro documentando
	CVS.
    </p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2757837"></a>8. Interfaces de usuario para CVS</h2></div></div><p>
      He aquí algunas interfaces de usuario para
      CVS, en mayor o menor estado de
      desarrollo. Todas ellas se pueden encontrar en <a href="http://freshmeat.net/" target="_top">http://freshmeat.net/</a>.
    </p><div class="itemizedlist"><ul type="disc"><li><p>
	  pharmacy: Una interfaz GNOME para CVS, disponible en
	  <a href="http://pharmacy.sourceforge.net/" target="_top">
	    http://pharmacy.sourceforge.net/</a>. Se encuentra aun
	  en un estado de desarrollo bastante temprano y no se
	  actualiza desde hace casi un año en el momento de escribir
	  esto. Aquí se puede ver un pantallazo del aspecto de su
	  pantalla principal:
	</p><p>
	  <img src="pharmacy-1.jpg">
	</p></li><li><p>
	  cvsgui: Una interfaz multiplataforma para CVS escrita en C++
	  (anteriormente conocida como gCVS), disponible en
	  <a href="http://sourceforge.net/projects/cvsgui" target="_top">
	  http://sourceforge.net/projects/cvsgui/</a>. Su pantalla
	  principal,
	</p><p>
	  <img src="cvsgui-1.png">
	</p><p>
	  y el visor de ramas y versiones de los ficheros:
	</p><p>
	  <img src="cvsgui-2.png">
	</p></li><li><p>
	  tkcvs: Interfaz gráfica para CVS escrita en Tcl/Tk muy
	  establecida y estable, disponible en
	  <a href="http://www.twobarleycorns.net/tkcvs.html" target="_top">
	    http://www.twobarleycorns.net/tkcvs.html</a>. El
	    pantallazo de su ventana principal,
	</p><p>
	  <img src="tkcvs-1.png">
	</p><p>
	  el navegador de módulos disponibles en el repositorio,
	</p><p>
	  <img src="tkcvs-2.png">
	</p><p>
	  y el visor de ramas y versiones de los ficheros:
	</p><p>
	  <img src="tkcvs-3.png">
	</p></li><li><p>
	  cervisia: Interfaz gráfica KDE para CVS, disponible en
	  <a href="http://cervisia.sourceforge.net/" target="_top">
	    http://cervisia.sourceforge.net/
	  </a>. El pantallazo de su ventana principal,
	</p><p>
	  <img src="cervisia-1.png">
	</p><p>
	  el visor de ramas y revisiones de los ficheros:
	</p><p>
	  <img src="cervisia-2.png">
	</p><p>
	  el visor de anotaciones
	</p><p>
	  <img src="cervisia-3.png">
	</p><p>
	  y el visor gráfico de diferencias:
	</p><p>
	  <img src="cervisia-4.png">
	</p></li><li><p>
	  lincvs: Interfaz gráfica para CVS que usa la biblioteca
	  grafica Qt, disponible en <a href="http://www.lincvs.org/" target="_top">http://www.lincvs.org/</a>.
	  Su pantalla principal:
	</p><p>
	  <img src="lincvs-1.png">
	</p></li><li><p>
	  PCL-CVS: extensión de (X)Emacs que permite manipular
	  ficheros gestionados con CVS de forma automática y
	  transparente, disponible como parte de XEmacs, y como parte
	  del propio CVS.
	</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2758162"></a>9. Otros recursos CVS interesantes</h2></div></div><div class="itemizedlist"><ul type="disc"><li><p>
	  La página del propio CVS que
	  ahora está en <a href="http://www.cvshome.org/" target="_top">http://www.cvshome.org/</a>.
	</p></li><li><p>
	  cvs2cl.pl: que es una herramienta para crear ficheros
	  Changelog al estilo GNU y que puede encontrarse en <a href="http://www.red-bean.com/cvs2cl/" target="_top">
	  http://www.red-bean.com/cvs2cl/</a>
	</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2758219"></a>10. Otros recursos CVS más avanzados</h2></div></div><div class="itemizedlist"><ul type="disc"><li><p>
	  cvsadmin: Herramienta para administrar las cuentas de un
	  repositorio, disponible en
	  <a href="http://www.cooptel.qc.ca/~limitln/cvsadmin/" target="_top">
	    http://www.cooptel.qc.ca/~limitln/cvsadmin/
	  </a>
	</p></li><li><p>
	  cvsauth: conjunto de parches para
	  CVS que sirven para autenticar
	  usuarios sin tener que ejecutar en el servidor
	  CVS como
	  <tt>root</tt>. Añade además cifrado SSL en
	  las conexiones pserver
	  tradicionales. Disponible en <a href="http://cvsauth.sourceforge.net/" target="_top">
	  http://cvsauth.sourceforge.net/
	  </a>
	</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2758292"></a>11. Licencia</h2></div></div><p>
      Permiso para copiar, distribuir o modificar este documento de
      acuerdo a los terminos de la Licencia de Documentacion Libre de
      GNU (GNU Free Documentation License), Version 1.1 o posterior,
      publicada por la Free Software Foundation. Este documento no
      contiene Secciones Invariantes (with no Invariant Sections), ni
      Textos de Portada (with no Front-Cover Texts) ni Textos de
      Contraportada (with no Back-Cover Texts).
    </p></div></div></body></html>
