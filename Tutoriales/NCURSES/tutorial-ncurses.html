<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<TITLE>Escribir Programas con NCURSES</TITLE>
	<META NAME="GENERATOR" CONTENT="StarOffice/5.1 (Linux)">
	<META NAME="CREATED" CONTENT="19990720;18141500">
	<META NAME="CHANGEDBY" CONTENT="Juan Piernas C&aacute;novas">
	<META NAME="CHANGED" CONTENT="19990720;18143400">
	<META NAME="CLASSIFICATION" CONTENT="Tutorial, Documentaci&oacute;n">
	<META NAME="KEYWORDS" CONTENT="NCURSES, Espa&ntilde;ol, Programaci&oacute;n">
	<META NAME="Versión" CONTENT="8.0.3514">
	<META NAME="Fecha" CONTENT="05/12/96">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
	<STYLE>
	<!--
		TD P { color: #000000 }
		P { color: #000000 }
		A:link { color: #0000ff }
		A:visited { color: #800080 }
	-->
	</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">
<P STYLE="border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"></FONT><BR><BR>
</P>
<P><B><FONT SIZE=6>Escribir</FONT><FONT SIZE=5> </FONT><FONT SIZE=6>Programas
con</FONT><FONT SIZE=5> </FONT><FONT SIZE=6>NCURSES</FONT></B> 
</P>
<P>Eric S. Raymond y Zeyd M. Ben-Hamlim 
</P>
<P><B><U><FONT SIZE=5>CONTENIDOS</FONT></U></B> 
</P>
<UL>
	<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Introducci&oacute;n">Introducci&oacute;n</A>
	<BR>&nbsp; 
	</P>
	<UL>
		<P><B>* </B><A HREF="#Breve_historia_de_curses">Breve_historia_de_curses</A>
				</P>
		<P><B>* </B><A HREF="#Alcance_de_este_documento">Alcance_de_este_documento</A>
				</P>
		<P><B>* </B><A HREF="#Terminolog&iacute;a">Terminolog&iacute;a</A> 
		</P>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Notas_sobre_esta_traduccion">Notas_sobre_esta_traduccion</A>
		<BR>&nbsp;</P>
	</UL>
	<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#La_Libreria_Curses">La_Libreria_Curses</A>
	<BR>&nbsp; 
	</P>
	<UL>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Una_descripcion_de_Curses">Una_descripcion_de_Curses</A>
		<BR>&nbsp; 
		</P>
		<UL>
			<UL>
				<P><B>* </B><A HREF="#Compilar_programas_utilizando_Curses">Compilar_programas_utilizando_Curses</A>
								</P>
				<P><B>* </B><A HREF="#Actualizaci&oacute;n_de_pantalla">Actualizaci&oacute;n_de_pantalla</A>
								</P>
				<P><B>* </B><A HREF="#Ventanas_Est&aacute;ndar_y_convenciones">Ventanas_Est&aacute;ndar_y_convenciones</A>
								</P>
				<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Variables">Variables</A>
				<BR>&nbsp;</P>
			</UL>
		</UL>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Uso_de_la_Librer&iacute;a">Uso_de_la_Librer&iacute;a</A>
		<BR>&nbsp; 
		</P>
		<UL>
			<UL>
				<P><B>* </B><A HREF="#Comenzar">Comenzar</A> 
				</P>
				<P><B>* </B><A HREF="#Salida">Salida</A> 
				</P>
				<P><B>* </B><A HREF="#Entrada">Entrada</A> 
				</P>
				<P><B>* </B><A HREF="#Uso_de_caracteres_de_Formularios">Uso_de_caracteres_de_Formularios</A>
								</P>
				<P><B>* </B><A HREF="#Atributos_de_caracteres_y_color">Atributos_de_caracteres_y_color</A>
								</P>
				<P><B>* </B><A HREF="#Interfaz_de_Rat&oacute;n">Interfaz_de_Rat&oacute;n</A>
								</P>
				<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Finalizaci&oacute;n">Finalizaci&oacute;n</A>
				<BR>&nbsp;</P>
			</UL>
		</UL>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Descripci&oacute;n_de_Funciones">Descripci&oacute;n_de_Funciones</A>
		<BR>&nbsp; 
		</P>
		<UL>
			<UL>
				<P><B>* </B><A HREF="#Inicializaci&oacute;n_y_Wrapup">Inicializaci&oacute;n_y_Wrapup</A>
								</P>
				<P><B>* </B><A HREF="#Realizar_la_salida_al_Terminal">Realizar_la_salida_al_Terminal</A>
								</P>
				<P><B>* </B><A HREF="#Acceso_a_las_Capacidades_de_bajo_nivel">Acceso_a_las_Capacidades_de_bajo_nivel</A>
								</P>
				<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Depuraci&oacute;n">Depuraci&oacute;n</A>
				<BR>&nbsp;</P>
			</UL>
		</UL>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Avisos_Consejos_Y_Trucos">Avisos_Consejos_Y_Trucos</A>
		<BR>&nbsp; 
		</P>
		<UL>
			<UL>
				<P><B>* </B><A HREF="#Algunas_notas_de_precauci&oacute;n">Algunas_notas_de_precauci&oacute;n</A>
								</P>
				<P><B>* </B><A HREF="#Abandonar_temporalmente_el_modo_Ncurses">Abandonar_temporalmente_el_modo_Ncurses</A>
								</P>
				<P><B>* </B><A HREF="#Uso_De_Ncurses_Bajo_Xterm">Uso_De_Ncurses_Bajo_Xterm</A>
								</P>
				<P><B>* </B><A HREF="#Manipulaci&oacute;n_de_M&uacute;ltiples_Terminales">Manipulaci&oacute;n_de_M&uacute;ltiples_Terminales</A>
								</P>
				<P><B>* </B><A HREF="#Prueba_de_las_capacidades_del_terminal">Prueba_de_las_capacidades_del_terminal</A>
								</P>
				<P><B>* </B><A HREF="#Sintonizaci&oacute;n_para_la_velocidad">Sintonizaci&oacute;n_para_la_velocidad</A>
								</P>
				<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Aspectos_especiales_de_Ncurses">Aspectos_especiales_de_Ncurses</A>
				<BR>&nbsp;</P>
			</UL>
		</UL>
		<P STYLE="margin-bottom: 0cm"><B>*
		</B><A HREF="#Compatibilidad_con_versiones_anteriores">Compatibilidad_con_versiones_anteriores</A>
		<BR>&nbsp; 
		</P>
		<UL>
			<UL>
				<P><B>* </B><A HREF="#Refresco_de_ventanas_superpuestas">Refresco_de_ventanas_superpuestas</A>
								</P>
				<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Antecedentes_de_Borrado">Antecedentes_de_Borrado</A>
				<BR>&nbsp;</P>
			</UL>
		</UL>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Ajuste_con_XSI_Curses">Ajuste_con_XSI_Curses</A>
		<BR>&nbsp;</P>
	</UL>
	<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Librer&iacute;a_Paneles">Librer&iacute;a_Paneles</A>
	<BR>&nbsp; 
	</P>
	<UL>
		<P><B>* </B><A HREF="#Compilaci&oacute;n_con_la_Librer&iacute;a_Paneles">Compilaci&oacute;n_con_la_Librer&iacute;a_Paneles</A>
				</P>
		<P><B>* </B><A HREF="#Descripci&oacute;n_de_Paneles">Descripci&oacute;n_de_Paneles</A>
				</P>
		<P><B>* </B><A HREF="#Paneles_Salida_y_la_Pantalla_Est&aacute;ndar">Paneles_Salida_y_la_Pantalla_Est&aacute;ndar</A>
				</P>
		<P><B>* </B><A HREF="#Escondiendo_Paneles">Escondiendo_Paneles</A> 
		</P>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Otras_Caracter&iacute;sticas_Diversas">Otras_Caracter&iacute;sticas_Diversas</A>
		<BR>&nbsp;</P>
	</UL>
	<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Librer&iacute;a_Men&uacute;">Librer&iacute;a_Men&uacute;</A>
	<BR>&nbsp; 
	</P>
	<UL>
		<P><B>* </B><A HREF="#Compilaci&oacute;n_con_la_Librer&iacute;a_Men&uacute;">Compilaci&oacute;n_con_la_Librer&iacute;a_Men&uacute;</A>
				</P>
		<P><B>* </B><A HREF="#Descripci&oacute;n_de_Men&uacute;s">Descripci&oacute;n_de_Men&uacute;s</A>
				</P>
		<P><B>* </B><A HREF="#Selecci&oacute;n_de_Objetos">Selecci&oacute;n_de_Objetos</A>
				</P>
		<P><B>* </B><A HREF="#Visualizaci&oacute;n_de_Men&uacute;">Visualizaci&oacute;n_de_Men&uacute;</A>
				</P>
		<P><B>* </B><A HREF="#Procesamiento_de_la_entrada_de_Men&uacute;">Procesamiento_de_la_entrada_de_Men&uacute;</A>
				</P>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Otros_Aspectos_Diversos">Otros_Aspectos_Diversos</A>
		<BR>&nbsp;</P>
	</UL>
	<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Librer&iacute;a_Formulario">Librer&iacute;a_Formulario</A>
	<BR>&nbsp; 
	</P>
	<UL>
		<P><B>* </B><A HREF="#Compilaci&oacute;n_con_la_librer&iacute;a_Formularios">Compilaci&oacute;n_con_la_librer&iacute;a_Formularios</A>
				</P>
		<P><B>* </B><A HREF="#Descripci&oacute;n_de_Formularios">Descripci&oacute;n_de_Formularios</A>
				</P>
		<P><B>* </B><A HREF="#Crear_y_Liberar_Campos_y_Formularios">Crear_y_Liberar_Campos_y_Formularios</A>
				</P>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Cambiar_Atributos_de_Campos">Cambiar_Atributos_de_Campos</A>
		<BR>&nbsp; 
		</P>
		<UL>
			<UL>
				<P><B>* </B><A HREF="#Cambio_de_tama&ntilde;o_y_localizaci&oacute;n_Datos">Cambio_de_tama&ntilde;o_y_localizaci&oacute;n_Datos</A>
								</P>
				<P><B>* </B><A HREF="#Cambiar_la_localizaci&oacute;n_de_un_Campo">Cambiar_la_localizaci&oacute;n_de_un_Campo</A>
								</P>
				<P><B>* </B><A HREF="#El_Atributo_de_Justificaci&oacute;n">El_Atributo_de_Justificaci&oacute;n</A>
								</P>
				<P><B>* </B><A HREF="#Visualizaci&oacute;n_de_Atributos_de_Campo">Visualizaci&oacute;n_de_Atributos_de_Campo</A>
								</P>
				<P><B>* </B><A HREF="#Bits_de_Opciones_de_Campo">Bits_de_Opciones_de_Campo</A>
								</P>
				<P><B>* </B><A HREF="#Estados_de_Campo">Estados_de_Campo</A> 
				</P>
				<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Puntero_de_Campo_para_Usuario">Puntero_de_Campo_para_Usuario</A>
				<BR>&nbsp;</P>
			</UL>
		</UL>
		<P><B>* </B><A HREF="#Campos_Variables_de_Tama&ntilde;o">Campos_Variables_de_Tama&ntilde;o</A>
				</P>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Validaci&oacute;n_de_Campo">Validaci&oacute;n_de_Campo</A>
		<BR>&nbsp; 
		</P>
		<UL>
			<UL>
				<P><B>* </B><A HREF="#TYPE_ALPHA">TYPE_ALPHA</A> 
				</P>
				<P><B>* </B><A HREF="#TYPE_ALNUM">TYPE_ALNUM</A> 
				</P>
				<P><B>* </B><A HREF="#TYPE_ENUM">TYPE_ENUM</A> 
				</P>
				<P><B>* </B><A HREF="#TYPE_INTEGER">TYPE_INTEGER</A> 
				</P>
				<P><B>* </B><A HREF="#TYPE_NUMERIC">TYPE_NUMERIC</A> 
				</P>
				<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#TYPE_REGEXP">TYPE_REGEXP</A>
				<BR>&nbsp;</P>
			</UL>
		</UL>
		<P><B>* </B><A HREF="#Manipulaci&oacute;n_del_Buffer_Field_Directo">Manipulaci&oacute;n_del_Buffer_Field_Directo</A>
				</P>
		<P><B>* </B><A HREF="#Atributos_de_Formularios">Atributos_de_Formularios</A>
				</P>
		<P><B>* </B><A HREF="#Control_de_Visualizaci&oacute;n_de_Formularios">Control_de_Visualizaci&oacute;n_de_Formularios</A>
				</P>
		<P STYLE="margin-bottom: 0cm"><B>*
		</B><A HREF="#Entrada_en_Dispositivo_de_Formularios">Entrada_en_Dispositivo_de_Formularios</A>
		<BR>&nbsp; 
		</P>
		<UL>
			<UL>
				<P><B>* </B><A HREF="#Petici&oacute;n_de_Navegaci&oacute;n_de_P&aacute;gina">Petici&oacute;n_de_Navegaci&oacute;n_de_P&aacute;gina</A>
								</P>
				<P><B>* </B><A HREF="#Petici&oacute;n_de_Navegaci&oacute;n_InterCampo">Petici&oacute;n_de_Navegaci&oacute;n_InterCampo</A>
								</P>
				<P><B>* </B><A HREF="#Petici&oacute;n_de_Navegaci&oacute;n_IntraCampo">Petici&oacute;n_de_Navegaci&oacute;n_IntraCampo</A>
								</P>
				<P><B>* </B><A HREF="#Petici&oacute;n_de_Paginar">Petici&oacute;n_de_Paginar</A>
								</P>
				<P><B>* </B><A HREF="#Petici&oacute;n_de_Editado_de_Campos">Petici&oacute;n_de_Editado_de_Campos</A>
								</P>
				<P><B>* </B><A HREF="#Petici&oacute;n_de_Editado_de_Campos">Petici&oacute;n_de_Editado_de_Campos</A>
								</P>
				<P><B>* </B><A HREF="#Petici&oacute;n_de_Orden">Petici&oacute;n_de_Orden</A>
								</P>
				<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Comandos_de_la_Aplicaci&oacute;n">Comandos_de_la_Aplicaci&oacute;n</A>
				<BR>&nbsp;</P>
			</UL>
		</UL>
		<P><B>* </B><A HREF="#Cambiar_Enlaces_en_los_Campos">Cambiar_Enlaces_en_los_Campos</A>
				</P>
		<P><B>* </B><A HREF="#Comandos_de_cambios_de_Campos">Comandos_de_cambios_de_Campos</A>
				</P>
		<P><B>* </B><A HREF="#Opciones_de_Formularios">Opciones_de_Formularios</A>
				</P>
		<P STYLE="margin-bottom: 0cm"><B>* </B><A HREF="#Tipos_de_validaci&oacute;n_del_Usuario">Tipos_de_validaci&oacute;n_del_Usuario</A>
		<BR>&nbsp; 
		</P>
		<UL>
			<UL>
				<P><B>* </B><A HREF="#Tipos_de_Uniones">Tipos_de_Uniones</A> 
				</P>
				<P><B>* </B><A HREF="#Nuevos_Tipos_de_Campos">Nuevos_Tipos_de_Campos</A>
								</P>
				<P><B>* </B><A HREF="#Argumentos_de_Funciones_de_Validaci&oacute;n">Argumentos_de_Funciones_de_Validaci&oacute;n</A>
								</P>
				<P><B>* </B><A HREF="#Funciones_de_orden_para_Tipos_de_Usuario">Funciones_de_orden_para_Tipos_de_Usuari</A>
								</P>
				<P><B>* </B><A HREF="#Evitar_Problemas">Evitar_Problemas</A></P>
			</UL>
		</UL>
	</UL>
</UL>
<HR>
<P><A NAME="_Ref455395236"></A><A NAME="Introducci&oacute;n"></A><B><FONT SIZE=4>Introducci&oacute;n</FONT></B>
</P>
<P>Este documento es una introducci&oacute;n para programar con
Curses. No es una referencia exhaustiva para la Interfaz de
Programaci&oacute;n de Aplicaciones de Curses (API); este papel esta
cubierto por las p&aacute;ginas del manual de curses. Mejor dicho,
pretende ayudar a programadores de C facilit&aacute;ndoles el uso del
paquete. 
</P>
<P>Este documento est&aacute; dirigido a programadores de
aplicaciones en C que no est&aacute;n especialmente familiarizados
con <I>Ncurses. </I>Si usted es un especialista programador de
<I>Curses</I>, no necesita leer las secciones de <A HREF="#Interfaz_de_Rat&oacute;n">Interfaz_de_Rat&oacute;n</A>,
<A HREF="#Depuraci&oacute;n">Depuraci&oacute;n</A>,
<A HREF="#Compatibilidad_con_versiones_anteriores">Compatibilidad_con_versiones_anteriores</A>,
<A HREF="#Avisos_Consejos_Y_Trucos">Avisos_Consejos_Y_Trucos</A>.
Esto le llevar&aacute; con velocidad a las caracter&iacute;sticas y
rasgos especiales de la implementaci&oacute;n de <I>Ncurses. </I>Si
usted no tiene tanta experiencia, contin&uacute;e leyendo. 
</P>
<P>El paquete <I>Curses</I> es una subrutina de librer&iacute;a para
el terminal independiente de pintura de pantalla y manejo de sucesos
de entrada que presenta un modelo de pantalla de alto nivel al
programador, ocultando diferencias entre los diferentes tipos de
terminales y haciendo optimizaci&oacute;n autom&aacute;tica de la
salida de una pantalla llena de texto en otra. <I>Curses</I> utiliza
un terminal de informaci&oacute;n, que es un formato de base de datos
que puede describir las capacidades de miles de terminales
diferentes. 
</P>
<P>El Curses API puede parecerse a los terminales arcaicos de los
entornos UNIX cada vez m&aacute;s dominados por X, Motif y Tcl/Tk. 
</P>
<P>Sin embargo, UNIX todav&iacute;a soporta l&iacute;neas TTY y X
soporta xterm(1); El Curses API tiene la ventaja de : a)
respaldo-portabilidad de la celda del car&aacute;cter de un terminal,
y b) simplicidad. Para una aplicaci&oacute;n que no necesite gr&aacute;ficos
mapas de bits y fuentes m&uacute;ltiples, una implementaci&oacute;n
usando curses ser&aacute; t&iacute;picamente un gran negocio m&aacute;s
simple y menos caro que uno usando una herramienta X. 
</P>
<P><A NAME="_Ref455395257"></A><A NAME="Breve_historia_de_curses"></A>
<B><FONT SIZE=4>Breve historia de&nbsp;Curses</FONT></B> 
</P>
<P>Hist&oacute;ricamente, el primer antecesor de curses fueron las
rutinas escritas para proporcionar el manejo de pantalla para el
juego ?rogue?; esto utilizaba las ya existentes capacidades de la
base de datos de capacidades del terminal (termcap) para describir
capacidades del terminal. Las rutinas fueron abstra&iacute;das dentro
de una librer&iacute;a documentada y lanzadas por primera vez con las
versiones tempranas de BSD UNIX. 
</P>
<P>System III UNIX de Bell Labs constaba de una librer&iacute;a
curses reescrita y mucho m&aacute;s mejorada. Esta inclu&iacute;a el
formato del terminal de informaci&oacute;n(terminfo). Este terminal
se basa en la base de datos de capacidades del terminal (termcap) de
Berkeley, pero contiene mejoras y extensiones. Cadenas de caracteres
con capacidades parametrizadas fueron introducidas, haciendo posible
describir m&uacute;ltiples atributos de v&iacute;deo, colores y
manejar muchos mas terminales no usuales que con el terminal anterior
(termcap). En los posteriores lanzamientos de AT&amp;T System V ,
curses desarrolla el uso de mas facilidades y ofrece m&aacute;s
capacidades, llegando incluso m&aacute;s all&aacute; que las curses
de BSD en poder y flexibilidad. 
</P>
<P><A NAME="Alcance_de_este_documento"></A><B><FONT SIZE=4>Alcance de
este documento</FONT></B> 
</P>
<P>Este documento describe ncurses, una implementaci&oacute;n
gratuita de las curses API de System V con algunas extensiones
claramente marcadas. Incluye las siguientes caracter&iacute;sticas de
las curses de System V: 
</P>
<P><FONT FACE="Symbol">&middot;</FONT> Soporte para m&uacute;ltiple
atributo de pantalla (highlight) de pantalla (curses de BSD solo
manejaban unos atributos de pantalla de salida, normalmente
video-inverso ). 
</P>
<P><FONT FACE="Symbol">&middot;</FONT> Soporte de dibujo de l&iacute;neas
y cajas usando caracteres de formularios. 
</P>
<P><FONT FACE="Symbol">&middot;</FONT> Reconocimiento de teclas de
funciones en la entrada. 
</P>
<P><FONT FACE="Symbol">&middot;</FONT> Soporte de color. 
</P>
<P><FONT FACE="Symbol">&middot;</FONT> Soporte de blocs (pads)
(ventanas con el largo de la pantalla en las que la pantalla o una
subventana define una ventana de vista). 
</P>
<P>Adem&aacute;s, este paquete realiza el uso de las caracter&iacute;sticas
de insertar y borrar l&iacute;neas y caracteres de terminales mas
equipados, y determina c&oacute;mo para optimizar utilizan estas
caracter&iacute;sticas sin ayuda del programador. Esto permite
combinaciones arbitrarias de atributos de v&iacute;deo para ser
presentados, incluso en terminales que dejan ?magic cookies? en la
pantalla para marcar cambios en los atributos. 
</P>
<P>El paquete ncurses puede tambi&eacute;n capturar y usar eventos de
un rat&oacute;n en algunos entornos (notablemente, xterm bajo el
sistema de ventanas X). Este documento incluye consejos para el uso
del rat&oacute;n. 
</P>
<P>El paquete ncurses fue creado por Pavel Curtis. La persona que
mantiene originalmente el paquete es Zeyd Ben-Halim
&lt;<A HREF="mailto:zmbenhal@clark.net">zmbenhal@clark.net</A>&gt;.
Eric S. Raymon <A HREF="mailto:esr@snark.thyrus.com">esr@snark.thyrus.com</A>
escribi&oacute; muchas de las nuevas caracter&iacute;sticas en las
versiones posteriores a 1.8.1 y escribi&oacute; la mayor parte de
esta introducci&oacute;n. Las personas que lo mantienen ahora
primario actuales son Thomas Dickey &lt;dickey@clark.net&gt; y
Juergen Pfeifer &gt;<A HREF="mailto:Juergen.Pfeifer@T-Online.de">Juergen.Pfeifer@T-Online.de</A>&gt;
</P>
<P>Este documento describe tambi&eacute;n la librer&iacute;a de
extensiones <A HREF="#Paneles">Paneles</A>, similarmente producida en
la capacidad <A HREF="#Paneles">Paneles</A> de SVr4. Esta librer&iacute;a
te permite asociar almacenamiento secundario con cada pila o
superficie de ventanas sobrelapadas, y proporciona operaciones de
movimiento de ventanas alrededor de la pila y cambios en su
visibilidad de modo natural (manejando ventanas solapadas). 
</P>
<P>Finalmente, este documento describe en detalle las librer&iacute;as
de <A HREF="#Men&uacute;">Men&uacute;</A> y <A HREF="#Formulario">Formulario</A>
(forms), tambi&eacute;n copiadas de System V, que soporta f&aacute;cil
construcci&oacute;n y secuencias de men&uacute;s y formularios
rellenables. Este c&oacute;digo fue contribuido al proyecto por J&uuml;gen
Pfeifer. 
</P>
<P><A NAME="Terminolog&iacute;a"></A><B><FONT SIZE=4>Terminolog&iacute;a</FONT></B>
</P>
<P>En este documento, la siguiente terminolog&iacute;a es utilizada
con consistencia razonable: 
</P>
<P>Ventana 
</P>
<P>Estructura de datos que describe un subrect&aacute;ngulo de la
pantalla (posiblemente la pantalla entera). Puede escribir en la
ventana como si fuera una pantalla en miniatura, haciendo el barrido
independiente de otras ventanas en la pantalla f&iacute;sica. 
</P>
<P><B>Pantallas</B> 
</P>
<P>Subconjunto de ventanas que son tan grandes como el terminal de
pantalla, por ejemplo, comienzan en la esquina izquierda superior y
abarca hasta la esquina izquierda inferior. Una de estas, stdscr, es
suministrada autom&aacute;ticamente para el programador. 
</P>
<P><B>Pantalla Terminal</B> 
</P>
<P>La idea del paquete de que presentaci&oacute;n de terminal aparece
actualmente, por ejemplo, cual ve el usuario ahora. Esto es una
pantalla especial. 
</P>
<P><A NAME="Notas_sobre_esta_traduccion"></A><B><FONT SIZE=4>Notas
sobre esta traducci&oacute;n</FONT></B> 
</P>
<P>El documento original del que se ha realizado esta traducci&oacute;n
se llama &quot;Writing Programs with ncurses&quot; cuyos autores, tal
y como se explica en otros apartados, fueron Eric S. Raymond y Zeyd
M. Ben-Hamlim. Este documento se puede encontrar en diversas
direcciones de internet, a continuaci&oacute;n escribimos algunas de
estas: 
</P>
<UL>
	<UL>
		<P><A HREF="http://bat710.univ-lyon1.fr/~ascil/ncurses/">http://bat710.univ-lyon1.fr/~ascil/ncurses/</A>
				</P>
		<P><A HREF="http://www.aaronsrod.com/freemoney/ncurses-intro.html">http://www.aaronsrod.com/freemoney/ncurses-intro.html</A>
				</P>
		<P><A HREF="http://aotech1.tuwien.ac.at/~dusty/ncurses-intro.html">http://aotech1.tuwien.ac.at/~dusty/ncurses-intro.html</A></P>
	</UL>
</UL>
<P>Otras direcciones interesantes que contiene documentos sobre la
librer&iacute;a ncurses, incluso documentos con el mismo titulo que
este pero que en realidad no son igual que este, son: 
</P>
<UL>
	<UL>
		<P><A HREF="http://www.ecks.org/docs/ncurses-hack.html">http://www.ecks.org/docs/ncurses-hack.html</A>
		(Documento de ncurses para hackers)</P>
	</UL>
</UL>
<P>Esta traducci&oacute;n ha sido realizada por Patricia Mart&iacute;nez
Cano, alumna de la Facultad de Inform&aacute;tica de la Universidad
de Murcia, bajo la coordinaci&oacute;n de <A HREF="mailto:piernas@ditec.um.es">Juan
Piernas C&aacute;novas</A>. La publicaci&oacute;n de esta traducci&oacute;n
ha sido autorizada por Eric S. Raymond 
</P>
<P><A NAME="La_Libreria_Curses"></A><B><FONT SIZE=4>La Librer&iacute;a
Curses</FONT></B> 
</P>
<P><A NAME="Una_descripcion_de_Curses"></A><B><FONT SIZE=4>Una
descripci&oacute;n de Curses</FONT></B> 
</P>
<P><A NAME="Compilar_programas_utilizando_Curses"></A><B>Compilar
programas utilizando Curses</B> 
</P>
<P>Para utilizar la librer&iacute;a, es necesario tener ciertos tipos
y variables definidas. Por ello, el programador debe tener una l&iacute;nea:
</P>
<P>#include &lt;curses.h&gt; 
</P>
<P>al principio del programa. El paquete de pantalla utiliza la
librer&iacute;a est&aacute;ndar I/O, por consiguiente &lt;curses.h&gt;
incluye &lt;stdio.h&gt;. &gt;curses.h&gt; tambi&eacute;n incluye
&lt;termios.h&gt;, &lt;termio.h&gt; o &lt;sgtty.h&gt; dependiendo de
su sistema. Es redundante (pero inofensivo) para el programador
incluirlas, tambi&eacute;n. Al enlazar con curses usted necesita
tener -lncurses en su LDFLAGS o en la l&iacute;nea de comando. No se
necesita para otras librer&iacute;as. 
</P>
<P><A NAME="Actualizaci&oacute;n_de_pantalla"></A><B>Actualizaci&oacute;n
de pantalla</B> 
</P>
<P>Para actualizar la pantalla &oacute;ptimamente, es necesario para
las rutinas saber que aspecto tiene la pantalla actual y que aspecto
quiere el programador que tenga despu&eacute;s. Para este prop&oacute;sito,
una tipo de estructura de datos llamada ?window? se define como la
que describe la imagen de una ventana para las rutinas, incluyendo su
posici&oacute;n de comienzo en la pantalla (la coordenada (y,x) de la
esquina superior izquierda) y su tama&ntilde;o. Una de estas (llamada
curscr, para la pantalla actual) es una imagen de pantalla de c&oacute;mo
el terminal actual aparece. Otra pantalla (llamada stdscr, para
pantalla est&aacute;ndar) es suministrada por defecto para hacer
cambios en ella. 
</P>
<P>Una ventana es puramente una representaci&oacute;n interna. Se
utiliza para construir y almacenar una imagen potencial de una
porci&oacute;n del terminal. No lleva necesariamente una relaci&oacute;n
con que esta realmente en el terminal; es mas como un cuaderno de
apuntes o un buffer escrito. 
</P>
<P>Para hacer que la secci&oacute;n de la pantalla f&iacute;sica
correspondiente a una ventana refleje el contenido de la estructura
de la ventana, la rutina refresh() (o wrefresh() si la ventana no es
stdscr) es llamada. 
</P>
<P>Una secci&oacute;n f&iacute;sica dada puede estar sin el alcance
de un numero de ventanas solapadas. Adem&aacute;s, se pueden realizar
cambios en las ventanas en cualquier orden, sin poner atenci&oacute;n
en la eficiencia. Entonces, el programador puede efectivamente decir
?haz que parezca esto?, y dejar a la implementaci&oacute;n del
paquete determinar el camino mas eficiente de repintar la pantalla. 
</P>
<P><A NAME="Ventanas_Est&aacute;ndar_y_convenciones"></A><B>Ventanas
est&aacute;ndar y convenciones de nombramiento de Funciones</B> 
</P>
<P>Como se ha indicado anteriormente, las rutinas puedes usar
distintas ventanas, pero dos son dadas autom&aacute;ticamente:
curscr, la cual sabe el aspecto del terminal, y stdscr, la cual es el
aspecto que el programador quiere que tenga el terminal despu&eacute;s.
El usuario no debe nunca realmente acceder directamente a curscr. Los
cambio deben ser realizados a trav&eacute;s de API, y entonces la
rutina de refresco (refresh()) o wrefresh) ser&aacute; llamada. 
</P>
<P>Muchas funciones son definidas para utilizar stdscr como pantalla
por defecto. Por ejemplo, para a&ntilde;adir un car&aacute;cter a
stdsc, se realiza una llamada a addch() con el car&aacute;cter
deseado como argumento. Para escribir en una ventana diferente el uso
de la rutina waddch() (para una ventana espec&iacute;fica
,?w?indow-specific addch()) es permitido. Esta convenci&oacute;n de
prefijar los nombres de las funciones con una ?w? cuando se aplican a
ventanas espec&iacute;ficas es consistente. Las &uacute;nicas rutinas
que no sigue esto son aquellas en las que una ventana debe ser
siempre especificadas. 
</P>
<P>Para mover las coordenadas actuales (y,x) de un punto a otro, se
proporcionan las rutinas move() y wmove(). 
</P>
<P>Sin embargo, es a veces deseable para el primer movimiento y
despu&eacute;s actuar con alguna operaci&oacute;n de entrada
salida(I/O ). Para evitar torpezas, muchas de las rutinas de entrada
salida pueden ser precedidas por el prefijo ?mv? y la coordenada
(y,x) deseada como argumento de la funci&oacute;n. Por ejemplo, la
llamada 
</P>
<P>move(y,x); 
</P>
<P>addch(ch); 
</P>
<P>puede ser reemplazada por 
</P>
<P>mvaddch(y,x,ch); 
</P>
<P>y 
</P>
<P>wmove(win,y,x); 
</P>
<P>waddch(win,ch); 
</P>
<P>puede ser reemplazada por 
</P>
<P>mvwaddch(win,y,x,ch); 
</P>
<P>N&oacute;tese que el puntero de descripci&oacute;n de la ventana
(win) va despu&eacute;s de las coordenadas a&ntilde;adidas (y,x). Si
la funci&oacute;n requiere de un puntero de ventana, siempre ser&aacute;
pasado como primer par&aacute;metro. 
</P>
<P><A NAME="Variables"></A><B>Variables</B> 
</P>
<P>La librer&iacute;a curses presenta algunas variables que describen
las capacidades del terminal. 
</P>
<P>Tipo nombre descripci&oacute;n 
</P>
<P>------------------------------------------------------------------
</P>
<P>int LINES numero de l&iacute;neas en el terminal 
</P>
<P>int COLS numero de columnas en el terminal 
</P>
<P>La librer&iacute;a curses.h : adem&aacute;s introduce algunos
constantes definidas y tipos de uso general: 
</P>
<P>bool 
</P>
<P>Tipo booleano, realmente es un `char' (e.g., bool doneit;) 
</P>
<P>TRUE 
</P>
<P>Flag booleano `true' (1). 
</P>
<P>FALSE 
</P>
<P>Flag booleano `false' (0). 
</P>
<P>ERR 
</P>
<P>Flag de error devuelto por rutinas en un fallo (-1). 
</P>
<P>OK 
</P>
<P>Flag de error devuelto por rutinas cuando las cosas acaban con
&eacute;xito. 
</P>
<P><A NAME="Uso_de_la_Librer&iacute;a"></A><B><FONT SIZE=4>Uso de la
Librer&iacute;a</FONT></B> 
</P>
<P>Ahora describimos como utilizar realmente el paquete de pantalla.
En esto, nosotros asumimos que toda la actualizaci&oacute;n, lectura,
etc. es realizada por stdscr. 
</P>
<P>Estas instrucciones trabajaran en una ventana, suministrando usted
los cambios en los nombres y par&aacute;metros como se ha mencionado
arriba. 
</P>
<P>Aqu&iacute; hay un programa ejemplo para motivar la discusi&oacute;n:
</P>
<P>#include &lt;curses.h&gt; 
</P>
<P>#include &lt;signal.h&gt; 
</P>
<P>static void finish(int sig); 
</P>
<P>main(int argc, char *argv[]) 
</P>
<P>{ 
</P>
<P>/* actualice aqu&iacute; sus estructuras de datos no son de curses
*/ 
</P>
<P>(void) signal(SIGINT, finish); /* organizar interrupciones para
terminar */ 
</P>
<P>(void) initscr(); /* inicializar la librer&iacute;a curses */ 
</P>
<P>keypad(stdscr, TRUE); /* permitir el mapeo de teclado */ 
</P>
<P>(void) nonl(); /* decir a curses no hacer NL-&gt;CR/NL a la salida
*/ 
</P>
<P>(void) cbreak(); /* coger los caracteres de entrada uno cada vez,
no esperar por ellos \n */ 
</P>
<P>(void) noecho(); /* no hacer el eco de entrada */ 
</P>
<P>if (has_colors()) 
</P>
<P>{ 
</P>
<P>start_color(); 
</P>
<P>/* 
</P>
<P>* Asignaci&oacute;n de colores simples, todos los necesarios
normalmente. 
</P>
<P>*/ 
</P>
<P>init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK); 
</P>
<P>init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK); 
</P>
<P>init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK); 
</P>
<P>init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK); 
</P>
<P>init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK); 
</P>
<P>init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK); 
</P>
<P>init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK); 
</P>
<P>init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK); 
</P>
<P>} 
</P>
<P>for (;;) 
</P>
<P>{ 
</P>
<P>int c = getch(); /* refresco, aceptar una tecla pulsada en la
entrada */ 
</P>
<P>/* procesar el comando y la tecla pulsada */ 
</P>
<P>} 
</P>
<P>finish(0); /* Ya lo hemos realizado */ 
</P>
<P>} 
</P>
<P>static void finish(int sig) 
</P>
<P>{ 
</P>
<P>endwin(); 
</P>
<P>/* hacer el wrapup no-curses aqui */ 
</P>
<P>exit(0); 
</P>
<P>} 
</P>
<P><A NAME="Comenzar"></A><B>Comenzar</B> 
</P>
<P>Para utilizar el paquete de pantalla, las rutinas deben conocer
las caracter&iacute;sticas del terminal, y el espacio para curscr y
stdscr debe estar asignado. La funci&oacute;n initscr() realiza ambas
cosas. Puesto que debe asignar espacio para las ventanas, puede
provocar un desbordamiento cuando intente hacerlo. Esto ocurre en
raras ocasiones, initscr() podr&aacute; terminar el programa con un
mensaje de error. Initscr() debe siempre ser referenciada antes de
las rutinas que afectan a las ventanas que son utilizadas. Si esto no
es as&iacute;, el programa podr&aacute; hacer un volcado del n&uacute;cleo
tan pronto como curscr o stdscr sean referenciadas. Sin embargo, es
normalmente mejor esperar que se la llame cuando usted este seguro de
que la necesitar&aacute;, as&iacute; como chequear para comprobar
errores en la inicializaci&oacute;n. Las rutinas de cambios de estado
como nl() y cbreak() deben ser referenciadas despu&eacute;s de
iniscr(). 
</P>
<P>Una vez que las ventanas de pantalla han sido situadas en memora,
usted puede establecerlas en su programa. Si quiere permitir a una
pantalla hace el barrido, use scrollok(). Si quiere que el cursor
este en la izquierda despu&eacute;s del ultimo cambio, utilice
leaveok(). Si esto no se realiza, refresh() mover&aacute; el cursor a
la coordenada actual (y,x) de la pantalla despu&eacute;s de
actualizarla. 
</P>
<P>Usted puede crear nuevas de ventanas por si mismo utilizando las
funciones newwin(), derwin(), y subwin(). La rutina delwin() le
permitir&aacute; deshacerse de ventanas antiguas. Todas estas
opciones descritas anteriormente pueden ser aplicadas a cualquier
ventana. 
</P>
<P><A NAME="Salida"></A><B>Salida (Output)</B> 
</P>
<P>Ahora que las cosas han sido establecidas, querr&aacute; en
realidad actualizar el terminal. Las funciones b&aacute;sicas
utilizadas para cambiar lo que ira en una ventana son addch() y
move(). addch() a&ntilde;ade un car&aacute;cter a las coordenadas
(y,x) actuales. move() cambia las coordenadas (y,x) actuales a donde
quiera usted que est&eacute;n. Devuelve un ERR si intenta mover fuera
de la ventana. Como se menciona arriba, puede combinar las dos en
mvaddch() para hacer ambas cosas a la vez. 
</P>
<P>Las otras funciones de salida, como addstr() y printw(), todas
llaman a addch() para a&ntilde;adir caracteres a la ventana. 
</P>
<P>Despu&eacute;s de que haya puesto en la ventana lo que usted
quer&iacute;a all&iacute;, cuando quiera que la parte del terminal
cubierta por la ventana tenga ese aspecto, debe llamar a refresh().
Para optimizar el hecho de que se encuentren los cambios, refresh()
asume que parte de la ventana no cambiada desde el ultimo refresh()
de la ventana no ha sido actualizado en el terminal, por ejemplo, que
no ha refrescado la parte del terminal con la ventana solapada. Si no
es este caso, la rutina touchwin() se suministra para hacer que
parezca que la ventana entera ha sido cambiada, de este modo realiza
refresh() chequeando la subsecci&oacute;n entera del terminal para
los cambios. 
</P>
<P>Si llama a wrefresh() con curscr como argumento, har&aacute; que
la pantalla parezca como curscr piensa que debe parecer. Esto es &uacute;til
para implementar un comando que redibuje la pantalla en caso de
desorden. 
</P>
<P><A NAME="Entrada"></A><B>Entrada (Input)</B> 
</P>
<P>La funci&oacute;n complementaria de addch() es getch() que, si el
eco esta activo, llamara a addch() para sacar el car&aacute;cter por
pantalla. Por ello el terminal necesita saber que hay en el terminal
a todas horas, si los caracteres est&aacute;n siendo sacados por
pantalla, el tty debe estar en modo crudo o cocinado (cbreak). Por
ello inicialmente el terminal ha activado el eco y esta en modo
cocinado, uno o el otro ha sido cambiado antes de llamar a getch();
de otro modo, la salida del programa ser&aacute; impredecible 
</P>
<P>Cuando necesita aceptar una l&iacute;nea orientada a la entrada en
una ventana, las funciones wgetstr() y semejantes est&aacute;n
disponibles. Hay incluso una funci&oacute;n wscanw() que puede hacer
scanf()(3)- estilo de an&aacute;lisis multi-campo en la entrada de la
ventana. Estas funciones pseudo-lineas-orientadas activan el eco
mientras se ejecutan. 
</P>
<P>El c&oacute;digo ejemplo anterior utiliza la llamada a
keypad(stdscr, TRUE) para permitir el soporte de mapeado de
teclas-funciones. Con esta caracter&iacute;stica, el c&oacute;digo
getch() ve el flujo de entrada como secuencias de caracteres que
corresponden a flechas y teclas de funciones. Estas secuencias son
devueltas como valores pseudo-car&aacute;cter. Los valores de #define
devueltos son escuchados en la curses.h. El mapeo de secuencias a
valores #define es determinado mediante capacidades de teclas en la
correspondiente entrada del terminal de informaci&oacute;n. 
</P>
<P><A NAME="Uso_de_caracteres_de_Formularios"></A><B>Uso de
caracteres de Formularios</B> 
</P>
<P>La funci&oacute;n addch() (y algunas otras, incluyendo box() y
border()) pueden aceptar algunos argumentos pseudo-caracteres que son
definidos especialmente por ncurses. Estos son los valores #define
establecidos en el encabezado de curses.h; mire all&iacute; la lista
completa (busque el prefijo ACS_). 
</P>
<P>Las m&aacute;s &uacute;til de las definiciones ACS son los
caracteres de dibujo de formularios. Puede utilizar estos para
dibujar cajas y gr&aacute;ficos simples en la pantalla. Si el
terminal no tiene estos caracteres, curses.h los convertir&aacute; a
un reconocible (aunque feo) conjunto de caracteres ASCII. 
</P>
<P><A NAME="Atributos_de_caracteres_y_color"></A><B>Atributos&nbsp;de
caracteres y color</B> 
</P>
<P>El paquete ncurses soporta los atributos de pantalla incluyendo
salida normal, video-inverso, subrayado(underline), y parpadeo
(blink). Adem&aacute;s soporta color, que es tratado como otra forma
de atributo de pantalla. 
</P>
<P>Los atributos de pantalla est&aacute;n codificados, internamente,
como bits altos de los tipos de pseudo-caracteres(chtype) que
curses.h utiliza para representar el contenido de una celda de la
pantalla. Vea el encabezado del fichero curses.h para completar la
lista de valores de mascara de atributos de pantalla (busque el
prefijo A_). 
</P>
<P>Hay dos modos de hacer los atributos de pantalla. Uno es el
l&oacute;gico- o poner el valor del atributo de pantalla que desee en
el argumento del car&aacute;cter de una llamada addch(), o otra
llamada de salida, que tome un argumento chtype. El otro es poner el
valor actual del atributo. Esto esta l&oacute;gicamente relacionado
con el atributo de pantalla que especifique en el primer formulario.
Usted hace esto con las funciones attron(), attroff(), y attrset();
vea las p&aacute;ginas del manual para mas detalles. El color es una
clase especial de luminosidad. 
</P>
<P>El paquete realmente piensa en t&eacute;rminos de pares de
colores, combinaciones de colores de primer y segundo plano. El modo
sample establece ocho pares de colores, todos con garant&iacute;a
disponible en oscuro. N&oacute;tese que cada par de colores es , en
efecto, llamado con el nombre de su color de primer plano. Cualquier
otro rango de ocho valores no conflictivos podr&iacute;an haber sido
utilizados como primeros argumentos de los valores de init_pair(). 
</P>
<P>Una vez que haya hecho un init:pair() que cree N pares de colores,
puede utilizar COLOR_PAIR(N) como un atributo de pantalla que invoca
a una particular combinaci&oacute;n de color. N&oacute;tese que
COLOR_PAIR(N), para la constante N, es por si mismo una constante en
tiempo de compilaci&oacute;n y puede ser utilizada en la
inicializaci&oacute;n. 
</P>
<P><A NAME="Interfaz_de_Rat&oacute;n"></A><B>Interfaz de Rat&oacute;n</B>
</P>
<P>La librer&iacute;a curses adem&aacute;s suministra una interfaz de
rat&oacute;n. Nota: esta capacidad es original de ncurses, no es
parte de XSI Curses est&aacute;ndar, ni de la versi&oacute;n 4 de
System v, ni de curses BSD. Por ello, recomendamos que envuelva el
c&oacute;digo relacionado con el rat&oacute;n en una #ifdef
utilizando la macro caracter&iacute;stica NCURSES_MOUSE_VERSION de
esta forma no ser&aacute; compilado ni enlazado en sistemas
no-ncurses. 
</P>
<P>Actualmente, la recogida de eventos del rat&oacute;n solo trabaja
bajo xterm. En el futuro, ncurses detectara la presencia de gpm(),
una versi&oacute;n gratuita de Alessandro Rubini que es un servidor
de rat&oacute;n para sistemas Linux, y acepta la capturaci&oacute;n
de eventos a trav&eacute;s de &eacute;l. 
</P>
<P>La interfaz de rat&oacute;n es muy simple. Para activarla, puede
utilizar la funci&oacute;n mousemask(), pasando como primer argumento
el bit de mascara que especifica el tipo de evento que usted quiere
que su programa reconozca. Devolver&aacute; la m&aacute;scara de bits
de los eventos que realmente se convertir&aacute;n en visibles, los
cuales difieren del argumento si el dispositivo del rat&oacute;n no
es capaz de reconocer algunos de los tipos de eventos que usted ha
especificado. 
</P>
<P>Una vez que el rat&oacute;n esta activo, el comando de su bucle de
aplicaci&oacute;n debe observar el valor devuelto de KEY-MOUSE a
trav&eacute;s de wgetch(). Cuando vea esto el evento de rat&oacute;n
recogido ha sido introducido en la cola. Para sacarlo de ella,
utilice la funci&oacute;n getmouse() (debe hacer esto antes de la
pr&oacute;xima wgetch(), de otro modo otro evento de rat&oacute;n
puede venir y hacer el primero inaccesible. 
</P>
<P>Cada llamada a getmouse() rellena una estructura (la direcci&oacute;n
que le pasara) con el dato del evento del rat&oacute;n. El dato del
evento incluye zero-origin , las coordenadas de la celda del car&aacute;cter
de la pantalla relativa del puntero de rat&oacute;n. Adem&aacute;s
incluye una mascara de evento. Los bits en esta mascara se les dar&aacute;
un valor, correspondiendo al tipo de evento que haya sido reconocido.
</P>
<P>La estructura de rat&oacute;n contiene dos campos adicionales que
podr&iacute;an ser significativo en el futuro como interfaces ncurses
hacia nuevas formularios de dispositivo puntero. Adem&aacute;s de las
coordenadas x e y , hay un hueco para una coordenada z; esto seria
&uacute;til con las pantalla t&aacute;ctiles que devuelven un
par&aacute;metro de presi&oacute;n o duraci&oacute;n . Hay adem&aacute;s
un campo de dispositivo ID, que podr&iacute;a ser utilizado para
distinguir entre diferentes punteros de dispositivos. 
</P>
<P>La clase de eventos visibles puede ser cambiada en cualquier
momento a trav&eacute;s de mousemask(). Los eventos pueden ser
reconocidos incluyendo pulsaci&oacute;n, liberaci&oacute;n, simple,
doble y triple clic (puede establecerse el m&aacute;ximo de bot&oacute;n
pulsado para los clics). Si no permite los clics, ser&aacute;n
reconocidos como pares de pulsado- liberaci&oacute;n. En algunos
entornos, la mascara de eventos incluye bits de reconocimiento del
estado de ?shift?, ?alt? y teclas de control de teclado durante los
eventos. 
</P>
<P>Tambi&eacute;n se incluye una funci&oacute;n para chequear si ha
ca&iacute;do un evento de rat&oacute;n dentro de ventanas dadas.
Puede utilizarla para ver si una ventada dada puede considerar un
evento de rat&oacute;n relevante a ella. 
</P>
<P>Debido a que el reconocimiento de eventos de rat&oacute;n no
estar&aacute; disponible en todos los entornos, seria poco
aconsejable construir aplicaciones ncurses que requieran el uso de
rat&oacute;n. Mas bien, deber&iacute;a utilizar el rat&oacute;n como
una alternativa para comandos punto y disparo que su aplicaci&oacute;n
normalmente aceptar&iacute;a por teclado. Dos de los juegos test en
las distribuciones ncurses (bs y knight) contiene c&oacute;digo que
ilustra como puede realizarse eso. 
</P>
<P>Lea la pagina de manual para curs_mouse(3X) para mas detalles de
ls funciones de la interfaz de rat&oacute;n. 
</P>
<P><A NAME="Finalizaci&oacute;n"></A><B>Finalizaci&oacute;n</B> 
</P>
<P>Para limpiar despu&eacute;s de las rutinas ncurses, se suministra
la rutina endwin(). Esta restaura los modos de tty a como estuvieran
cuando initscr() fue llamada por primera vez, y mueve el cursor abajo
a la esquina izquierda. Por esto en cualquier momento despu&eacute;s
de la llamada a initscr, endwin() deber&iacute;a ser referenciada
antes de la salida. 
</P>
<P><A NAME="Descripci&oacute;n_de_Funciones"></A><B><FONT SIZE=4>Descripci&oacute;n
de Funciones</FONT></B> 
</P>
<P>Describiremos a continuaci&oacute;n con detalle el comportamiento
de varia funciones de curses importantes, como complemento de las
paginas de descripci&oacute;n del manual. 
</P>
<P><A NAME="Inicializaci&oacute;n_y_Wrapup"></A><B>Inicializaci&oacute;n
y Wrapup</B> 
</P>
<P>Initscr(): La primera funci&oacute;n referenciada deber&iacute;a
ser siempre initscr(). Esta determinara el tipo de terminal e
inicializa las estructuras de datos de curses. initscr () adem&aacute;s
decide que la primera llamada a refresh() limpiar&aacute; la
pantalla. Si se produce un mensaje de error se escribe en el error
est&aacute;ndar y el programa termina su ejecuci&oacute;n. Por otra
parte devuelve un puntero a stdscr. Unas pocas funciones deben ser
llamadas antes de initscr (slk_init(), filter(), ripofflines(),
use_env(), y si esta utilizando m&uacute;ltiples terminales ,
newterm()). 
</P>
<P>Endwin(): Su programa debe siempre referenciar a endwin() antes de
finalizar o salir del programa. Esta funcion restaurara los modos
tty, movera el cursor al al esquina de abajo izquierda de la
pantalla, inicializa el terminal a modo no visual. Referenciando a
refresh() o doupdate() despues de un escape temporal del programa
restaurara la pantalla ncurses que habia antes del escape. 
</P>
<P>Newterm(type,ofp, ifp) : Un programa que sale a mas de un terminal
utiliza newterm() en vez de initscr(). newterm() debe ser
referenciado una vez por cada terminal: Devuelve una variable de tipo
SCREEN* que debe ser salvada como la referencia a un terminal. Los
argumentos son el tipo del terminal (una cadena de caracteres) y los
puntero a fichero (FILE) para la salida y entrada del terminal. Si el
tipo es NULL entonces la variable de entorno $TERM se utiliza.
Endwin() debe llamar una vez en el tiempo de los toques finales para
cada terminal abierto utilizando esta funci&oacute;n. 
</P>
<P>Set_term() : Esta funci&oacute;n se utiliza para cambiar a un
terminal diferente previamente abierto con newterm(). La pantalla de
referencia para el nuevo terminal se pasa como par&aacute;metro. El
terminal anterior es devuelto por la funci&oacute;n. Todas las dem&aacute;s
llamadas afectan solo al terminal actual. 
</P>
<P>Delscreen(sp): Es la inversa de newterm(); deslocaliza las
estructuras de datos asociadas con la referencia SCREEN dada. 
</P>
<P><A NAME="Realizar_la_salida_al_Terminal"></A><B>Realizar la salida
al Terminal</B> 
</P>
<P>Refresh() y wrefresh(win): estas funciones deben ser referenciadas
para realmente poner la salida en el terminal, como otras rutinas
solo manipulan estructuras de datos. Wrefresh() copia la ventana
nombrada al terminal f&iacute;sico de la pantalla, teniendo en cuenta
que ya esta preparada para actualizaciones. refresh() hace el
refresco de stdscr(). A menos que leaveok() haya sido activado el
cursor f&iacute;sico del terminal se deja en la localizaci&oacute;n
del cursor de la ventana. 
</P>
<P>Doupdate() y wnoutrefresh(win): estas dos funciones permiten
m&uacute;ltiples actualizaciones con mas eficiencia que wrefresh.
Para utilizarlas, es importante entender como trabaja curse. Adem&aacute;s
de todas las estructura de las ventanas, curses mantiene dos
estructura de datos que representan el terminal de pantalla: una
pantalla fisica describe que hay en realidad en la pantalla, y una
pantalla virtual, que describe lo que el programador quiere que haya
en pantalla. Wrefresh trabaja con la primera copia de la ventana
nombrada en el terminal virtual (wnoutrefrsh()), y entonces llama a
la rutina para actualizar la pantalla (doupdate()). Si el programador
desea la salida de varias ventanas a la vez, una serie de llamadas a
wrefresh() resultar&aacute;n en llamadas alternativas a
wnoutrefresh(), causando varias explosiones a la salida en la
pantalla. Llamando a wnoutrefrsh() para cada ventana, entonces es
posible llamar a doputate() una vez, resultando en un &uacute;nico
estallido a la salida, con pocos caracteres transmitidos en total
(esto adem&aacute;s evita visualizar un molesto parpadeo en cada
actualizaci&oacute;n). 
</P>
<P><A NAME="Acceso_a_las_Capacidades_de_bajo_nivel"></A><B>Acceso a
las Capacidades de bajo nivel</B> 
</P>
<P>Setupterm(term,filenum,errret): esta rutina es referenciada para
inicializar la descripci&oacute;n del terminal, sin inicializar las
estructuras de pantalla de curses o cambiar los bits de modo de los
driver de tty. Term es la cadena de caracteres que representa el
nombre del terminal que se utiliza. Filenum es el descriptor de
fichero UNIX del terminal que se usa para la salida. erret es un
puntero a un entero, en el que se devuelve la indicaci&oacute;n de un
&eacute;xito o un fallo. Los valores devueltos pueden ser 1(si todo
esta bien), 0 (finalizaci&oacute;n no adecuada) o -1(alg&uacute;n
problema localizando la base de datos del terminal de informaci&oacute;n).
</P>
<P>El valor de term puede ser un NULL, que har&aacute; que el valor
de TERM sea utilizado en el entorno. El puntero errret puede tambi&eacute;n
ser un NULL, que significa que el c&oacute;digo de error no se
quiere. Si errret tiene el valor por defecto, y algo va mal,
setpterm() escribir&aacute; por pantalla un mensaje de error
apropiado y saldr&aacute;, antes de regresar. Por esto, un programa
simple puede llamar a setupterm(0,1,0) y no preocuparse de
inicializar errores. Despu&eacute;s de la llamada a setupterm(), la
variable global cur_term esta establecida como puntero de la
estructura actual de las capacidades del terminal. Llamando a
setupterm() para cada terminal, y salvando y restaurando cur_term, es
posible para un programa utilizar dos o mas terminales a la vez.
Setupterm() adem&aacute;s restaura los nombres de la secci&oacute;n
de la descripci&oacute;n del terminal en la tabla ttytype() de
caracteres globales. En consecuencia, llama a setupterm() que
sobrescribir&aacute; esta tabla, si podr&aacute; tenerla guardada
para usted si necesita que lo este. 
</P>
<P><A NAME="Depuraci&oacute;n"></A><B>Depuraci&oacute;n</B> 
</P>
<P>NOTA: Estas funciones no forman parte de las curses API est&aacute;ndar.
</P>
<P>Trace(): esta funci&oacute;n se usa para espec&iacute;ficamente
establecer el nivel de traza. Si el nivel de traza es no-cero, la
ejecuci&oacute;n de su programa generara un fichero llamado ?trace?
en el directorio actual de trabajo conteniendo el documento de las
acciones de la librer&iacute;a. Un nivel de traza mayor permite un
documento mas detallado (y prolijo) - vea los comentarios unidos a
las definiciones TRACE_ en el fichero curses.h para mas detalles.
(Adem&aacute;s es posible establecer un nivel de traza asignando el
nivel de traza a la variable de entorno NCURSES_TRACE). 
</P>
<P>_tracef(): esta funci&oacute;n puede ser utilizada para realizar
la salida de su propia informaci&oacute;n de depuraci&oacute;n. Solo
esta disponible si realiza el enlace con _lncurses_g. Puede ser
utilizada de la misma manera que printf(),solo produce la salida a
una nueva linea despues de terminar los argumentos. La salida va a un
fichero llamado trace en el directorio actual. 
</P>
<P>Los registros de traza pueden ser dif&iacute;ciles de interpretar
debido a que hay en ellos un volumen completo del volcado de memoria.
Esto es un escrito llamado ?tracemunch? incluido con la distribuci&oacute;n
de ncurses que puede aliviar este problema de alguna manera; esto
compacta las secuencias largas de operaciones similares en l&iacute;neas
simples de pseudo-operaciones. Estas pseudo-ops pueden ser
distinguidas por el hecho de que se las nombra con letras may&uacute;sculas.
</P>
<P><A NAME="Avisos_Consejos_Y_Trucos"></A><B><FONT SIZE=4>Avisos,
Consejos Y Trucos</FONT></B> 
</P>
<P>Las paginas del manual son una completa referencia para esta
librer&iacute;a. En el resto de este documento, discutidos varios
m&eacute;todos &uacute;tiles que no son tan obvios en las
descripciones de las paginas del manual. 
</P>
<P><A NAME="Algunas_notas_de_precauci&oacute;n"></A><B>Algunas notas
de precauci&oacute;n</B> 
</P>
<P>Si se encuentra a si mismo pensando si necesita utilizar noraw() o
nocbreak(), piense de nuevo y act&uacute;e con cautela. Probablemente
sea mejor elegir utilizar getstr() o una de sus semejantes en modo
cocinado. Las funciones noraw() y nocbreak() intentan restaurar el
modo cocinado, pero pueden terminar aporreando algunos bits de
control establecidos antes de comenzar su aplicaci&oacute;n. Adem&aacute;s,
pueden siempre haber estado poco documentadas, y estar casi rompiendo
la utilidad de la aplicaci&oacute;n con otras librer&iacute;as
curses. 
</P>
<P>Lleve en mente que refresh() es un sin&oacute;nimo de wrefresh
(stdscr), y no intente mezclar el uso de stdscr con el uso de
ventanas declaradas con newwin(); una llamada a refresh() puede
quitarlas de la pantalla. La manera correcta de manejar esto es usar
subwin(), o no tocar stdscr y embaldosar su pantalla con ventanas
declaradas que usted despu&eacute;s llamara a wnoutrefresh() en
alguna parte de su bucle de eventos de programa, con una llamada
doupdate para hacer estallar el repintado actual. 
</P>
<P>Usted estar&aacute; menos cerca de tener problemas si dise&ntilde;a
sus trazados de pantalla para usar embaldosados mejor que ventanas
solapadas. Hist&oacute;ricamente, el soporte curses para ventanas
solapadas ha sido flojo, fr&aacute;gil y documentado pobremente. La
librer&iacute;a ncurses no es todav&iacute;a una excepci&oacute;n a
esta regla. 
</P>
<P>Hay una librer&iacute;a gratuita llamada paneles que se incluye en
la distribuci&oacute;n de ncurses que hace un bonito trabajo de dar
fuerza a las caracter&iacute;sticas de las ventanas solapadas. 
</P>
<P>Intente evitar utilizar las variables globales LINES y COLS.
Utilice getmaxyx() en el contexto de stdscr en su lugar. Raz&oacute;n:
su c&oacute;digo puede ser llevado para ejecutarse un entorno con
cambios de tama&ntilde;o de las ventanas, en el caso de que varias
ventanas puedan ser abiertas con diferentes tama&ntilde;os. 
</P>
<P><A NAME="Abandonar_temporalmente_el_modo_Ncurses"></A><B>Abandonar
temporalmente el modo <I>Ncurses</I></B> 
</P>
<P>Algunas veces querr&aacute; escribir un programa que se utilice la
mayor parte del tiempo en modo pantalla, pero ocasionalmente vuelva a
modo cocinado. Una raz&oacute;n com&uacute;n para esto es que permita
la salida del entorno (shell-out). Esta conducta es f&aacute;cil de
realizar con ncurses. 
</P>
<P>Para dejar el modo ncurses, llame a endwin() como si estuviera
intentando terminar el programa. Esto har&aacute; que la pantalla
vuelva al modo cocinado; puede hacer su salida del
entorno(shell-out). Cuando quiera volver a al modo ncurses,
simplemente llame a refresh() o doupdate().Esto repintara la
pantalla. 
</P>
<P>Hay una funcion booleana, isendwin(), cuyo c&oacute;digo puede
utilizarse para testear si el modo ncurses de pantalla esta activo.
Devuelve TRUE en el intervalo entre una llamada a endwin() y el
siguiente refresh(), FALSE de otra forma. 
</P>
<P>Aqu&iacute; hay un c&oacute;digo de ejemplo para la salida del
entorno: 
</P>
<P>addstr(&quot;Shelling out...&quot;); 
</P>
<P>def_prog_mode(); /* salvar los modos tty actuales */ 
</P>
<P>endwin(); /* restaurar los modos tty originales */ 
</P>
<P>system(&quot;sh&quot;); /* ejecutar el entorno(shell) */ 
</P>
<P>addstr(&quot;returned.\n&quot;); /* preparando el mensaje de
retorno */ 
</P>
<P>refresh(); /* restaurar los modos salvados, repintar la pantalla
*/ 
</P>
<P><A NAME="Uso_De_Ncurses_Bajo_Xterm"></A><B>Uso De <I>Ncurses</I>
Bajo Xterm</B> 
</P>
<P>Una operaci&oacute;n de cambio de tama&ntilde;o en X env&iacute;a
SIGWINCH a la aplicaci&oacute;n que se ejecuta bajo xterm. La
librer&iacute;a ncurses no captura la se&ntilde;al, porque no puede
en general saber como quiere que la pantalla sea repintada. Tendr&aacute;
que escribir el manejador de SIGWINCH usted mismo. 
</P>
<P>La forma mas f&aacute;cil de codificar su manejador de SIGWINCH es
haber hecho un endwin, seguida de un refresco y un repintado de
pantalla que usted codifique. El refresco recoger&aacute; un nuevo
tama&ntilde;o de pantalla del entorno xterm. 
</P>
<P><A NAME="Manipulaci&oacute;n_de_M&uacute;ltiples_Terminales"></A><B>Manipulaci&oacute;n
de M&uacute;ltiples Terminales</B> 
</P>
<P>La funci&oacute;n initscr() en realidad llama a la funci&oacute;n
llamada newterm() para hacer la mayor parte de su trabajo. Si esta
escribiendo un programa que abra m&uacute;ltiples terminales, utilice
newterm directamente. 
</P>
<P>Por cada llamada, tendr&aacute; que especificar el tipo de
terminal y un par de punteros a ficheros; cada llamada devolver&aacute;
una referencia a pantalla, y stdscr establecer&aacute; en la ultima
asignada. Cambiara de pantallas con la llamada a set_term. Note que
tambi&eacute;n tendr&aacute; que llamar a def_shell_mode y
def_prog_mode para cada tty por si mismo. 
</P>
<P><A NAME="Prueba_de_las_capacidades_del_terminal"></A><B>Prueba de
las capacidades del terminal</B> 
</P>
<P>Algunas veces usted querr&iacute;a escribir programas que testeen
la presencia de varias caracter&iacute;sticas andes de decidir si va
a entrar en el modo ncurses. Una forma f&aacute;cil de hacer esto es
llamar a setupterm(), entonces utilice las funciones tigerrflag(),
tigetnum(), y tigetstr() para hacer el test. 
</P>
<P>Un caso particularmente &uacute;til de esto surge normalmente
cuando quiere consultar si un tipo de terminal dado deber&iacute;a
ser tratado como ?smart (accesible mediante el cursor) o ?stupid?. El
modo correcto de consultar esto es miras si el valor devuelto de
tigetstr (&quot;cup&quot;) es no nulo. Alternativamente, puede
incluir el fichero term.h y testear el valor de la macro
cursor_address. 
</P>
<P><A NAME="Sintonizaci&oacute;n_para_la_velocidad"></A><B>Sintonizaci&oacute;n
para la velocidad</B> 
</P>
<P>Utilice la familia de funciones addchstr() para un repintado del
texto mas r&aacute;pido cuando sepa que el texto no contiene ning&uacute;n
car&aacute;cter de control. Intente hacer cambios en los atributos
poco frecuentes en sus pantallas. &iexcl;No utilice la opci&oacute;n
immedok()! 
</P>
<P><A NAME="Aspectos_especiales_de_Ncurses"></A><B>Aspectos
especiales de <I>Ncurses</I></B> 
</P>
<P>Cuando ejecute en PC-clonicos, ncurses ha realzado el soporte para
caracteres de gama medio altos de IBM (hight-half) y ROM. El modo de
v&iacute;deo A_ALTCHARSET , permite visualizar ambos medio-altos
gr&aacute;ficos ACS y los gr&aacute;ficos PC ROM 0-31 que normalmente
se interpretan como caracteres de control. 
</P>
<P>La funcion wresize() permite cambiar el tama&ntilde;o de una
ventana en un lugar. 
</P>
<P><A NAME="Compatibilidad_con_versiones_anteriores"></A><B><FONT SIZE=4>Compatibilidad
con versiones anteriores</FONT></B> 
</P>
<P>A pesar de nuestros mejores esfuerzos, hay algunas diferencias
entre ncurses y la (no documentada) conducta de implementaciones
anteriores de curses. Estas se presentan en la documentaci&oacute;n
de API para ambig&uuml;edades u omisiones. 
</P>
<P><A NAME="Refresco_de_ventanas_superpuestas"></A><B>Refresco de
ventanas superpuestas</B> 
</P>
<P>Si define dos ventanas A y B que se superponen, y entonces
alternativamente escriben deprisa y las refrescan, los cambios hechos
en la regi&oacute;n solapada bajo versiones hist&oacute;ricas de
curses estaban normalmente documentadas sin precisi&oacute;n. 
</P>
<P>Para comprender por qu&eacute; esto es un problema, recuerde que
las actualizaciones de pantalla son calculadas entre dos
representaciones de la visualizaci&oacute;n entera. La documentaci&oacute;n
dice que cuando usted refresque una ventana, primero es copiada a la
pantalla virtual, y entonces los cambios se calculan para actualizar
la pantalla f&iacute;sica ( y se aplican al terminal). Pero &quot;copiado&quot;
no es muy especifico, y diferencias sutiles en como el copiado de
trabajos pueden producir diferentes conductas en el caso donde dos
ventanas solapadas son cada una refrescadas en intervalos
impredecibles. 
</P>
<P>Lo que ocurre a las regiones de sobrelapado depende de que hace
wnoutrefresh() con sus argumentos -- que porci&oacute;n de la ventana
del argumento se copia a la pantalla virtual. Algunas
implementaciones hacen &quot;cambios de copia&quot;, copiando solo
posiciones en la pantalla que han sido cambiadas (o han sido marcadas
como cambiadas con wtouch() y semejantes). Algunas implementaciones
hacen &quot;copia integra&quot; copiando todas las posiciones de
pantalla a la pantalla virtual si o si no han sido cambiadas. 
</P>
<P>La librer&iacute;a ncurses por s&iacute; misma no ha sido siempre
consistente en su puntuaci&oacute;n. Debido a una traba, las
versiones 1.8.7 a 1.9.8 a hac&iacute;an la copia integra. Las
versiones 1.8.6 y anteriores, y 19.9 y m&aacute;s recientes, hacen la
copia de cambios. 
</P>
<P>Para implementaciones m&aacute;s comerciales de curses, no se
documenta y no se conoce con seguridad (por lo menos no para los que
mantienen ncurses) si hacen la copia de cambios o la copia integra.
Sabemos que la versi&oacute;n System V 3 curses tiene l&oacute;gica
en parecer que realiza la copia de cambios, pero la l&oacute;gica de
alrededor y las representaciones de datos son suficientemente
complejas, y nuestro conocimiento lo suficientemente indirecto, que
es dif&iacute;cil saber si esto es as&iacute;. No esta claro que
pretende decir la documentaci&oacute;n de SVr4y XSI est&aacute;ndar.
La XSI Curses est&aacute;ndar escasamente menciona wnourefresh(); los
documentos SVr4 parecen estar describiendo la copia integra, pero es
posible con alg&uacute;n esfuerzo y trabajo duro leerlas comprobando
la otra manera. 
</P>
<P>Deber&iacute;a por ello ser poco sensato confiar en el
comportamiento de los programas que podr&iacute;an haber estado
enlazados con otras implementaciones de curses. En su lugar, puede
hacer un expl&iacute;cito touchwin() antes de la llamada a
wnoutrefresh() para garantizar una copia integra de los contenidos a
alg&uacute;n sitio. 
</P>
<P>El modo realmente limpio de manejar esto es utilizar la librer&iacute;a
paneles. Si, cuando quiera una actualizaci&oacute;n de pantalla,
usted hace update_panels(), har&aacute; todo las llamadas necesarias
a wnourefrsh() para cualquier orden de pila de paneles que haya
definido. Entonces puede realizar un doupdate() y habr&aacute; un
simple estallido de la Entrada-Salida f&iacute;sica que har&aacute;
todas sus actualizaciones. 
</P>
<P><A NAME="Antecedentes_de_Borrado"></A><B>Antecedentes del Borrado</B>
</P>
<P>Si ha estado utilizando una versi&oacute;n muy antigua de ncuses
(1.8.7 o anterior) le sorprender&iacute;a su comportamiento para las
funciones de borrado. En versiones anteriores, las &aacute;reas
borradas de una ventana eran rellanadas con un modificado en blanco
de los atributos actuales (como hab&iacute;an sido establecidos por
wattrset(), wattron(), wattroff() y semejantes). 
</P>
<P>En versiones nuevas, esto no es as&iacute;, En cambio, los
atributos de los blancos borrados son normales a menos y hasta que se
modifiquen con las funciones bkgset() o wbkdset(). 
</P>
<P>Este cambio de actuaci&oacute;n ajusta ncurses al System V versi&oacute;n
4 y a la XSI Curses est&aacute;ndar. 
</P>
<P><A NAME="Ajuste_con_XSI_Curses"></A><B>Ajuste con XSI Curses</B> 
</P>
<P>La librer&iacute;a ncurses pretende ser un ajuste de nivel base
con la XSI Curses est&aacute;ndar de X/Open. Muchas caracter&iacute;sticas
de nivel extendido (de hecho, casi todas las caracter&iacute;sticas
que no conciernen directamente con caracteres anchos e
internacionalizaci&oacute;n) son tambi&eacute;n soportados. 
</P>
<P>Un efecto del ajuste XSI es el cambio en la conducta descrita en
<A HREF="#Antecedentes_de_Borrado">Antecedentes_de_Borrado</A>-<A HREF="#Compatibilidad_con_versiones_anteriores">Compatibilidad_con_versiones_anteriores</A>.
</P>
<P>Tambi&eacute;n, ncurses re&uacute;ne los requerimientos XSI que
cada puntero de entrada de macro tiene una funci&oacute;n
correspondiente y seria enlazada (y ser&aacute; un prototipo
chequeado) si la definici&oacute;n de la macro esta desactivada con
#undef. 
</P>
<P><A NAME="Librer&iacute;a_Paneles"></A><A NAME="Paneles"></A><B><FONT SIZE=4>Librer&iacute;a&nbsp;Paneles</FONT></B>
</P>
<P>La librer&iacute;a ncurses provee por si misma un buen soporte de
visualizaciones de pantalla en el que las ventanas son embaldosadas
(no solapadas). En casos mas generales en los que las ventanas se
solapar&iacute;an, tiene que utilizar series de llamadas
wnoutrefresh() seguidas de doupdate(), y ser cuidadoso acerca del
orden en que hace los refrescos de ventana. Tiene que ser de
abajo-arriba,, de otra manera partes de las ventanas que serian
oscurecidas se mostraran a trav&eacute;s. 
</P>
<P>Cuando su dise&ntilde;o de interfaz es tal que las ventanas se
zambullen profundamente en la pila de visibilidad o surgen a lo mas
alto en tiempo de ejecuci&oacute;n, el resultado
reserva-mantenimiento puede ser tedioso y dif&iacute;cil de conseguir
bien. De aqu&iacute; la librer&iacute;a paneles. 
</P>
<P>La librer&iacute;a paneles aparece primero en AT&amp;t system V.
La versi&oacute;n documentada aqu&iacute; es el c&oacute;digo
gratuito distribuido con ncurses. 
</P>
<P><A NAME="Compilaci&oacute;n_con_la_Librer&iacute;a_Paneles"></A><B><FONT SIZE=4>Compilaci&oacute;n
con la Librer&iacute;a Paneles</FONT></B> 
</P>
<P>Sus m&oacute;dulos que utilicen paneles deben importar las
definiciones de la librer&iacute;a paneles con 
</P>
<P>#include &lt;panel.h&gt; 
</P>
<P>y deben ser enlazadas expl&iacute;citamente con la librer&iacute;a
paneles utilizando un argumento -lpanel. Note que deben tambi&eacute;n
enlazar la librer&iacute;a ncurses con -lncurses. Muchos compiladores
son de dos pasos y aceptaran cualquier orden, pero es una buena
practica poner -lpanel primero y -lncurses en segundo lugar. 
</P>
<P><A NAME="Descripci&oacute;n_de_Paneles"></A><B><FONT SIZE=4>Descripci&oacute;n
de Paneles</FONT></B> 
</P>
<P>Un objeto panel es una ventana que es impl&iacute;citamente
tratada como una parte de una superficie que incluye todos los dem&aacute;s
objetos panel. La superficie tiene un orden implicito de abajo-arriba
de visibilidad. La librer&iacute;a paneles incluye una funcion de
actualizacion (analoga a refrsh()) que visualiza todos los paneles en
la superficie en el orden apropiado para resolver superposiciones. La
ventana est&aacute;ndar, stdscr, es considerada por debajo de todos
los paneles. 
</P>
<P>Detalles de las funciones de paneles est&aacute;n disponibles en
las paginas del manual. Nosotros nos acercaremos a los atributos de
pantalla. 
</P>
<P>Usted crea un panel de una ventana llamando a new_panel() con un
puntero de ventana. Este entonces llegara a la parte superior de la
superficie. La ventana del panel estar&aacute; disponible como el
valor de la llamada a panel_window() con el puntero del panel como
argumento. 
</P>
<P>Puede borrar el panel (quitarlo de la superficie) con del_panel.
Esto no descolocara la ventana asociada; tiene que hacer esto por s&iacute;
mismo. Puede reemplazar una ventana de panel con una ventana
diferente llamando a replace_window. La nueva ventana seria de
diferente tama&ntilde;o; el c&oacute;digo del panel recomputerizara
todas las superposiciones. Esta operaci&oacute;n no cambia la
posici&oacute;n del panel en la superficie. 
</P>
<P>Dos funciones (top_panel(), bottom_panel()) se suministra para
reestructurar la superficie. La primera pone su ventana argumento en
lo mas alto de la superficie; la segunda la env&iacute;a a la parte
baja. Ambas operaciones dejan la localizaci&oacute;n de pantalla,
contenido y tama&ntilde;o sin cambiar. 
</P>
<P>La funci&oacute;n update_panels() hace todas las llamadas a
wnoutrefresh necesarias para preparar doupdate()(que debe llamar
usted mismo, despu&eacute;s). 
</P>
<P>Normalmente, querr&aacute; llamar a update_panels() y doupdate()
justo antes de aceptar un comando a la entrada, una vez en cada dicho
de iteraci&oacute;n con el usuario. Si llama a update_panels()
despu&eacute;s de cada y todas las escrituras en panel, generara
muchos refrescos innecesarios y parpadeos de pantalla. 
</P>
<P><A NAME="Paneles_Salida_y_la_Pantalla_Est&aacute;ndar"></A><B><FONT SIZE=4>Paneles,
Salida, y la Pantalla Est&aacute;ndar</FONT></B> 
</P>
<P>No debe mezclar las operaciones wnout refrsh() o wrefresh() con el
c&oacute;digo de paneles; funcionara solo si la ventana argumento
esta en el panel mas alto o no oscurecido por otros paneles. 
</P>
<P>La ventana stdscr es un caso especial. Se considera por debajo de
todos los paneles. Debido a los cambios a paneles puede oscurecer
parte de stdscr, aunque, podr&iacute;a llama a update_panels() antes
de doupdate() incluso cuando solo quiera cambiar stdscr. 
</P>
<P>Note que wgetch llama autom&aacute;ticamente a wrefresh. Por ello,
contestando a la entrada de la ventana de panel, necesita estar
seguro de que el panel es totalmente no oscurecido. 
</P>
<P>No hay en el presente una forma de visualizar los cambios de un
panel oscurecido sin repintar todos los paneles. 
</P>
<P><A NAME="Escondiendo_Paneles"></A><B><FONT SIZE=4>Escondiendo
Paneles</FONT></B> 
</P>
<P>Es posible quitar un panel de la superficie temporalmente; utilice
hide_panel para esto. Utilice show_panel() para hacerlo visible de
nuevo. La funci&oacute;n predicado panel_hidden testea si un panel
esta oculto o no. 
</P>
<P>El c&oacute;digo panel_update ignora los paneles ocultos. No puede
hacer top_panel() o bottom_panel() con un panel oculto. Otras
operaciones de paneles se pueden aplicar. 
</P>
<P><A NAME="Otras_Caracter&iacute;sticas_Diversas"></A><B><FONT SIZE=4>Otras
Caracter&iacute;sticas Diversas</FONT></B> 
</P>
<P>Es posible guiar la superficie utilizando las punciones
panel_above() y panel_below. Dado un puntero de panel, devuelven un
panel por encima o por debajo de este panel. Dado NULL, devuelven el
panel mas abajo y el panel de mas arriba. 
</P>
<P>Cada panel tiene un puntero de uso asociado, no utilizado por el
c&oacute;digo del panel, al que puede adjuntar un dato de aplicaci&oacute;n.
Ver la pagina de documentaci&oacute;n de set_panel_userptr() y panel
_userptr para mas detalles. 
</P>
<P><A NAME="Librer&iacute;a_Men&uacute;"></A><A NAME="Men&uacute;"></A>
<B><FONT SIZE=4>Librer&iacute;a Men&uacute;</FONT></B> 
</P>
<P>Un men&uacute; es una pantalla de visualizaci&oacute;n que asiste
al usuario para elegir alguno de los subconjunto de un conjunto dado
de cosas. La librer&iacute;a men&uacute; es una extensi&oacute;n de
curses que soporta programaci&oacute;n f&aacute;cil de las jerarqu&iacute;as
de men&uacute;s con una uniforme pEro flexible interfaz. 
</P>
<P>La librer&iacute;a men&uacute; aparece por primera vez en AT&amp;T
system V. La versi&oacute;n documentada aqu&iacute; es un c&oacute;digo
distribuido gratuitamente con ncurses. 
</P>
<P><A NAME="Compilaci&oacute;n_con_la_Librer&iacute;a_Men&uacute;"></A>
<B><FONT SIZE=4>Compilaci&oacute;n con la Librer&iacute;a&nbsp;Men&uacute;</FONT></B>
</P>
<P>Sus m&oacute;dulos que utilicen men&uacute; deben importar las
declaraciones de la librer&iacute;a men&uacute; con 
</P>
<P>#include &lt;menu.h&gt; 
</P>
<P>y debe enlazarse expl&iacute;citamente con la librer&iacute;a men&uacute;
utilizando el argumento -lmenu. N&oacute;tese que deben tambi&eacute;n
enlazar la librer&iacute;a ncurses con -lncurses. Muchos compiladores
son de dos pasos y aceptaran cualquier orden, pero es todav&iacute;a
mejor poner -lmenu primero y -lncurses despu&eacute;s. 
</P>
<P><A NAME="Descripci&oacute;n_de_Men&uacute;s"></A><B><FONT SIZE=4>Descripci&oacute;n
de Men&uacute;s</FONT></B> 
</P>
<P>Los men&uacute;s creados por esta librer&iacute;a consisten en una
colecci&oacute;n de objetos incluyendo una parte que es cadena de
caracteres como nombre y una parte que es una cadena de caracteres
como descripci&oacute;n. Para hacer men&uacute;s, usted crea grupos
de esto objetos y los conecta con la estructura de los objetos de
men&uacute;. 
</P>
<P>El men&uacute; puede entonces ser asociado, esto es escrito a una
ventana asociada. Realmente, cada men&uacute; tiene dos ventanas
asociadas; una ventana de contenido en la que el programador puede
escribir t&iacute;tulos o bordes, y una subventana en la que los
objetos de men&uacute; propiamente dichos son visualizados. Si esta
subventana es demasiado peque&ntilde;a para visualizar todos los
objetos, ser&aacute; un punto de visualizaci&oacute;n listado con la
colecci&oacute;n de objetos. 
</P>
<P>Un men&uacute; puede tambi&eacute;n ser quitado de la asociaci&oacute;n
(esto es, no visualizado), y finalmente liberado para hacer el
almacenamiento asociado con el y con los objetos disponible para
reutilizaci&oacute;n. 
</P>
<P>El flujo general de control de un programa men&uacute; aparece
as&iacute;: 
</P>
<P>Inicializar curses. 
</P>
<P>Crear los objetos de men&uacute;, utilizando new_item(). 
</P>
<P>Crear el men&uacute; utilizando new_menu(). 
</P>
<P>Asociar el men&uacute; utilizando menu_post() 
</P>
<P>Refresco de pantalla. 
</P>
<P>Procesar respuesta de usuario a traves de un bucle de entrada. 
</P>
<P>Quitar la asociaci&oacute;n del men&uacute; utilizando
menu_unpost(). 
</P>
<P>Liberar el men&uacute;, utilizando free_menu(). 
</P>
<P>Liberar los objetos utilizando free_item(). 
</P>
<P>Finalizar curses. 
</P>
<P><A NAME="Selecci&oacute;n_de_Objetos"></A><B><FONT SIZE=4>Selecci&oacute;n
de Objetos</FONT></B> 
</P>
<P>Los men&uacute;s pueden ser multi-valor o (por defecto)
valor-simple (vea la pagina del manual menu_opts(3x) para ver como
cambiar el valor por defecto. Ambos tipos siempre tienen un objeto
actual. 
</P>
<P>Del men&uacute; valor-simple puede leer el valor seleccionado
simplemente observando el objeto actual. Del multi-valor, coger&aacute;
el actual seleccionado saltando a trav&eacute;s de los objetos
aplicando la funci&oacute;n predicado item_value(). Su c&oacute;digo
de procesamiento de men&uacute; puede utilizar la funcion
set_item_value() para poner banderas a los objetos de la selecci&oacute;n.
</P>
<P>Los objetos men&uacute; pueden ser hechos no seleccionables
utilizando set_item_opts() o item_opts_off() con el argumento
O_SELECTABLE . Esto es la &uacute;nica opci&oacute;n hasta ahora
definida para men&uacute;s, pero es una buena practica codificar como
si otros bits de opciones estuvieran activos. 
</P>
<P><A NAME="Visualizaci&oacute;n_de_Men&uacute;"></A><B><FONT SIZE=4>Visualizaci&oacute;n
de Men&uacute;</FONT></B> 
</P>
<P>La librer&iacute;a men&uacute; calcula un tama&ntilde;o m&iacute;nimo
de visualizaci&oacute;n de su ventana, basado en las siguientes
variables: 
</P>
<P>El numero y m&aacute;xima longitud de los objetos men&uacute;s. 
</P>
<P>Si la opcion O_ROWMAJOR esta activa. 
</P>
<P>Si la visualizaci&oacute;n de descripciones esta activa. 
</P>
<P>Cualquiera que el formato de men&uacute; pueda haber sido
establecido por el programador. 
</P>
<P>La longitud de la cadena mascara de caracteres de men&uacute;
utilizada para los atributos de pantalla de objetos seleccionados. 
</P>
<P>La funci&oacute;n set_menu_format() te permite establecer el
tama&ntilde;o m&aacute;ximo del punto de visualizacion (viewport) de
la pagina de men&uacute; que se utilizara para visualizar los objetos
de men&uacute;. Puede recuperar cualquier formato asociado con un
men&uacute; con menu_format(). El formato por defecto es lineas=16,
columnas=1. 
</P>
<P>La pagina actual de men&uacute; puede ser menor que el tama&ntilde;o
del formato. Esto depende del numero de objeto y el tama&ntilde;o y
si O_ROWMAJOR esta activo. Esta opci&oacute;n (por defecto) provoca
que los objetos men&uacute; sean visualizados en modelo ?raste-scan?,
as&iacute; que si mas de un objeto se ajustara horizontalmente la
primera pareja de objetos lado con lado en la l&iacute;nea superior.
La alternativa es visualizar la mayor columna, que intenta poner
primero diferentes objetos en la primera columna. 
</P>
<P>Como se menciona anteriormente, un formato de men&uacute; no
suficientemente ancho permite que todos los objetos se ajusten en la
pantalla resulten en un visualizado de men&uacute; que es
verticalmente paginable. Puede paginarlo con peticiones al
dispositivo de men&uacute;, que ser&aacute; descrito en la secci&oacute;n
<A HREF="#Procesamiento_de_la_entrada_de_Men&uacute;">Procesamiento_de_la_entrada_de_Men&uacute;</A>.
</P>
<P>Cada men&uacute; tiene una cadena de caracteres de marcas para
visualmente seguir de cerca los objetos seleccionados; vea las pagina
del manual menu_mark(3x) para mas detalles. La longitud de la cadena
de caracteres de marcas tambi&eacute;n influye en el tama&ntilde;o de
la pagina de men&uacute;. 
</P>
<P>La funci&oacute;n scale_menu() devuelve el tama&ntilde;o m&iacute;nimo
de visualizaci&oacute;n que el c&oacute;digo de men&uacute;
computeriza de todos estos factores. Hay otras visualizaciones de
atributos de men&uacute; incluyendo un atributo de selecci&oacute;n,
un atributo para objetos seleccionables, un atributo para objetos no
seleccionables y un car&aacute;cter de relleno usado para separar el
nombre del texto del objeto de la descripci&oacute;n del texto. Esto
tiene valores por defecto razonables que la librer&iacute;a le
permite cambiar (vea la pagina de manual menu_attribs(3x)). 
</P>
<P><A NAME="Ventanas_de_Men&uacute;"></A><B><FONT SIZE=4>Ventanas de
Men&uacute;</FONT></B> 
</P>
<P>Cada men&uacute; tiene, como se menciona antes, un par de ventanas
asociadas. Ambas ventanas son pintadas cuando el men&uacute; es
situado y borrado cuando el men&uacute; es quitado de su situaci&oacute;n.
</P>
<P>El exterior o la estructura de la ventana no es de otra manera
tocada por otras rutinas de men&uacute;. Existe luego el programador
puede asociar un titulo, un borde, o quiz&aacute;s el texto de ayuda
con el men&uacute; y tener refresco apropiado o borrado e tiempo de
asociaci&oacute;n/ no asociaci&oacute;n. La parte interna de la
ventana o subventana esta donde la pagina de men&uacute; actual es
visualizada. Por defecto, ambas ventanas son stdscr. Puede
establecerlas con la funci&oacute;n de menu_win(3x). Cuando llama a
menu_post(), puede escribir el men&uacute; en su subventana. Cuando
llama a menu_unpost(), puede borrar la subventana, sin embargo,
ninguna de estas realmente modifica la pantalla. Para hacer esto,
llame a wrefresh() o alguna equivalente. 
</P>
<P><A NAME="Procesamiento_de_la_entrada_de_Men&uacute;"></A><B><FONT SIZE=4>Procesamiento
de la entrada&nbsp;de Men&uacute;</FONT></B> 
</P>
<P>El bucle del c&oacute;digo del procesamiento de men&uacute;
llamar&iacute;a a menu_driver() repetidamente. El primer argumento de
esta rutina es un puntero de men&uacute;; el segundo es un c&oacute;digo
de comando de men&uacute;. Usted deber&iacute;a escribir una rutina
de entrada-captura que mapee los caracteres de entrada al c&oacute;digo
de los comandos de men&uacute;, y pase su salida a menu_driver(). El
c&oacute;digo de comando de men&uacute; esta completamente
documentado en menu_driver(3x). 
</P>
<P>El grupo m&aacute;s simple de c&oacute;digo de comando es
REQ_NEXT_ITEM, EQ_PREV_ITEM, REQ_FIRST_ITEM, REQ_LAST_ITEM,
REQ_UP_ITEM, REQ_DOWN_ITEM, REQ_LEFT_ITEM, REQ_RIGHT_ITEM. Estos
cambia los objetos seleccionados actualmente. Estas solicitudes
pueden causar listado de la pagina de men&uacute; si solo se
visualiza una parte. 
</P>
<P>Hay solicitudes expl&iacute;citas de paginaci&oacute;n que tambi&eacute;n
cambia el objeto actual (porque la localizaci&oacute;n seleccionada
no cambia, pero el objeto lo hace). Estos son REQ_SCR_DLINE,
REQ_SCR_ULINE, REQ_SCR_DPAGE, y REQ_SCR_UPAGE. 
</P>
<P>La REQ_TOGGLE_ITEM selecciona o quita la selecci&oacute;n del
objeto actual. ES utilizada en menus multi-valor; si la utiliza con
O_ONEVALUE , cogera un error devuelto (E_REQUEST_DENIED). 
</P>
<P>Cada men&uacute; tiene un buffer patr&oacute;n asociado. La l&oacute;gica
de menu_driver() intenta acumular caracteres ASCII imprimibles pasado
al buffer; cuando concuerda un prefijo con el nombre de un objeto,
este objeto ( o el pr&oacute;ximo que concuerde) es seleccionado. Si
a&ntilde;adiendo un car&aacute;cter producido no hay nueva
concordancia, ese car&aacute;cter es borrado del buffer patr&oacute;n,
y menu_driver() devuelve E_NO_MATCH. 
</P>
<P>Algunas solicitudes cambian el buffer patr&oacute;n directamente:
REQ_CLEAR_PATTERN, REQ_BACK_PATTERN, REQ_NEXT_MATCH, REQ_PREV_MATCH.
La ultimas dos se utilizan cuando la entrada del buffer patr&oacute;n
concuerda con mas de un objeto en un men&uacute; multi_valor. 
</P>
<P>Cada paginaci&oacute;n con &eacute;xito o solicitud de navegaci&oacute;n
de objeto limpia el buffer patr&oacute;n. Adem&aacute;s es posible
establecer el buffer patr&oacute;n expl&iacute;citamente con
set_menu_pattern(). 
</P>
<P>Finalmente, las solicitudes de dispositivo de men&uacute; de la
constante MAX_COMMAND se consideran comandos de aplicaci&oacute;n
especifica. El c&oacute;digo de menu_driver() las ignoran y devuelve
E_UNKNOWN_COMMAND. 
</P>
<P><A NAME="Otros_Aspectos_Diversos"></A><B><FONT SIZE=4>Otros
Aspectos Diversos</FONT></B> 
</P>
<P>Varias opciones de men&uacute; pueden afectar el procesamiento y
la aparici&oacute;n visual y entrada de procesamiento de men&uacute;s.
Ver menu_opts(3x) para mas detalles. 
</P>
<P>Es posible cambiar el objeto actual del c&oacute;digo de
aplicaci&oacute;n; esto es &uacute;til si quiere escribir sus propias
solicitudes de navegaci&oacute;n. Es adem&aacute;s posible
expl&iacute;citamente establecer la l&iacute;neas superior del
visualizado de men&uacute;. Ver mitem_current(3x). Si su aplicaci&oacute;n
necesita cambiar el cursor subventana de men&uacute; por alguna
raz&oacute;n, pos_menu_cursor() restaurara a la localizaci&oacute;n
actual para continuar con el procesamiento del dispositivo de men&uacute;.
</P>
<P>Es posible establecer enlaces para ser llamados en la
inicializaci&oacute;n del men&uacute; en tiempo de los &uacute;ltimos
toques finales, y cuando se de que los objetos seleccionados cambien.
Ver menu_hook(3x). 
</P>
<P>Cada objeto, en cada men&uacute;, tiene asociado un puntero de uso
en el que puede manejar la aplicaci&oacute;n de datos. Ver
mitem_userptr(3x) y menu_userptr(3x). 
</P>
<P><A NAME="Formulario"></A><A NAME="Librer&iacute;a_Formulario"></A><B><FONT SIZE=4>Librer&iacute;a
Formulario(Forms)</FONT></B> 
</P>
<P>La librer&iacute;a formulario (form) es una extensi&oacute;n de
curses que soporta programaci&oacute;n f&aacute;cil en formularios de
pantalla para entrada de texto y control de programa. 
</P>
<P>La librer&iacute;a formulario apareci&oacute; por primera vez en
AT&amp;T System V. La versi&oacute;n documentada aqu&iacute; es un
c&oacute;digo gratuito distribuido con ncurses. 
</P>
<P><A NAME="Compilaci&oacute;n_con_la_librer&iacute;a_Formularios"></A>
<B><FONT SIZE=4>Compilaci&oacute;n con la librer&iacute;a Formularios
(Forms)</FONT></B> 
</P>
<P>Sus m&oacute;dulos que utilicen formularios deben importar las
declaraciones de la librer&iacute;a con 
</P>
<P>#include &lt;form.h&gt; 
</P>
<P>y debe ser enlazado expl&iacute;citamente con la librer&iacute;a
formularios utilizando el argumento -lform. Note que debe tambi&eacute;n
enlazarse con la librer&iacute;a ncurses con -lncurses. Muchos
compiladores son de dos pasos y aceptaran cualquier orden, pero
todav&iacute;a es una buena practica poner -lform primero y -lncurses
despu&eacute;s. 
</P>
<P><A NAME="Descripci&oacute;n_de_Formularios"></A><B><FONT SIZE=4>Descripci&oacute;n
de Formularios</FONT></B> 
</P>
<P>Un formulario es una colecci&oacute;n de campos; cada campo puede
ser una etiqueta(texto aclaratorio) o una localizaci&oacute;n de
datos de entrada. Formularios Largos pueden ser segmentados en
paginas; cada entrada a una nueva pagina limpia la pantalla. 
</P>
<P>Para hacer formularios, crea grupos de campos y los conecta con
objetos estructura de formularios; la librer&iacute;a formulario
realiza hace esto relativamente sencillo. 
</P>
<P>Una vez definido, un formulario puede ser asociado, es decir
escrito en una ventana asociada. En realidad, cada formulario tiene
dos ventanas asociadas; una ventana de contenido en la que el
programador puede escribir t&iacute;tulos y bordes, y una subventana
en la que los campos de formularios apropiados son visualizados. 
</P>
<P>Como el formulario de usuario rellena el formulario asociado, las
teclas de navegaci&oacute;n y edici&oacute;n permiten movimiento
entre campos, las teclas de edici&oacute;n permiten modificaci&oacute;n
de los campos, y el texto sencillo a&ntilde;adiduras o cambios de
datos en el campo actual. La librer&iacute;a form le permite (el
dise&ntilde;ador de formularios) ligar cada tecla de navegaci&oacute;n
y de edici&oacute;n a una tecla pulsada aceptada por los campos de
curses que pueden tener condiciones de validaci&oacute;n en ellas,
as&iacute; que chequean la entrada de datos por tipo y valor. La
librer&iacute;a formulario suministra un rico conjunto de campos de
tipos predefinidos, y hace relativamente f&aacute;cil definir nuevos.
</P>
<P>Una vez que su transacci&oacute;n es completada (o abortada), un
formulario puede ser quitada de su asociaci&oacute;n (esto es, ya no
esta visualizado), y finalmente liberado hace que el almacenamiento
asociado con el y sus objetos disponibles puedan reulilizarse. 
</P>
<P>El flujo general de control de un programa con formularios aparece
asi: 
</P>
<P>1. Inicializar curses. 
</P>
<P>2. Crear los campos de formularios, utilizando new_field(). 
</P>
<P>3. Crear el formulario utilizando new_form(). 
</P>
<P>4. Asociar el formulario utilizando form_post(). 
</P>
<P>5. Refrescar la pantalla. 
</P>
<P>6. Procesar las solicitudes del usuario a trav&eacute;s de un
bucle de entrada. 
</P>
<P>7. Quitar la asociaci&oacute;n del formulario utilizando
form_unpost(). 
</P>
<P>8. Liberar el formulario, utilizando free_form(). 
</P>
<P>9. Liberar los campos utilizando free_field(). 
</P>
<P>10. Terminar curses. 
</P>
<P>Note que esto se parece mucho a un programa men&uacute;; la
librer&iacute;a formulario maneja tarea que son en muchos sentidos
semejantes, y su interfaz fue obviamente dise&ntilde;ada para
parecerse a la <A HREF="#Librer&iacute;a_Men&uacute;">Librer&iacute;a_Men&uacute;</A>
cada vez que sea posible. 
</P>
<P>En programas con formularios, sin embargo, el ?proceso de
solicitudes de usuarios? es de alguna manera mas complicado que para
men&uacute;s. Adem&aacute;s de las operaciones de navegaci&oacute;n
como men&uacute;, el bucle de dispositivo de men&uacute; tiene que
soportar edici&oacute;n de campos y validaci&oacute;n de datos. 
</P>
<P><A NAME="Crear_y_Liberar_Campos_y_Formularios"></A><B><FONT SIZE=4>Crear
y Liberar&nbsp;Campos y Formularios</FONT></B> 
</P>
<P>La funci&oacute;n b&aacute;sica para crear campos es new_field(): 
</P>
<P>FIELD *new_field(int height, int width, /* nuevo tama&ntilde;o de
campo */ 
</P>
<P>int top, int left, /* esquina superior izquierda */ 
</P>
<P>int offscreen, /* numero de l&iacute;neas de pantalla */ 
</P>
<P>int nbuf); /* numero de buffers de trabajo */ 
</P>
<P>Los objetos men&uacute; ocupan siempre una l&iacute;nea simple,
pero los campos de formulario pueden tener m&uacute;ltiples l&iacute;neas.
Por esto new_field() requiere que usted especifique la profundidad y
altura (los dos primeros argumento, que ambos deben ser mayores que
cero). 
</P>
<P>Debe especificar la localizaron del campo de la esquina superior
izquierda en la pantalla (el tercer y cuarto argumento, que debe ser
cero o mayor). Note que estas coordenadas son relativas a la
subventana de la formulario, que coincidir&aacute; con stdscr por
defecto pero no necesita ser stdscr si ha hecho una llamada expl&iacute;cita
a set_form_window(). 
</P>
<P>El quinto argumento permite especificar el numero de l&iacute;neas
fuera de pantalla. Si este es cero, el campo entero ser&aacute;
siempre visible. Si es no cero, el formulario se podr&aacute;
paginar, con solo una pantalla entera (inicialmente la parte de
arriba) visible y a un tiempo dado. Si hace el campo din&aacute;mico
y crece tanto que no se ajuste a la pantalla, el formulario se podr&aacute;
paginar incluso si el argumento fuera de pantalla (offscreen) era
inicialmente cero. 
</P>
<P>La librer&iacute;a formularios localiza un buffer de trabajo por
campo; el tama&ntilde;o de cada buffer es ((altura+offscreen)*anchura
+1, un car&aacute;cter para cada posici&oacute;n en el campo mas un
car&aacute;cter de fin NUL. El sexto argumento es un numero adicional
de buffers de datos para localizar por el campo; su aplicaci&oacute;n
puede utilizarlos para sus propios prop&oacute;sitos. 
</P>
<P>FIELD *dup_field(FIELD *field, /* campo a copiar */ 
</P>
<P>int top, int left); /* localizaci&oacute;n de la nueva copia */ 
</P>
<P>La funci&oacute;n dup_field() duplica un campo existente en una
nueva localizaci&oacute;n. El tama&ntilde;o y la informularioci&oacute;n
de los buffers son copiadas; algunos banderas de atributos y bits de
estados no son (ver la funci&oacute;n form_fiel_new(3x) para mas
detalles). 
</P>
<P>FIELD *link_field(FIELD *field, /* campo a copiar */ 
</P>
<P>int top, int left); /* localizaci&oacute;n del nuevo campo */ 
</P>
<P>La funcion link_field() tambi&eacute;n duplica un campo existente
en una nueva localizaci&oacute;n. La diferencia con dup_field() es
que dispone para que los nuevos campos de buffer sean compartidos con
el antiguo. 
</P>
<P>Aparte del uso obvio de hacer campos editables de dos diferentes
paginas de formularios, enlazando campos dando un formulario de
cortar en etiquetas din&aacute;micas. Si declara varios campos
ligados a un original, y entonces los hace inactivos, los cambios
desde el original ser&aacute;n propagados a los campos enlazados. 
</P>
<P>Como con campos duplicados, los campos enlazados tienen bits de
atributos separado del original. 
</P>
<P>Como puede adivinar, todas estas localizaciones de campos
devuelven NULL si la localizaci&oacute;n del campo no es posible
debido a un error de memoria insuficiente o argumentos fuera del
limite. 
</P>
<P>Para conectar los campos de un formulario, utilice 
</P>
<P>FORM *new_form(FIELD **fields); 
</P>
<P>Esta funci&oacute;n espera ver un valor NULL- una tabla de
punteros de campos. Dichos campos est&aacute;n conectados a una nueva
localizaci&oacute;n de objeto formulario; su direcci&oacute;n es
devuelta ( o NULL si la localizaci&oacute;n falla). 
</P>
<P>Note que new_field() no copia la tabla de punteros a un
almacenamiento privado; si modifica el contenido de la tabla de
punteros durante el procesamiento de los formularios, muchas cosas
extra&ntilde;as de diversas maneras pueden ocurrir. Tambi&eacute;n
note que cualquier campo dado puede ser conectado a una formulario. 
</P>
<P>Las funciones free_field() y free_form est&aacute;n disponibles
para liberar objetos campos y formularios. Es un error no intentar
liberar un campo conectado a una formulario, pero no viceversa; por
ello, usted generalmente liberara sus objetos formularios primero. 
</P>
<P><A NAME="Cambiar_Atributos_de_Campos"></A><B><FONT SIZE=4>Cambiar
Atributos de&nbsp;Campos (Fields)</FONT></B> 
</P>
<P>Cada campo de formulario tiene un numero de localizaci&oacute;n y
atributos de tama&ntilde;o asociados con el. Hay otros atributos de
campo utilizado para controlar la visualizaci&oacute;n y edici&oacute;n
de un campo. Algunos(por ejemplo, el bit O_STATIC) envuelve
suficientes complicaciones para ser cubierto en secciones propias
posteriormente. Nosotros cubrimos las funciones utilizados para coger
y establecer diferentes atributos b&aacute;sicos aqu&iacute;. 
</P>
<P>Cuando un campo se crea, los atributos no especificados por la
funci&oacute;n new_field se copian desde un campo de sistema
invisible. En el ajuste de atributos y cambios de funciones, el
argumento NULL se toma para referirse a este campo. Los cambio
persiste como valores por defectos hasta que sus aplicaciones de
formularios terminan. 
</P>
<P><A NAME="Cambio_de_tama&ntilde;o_y_localizaci&oacute;n_Datos"></A><A NAME="Cambio_de_tama&ntilde;o_y_localizaci&oacute;n_de_Datos"></A>
<B>Cambio de tama&ntilde;o y localizaci&oacute;n de Datos</B> 
</P>
<P>Puede recuperar los tama&ntilde;os de los campos y localizaciones
a trav&eacute;s de 
</P>
<P>int field_info(FIELD *field, /* campo desde el que se cambia */ 
</P>
<P>int *height, *int width, /* tama&ntilde;o del campo */ 
</P>
<P>int *top, int *left, /* esquina superior izquierda */ 
</P>
<P>int *offscreen, /* numero de l&iacute;neas fuera de pantalla */ 
</P>
<P>int *nbuf); /* numero de buffer de trabajo */ 
</P>
<P>Esta funci&oacute;n es un tipo de inversa de new_fiel(); en vez de
establecer los atributos de tama&ntilde;o y localizaci&oacute;n de un
nuevo campo, se cambian desde uno existente. 
</P>
<P><A NAME="Cambiar_la_localizaci&oacute;n_de_un_Campo"></A><B>Cambiar
la localizaci&oacute;n de un Campo (Field)</B> 
</P>
<P>Si es posible mover una localizaci&oacute;n de campo en pantalla: 
</P>
<P>int move_field(FIELD *field, /* campo a alterar */ 
</P>
<P>int top, int left); /* nueva esquina superior izquierda */ 
</P>
<P>Puede, por supuesto, preguntar la localizaci&oacute;n actual a
trav&eacute;s de fiel_info(). 
</P>
<P><A NAME="El_Atributo_de_Justificaci&oacute;n"></A><B>El Atributo
de Justificaci&oacute;n</B> 
</P>
<P>Los campos de una l&iacute;nea puede estar no-justificado,
justificados a la derecha, justificados a la izquierda, o centrados.
Aqu&iacute; decimos como manipular este atributo: 
</P>
<P>int set_field_just(FIELD *field, /* campo a modificar */ 
</P>
<P>int justmode); /* modo para establecer */ 
</P>
<P>int field_just(FIELD *field); /* cambiar el modo de campo */ 
</P>
<P>Los valores de modo aceptados y devueltos por estas funciones son
macros preprocesadas are preprocessor macros NO_JUSTIFICATION,
JUSTIFY_RIGHT, 
</P>
<P>JUSTIFY_LEFT, o JUSTIFY_CENTER. 
</P>
<P><A NAME="Visualizaci&oacute;n_de_Atributos_de_Campo"></A><B>Visualizaci&oacute;n
de atributos de Campo (Field)</B> 
</P>
<P>Para cada campo, puede establecer el atributo de primer plano para
caracteres introducidos, un atributo de segundo plano para el campo
entere, y un car&aacute;cter comod&iacute;n para la porci&oacute;n de
campo no rellenada. Puede tambi&eacute;n controlar paginaci&oacute;n
del formulario. 
</P>
<P>Este grupo de cuatro atributos de campo controlan la apariencia
visual de un campo en la pantalla, sin afectar de ninguna forma al
dato en el buffer de campo. 
</P>
<P>int set_field_fore(FIELD *field, /* campo a modificar */ 
</P>
<P>chtype attr); /* atributo a establecer */ 
</P>
<P>chtype field_fore(FIELD *field); /* campo a consultar */ 
</P>
<P>int set_field_back(FIELD *field, /* campo a modificar */ 
</P>
<P>chtype attr); /* atributo a establecer */ 
</P>
<P>chtype field_back(FIELD *field); /* campo a consultar */ 
</P>
<P>int set_field_pad(FIELD *field, /* campo a alterar */ 
</P>
<P>int pad); /* car&aacute;cter comod&iacute;n a establecer */ 
</P>
<P>chtype field_pad(FIELD *field); 
</P>
<P>int set_new_page(FIELD *field, /* campo a modificar */ 
</P>
<P>int flag); /* TRUE para forzar una nueva pagina */ 
</P>
<P>chtype new_page(FIELD *field); /* campo en cuesti&oacute;n */ 
</P>
<P>Los atributos a establecer y devueltos por las primeras cuatro
funciones son valores de atributos de visualizaci&oacute;n normales
de curses(3x). (A_STANDOUT, A_BOL, A_REVERSE, etc). El bit de pagina
de un campo controla si esta siendo visualizado al comenzar de un
nuevo formulario. 
</P>
<P><A NAME="Bits_de_Opciones_de_Campo"></A><B>Bits de Opciones de
Campo (Field)</B> 
</P>
<P>Hay tambi&eacute;n una gran colecci&oacute;n de bits de opciones
de campo que puede establecer el control de varios aspectos de
procesamiento de formularios. Puede manipularlos con esta funciones: 
</P>
<P>int set_field_opts(FIELD *field, /* campo a modificar */ 
</P>
<P>int attr); /* atributo a establecer */ 
</P>
<P>int field_opts_on(FIELD *field, /* campo a modificar */ 
</P>
<P>int attr); /* atributos a activar */ 
</P>
<P>int field_opts_off(FIELD *field, /* campo a modificar */ 
</P>
<P>int attr); /* atributos a desactivar */ 
</P>
<P>int field_opts(FIELD *field); /* campo a consultar */ 
</P>
<P>Por defecto todos estas opciones est&aacute;n activas. Aqu&iacute;
presentamos los bits de opciones disponibles: 
</P>
<P>O_VISIBLE 
</P>
<P>Controla si el campo es visible en pantalla. Puede utilizarse
durante el procesamiento del formulario para ocultar o mostrar los
campos. 
</P>
<P>O_ACTIVE 
</P>
<P>Controla si el campo esta activo durante el procesamiento del
formulario (por ejemplo visitado por teclas de navegaci&oacute;n de
formularios). Puede utilizarse para hacer etiquetas o campos
derivados con valores alterables de buffer por las aplicaciones de
formularios, no el usuario 
</P>
<P>O_PUBLIC 
</P>
<P>Controla si el dato es visualizado durante la entrada de campo. Si
esta acci&oacute;n esta desactivada en un campo, la librer&iacute;a
aceptara y editara datos en este campo, pero no ser&aacute;
visualizado y el cursor visible del campo no se mover&aacute;. Puede
desactivar el bit O_PUBLIC para definir campos con contrase&ntilde;a.
</P>
<P>O_EDIT 
</P>
<P>Controla si el dato del campo puede ser modificado. Cuando esta
opci&oacute;n es desactivada todas las respuestas editables excepto
REQ_PREV_CHOICE y REQ_NEXT_CHOICE fallaran. Tales campos de solo
lectura pueden ser &uacute;tiles para mensajes de ayuda. 
</P>
<P>O_WRAP 
</P>
<P>Controla el limpiado de palabra en campo multi-linea. Normalmente,
cuando alg&uacute;n car&aacute;cter de una (separado por espacio)
palabra alcanza el final de la l&iacute;nea actual, la palabra entera
ser&aacute; llevada a la siguiente l&iacute;nea (asumiendo que hay
una). Cuando esta opci&oacute;n esta desactivada, la palabra ser&aacute;
cortada por la mitas del fin de l&iacute;nea. 
</P>
<P>O_BLANK 
</P>
<P>Controla el espaciado del campo. Cuando esta opci&oacute;n esta
activa, introduciendo un car&aacute;cter en la primera posici&oacute;n
del campo borra el campo entero (excepto el car&aacute;cter reci&eacute;n
introducido). 
</P>
<P>O_AUTOSKIP 
</P>
<P>Controla el omitir autom&aacute;ticamente el pr&oacute;ximo campo
cuando este est&aacute; completo. Normalmente, cuando el formulario
de usuario intentan escribir mas datos en un campo que se ajustaran,
la localizaci&oacute;n de editado salta al siguiente campo. Cuando
esta opci&oacute;n esta desactivada, el cursor de usuario manejara el
final del campo. Esta opci&oacute;n se ignora en campos din&aacute;micos
que no han alcanzado su tama&ntilde;o limite. 
</P>
<P>O_NULLOK 
</P>
<P>Controla si la <A HREF="#Validaci&oacute;n_de_Campo">Validaci&oacute;n_de_Campo</A>
es aplicada a campos en blanco. Normalmente, no lo es; el usuario
puede dejar un campo en blanco sin invocar al normal chequeo de
validaci&oacute;n a la salida. Si esta opci&oacute;n esta desactivada
en un campo, salir de &eacute;l invocar&aacute; al chequeo de
validaci&oacute;n. 
</P>
<P>O_PASSOK 
</P>
<P>Controla si la validaci&oacute;n ocurre en cada salida, o solo
despu&eacute;s de que un campo es modificado. Normalmente lo ultimo
es verdad. Estableciendo O_PASSOK puede n ser &uacute;tiles si su
funci&oacute;n de validaci&oacute;n de campo puede cambia r durante
el procesamiento de formularios. 
</P>
<P>O_STATIC 
</P>
<P>Controla si el campo esta ajustado a sus dimensiones iniciales. Si
lo desactiva, el campo ser&aacute; din&aacute;mico y se extender&aacute;
para ajustar el dato introducido. 
</P>
<P>Una opci&oacute;n de campo no puede ser modificada mientras el
campo esta seleccionado actualmente. Sin embargo, las opciones pueden
no ser modificadas en campos situados que no son los actuales. 
</P>
<P>Los valores de las opciones son mascaras de bits y pueden ser
compuesta con l&oacute;gicas- o de manera obvia. 
</P>
<P><A NAME="Estados_de_Campo"></A><B>Estados de Campo (Field)</B> 
</P>
<P>Cada campo tiene una bandera de estado, que se establece a FALSE
cuando el campo es creado y TRUE cuando el valor en el buffer del
campo cambia. Esta bandera puede ser consultado su valor e
inicializado directamente: 
</P>
<P>int set_field_status(FIELD *field, /* campo a modificar */ 
</P>
<P>int status); /* modo de inicializaci&oacute;n */ 
</P>
<P>int field_status(FIELD *field); /* modo de cambio de campo */ 
</P>
<P>Inicializando esta bandera bajo el control del programa puede ser
&uacute;til si utiliza el mismo formulario repetidamente, buscando
campos modificados cada vez. 
</P>
<P>Llamando a field_status() en un campo no seleccionado actualmente
para la entrada devolver&aacute; un valor correcto. Llamando a
field_status() en un campo que es seleccionado actualmente por la
entrada no tiene necesariamente que dar un valor de estado de campo
correcto, debido a que el dato introducido no es necesariamente
copiado al buffer cero antes de salir del chequeo de validaci&oacute;n.
Para garantizar que el valor de estado devuelto refleja la realidad,
llamar a field_status() en una rutina de chequeo de validaci&oacute;n
de salida, desde la inicializaci&oacute;n o terminaci&oacute;n del
campo o de la forma, o justo despu&eacute;s de un requerimiento de
REQ_VALIDATION haya sido procesado por el dispositivo de la forma. 
</P>
<P><A NAME="Puntero_de_Campo_para_Usuario"></A><B>Puntero de&nbsp;Campo
(Field) para Usuario</B> 
</P>
<P>Cada estructura de campo contiene una ranura para un puntero de
car&aacute;cter que no es utilizada por la librer&iacute;a
formularios. Es necesario para ser utilizada por las aplicaciones
para almacenar datos privados para el campo. Puede manipularlo con: 
</P>
<P>int set_field_userptr(FIELD *field, /* campo a modificar */ 
</P>
<P>char *userptr); /* modo a establecer */ 
</P>
<P>char *field_userptr(FIELD *field); /* modo de cambio para el campo
*/ 
</P>
<P>( Correctamente, este puntero de usuario de campo debe tener un
tipo (void*). El tipo (char*) es guardado por la compatibilidad con
System V). 
</P>
<P>Es valido establecer el puntero de usuario con el campo por
defecto (con una llamada a set_field_userptr() pas&aacute;ndole un
puntero de campo NULL). Cuando un nuevo campo se crea, el puntero de
usuario de campo por defecto es copiado para inicializar el nuevo
puntero de usuario de campo. 
</P>
<P><A NAME="Campos_Variables_de_Tama&ntilde;o"></A><B><FONT SIZE=4>Campos
(Field) Variables de Tama&ntilde;o</FONT></B> 
</P>
<P>Normalmente, un campo es ajustado al tama&ntilde;o especificado en
el tiempo de creaci&oacute;n. Si, sin embargo, desactiva el bit
O_STATIC , se convertir&aacute; en din&aacute;mico y autom&aacute;ticamente
se reajustara su tama&ntilde;o para acomodar el dato como es
introducido. Si el campo tiene extra buffers asociados con &eacute;l,
crecer&aacute;n a lo largo con el buffer principal de entrada. 
</P>
<P>Un campo din&aacute;mico de una l&iacute;nea tendr&aacute; una
altura fija pero una profundidad variable, paginaci&oacute;n
horizontal para visualizar datos dentro del &aacute;rea de campo como
originalmente. 
</P>
<P><A NAME="Validaci&oacute;n_de_Campo"></A><B><FONT SIZE=4>Validaci&oacute;n
de Campo (Field)</FONT></B> 
</P>
<P>Por defecto, un campo aceptara cualquier dato que ajustase en su
buffer de entrada. Sin embargo, es posible adjuntar un tipo de
validaci&oacute;n a un campo. Si hace esto, cualquier intento de
dejar el campo mientras contenga datos que no concuerden con el tipo
de validaci&oacute;n fallara. Algunos tipos de validaci&oacute;n
tambi&eacute;n tiene un chequeo de validez de car&aacute;cter para
cada vez que un car&aacute;cter es introducido en el campo. 
</P>
<P>Un chequeo de validaci&oacute;n no se le llama cuando la funcion
set_field_buffer() modifica el buffer de entrada, ni cuando ese
buffer es cambiado a trav&eacute;s de un campo enlazado. 
</P>
<P>La librer&iacute;a formulario suministra un rico conjunto de tipo
s de validaci&oacute;n predefinidos , y le da la capacidad de definir
propios tipos por usted mismo. Puede examinar y cambiar los atributos
de validaci&oacute;n con las siguientes funciones: 
</P>
<P>int set_field_type(FIELD *field, /* campo a modificar */ 
</P>
<P>FIELDTYPE *ftype, /* tipo asociado */ 
</P>
<P>...); /* argumentos adicionales */ 
</P>
<P>FIELDTYPE *field_type(FIELD *field); /* campo de aplicaci&oacute;n
*/ 
</P>
<P>El tipo de validaci&oacute;n de un campo es considerado un
atributo del campo. Como con otros atributos de campo, tambi&eacute;n
haciendo set_field_type() con un campo NULO cambiara el sistema por
defecto por la validaci&oacute;n de nuevos campo creados. 
</P>
<P>Aqu&iacute; mostramos los tipo de validaci&oacute;n predefinidos: 
</P>
<P><A NAME="TYPE_ALPHA"></A><B>TYPE_ALPHA</B> 
</P>
<P>Este tipo de campo acepta datos alfab&eacute;ticos; no espacios en
blanco, no d&iacute;gitos no caracteres especiales ( es chequeado a
tiempo de la entrada de caracteres). Esto es establecido con: 
</P>
<P>Int set_field_type(FIELD *field, /* campo a modificar */ 
</P>
<P>TYPE_ALPHA, /* tipo asociado */ 
</P>
<P>Int width); /* m&aacute;xima profundidad de campo */ 
</P>
<P>El argumento de profundidad establece una profundidad m&iacute;nima
de dato. Normalmente querr&aacute; establecer esto a la profundidad
de campo; si es mayor que la profundidad del campo, el chequeo de
validaci&oacute;n fallara siempre. Una profundidad m&iacute;nima de
cero hace opcional el campo de terminaci&oacute;n. 
</P>
<P><A NAME="TYPE_ALNUM"></A><B>TYPE_ALNUM</B> 
</P>
<P>Este campo acepta datos alfab&eacute;ticos y d&iacute;gitos; no
espacios en blanco, no caracteres especiales (es chequeado a tiempo
de la entrada de caracteres). Se establece con: 
</P>
<P>Int set_field_type(FIELD *field, /* campo a modificar */ 
</P>
<P>TYPE_ALNUM, /* tipo asociado */ 
</P>
<P>Int width); /* m&aacute;xima profundidad de campo */ 
</P>
<P>El argumento de profundidad establece una profundidad m&iacute;nima
de campo. Como con TYPE_ALPHA , normalmente querr&aacute; establecer
esto con el campo de profundidad; si es mayor que la profundidad del
campo, el chequeo de validaci&oacute;n fallara siempre. Una
profundidad m&iacute;nima de cero hace opcional el campo de
terminaci&oacute;n. 
</P>
<P><B>TYPE_ENUM</B> 
</P>
<P>Este tipo permite restringir los valores del campo entre un
conjunto especificado de valores de cadenas de caracteres (por
ejemplo, las dos letra del c&oacute;digo postal para los estados de
U.S.). Se establece con: 
</P>
<P>Int set_field_type(FIELD *field, /* campo a modificar */ 
</P>
<P>TYPE_ENUM, /* tipo asociado */ 
</P>
<P>Char **valuelist; /* lista de valores posibles */ 
</P>
<P>Int checkcase; /* &iquest;case-sensitive? */ 
</P>
<P>Int checkunique); /* &iquest;debe especificarse un&iacute;vocamente?
*/ 
</P>
<P>El par&aacute;metro de la lista de valores debe ser un puntero a
NULL- lista terminada de cadenas de caracteres validos. El argumento
checkcase, si es verdadero, hace la comparaci&oacute;n con la cadena
de caracteres case-sensitive. 
</P>
<P>Cuando para el usuario existe un campo TYPE_ENUM, el proceso de
validaci&oacute;n intenta completar el dato en el buffer a una
entrada valida. Si una cadena de elecci&oacute;n completa ha sido
introducida, es por supuesto valida. Pero es posible tambi&eacute;n
introducir un prefijo de una cadena valida y haberla completado para
usted. 
</P>
<P>Por defecto, si introduce un prefijo as&iacute; y une mas de un
valor en la lista de cadenas, el prefijo ser&aacute; completado por
el primer valor que concuerde. Pero el argumento checkunique, si es
verdadero, requiere que el prefijo concuerde para ser &uacute;nico
para que sea validado. 
</P>
<P>Las solicitudes de entrada REQ_NEXT_CHOCE y REQ_PREV_CHOICE pueden
ser particularmente &uacute;tiles con estos campos. 
</P>
<P><A NAME="TYPE_INTEGER"></A><A NAME="TYPE_ENUM"></A><B>TYPE_INTEGER</B>
</P>
<P>Este tipo de campo acepta un entero. Se establece como se explica
a continuaci&oacute;n: 
</P>
<P>Int set_field_type(FIELD *field, /* campo a modificar */ 
</P>
<P>TYPE_INTEGER, /* tipo asociado */ 
</P>
<P>Int padding; /* lugares para ceros de relleno */ 
</P>
<P>Int vmin, int vmax); /* rango valido */ 
</P>
<P>Los caracteres validos consiste en un encabezado signo menos o
d&iacute;gitos opcionales. El rango de chequeo se realiza en la
salida. Si el rengo m&aacute;ximo es menor o igual que el m&iacute;nimo,
el rango se ignora. 
</P>
<P>Si el valor sobrepasa el rango de chequeo, se rellena con tantos
d&iacute;gitos cero de rastreo como sea necesario hasta encontrar el
argumento de relleno. 
</P>
<P>Un valor de buffer TYPE_INTEGER puede convenientemente ser
interpretado con la funci&oacute;n atoi(3) de la librer&iacute;a C. 
</P>
<P><A NAME="TYPE_NUMERIC"></A><B>TYPE_NUMERIC</B> 
</P>
<P>Este tipo de campo acepta un entero. Se establece como se explica
a continuaci&oacute;n: 
</P>
<P>Int set_field_type(FIELD *field, /* campo a modificar */ 
</P>
<P>TYPE_NUMERIC, /* tipo asociado */ 
</P>
<P>Int padding; /* lugares para ceros de relleno */ 
</P>
<P>double vmin, double vmax); /* rango valido */ 
</P>
<P>Caracteres validos consisten en un signo menos de encabezado y
d&iacute;gitos opcionales, posiblemente incluyendo un punto decimal.
Si su sistema soporta puntos a caracteres decimales locales
utilizados debe ser el definido por su local. El rango de chequeo es
realizado a la salida. Si el rango m&aacute;ximo es menor o igual que
el m&iacute;nimo, el rango se ignoran. 
</P>
<P>Si el valor sobrepasa el rango de chequeo, se rellena con tantos
d&iacute;gitos cero de rastreo como sea necesario hasta encontrar el
argumento de relleno. 
</P>
<P>Un valor de buffer TYPE_NUMERIC puede convenientemente ser
interpretado con la funcion atof(3) de la librer&iacute;a C. 
</P>
<P><A NAME="TYPE_REGEXP"></A><B>TYPE_REGEXP</B> 
</P>
<P>Este tipo de campo acepta un dato concordante que corresponde con
una expresi&oacute;n regular. Se establece como se especifica a
continuaci&oacute;n: 
</P>
<P>int set_field_type(FIELD *field, /* campo a modificar */ 
</P>
<P>TYPE_REGEXP, /* tipo asociado */ 
</P>
<P>char *regexp); /* expresion para comprobar */ 
</P>
<P>La sintaxis para la expresi&oacute;n regular es la de regcomp(3).
El chequeo de la concordancia de la expresi&oacute;n regular es
realizado a la salida. 
</P>
<P><A NAME="Manipulaci&oacute;n_del_Buffer_Field_Directo"></A><B>Manipulaci&oacute;n
del Buffer Field Directo</B> 
</P>
<P>El atributo principal de un campo es lo que contiene su buffer.
Cuando un formulario ha sido completado, su aplicaci&oacute;n
normalmente necesita saber el estado de cada buffer de campo. Puede
averiguar esto con: 
</P>
<P>char *field_buffer(FIELD *field, /* campo a consultar */ 
</P>
<P>int bufindex); /* numero de bufferes a revisar */ 
</P>
<P>Normalmente, el estado del buffer con numero cero para cada campo
se establece por el usuario editando acciones en ese campo. A veces
es &uacute;til establecer el valor de buffer de numero cero ( o alg&uacute;n
otro) desde si aplicaci&oacute;n: 
</P>
<P>int set_field_buffer(FIELD *field, /* campo a modificar */ 
</P>
<P>int bufindex, /* numero de buffer a cambiar */ 
</P>
<P>char *value); /* cadena del valor a establecer */ 
</P>
<P>Si el campo no es lo suficientemente grande y no puede ser
restablecido su tama&ntilde;o a un tama&ntilde;o mayor para contener
el valor especificado, el valor se truncara para que se ajuste. 
</P>
<P>Llamando a field_buffer() con un puntero nulo dar&aacute; un
error. Llamando a field_buffer() en un campo que no es el
seleccionado actualmente por la entrada devolver&aacute; un valor
correcto. Llamando a field_buffer() con un campo que no es
actualmente seleccionado por la entrada puede no ser necesario dar un
valor de buffer de campo correcto, porque el dato introducido no es
necesariamente copiado al buffer cero antes de la salida del chequeo
de validaci&oacute;n. Para garantizar que el valor de buffer devuelto
refleja en la realidad de la pantalla, llame a field_buffer en (1)
una salida de la rutina de del chequeo de validaci&oacute;n (2) desde
la inicializaci&oacute;n del campo o del formulario o la terminaci&oacute;n,
o (3) justo despu&eacute;s de que una solicitud de REQ_VALIDATION
haya sido procesada por el dispositivo de formularios. 
</P>
<P><A NAME="Atributos_de_Formularios"></A><B><FONT SIZE=4>Atributos
de Formularios (Forms)</FONT></B> 
</P>
<P>Como con los atributos de campo, los atributos de formularios
heredan un valor por defecto desde la estructura del formulario por
defecto del sistema. Este valor puede ser cambiado o establecido o
estas funciones utilizando un argumento de puntero de formulario a
NULL. 
</P>
<P>El atributo principal de un formulario es su lista de campos.
Puede preguntar su valor y cambiar esta lista con: 
</P>
<P>int set_form_fields(FORM *form, /* formulario a modificar */ 
</P>
<P>FIELD **fields); /* campos a conectar */ 
</P>
<P>char *form_fields(FORM *form); /* campos del formulario */ 
</P>
<P>int field_count(FORM *form); /* cuenta de campos conectados */ 
</P>
<P>El segundo argumento de set_form_field() puede ser un NULL- tabla
de punteros de campo terminados como el requerido por new_form(). En
este caso, los campos antiguos del formulario est&aacute;n
desconectados pero no liberados ( y elegidos para ser conectados a
otros formularios), entonces los nuevos campo esta conectados. 
</P>
<P>Puede tambi&eacute;n esta a nulo, en cuyo caso los campo antiguo
est&aacute;n desconectados ( y no liberados) pero nuevos no est&aacute;n
conectados. 
</P>
<P>La funci&oacute;n field_count() simplemente cuenta el numero de
campo conectados a un formulario dado. Devuelve -1 si el argumento de
puntero de formulario es NULL. 
</P>
<P><A NAME="Control_de_Visualizaci&oacute;n_de_Formularios"></A><B><FONT SIZE=4>Control
de Visualizaci&oacute;n de Formularios (Forms)</FONT></B> 
</P>
<P>En resumen de esta secci&oacute;n, puede ver que la visualizaci&oacute;n
del formulario normalmente comienza por la definici&oacute;n de su
tama&ntilde;o (y campos), represent&aacute;ndola, y refrescando la
pantalla. Hay un paso oculto antes de la representaci&oacute;n, que
es la asociaci&oacute;n del formulario con una ventana estructurada
(en realidad, un para de ventanas) en las que ser&aacute;n
visualizadas. Por defecto, la librer&iacute;a formularios asocia cada
formulario con la pantalla completa stdscr. 
</P>
<P>Haciendo este paso expl&iacute;cito, puede asociar el formulario
con la estructura de ventana declarada en su pantalla de
visualizaci&oacute;n. Esta puede ser &uacute;til si quiere adaptara
la visualizaci&oacute;n del formulario a diferentes tama&ntilde;os de
pantalla, din&aacute;micamente formularios embaldosados en la
pantalla, o utilizar un formulario como parte de una planificaci&oacute;n
de interfaz manejada con <A HREF="#Paneles">Paneles</A>. 
</P>
<P>Las dos ventanas asociadas con cada formulario tiene las mismas
funciones como sus an&aacute;logas en la <A HREF="#Librer&iacute;a_Men&uacute;">Librer&iacute;a_Men&uacute;</A>.
Ambas ventanas son pintadas cuando el formulario es asociado y
borrado cuando el formulario es quitado de su asociacion. 
</P>
<P>La salida o estructura de ventana no es de otra manera tocada por
las rutinas de formularios. Existe para que el programador pueda
asociar un titulo, un borde, o quiz&aacute;s texto de ayuda con el
formulario y tenerla refrescado apropiadamente o borrado a tiempo de
asociaci&oacute;n / sin asociaci&oacute;n. La ventana de entrada o
subventana esta donde la pagina de formulario actual es en realidad
visualizada. 
</P>
<P>Para declarar sus propias estructuras de ventanas para una forma,
necesitara saber el tama&ntilde;o del rect&aacute;ngulo limite de la
forma. Puede conseguir esta informaci&oacute;n con: 
</P>
<P>int scale_form(FORM *form, /* formulario a consultar */ 
</P>
<P>int *rows, /* l&iacute;neas de formularios */ 
</P>
<P>Las dimensiones del formulario se pasan en las asociaciones
apuntadas por los argumentos. Una vez que tiene esta informaci&oacute;n,
puede usarla para declarar ventanas, entonces usar una de esta
funciones: 
</P>
<P>int set_form_win(FORM *form, /* formulario a modificar */ 
</P>
<P>WINDOW *win); /* estructura de ventana a conectar */ 
</P>
<P>WINDOW *form_win(FORM *form); /* estructura de ventana de
formulario */ 
</P>
<P>int set_form_sub(FORM *form, /* formulario a modificar */ 
</P>
<P>WINDOW *win); /* subventana de formulario a conectar */ 
</P>
<P>WINDOW *form_sub(FORM *form); /* subventana de formulario */ 
</P>
<P>Note que las operaciones de curse, incluyendo refresh(), en la
forma, podr&iacute;an estar hechas en la estructura de ventana, no en
la subventana de forma. 
</P>
<P>Es posible chequear desde su aplicaci&oacute;n si todas los campo
paginables est&aacute;n en realidad visualizadas dentro de la
subventana de forma. 
</P>
<P>Utilice estas funciones: 
</P>
<P>int data_ahead(FORM *form); /* formulario a consultar */ 
</P>
<P>int data_behind(FORM *form); /* formulario a consultar */ 
</P>
<P>La funci&oacute;n data_ahead() devuelve TRUE si (a) el campo
actual esta actualizado y no ha visualizado el dato de la derecha,
(b) el campo actual es multi-linea y hay datos de fuera de la
pantalla debajo de &eacute;l. 
</P>
<P>La funci&oacute;n data_behind() devuelve TRUE si la primara
posici&oacute;n de car&aacute;cter( esquina superior izquierda) esta
fuera de la pantalla (no siendo visualizada). 
</P>
<P>Finalmente, hay una funci&oacute;n para restaura el cursor de
ventana del formulario al valor esperado por el dispositivo del
formulario: 
</P>
<P>Int pos_form_cursor(FORM*) 
</P>
<P>Si su aplicaci&oacute;n cambia el cursor de ventana de la forma,
llame a esta funci&oacute;n antes de manejar el control de vuelta al
dispositivo de formularios para re-sincronizarlo. 
</P>
<P><A NAME="Entrada_en_Dispositivo_de_Formularios"></A><B><FONT SIZE=4>Entrada
en el Dispositivo de Formularios (Forms)</FONT></B> 
</P>
<P>La funci&oacute;n form_driver() maneja las respuestas de entrada
virtuales para la navegaci&oacute;n del formulario, editando, y
validando solicitudes, justamente como menu_driver lo hace para men&uacute;s
( vea la secci&oacute;n <A HREF="#Procesamiento_de_la_entrada_de_Men&uacute;">Procesamiento_de_la_entrada_de_Men&uacute;</A>).
</P>
<P>int form_driver(FORM *form, /* formulario para pasar a la entrada
*/ 
</P>
<P>int request); /* c&oacute;digo de solicitud de formulario */ 
</P>
<P>Su funci&oacute;n de virtualizaci&oacute;n de entrada necesita
tomar la entrada y entonces convertirla a un car&aacute;cter
alfanum&eacute;rico (que es tratado como un dato introducido en el
campo actualmente seleccionado), o una solicitud de procesamiento de
la forma. 
</P>
<P>El dispositivo del formulario suministra enlaces (a trav&eacute;s
de las funciones de validaci&oacute;n de entrada y de terminaci&oacute;n
del campo) con los que su c&oacute;digo de aplicaci&oacute;n puede
chequear que entrada es tomada por el dispositivo que concuerde con
el que era esperado. 
</P>
<P><A NAME="Petici&oacute;n_de_Navegaci&oacute;n_de_P&aacute;gina"></A>
<B>Petici&oacute;n de Navegaci&oacute;n de P&aacute;gina</B> 
</P>
<P>Estas solicitudes causan que el nivel de pagina se mueva a trav&eacute;s
del formulario, provocando la visualizaci&oacute;n de una nueva
pantalla de formulario. 
</P>
<P>REQ_NEXT_PAGE 
</P>
<P>Mover a la siguiente pagina del formulario. 
</P>
<P>REQ_PREV_PAGE 
</P>
<P>Mover a la anterior pagina del formulario. 
</P>
<P>REQ_FIRST_PAGE 
</P>
<P>Mover a la primera pagina del formulario. 
</P>
<P>REQ_LAST_PAGE 
</P>
<P>Mover a la ultima pagina del formulario. 
</P>
<P>Estas solicitudes tratan la lista como c&iacute;clica; esto es,
REQ_NEXT_PAGE desde la ultima pagina va a la primera, y REQ_PREV_PAGE
desde la primera pagina va a la ultima. <BR>&nbsp; <BR>&nbsp; 
</P>
<P><A NAME="Petici&oacute;n_de_Navegaci&oacute;n_InterCampo"></A><B>Petici&oacute;n
de Navegaci&oacute;n Inter-Campo (Field)</B> 
</P>
<P>Estas peticiones manejar la navegaci&oacute;n entre campos de la
misma pagina. 
</P>
<P>REQ_NEXT_FIELD 
</P>
<P>Mover al siguiente campo. 
</P>
<P>REQ_PREV_FIELD 
</P>
<P>Mover al campo anterior. 
</P>
<P>REQ_FIRST_FIELD 
</P>
<P>Mover al primer campo. 
</P>
<P>REQ_LAST_FIELD 
</P>
<P>Mover al ultimo campo. 
</P>
<P>REQ_SNEXT_FIELD 
</P>
<P>Mover al siguiente campo ordenado. 
</P>
<P>REQ_SPREV_FIELD 
</P>
<P>Mover al anterior campo ordenado. 
</P>
<P>REQ_SFIRST_FIELD 
</P>
<P>Mover al primer campo ordenado.. 
</P>
<P>REQ_SLAST_FIELD 
</P>
<P>Mover al ultimo campo ordenado. 
</P>
<P>REQ_LEFT_FIELD 
</P>
<P>Mover al campo de la izquierda. 
</P>
<P>REQ_RIGHT_FIELD 
</P>
<P>Mover al campo de la derecha. 
</P>
<P>REQ_UP_FIELD 
</P>
<P>Mover al campo de arriba. 
</P>
<P>REQ_DOWN_FIELD 
</P>
<P>Mover al campo de abajo. 
</P>
<P>Estas peticiones tratan la lista de campos en la pagina como
c&iacute;clica; esto es REQ_NEXT_FIELD desde el ultimo campo va al
primero, y REQ_PREV_FIELD desde el primer campo va al ultimo. El
orden de los campo para esto ( y las solicitudes REQ_FIRST_FIELD y
REQ_LAST_FIELD ) es simplemente el orden de los punteros de campo en
la tabla del formulario (como se inicializa con new_form() o
set_form_fields()). 
</P>
<P>Tambi&eacute;n es posible atravesar los campos como si hubieran
sido clasificados en orden de posici&oacute;n en pantalla, as&iacute;
la secuencia va de izquierda a derecha y de arriba abajo. Para hacer
esto, utilice el segundo grupo de cuatro peticiones de movimiento
ordenado. 
</P>
<P>Finalmente, es posible moverse entre campos utilizando direcciones
visuales arriba, abajo, derecha e izquierda. Para llevar a cabo esto,
utilice el tercer grupo de cuatro solicitudes. Note, sin embargo, que
la posici&oacute;n del formulario para los prop&oacute;sitos de estas
peticiones es la esquina superior izquierda. 
</P>
<P>Por ejemplo, suponga que tiene un campo multi-linea B, y dos
campos de l&iacute;nea simple A y C en la misma l&iacute;nea con B,
con A ala izquierda de B y C a la derecha de B. Una REQ_MOVE_RIGHT
desde A ira a B solo si A,B, y C todos comparten la misma primera
l&iacute;nea; de otra forma pasaran por alto B hacia C. 
</P>
<P><A NAME="Petici&oacute;n_de_Navegaci&oacute;n_IntraCampo"></A><B>Petici&oacute;n
de Navegaci&oacute;n Intra-Campo (Field)</B> 
</P>
<P>Estas peticiones conducen el movimiento del cursor del editor
dentro el campo seleccionado actualmente. 
</P>
<P>REQ_NEXT_CHAR 
</P>
<P>Mover al siguiente car&aacute;cter. 
</P>
<P>REQ_PREV_CHAR 
</P>
<P>Mover al car&aacute;cter anterior. 
</P>
<P>REQ_NEXT_LINE 
</P>
<P>Mover a la siguiente l&iacute;nea 
</P>
<P>REQ_PREV_LINE 
</P>
<P>Mover a la l&iacute;nea anterior. 
</P>
<P>REQ_NEXT_WORD 
</P>
<P>Mover a la siguiente palabra. 
</P>
<P>REQ_PREV_WORD 
</P>
<P>Mover a la palabra anterior. 
</P>
<P>REQ_BEG_FIELD 
</P>
<P>Mover al comienzo del campo. 
</P>
<P>REQ_END_FIELD 
</P>
<P>Mover al final del campo. 
</P>
<P>REQ_BEG_LINE 
</P>
<P>Mover al principio de la l&iacute;nea. 
</P>
<P>REQ_END_LINE 
</P>
<P>Mover al final de la l&iacute;nea. 
</P>
<P>REQ_LEFT_CHAR 
</P>
<P>Mover a la izquierda en el campo. 
</P>
<P>REQ_RIGHT_CHAR 
</P>
<P>Mover a la derecha en el campo. 
</P>
<P>REQ_UP_CHAR 
</P>
<P>Mover hacia arriba en el campo. 
</P>
<P>REQ_DOWN_CHAR 
</P>
<P>Mover hacia abajo en el campo. 
</P>
<P>Cada palabra se separa del car&aacute;cter anterior y del
siguiente con un espacio en blanco. El comando para mover al
principio y el final de la l&iacute;nea o del campo busca el primer o
el ultimo car&aacute;cter de relleno en sus rangos. 
</P>
<P><A NAME="Petici&oacute;n_de_Paginar"></A><B>Petici&oacute;n de
Paginar</B> 
</P>
<P>Los campos que son din&aacute;micos y han crecido y los campos
expl&iacute;citamente creados con l&iacute;neas fuera de pantalla se
pueden paginar. Los campos de una l&iacute;nea se pueden paginar
horizontalmente; los campos multi-linea se pueden paginar
verticalmente. La mayor parte de la paginaci&oacute;n se provoca
editando y con el movimiento intra-campo ( la librer&iacute;a pagina
el campo para conservar el cursor visible). Es posible explicitar la
petici&oacute;n de paginaci&oacute;n con las siguientes solicitudes: 
</P>
<P>REQ_SCR_FLINE 
</P>
<P>Pagina verticalmente una l&iacute;nea hacia delante. 
</P>
<P>REQ_SCR_BLINE 
</P>
<P>Pagina verticalmente una l&iacute;nea hacia atr&aacute;s. 
</P>
<P>REQ_SCR_FPAGE 
</P>
<P>Pagina verticalmente una pagina hacia delante.. 
</P>
<P>REQ_SCR_BPAGE 
</P>
<P>Pagina verticalmente una pagina hacia delante.. 
</P>
<P>REQ_SCR_FHPAGE 
</P>
<P>Pagina verticalmente media pagina hacia delante.. 
</P>
<P>REQ_SCR_BHPAGE 
</P>
<P>Pagina verticalmente media pagina hacia delante.. 
</P>
<P>REQ_SCR_FCHAR 
</P>
<P>Pagina horizontalmente un car&aacute;cter hacia delante. 
</P>
<P>REQ_SCR_BCHAR 
</P>
<P>Pagina horizontalmente un car&aacute;cter hacia atr&aacute;s. 
</P>
<P>REQ_SCR_HFLINE 
</P>
<P>Pagina horizontalmente una profundidad de campo hacia delante. 
</P>
<P>REQ_SCR_HBLINE 
</P>
<P>Pagina horizontalmente una profundidad de campo hacia atr&aacute;s.
</P>
<P>REQ_SCR_HFHALF 
</P>
<P>Pagina horizontalmente media profundidad de campo hacia delante. 
</P>
<P>REQ_SCR_HBHALF 
</P>
<P>Pagina horizontalmente media profundidad de campo hacia atr&aacute;s.
</P>
<P>Para los prop&oacute;sitos de paginaci&oacute;n, una pagina de un
campo es la altura de su parte visible. 
</P>
<P><A NAME="Petici&oacute;n_de_Editado_de_Campos"></A><B>Petici&oacute;n
de Editado de Campos (Field)</B> 
</P>
<P>Cuando pase un car&aacute;cter ASCII al dispositivo de los
formularios, es tratado como una petici&oacute;n de a&ntilde;adir el
car&aacute;cter al buffer de datos del campo. Si esto es un inserci&oacute;n
o un reemplazamiento depende del modo de edici&oacute;n del campo
(inserci&oacute;n es por defecto). 
</P>
<P>Las siguientes peticiones soportan el editado del campo y cambiar
el modo de edici&oacute;n: 
</P>
<P>REQ_INS_MODE 
</P>
<P>Establecer el modo de inserci&oacute;n. 
</P>
<P>REQ_OVL_MODE 
</P>
<P>Establecer el modo de sobrelapamiento. 
</P>
<P>REQ_NEW_LINE 
</P>
<P>Petici&oacute;n de nueva l&iacute;nea (mire arriba para una
explicaci&oacute;n). 
</P>
<P>REQ_INS_CHAR 
</P>
<P>Insertar el espacio de localizaci&oacute;n de car&aacute;cter. 
</P>
<P>REQ_INS_LINE 
</P>
<P>Insertar una l&iacute;nea en blanco en la localizaci&oacute;n del
car&aacute;cter. 
</P>
<P>REQ_DEL_CHAR 
</P>
<P>Borrar un car&aacute;cter donde este el cursor. 
</P>
<P>REQ_DEL_PREV 
</P>
<P>Borrar la palabra anterior al cursor. 
</P>
<P>REQ_DEL_LINE 
</P>
<P>Borrar una l&iacute;nea donde este el cursor. 
</P>
<P>REQ_DEL_WORD 
</P>
<P>Borrar una palabra donde este el cursor. 
</P>
<P>REQ_CLR_EOL 
</P>
<P>Limpiar hasta el final de la l&iacute;nea. 
</P>
<P>REQ_CLR_EOF 
</P>
<P>Limpiar hasta el final del campo. 
</P>
<P>REQ_CLEAR_FIELD 
</P>
<P>Limpiar el campo entero. 
</P>
<P>El comportamiento de las peticiones REQ_NEW_LINE y REQ_DEL_PREV es
complicada y controlada en mayor parte por un par de opciones de
formularios. Los casos especiales son provocados cuando el curso esta
al principio de un campo, o en la ultima l&iacute;nea del campo. 
</P>
<P>Primero, consideramos REQ_NEW_LINE: 
</P>
<P>La conducta normal de REQ_NEW_LINE en el modo de inserci&oacute;n
es para romper la l&iacute;nea actual, en la posici&oacute;n del
cursor de edici&oacute;n, insertando la parte de l&iacute;nea actual
despu&eacute;s del cursor como una nueva l&iacute;nea siguiente a la
actual y moviendo el cursor al principio de la nueva l&iacute;nea
(puede pensar esto como si insertara una nueva l&iacute;nea en el
buffer de campo). 
</P>
<P>La conducta normal de REQ_NEW_LINE en modo de sobrelapado es
limpiar la l&iacute;nea actual de la posici&oacute;n del cursor de
edici&oacute;n al final de la l&iacute;nea. El cursor es entonces
movido al principio de la siguiente l&iacute;nea. 
</P>
<P>Sin embargo, REQ_NEW_LINE al principio de un campo, o en la ultima
l&iacute;nea del campo, en cambio hace un REQ_NEXT_FIELD. Si la
opci&oacute;n O_NL_OVERLOAD esta desactivada, esta acci&oacute;n
especial tambi&eacute;n esta desactivada. 
</P>
<P>Ahora vamos a considerar REQ_DEL_PREV: 
</P>
<P>La conducta normal de REQ_DEL_PREV es borrar el car&aacute;cter
anterior. Si el modo de inserci&oacute;n esta activo, y el cursor
esta al comienzo de la l&iacute;nea, y el texto de la l&iacute;nea no
se ajusta a la anterior, en cambio a&ntilde;ade el contenido de la
l&iacute;nea actual a la anterior y borrar la l&iacute;nea actual
(puede pensar esto como el borrado de una nueva l&iacute;nea del
buffer de campo). 
</P>
<P>Sin embargo, REQ_DEL_PREV al principio de un campo es tratado como
una REQ_PREV_FIELD. 
</P>
<P>Si la opci&oacute;n O_BS_OVERLOAD esta desactivada, esta acci&oacute;n
especial esta desactivada y el dispositivo de los formularios
devuelve un E_REQUEST_DENIED. 
</P>
<P>Vea las Opciones de Formularios para la discusi&oacute;n de c&oacute;mo
establecer y limpiar las opciones de overload. 
</P>
<P><A NAME="Petici&oacute;n_de_Orden"></A><B>Petici&oacute;n de Orden</B>
</P>
<P>Si el tipo de nuestro campo esta ordenado, y tiene funciones
asociadas de conseguir el siguiente y el valor previo del tipo desde
un valor dado, hay peticiones que pueden conseguir este valor dentro
del buffer de campo: 
</P>
<P>REQ_NEXT_CHOICE 
</P>
<P>Coloca el valor sucesor al valor actual en el buffer. 
</P>
<P>REQ_PREV_CHOICE 
</P>
<P>Coloca el valor antecesor al valor actual en el buffer. 
</P>
<P>De los tipos de campos ya implementados, solo TYPE_ENUM tiene
construido una funci&oacute;n de sucesor y antecesor. Cuando defina
un tipo de campo por usted mismo (vea
<A HREF="#Tipos_de_validaci&oacute;n_del_Usuario">Tipos_de_validaci&oacute;n_del_Usuario</A>),
puede asociar sus propias funciones de orden. 
</P>
<P><A NAME="Comandos_de_la_Aplicaci&oacute;n"></A><B>Comandos de la
Aplicaci&oacute;n</B> 
</P>
<P>Las peticiones de formularios son representadas como enteros por
encima del valor de curses mayor que KEY_MAX y menor que o igual a la
constante MAX_COMMAND. Si su rutina de virtulizaci&oacute;n de la
entrada devuelve un valor superior a MAX_COMMAND, el dispositivo de
formularios lo ignorara. 
</P>
<P><A NAME="Cambiar_Enlaces_en_los_Campos"></A><B><FONT SIZE=4>Cambiar
Enlaces en los Campos(Field)</FONT></B> 
</P>
<P>Es posible establecer enlaces de funciones para ser ejecutados en
cualquier momento que el campo actual o el formulario cambien. Aqu&iacute;
tiene unas funciones que aportan esto: 
</P>
<P>typedef void (*HOOK)(); /* puntero a una funci&oacute;n que
devuelve void */ 
</P>
<P>int set_form_init(FORM *form, /* formulario a modificar */ 
</P>
<P>HOOK hook); /* inicializaci&oacute;n del enlace */ 
</P>
<P>HOOK form_init(FORM *form); /* formulario a consultar */ 
</P>
<P>int set_form_term(FORM *form, /* formulario a modificar */ 
</P>
<P>HOOK hook); /* enlace de terminaci&oacute;n */ 
</P>
<P>HOOK form_term(FORM *form); /* formulario a consultar */ 
</P>
<P>int set_field_init(FORM *form, /* formulario a modificar */ 
</P>
<P>HOOK hook); /* inicializaci&oacute;n del enlace */ 
</P>
<P>HOOK field_init(FORM *form); /* formulario a consultar */ 
</P>
<P>int set_field_term(FORM *form, /* formulario a modificar */ 
</P>
<P>HOOK hook); /* enlace de terminaci&oacute;n */ 
</P>
<P>HOOK field_term(FORM *form); /* formulario a consultar */ 
</P>
<P>Estas funciones le permiten establecer o testear cuatro enlaces
diferentes. En cada conjunto de funciones, el segundo argumento
deber&iacute;a ser y una direcci&oacute;n de una funci&oacute;n de
enlace. Esta funciones difieren solo en el tiempo de llamar al
enlace. 
</P>
<P>form_init 
</P>
<P>Este enlace se le llama cuando el formulario es asociado; tambi&eacute;n,
justo despu&eacute;s de cada operaci&oacute;n de cambio de pagina. 
</P>
<P>field_init 
</P>
<P>Este enlace se le llama cuando el formulario es asociado; tambi&eacute;n,
despu&eacute;s de cambios en el campo. 
</P>
<P>field_term 
</P>
<P>Este enlace se le llama despu&eacute;s de la validaci&oacute;n de
campo; esto es, justo antes de que el campo sea modificado. Es
tambi&eacute;n llamado cuando el formulario no esta asociado. 
</P>
<P>form_term 
</P>
<P>Este enlaces es llamado cuando el formulario es quitado de su
asociaci&oacute;n; tambi&eacute;n, justo antes de cada operaci&oacute;n
de cambio de pagina. 
</P>
<P>Llamadas a estos enlaces puede ser provocados 
</P>
<P>1.Cuando las peticiones de edici&oacute;n de usuario son
procesadas por el dispositivo de los formularios. 
</P>
<P>2.Cuando la pagina actual es modificada por una llamada a
set_current_field(). 
</P>
<P>3.Cuando la pagina actual es modificada por una llamada a
set_form_page(). 
</P>
<P>Ver Comandos de Cambios de Campos para la discusi&oacute;n de los
dos &uacute;ltimos casos. 
</P>
<P>Puede establecer enlaces por defecto para todos los campos pasando
un conjunto de funciones con NULL como primer argumento. 
</P>
<P>Puede desactivar cualquiera de estos enlaces estableci&eacute;ndolos
a NULL, como valor por defecto. 
</P>
<P><A NAME="Comandos_de_cambios_de_Campos"></A><B><FONT SIZE=4>Comandos
de cambios de Campos (Field)</FONT></B> 
</P>
<P>Normalmente, la navegaci&oacute;n a trav&eacute;s del formulario
ser&aacute; dada por las peticiones de la entrada de usuario. Pero
algunas veces es &uacute;til ser capaz de mover el foco para editar y
visualizar bajo el control de nuestra aplicaci&oacute;n, o preguntar
que campo esta actualmente. Las siguientes instrucciones ayudan a
acabar esto: 
</P>
<P>int set_current_field(FORM *form, /* formulario a modificar */ 
</P>
<P>FIELD *field); /* campo a cambiarse */ 
</P>
<P>FIELD *current_field(FORM *form); /* formulario a consultar */ 
</P>
<P>int field_index(FORM *form, /* formulario a consultar */ 
</P>
<P>FIELD *field); /* campo para coger el indice */ 
</P>
<P>La funci&oacute;n field_index() devuelve un &iacute;ndice del
campo dado de la tabla de campos de formularios (la tabla pasada a
new_form() o set_form_fields()). 
</P>
<P>El campo actual inicial de un formulario es el primer campo activo
en su pagina. La funci&oacute;n set_form_fields() resetea esto. 
</P>
<P>Es posible tambi&eacute;n moverse alrededor por las paginas. 
</P>
<P>int set_form_page(FORM *form, /* formulario a modificar */ 
</P>
<P>int page); /* pagina a la que ir (0-originen) */ 
</P>
<P>int form_page(FORM *form); /* volver a la pagina actual del
formulario */ 
</P>
<P>La pagina inicial de un formulario creado nuevo es 0. La funci&oacute;n
set_form_field() resetea esto. 
</P>
<P><A NAME="Opciones_de_Formularios"></A><B><FONT SIZE=4>Opciones de
Formularios (Forms)</FONT></B> 
</P>
<P>Como con los campos, los formularios pueden tener bits de opciones
de control. Pueden ser cambiados o testeados con estas funciones: 
</P>
<P>int set_form_opts(FORM *form, /* formulario a modificar */ 
</P>
<P>int attr); /* atributo a establecer */ 
</P>
<P>int form_opts_on(FORM *form, /* formulario a modificar */ 
</P>
<P>int attr); /* atributos a activar */ 
</P>
<P>int form_opts_off(FORM *form, /* formulario a modificar */ 
</P>
<P>int attr); /* atributos a desactivar */ 
</P>
<P>int form_opts(FORM *form); /* formulario a consultar */ 
</P>
<P>Por defecto, todas las opciones esta activadas. Aqu&iacute; est&aacute;n
disponibles algunos bits de opciones: 
</P>
<P>O_NL_OVERLOAD 
</P>
<P>Permite el sobrecargamiento de REQ_NEW_LINE como se describe en
Peticiones de Edici&oacute;n. El valor de esta opci&oacute;n es
ignorado en campo din&aacute;micos que no han alcanzado su tama&ntilde;o
limite; estos no tienen ultima l&iacute;nea, por lo que las
circunstancia para provocar un REQ_NEW_FIELD nunca se alcanzan. 
</P>
<P>O_BS_OVERLOAD 
</P>
<P>Permite el sobrecargamiento de REQ_DEL_PREV como se describe en
Peticiones de Edici&oacute;n. 
</P>
<P>Los valores de opci&oacute;n son mascaras de bits y puede estar
compuestas con l&oacute;gica- o en el modo obvio. 
</P>
<P><A NAME="Tipos_de_validaci&oacute;n_del_Usuario"></A><B><FONT SIZE=4>Tipos
de validaci&oacute;n del Usuario</FONT></B> 
</P>
<P>La librer&iacute;a form le da la capacidad para definir tipo de
validaci&oacute;n de usuario por usted mismo. Mas aun, los argumentos
adicionales opcionales de set_field_type efectivamente le permiten
parametrizar los tipos de validaci&oacute;n. Muchos de las
complicaciones en la interfaz de los tipos de validaci&oacute;n
tienen que ver con el manejo de argumentos adicionales en las
funciones de validaci&oacute;n e usuario. 
</P>
<P><A NAME="Tipos_de_Uniones"></A><B>Tipos de Uniones</B> 
</P>
<P>El modo m&aacute;s simple de crear tipos de dato de usuario es
componerlos desde otros preexistentes: 
</P>
<P>FIELD *link_fieldtype(FIELDTYPE *type1, 
</P>
<P>FIELDTYPE *type2); 
</P>
<P>Esta funci&oacute;n crea un tipo de campo que aceptara cualquier
valor legal para sus argumentos de tipo campo (que pueden estar
predefinidos o definidos por el programador). Si una llamada a
set_field_type() despu&eacute;s requiere argumentos, el nuevo tipo
compuesto espera todos los argumentos para el primer tipo, que todos
los argumentos para el segundo. Ordenar funciones (ver
<A HREF="#Petici&oacute;n_de_Orden">Petici&oacute;n_de_Orden</A>)
asociadas con los componentes de los tipos trabajaran en la
composici&oacute;n; lo que hace es chequear la funci&oacute;n de
validaci&oacute;n para el primer tipo, entonces por el segundo, para
figurar que tipo que contiene el buffer deber&iacute;a ser tratado. 
</P>
<P><A NAME="Nuevos_Tipos_de_Campos"></A><B>Nuevos Tipos de Campos</B>
</P>
<P>Para crear un tipo de campo que cumpla los requisitos, necesita
especificar una o las dos cosas siguientes: 
</P>
<P>Una funci&oacute;n de validaci&oacute;n de car&aacute;cter, para
chequear cada car&aacute;cter como es introducido. 
</P>
<P>Una funci&oacute;n de validaci&oacute;n de campo para aplicarla a
la salida del campo. 
</P>
<P>Aqu&iacute; tiene como hacer esto: 
</P>
<P>typedef int (*HOOK)(); /* puntero a una funci&oacute;n que
devuelve un entero */ 
</P>
<P>FIELDTYPE *new_fieldtype(HOOK f_validate, /* validador de campo */
</P>
<P>HOOK c_validate) /* car&aacute;cter validador */ <BR>&nbsp; <BR>&nbsp;
</P>
<P>int free_fieldtype(FIELDTYPE *ftype); /* tipo a liberar */ 
</P>
<P>Al menos uno de los argumentos de new_fieldtype() debe ser un no
NULL. El dispositivo de los formularios llamara automaticamente la
nueva funci&oacute;n de validaci&oacute;n en los puntos apropiados
del procesando un campo del nuevo tipo. 
</P>
<P>La funci&oacute;n free_fieldtype() deslocaliza el argumento
fieldtype, liberando todo el almacenamiento asociado con el. 
</P>
<P>Normalmente, un validador de campo es llamado cuando el usuario
intenta deja el campo. Su primer argumento es un puntero de campo,
desde el cual puede coger el buffer de campo y testearlo. Si la
funci&oacute;n devuelve TRUE, la operaci&oacute;n termina con &eacute;xito;
si devuelve FALSE, el cursor de edici&oacute;n permanece en el campo.
</P>
<P>Un validador de car&aacute;cter coge el car&aacute;cter pasado
como primer argumento. Tambi&eacute;n devolver&iacute;a TRUE si el
car&aacute;cter es valido, FALSE en otro caso. 
</P>
<P><A NAME="Argumentos_de_Funciones_de_Validaci&oacute;n"></A><B>Argumentos
de Funciones de validaci&oacute;n</B> 
</P>
<P>Sus funciones de validaci&oacute;n de campo- y de car&aacute;cter-
se les pasara tambi&eacute;n un segundo argumento. Este segundo
argumento es la direcci&oacute;n de la estructura (que llamara a una
pila) construida desde cualquiera de los argumentos de tipos
espec&iacute;ficos de campo pasados a set_field_type(). Si estos
argumentos no est&aacute;n definidos para el tipo de campo, este
argumento de puntero de pila ser&aacute; NULL. 
</P>
<P>Para arreglar que estos argumentos sean pasados a sus funciones de
validaci&oacute;n, debe asociar un conjunto peque&ntilde;o de
funciones de almacenamiento-direcci&oacute;n con el tipo. El
dispositivo de formularios utilizara esta pila sintetizada desde los
argumentos posteriores de cada argumento de set_field_type(), y un
puntero a la pila ser&aacute; pasado a las funciones de validaci&oacute;n.
</P>
<P>Aqu&iacute; esta como usted hace la asociaci&oacute;n: 
</P>
<P>typedef char *(*PTRHOOK)(); /* puntero a la funci&oacute;n
devolviendo (char *) */ 
</P>
<P>typedef void (*VOIDHOOK)(); /* puntero a la funci&oacute;n
devolviendo void */ 
</P>
<P>int set_fieldtype_arg(FIELDTYPE *type, /* tipo a modificar */ 
</P>
<P>PTRHOOK make_str, /* hacer la estructura desde argumentos */ 
</P>
<P>PTRHOOK copy_str, /* hacer copia de la estructura */ 
</P>
<P>VOIDHOOK free_str); /* liberar almacenamiento de la estructura */ 
</P>
<P>Aqu&iacute; esta como el enlace almacenamiento-direcci&oacute;n se
usa: 
</P>
<P>make_str 
</P>
<P>Esta funci&oacute;n se le llama desde set_field_type(). Coge un
argumento, una va_list de argumentos de tipo especifico pasados para
set_field_type(). Se espera devolver un puntero de pila a una
estructura de datos que encapsule estos argumentos. 
</P>
<P>copy_str 
</P>
<P>Esta funci&oacute;n se le llama desde las funciones de la librer&iacute;a
form que localizan nuevas instancias de campos. Se espera coger un
puntero de pila, copiar la pila as almacenamiento localizado, y
devolver la direcci&oacute;n de la pila copiada. 
</P>
<P>free_str 
</P>
<P>Esta funci&oacute;n se le llama desde las rutinas de campo- y
tipo-deslocalizacion en la librer&iacute;a. Toma argumento de un
puntero de pila, y se espera que libere el almacenamiento de la pila.
</P>
<P>Las funciones make_str y copy_str pueden devolver NULL para
mostrar fallo de localizaci&oacute;n. Las rutinas de librer&iacute;a
las llamaran y devolver&aacute;n una indicaci&oacute;n de error
cuando esto ocurra. De este modo, sus funciones de validaci&oacute;n
nunca deber&iacute;an ver un puntero de fichero NULL y no necesita
chequear especialmente por ello. 
</P>
<P><A NAME="Funciones_de_orden_para_Tipos_de_Usuario"></A><B>Funciones
de orden para Tipos de Usuario</B> 
</P>
<P>Algunos tipos de campo de usuario son simplemente ordenados en la
misma manera bien definida que TYPE_ENUM lo esta. Por cada tipo, es
posible definir unas funciones de sucesor y predecesor para soportar
las peticiones REQ_NEXT_CHOICE y REQ_PREV_CHOICE. Aqu&iacute; esta
como: 
</P>
<P>typedef int (*INTHOOK)(); /* puntero para la funci&oacute;n que
devuelve un entero */ 
</P>
<P>int set_fieldtype_arg(FIELDTYPE *type, /* tipo a modificar */ 
</P>
<P>INTHOOK succ, /* coger el valor del sucesor */ 
</P>
<P>INTHOOK pred); /* coger el valor del predecesor */ 
</P>
<P>Los argumentos de sucesor y predecesor ser&aacute;n cada uno
pasados con dos argumentos; un puntero de campo, y un puntero de pila
(como para las funciones de validaci&oacute;n). Se espera que se
utilice la funci&oacute;n field_buffer() para leer el valor actual, y
set_field_buffer() en el buffer para establecer el valor siguiente o
previo. El enlace puede devolver TRUE para indicar &eacute;xito ( un
valor siguiente o previo legal esta establecido) o FALSE para indicar
fallo. 
</P>
<P><A NAME="Evitar_Problemas"></A><B>Evitar Problemas</B> 
</P>
<P>La interfaz para definir tipos de usuario es complicada y
delicada. Mejor que intentar crear un tipo de usuario enteramente
para cumplir los requisitos, puede comenzar estudiando el c&oacute;digo
fuente de la librer&iacute;a para cualquier tipo predefinido que se
parezca lo mas posible a lo que usted quiere. 
</P>
<P>Utilice el c&oacute;digo como modelo, y desarrollarlo hacia lo que
realmente quiera. Evitara muchos problemas y molestias de esta
manera. El c&oacute;digo en la librer&iacute;a ncurses ha sido
espec&iacute;ficamente exento del copyright del paquete para soportar
esto. 
</P>
<P>Si el tipo de usuario define funciones de orden, tiene que hacer
algo intuitivo con el campo en blanco. Una convenci&oacute;n &uacute;tiles
es hacer el sucesor de un campo en blanco al valor m&iacute;nimo del
tipo, y su predecesor al m&aacute;ximo. 
</P>
</BODY>
</HTML>