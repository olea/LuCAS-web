<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.0  (Linux)">

</HEAD>
<BODY LANG="es-ES" DIR="LTR">
<H1 CLASS="western">COMO: Fundamentos de Unix e Internet.<BR>Eric
Raymond&nbsp;&nbsp;&nbsp;&lt;esr@thyrsus.com&gt;</H1>
<H1 CLASS="western">Traducci&oacute;n: Camilo Figueroa
&lt;cigotete@gmail.com&gt;&nbsp;</H1>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P>Revision History</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P>Revision 2.9</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P>Minor updates.</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P>Revision 1.0</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P>Initial revision.</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Este documento describe en un lenguaje
no t&eacute;cnico los fundamentos de trabajo de computadores tipo PC,
sistemas operativos tipo Unix, y la Internet.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a name="inicio"></a><br />
<P STYLE="margin-bottom: 0cm">Tabla de contenido</P>
<P STYLE="margin-bottom: 0cm">1. <A HREF="#10">Introducci&oacute;n</A></P>
<P STYLE="margin-bottom: 0cm">1.1. <A HREF="#11">Prop&oacute;sito
de este documento</A> 
</P>
<P STYLE="margin-bottom: 0cm">1.2. <A HREF="#12">Nuevas
versiones de este documento</A></P>
<P STYLE="margin-bottom: 0cm">1.3. <A HREF="#13">Comentarios
y correcciones</A> 
</P>
<P STYLE="margin-bottom: 0cm">1.4. <A HREF="#14">Recursos
relacionados</A> 
</P>
<P STYLE="margin-bottom: 0cm">2. <A HREF="#20">Anatom&iacute;a
b&aacute;sica de su computador</A> 
</P>
<P STYLE="margin-bottom: 0cm">3. <A HREF="#30">&iquest;Que
sucede cuando enciende el compuatdor?</A> 
</P>
<P STYLE="margin-bottom: 0cm">4. <A HREF="#40">&iquest;Que
pasa cuando usted se registra en el sistema?</A> 
</P>
<P STYLE="margin-bottom: 0cm">5. <A HREF="#50">Que
sucede cuando usted corre programas desde la ventana de sesi&oacute;n?</A>
</P>
<P STYLE="margin-bottom: 0cm">6. <A HREF="#60">&iquest;Como
trabajan los dispositivos de entrada e interrupci&oacute;n?</A> 
</P>
<P STYLE="margin-bottom: 0cm">7. <A HREF="#70">&iquest;Que
hace su computador haga varias cosas a la vez?</A> 
</P>
<P STYLE="margin-bottom: 0cm">8. &iquest;<A HREF="#80">Que
hace que mi computador mantenga procesos de manera conjunta y
organizada?</A> 
</P>
<P STYLE="margin-bottom: 0cm">8.1. <A HREF="#81">Memoria
virtual: versi&oacute;n simple.</A> 
</P>
<P STYLE="margin-bottom: 0cm">8.2. <A HREF="#82">Memoria
virtual: versi&oacute;n detallada.</A> 
</P>
<P STYLE="margin-bottom: 0cm">8.3. <A HREF="#83">La
unidad de administraci&oacute;n de memoria.</A> 
</P>
<P STYLE="margin-bottom: 0cm">9. &iquest;<A HREF="#90">Que
hace que mi computador guarde cosas en memoria?</A> 
</P>
<P STYLE="margin-bottom: 0cm">9.1. <A HREF="#91">N&uacute;meros</A>
</P>
<P STYLE="margin-bottom: 0cm">9.2. <A HREF="#92">Caracteres</A>
</P>
<P STYLE="margin-bottom: 0cm">10. <A HREF="#100">&iquest;Que
hace mi computador cuando almacena cosas en el disco?</A> 
</P>
<P STYLE="margin-bottom: 0cm">10.1. <A HREF="#101">Nivel
inferior del disco y el sistema de arhivos</A> 
</P>
<P STYLE="margin-bottom: 0cm">10.2. <A HREF="#102">Nombres
de archivos y directorios</A> 
</P>
<P STYLE="margin-bottom: 0cm">10.3. <A HREF="#103">Puntos
de montaje</A> 
</P>
<P STYLE="margin-bottom: 0cm">10.4. <A HREF="#104">Como
un archivo logra ser visto</A> 
</P>
<P STYLE="margin-bottom: 0cm">10.5. <A HREF="#105">Propietario,
permisos y seguridad de archivo.</A> 
</P>
<P STYLE="margin-bottom: 0cm">10.6. <A HREF="#106">Como
las cosas pueden andar mal</A> 
</P>
<P STYLE="margin-bottom: 0cm">11. <A HREF="#110">&iquest;Como
trabajan los lenguajes de programaci&oacute;n?</A> 
</P>
<P STYLE="margin-bottom: 0cm">11.1. <A HREF="#111">Lenguajes
Compilados</A> 
</P>
<P STYLE="margin-bottom: 0cm">11.2. <A HREF="#112">lenguajes
Interpetados</A> 
</P>
<P STYLE="margin-bottom: 0cm">11.3. <A HREF="#113">Lenguajes
Pseudoc&oacute;digo</A></P>
<P STYLE="margin-bottom: 0cm">12. <A HREF="#120">&iquest;Que
hace que internet trabaje?</A> 
</P>
<P STYLE="margin-bottom: 0cm">12.1. <A HREF="#121">Nombres
y Ubicaciones</A> 
</P>
<P STYLE="margin-bottom: 0cm">12.2. <A HREF="#122">EL
Sistema de Nombres de Dominio</A> 
</P>
<P STYLE="margin-bottom: 0cm">12.3. <A HREF="#123">Paquetes
y enrutadores</A> 
</P>
<P STYLE="margin-bottom: 0cm">12.4. <A HREF="#124">TCP
e IP</A> 
</P>
<P STYLE="margin-bottom: 0cm">12.5. <A HREF="#125">HTTP,
un protocolo de aplicaci&oacute;n</A> 
</P>
<P STYLE="margin-bottom: 0cm">13. <A HREF="#130">Para
aprender m&aacute;s</A> 
</P>
<P></P>
<P> </P>
<a href="#inicio" style="float:left">inicio</a><br /><H1 CLASS="western">1. Introducci&oacute;n<a name="10"></a></H1>
<H2 CLASS="western">1.1. Prop&oacute;sito de este documento<a name="11"></a></H2>
<P STYLE="margin-bottom: 0cm">Este documento tiene la intenci&oacute;n
de ayudar a los usuarios de Linux y de Internet quienes “aprenden
haciendo” (learning by doing). Aunque esta es una gran manera de
adquirir espec&iacute;ficas habilidades, algunas veces nos deja
problemas particulares en algunos conocimientos fundamentales. Estos
problemas pueden dificultarnos la capacidad de pensar creativamente
la soluci&oacute;n efectiva de algunos problemas debido a la ausencia
de un buen modelo mental sobre lo que realmente esta sucediendo.</P>
<P STYLE="margin-bottom: 0cm">Intentar&eacute; describir con un
lenguaje simple y claro como trabaja todo esto. Este documento ha
sido adecuado para personas que usan Unix o Linux en hardware de
computadoras tipo PC. A&uacute;n as&iacute; usualmente usar&eacute;
el termino 'Unix' ya que la mayor&iacute;a de lo que se describir&aacute;
es consistente a trav&eacute;s de las plataformas y las variantes de
Linux. 
</P>
<P STYLE="margin-bottom: 0cm">Voy a asumir que usted esta usando un
computador tipo PC Intel. Los detalles difieren ligeramente si usted
esta usando un Alpha, un PowerPC o alg&uacute;n otro Unix, y que los
detalles b&aacute;sico son los mismos.</P>
<P STYLE="margin-bottom: 0cm">No deseo repetir las mismas cosas, as&iacute;
que usted debe poner atenci&oacute;n, pero esto no significa que debe
aprender cada palabra que lea. Es buena idea solo hojear el documento
cuando lo lea por primera vez, y regresar y releerlo unas pocas veces
despu&eacute;s de que haya digerido lo que haya le&iacute;do.</P>
<P STYLE="margin-bottom: 0cm">Este es un documento en constante
cambio. Intentar&eacute; crear nuevas secciones en la medida que los
usuarios lo soliciten, as&iacute; que regrese y revise
peri&oacute;dicamente. 
</P>
<H2 CLASS="western">1.2. Nuevas versiones de este documento<a name="12" id="12"></a></H2>
<P STYLE="margin-bottom: 0cm">Nuevas versiones de este documento
(Unix and Internet Fundamentals HOWTO / COMO de Fundamentos de Unix e
Internet) ser&aacute;n peri&oacute;dicamente publicadas en
<A HREF="news:comp.os.linux.help">comp.os.Linux.help</A> y
<A HREF="news:comp.os.linux.announce">comp.os.Linux.announce</A> y
<A HREF="news:news.answers">news.answers</A>. Estos documentos
tambi&eacute;n ser&aacute;n subidos a varios sitios web y servidores
FTP, incluyendo la p&aacute;gina de inicio de LDP.</P>
<P STYLE="margin-bottom: 0cm">Tambi&eacute;n puede visitar la &uacute;ltima
version de este documento en Internet en la
direcci&oacute;n:<A HREF="http://http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html">http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html</A>.</P>
<P STYLE="margin-bottom: 0cm">Este documento ha sido traducido al
<A HREF="http://theta.uoks.uj.edu.pl/%7Egszczepa/gszczepa/esr1iso2.htm">Polaco</A> y al <a href="http://es.tldp.org/Manuales-LuCAS/doc-fundamentos-unix-internet/fundamentos_unix_e_internet.html">Español</a></P>
<H2 CLASS="western">1.3. Comentarios, sugerencias y correcciones<a name="13" id="13"></a></H2>
<P STYLE="margin-bottom: 0cm">Si usted tiene preguntas, comentarios o
sugerencias sobre este documento,por favor sientase libre de escribir
al email de Eric Raymond, en <A HREF="mailto:esr@thyrsus.com">esr@thyrsus.com.</A>
Acepto cualquier sugerencia o critica. Especialmente recibo links
donde se encuentren detalladas explicaciones sobre conceptos
individuales. SI usted encuentra un error en este documento, por
favor h&aacute;gamelo saber para corregirlo en la siguiente versi&oacute;n.
Gracias.</P>
<P STYLE="margin-bottom: 0cm">Sobre esta traducción al español,  comentarios, sugerencias y correcciones a <a href="mailto:cigotete@gmail.com">cigotete@gmail.com</a>.</P>
<H2 CLASS="western">1.4. Recursos relacionados<a name="14" id="14"></a></H2>
<P STYLE="margin-bottom: 0cm">Si usted esta leyendo este documento
buscando como hackear, usted tambi&eacute;n debe leer el <A HREF="http://www.catb.org/%7Eesr/faqs/hacker-howto.html">Como
Ser un Hacker, Preguntas y Respuestas / How To Become A Hacker FAQ</A>,
que contiene links hacia otros &uacute;tiles recursos.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">2. Anatom&iacute;a b&aacute;sica de su computador<a name="20" id="20"></a></H1>
<P STYLE="margin-bottom: 0cm">Dentro de su computador hay un chip de
procesamiento que realiza actualmente el proceso de computaci&oacute;n.
&Eacute;l tiene una memoria interna (que la gente de DOS/Windows
llama “RAM” y la gente de Unix a menudo llama “Nucleo” (El
termino en Unix proviene de una vieja costumbre desde cuando las RAM
estaban hechas con formas de donas con n&uacute;cleo de ferrita). El
procesador y la memoria viven en la Tarjeta Madre (MotherBoard), que
es el coraz&oacute;n de su computador.</P>
<P STYLE="margin-bottom: 0cm">Su computador tiene una pantalla y un
teclado. tiene un disco duro y un CD-ROM y quiz&aacute;s un disco
blando. Algunos de esos dispositivos funcionan gracias a tarjetas
controladoras que se insertan dentro de la tarjeta madre y ayudan al
computador a manejar estos dispositivos. Otros dispositivos funcionan
directamente sobre la tarjeta madre gracias a chipsets (conjunto de
chips. n del t.) especializados, que cumplen la misma funci&oacute;n
de la tarjetas controladoras. El funcionamiento de su teclado es muy
sencillo para necesitar una tarjeta aparte; en este caso el
controlador esta construido directamente dentro del chasis del mismo
teclado. 
</P>
<P STYLE="margin-bottom: 0cm">M&aacute;s adelante nos adentraremos en
algunos de los detalles de como trabajan estos dispositivos. Por
ahora, veamos unas pocas cosas b&aacute;sicas para recordar sobre
como estos dispositivos trabajan juntos.</P>
<P STYLE="margin-bottom: 0cm">Todas las partes dentro de su
computador est&aacute;n conectadas por un bus. F&iacute;sicamente el
bus es donde usted inserta las tarjetas controladoras (la tarjeta de
video, el controlador de disco o si se tiene, la tarjeta de sonido).
El bus es la autopista entre su procesador, su pantalla, su disco y
cualquier otra cosa. 
</P>
<P STYLE="margin-bottom: 0cm">(Si usted ha visto referencias a 'ISA',
'PCI', y 'PCMCIA' relacionadas con los computadores y no las ha
entendido, estos son tipos de bus. ISA es, excepto por algunas
diferencias, el mismo bus que fue usado en los computadores
originales IBM en 1980. Actualmente est&aacute;n fuera de uso. PCI
(Periferical Component Interconnection / Componente de Interconexi&oacute;n
Perif&eacute;rica) es el bus usado en la mayor&iacute;a de los mas
modernos computadores as&iacute; como en los m&aacute;s modernos
computadores Machintosh. PCMCIA es una variedad de el bus ISA con
conectores m&aacute;s peque&ntilde;os, usado en computadores
port&aacute;tiles. 
</P>
<P STYLE="margin-bottom: 0cm">El procesador, quien hace que todo
funcione, realmente no puede comunicarse directamente con ninguno de
los dem&aacute;s dispositivos, &eacute;l tiene que hablar
directamente con ellos usando el bus. El &uacute;nico otro subsistema
que es realmente r&aacute;pido y con acceso inmediato al procesador
es la memoria (el n&uacute;cleo).</P>
<P STYLE="margin-bottom: 0cm">Cuando su computador lee un programa o
los datos del disco, lo que realmente sucede es que el procesador usa
el bus para enviar al controlador del disco una solicitud de lectura
del disco. Un instante despu&eacute;s el controlador del disco usa el
bus para advertirle al procesador que &eacute;l (el controlador del
disco) ha le&iacute;do los datos y los ha puesto en alg&uacute;n
lugar de la memoria. El procesador entonces puede usar el bus para
mirar los datos</P>
<P STYLE="margin-bottom: 0cm">El teclado y la pantalla tambi&eacute;n
usan el bus para comunicarse con el procesador, pero de una manera
simple. Esto lo discutiremos m&aacute;s adelante. Por ahora usted
sabe lo suficiente como para entender que sucede cuando enciende el
computador.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">3. Que sucede cuando enciende el computador?<a name="30" id="30"></a></H1>
<P STYLE="margin-bottom: 0cm">Un computador sin un programa
funcionando es solo un trozo inerte de elementos electr&oacute;nicos.
La primera cosa que un computador hace cuando es encendido es iniciar
un programa especial llamado Sistema Operativo. EL trabajo del
sistema operativo es ayudar a otros programas del computador a
trabajar con los dif&iacute;ciles detalles de controlar el hardware
del computador.</P>
<P STYLE="margin-bottom: 0cm">El proceso de iniciar el sistema
operativo se llama Booting/arranque (originalmente el termino fue
bootstrapping/'nicio de si mismo' en alusi&oacute;n al proceso de
arrancar “comenzando desde los pies a la cabeza”). El computador
sabe como iniciar porque la instrucciones del arranque est&aacute;n
definidas dentro de uno de sus chips, el chip BIOS (Basic Input
Output Sistem / Sistema b&aacute;sico de entrada y salida)</P>
<P STYLE="margin-bottom: 0cm">El chip BIOS le indica al computador
que mire un un peque&ntilde;o lugar, usualmente en el disco duro
numerado con el menor numero (por si hay otros discos. n. del t.)
buscando un programa especial llamado el 'boot loader'/'cargador del
arranque' (en Linux, el cargador del arranque es llamado Grub o
LILO). EL cargador de arranque es ubicado dentro de la memoria e
iniciado. El trabajo del cargador del inicio es es iniciar el sistema
operativo.</P>
<P STYLE="margin-bottom: 0cm">El cargador inicia esto buscando
primero el kernel, carg&aacute;ndolo dentro de la memoria e
inici&aacute;ndolo. Cuando usted inicia Linux y ve en pantalla el
texto “LILO” (o “Grub”. n. del .t.) seguido de un grupo de
puntos, significa que se esta cargando el kernel (cada punto
significa que ha cargado otro 'bloque del disco' del c&oacute;digo
del kernel.)</P>
<P STYLE="margin-bottom: 0cm">&iquest;Usted podr&iacute;a preguntarse
porque el BIOS no carga directamente el kernel?, &iquest;o porque el
proceso del 'cargador del inicio' consta de estos dos pasos? Bien, la
raz&oacute;n es porque la BIOS no es muy astuta. En efecto es muy
est&uacute;pida y Linux no usa la BIOS despu&eacute;s del momento del
arranque. la BIOS fue originalmente escrita para primitivos
computadores de 8 bits con diminutos discos, y literalmente no puede
acceder al disco lo suficiente como para cargar directamente el
kernel. Adicionalmente el proceso de inicio tambi&eacute;n permite
iniciar (y escoger. n del t.) uno de varios sistemas operativos que
se encuentran ubicados en diferentes lugares del disco en el evento
poco probable de que Unix no sea suficiente para usted. 
</P>
<P STYLE="margin-bottom: 0cm">Una vez el kernel arranca, &eacute;l
tiene que mirar a su alrededor encontrando el resto del hardware y
alist&aacute;ndose para hacer funcionar los programas. El kernel no
hace esto meti&eacute;ndose en las posiciones ordinarias de memoria,
en vez de ello lo hace en los puertos I/O
('Input/Output'/'Salida/Entrada)(I/O: son lugares especiales en el
Bus que probablemente est&aacute;n para que las tarjetas de control
de los dispositivos puedan escuchar las peticiones/ordenes del
kernel. El kernel no hace esto de una manera desordenada; &eacute;l
tiene una gran cantidad de informaci&oacute;n incorporada sobre
posiblemente donde y como los controladores responder&aacute;n en el
caso de que est&eacute;n presentes. Este proceso es llamado
autoprobing / autodetecci&oacute;n.</P>
<P STYLE="margin-bottom: 0cm">La mayor&iacute;a de los mensajes que
usted ve en el momento del arranque es el kernel realizando la
autodetecci&oacute;n de su hardware a trav&eacute;s de los puertos
I/O, identificando cual esta disponible para cada dispositivo y
adaptando dicho dispositivo a su maquina. El kernel Linux es
extremadamente bueno en esto, mejor que la mayor&iacute;a de los
otros kernels Unix y mucho mejor que el de DOS o Windows. En efecto,
muchos veteranos de Linux piensan que la habilidad de Linux en la
detecci&oacute;n del proceso de arranque (lo cual hace que sea
relativamente f&aacute;cil para instalar) fue la principal raz&oacute;n
para dejar de ser un paquete experimental y libre de Unix y atraer a
una masa critica de usuarios. 
</P>
<P STYLE="margin-bottom: 0cm">El que el kernel se encuentre
completamente cargado y funcionando no significa que haya terminado
el proceso de arranque; este es solo el primer paso del proceso
(algunas veces llamado 'run level 1'/'nivel de funcionamiento 1').
Despu&eacute;s del primer paso, el kernel toma control de un especial
proceso llamado 'init' el cual despliega varios procesos de
administraci&oacute;n.</P>
<P STYLE="margin-bottom: 0cm">El primer trabajo del proceso 'init'
usualmente es el controlar que la supervisi&oacute;n de los discos
este bien realizada. El sistema de archivos del disco tiene cosas muy
fragiles; podr&iacute;a estar muy afectado por una falla del hardware
o un s&uacute;bito cambio de voltaje, estas son buenas razones para
tomar medidas de recuperaci&oacute;n antes de que Unix este de nuevo
funcionando. Veremos algo de esto mas en detalle cuando hablemos
sobre <A HREF="#106">como
puede fallar el sistema de archivos.</A></P>
<P STYLE="margin-bottom: 0cm">El siguiente paso del proceso 'init' es
arrancar varios 'demonios'. Un demonio es un programa como la cola de
impresi&oacute;n, un detector de llegada de emails o un servidor web
que funciona escondido en segundo plano, esperando cosas que hacer.
Estos programas especiales a menudo tienen que coordinar varias
peticiones que podr&iacute;an entrar en conflicto. Estos procesos son
'demonios' por que a menudo es f&aacute;cil escribir un programa que
funcione constantemente y conozca sobre todas las peticiones que
deber&iacute;a tratar para asegurar que una multitud de copias de
procesos (cada copia procesando una solicitud y todas funcionando al
mismo tiempo) no se amontonen. La especifica colecci&oacute;n de
demonios de arranque puede variar, pero casi siempre incluye el
proceso de la cola de impresi&oacute;n (un demonio portero para su
impresora).</P>
<P STYLE="margin-bottom: 0cm">El siguiente paso es prepararse para
los usuarios. El proceso Init inicia una copia del programa getty
para observar/atender su consola (y quiz&aacute;s mas copias para
atender conexiones 'dial-in'/'por marcado remoto' en puerto serial).
Este programa es el que despliega el aviso de acceso de su consola.
Una vez todos los demonios y procesos getty de cada terminal han sido
iniciados, entramos al 'run level 2'/'nivel de funcionamiento 2'. En
este nivel usted puede acceder y correr programas.</P>
<P STYLE="margin-bottom: 0cm">Pero nosotros a&uacute;n no hemos
alcanzado este segundo paso. El siguiente paso consiste en arrancar
varios demonios que dan soporte a redes y otros servicios. Una vez
esto se ha hecho estamos en el 'run level 3'/nivel de funcionamiento
3' y el sistema se encuentra totalmente listo para ser usado.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">4. &iquest;Que pasa cuando usted se registra en
el sistema?<a name="40" id="40"></a></H1>
<P STYLE="margin-bottom: 0cm">Cuando usted se registra (dando un
nombre a getty) usted se identifica frente al computador. El corre
entonces un programa llamado (naturalmente) login. EL cual toma su
clave de acceso y revisa si usted esta autorizado para usar la
maquina. Si usted no esta autorizado su intento de acceso es
rechazado. Si usted esta autorizado el programa login realiza unas
pocas tareas de 'housekeeping'/'administraci&oacute;n-mantenimiento'
e inicia el interprete de comandos, el 'shell'/'ventana de sesi&oacute;n'.
(Si, getty y login pueden ser un programa. Ellos est&aacute;n
separados por razones hist&oacute;ricas que no son relevantes aqu&iacute;)</P>
<P STYLE="margin-bottom: 0cm">Esto es solo un poco de lo que el
sistema hace antes de darle una ventana de sesi&oacute;n (usted
necesitar&aacute; conocer esto mas adelante cuando hablemos sobre los
permisos de archivos). Usted se identifica con un nombre de acceso y
una clave. Dicho nombre de acceso es revisado en un archivo llamado
/etc/passwd, el cual contiene una secuencia de lineas, cada una
describiendo una cuenta de usuario. 
</P>
<P STYLE="margin-bottom: 0cm">Uno de esos campos corresponde a una
versi&oacute;n encriptada de la clave (algunas veces los campos
encriptados son realmente almacenados en un segundo archivo
/etc/shadow con ajustados permisos haciendo que sea dif&iacute;cil
descubrir la clave). Cuando usted ingresa con una cuenta la clave es
encriptada exactamente de la misma forma y el programa login compara
si son iguales. La seguridad de este m&eacute;todo esta en el hecho
que, mientras que es f&aacute;cil ir de la versi&oacute;n limpia de
la clave a la versi&oacute;n encriptada, la forma inversa es muy
dif&iacute;cil. De esta manera, a&uacute;n si alguien puede ver la
versi&oacute;n encriptada de la clave no le ser&aacute; posible
usarla. (esto tambi&eacute;n significa que si usted olvida su clave
no hay forma de recuperarla, solo funcionar&aacute; cambiarla a algo
que usted escoja.) 
</P>
<P STYLE="margin-bottom: 0cm">Una vez usted se ha registrado
satisfactoriamente, usted obtiene todos los privilegios asociados con
la especifica cuenta que usted esta usando. Usted tambi&eacute;n
puede ser reconocido como parte de un 'grupo'. Un grupo es una
colecci&oacute;n de nombres de usuarios establecida por el
administrador del sistema. Los grupos pueden tener privilegios
independientes de los privilegios de sus miembros. Un usuario puede
ser miembro de m&uacute;ltiples grupos. (para detalles sobre como
trabajan los privilegios en Unix vaya a la secci&oacute;n de
<A HREF="#105">permisos</A>.</P>
<P STYLE="margin-bottom: 0cm">Note que aunque usted se refiera
normalmente a usuarios y grupos por un nombre, ellos internamente
est&aacute;n realmente almacenados internamente en forma de
identificadores num&eacute;ricos (Idś). El archivo de clave compara
su nombre de cuenta contra un identificador de usuario; el archivo
/etc/group compara los nombres de grupo contra un identificador de
grupo. Los comandos que negocian con las cuentas y los grupos
realizan autom&aacute;ticamente la traducci&oacute;n.</P>
<P STYLE="margin-bottom: 0cm">Su inicio de cuenta tambi&eacute;n
contiene un 'directorio de inicio'. EL lugar es donde el sistema de
archivos de Unix ubicar&aacute; sus archivos personales. Finalmente
su cuenta de inicio tambi&eacute;n ajustar&aacute; su ventana de
sesi&oacute;n, el interprete de comandos que el programa login
arrancar&aacute; para aceptar sus comandos.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">5. &iquest;Que sucede cuando usted corre
programas desde la ventana de sesi&oacute;n?<a name="50" id="50"></a></H1>
<P STYLE="margin-bottom: 0cm">La ventana de sesi&oacute;n es el
interprete para los comandos que usted escribe en ella; es llamada
shell (caparaz&oacute;n) porque ella envuelve y oculta el kernel del
sistema operativo. Es una importante caracter&iacute;stica de Unix
que el shell y el kernel sean programas separados que se comunican a
trav&eacute;s de un peque&ntilde;o conjunto de llamadas del sistema.
Esto permite la posibilidad de probar m&uacute;ltiples shells y
diferentes sabores de interfaces.</P>
<P STYLE="margin-bottom: 0cm">Un shell normalmente mostrar&aacute; a
usted el s&iacute;mbolo '$' que usted ve despu&eacute;s de acceder en
el sistema (a menos que usted haya ajustado esto para alg&uacute;n
otro s&iacute;mbolo). Nosotros no hablaremos sobre la sintaxis de la
shell y sobre las sencillas cosas que usted puede ver en la pantalla;
en lugar de ello vamos a mirar detr&aacute;s de la escena de lo que
sucede desde el punto de vista del computador. 
</P>
<P STYLE="margin-bottom: 0cm">Desde el momento de arranque y despu&eacute;s
de que usted corre un programa, usted puede pensar en su computador
como un contenedor en el que habita un zool&oacute;gico de procesos
que est&aacute;n esperando algo que hacer. Ellos est&aacute;n en la
espera de eventos. Un evento puede ser el presionar una tecla o mover
el rat&oacute;n. O si su maquina est&aacute; enganchada a una red, un
evento podr&iacute;a ser un paquete de datos entrando en la red.</P>
<P STYLE="margin-bottom: 0cm">El kernel es uno de estos procesos. Es
especialmente &uacute;nico porque el controla cuando pueden correr
otros procesos del usuario, y es normal que sea el &uacute;nico
proceso que tiene acceso directo al hardware de la maquina. En
efecto, los dem&aacute;s procesos del usuario tienen que hacer una
petici&oacute;n al kernel cuando ellos quieran conseguir una entrada
del teclado, escribir en la pantalla, leer el disco o escribir en &eacute;l,
o solamente hacer cualquier otra cosa que impliquen bits en la
memoria.</P>
<P STYLE="margin-bottom: 0cm">Normalmente todas las entradas y
salidas (I/O) van a trav&eacute;s del kernel as&iacute; que el puede
programar las operaciones y prevenir procesos traslapados. Unos pocos
procesos de usuario tienen permitido rodear el kernel, usualmente por
que se les ha dado acceso directo a los puertos I/O. Los servidores X
(programas que manejan solicitudes de otros programas para hacer
gr&aacute;ficas de pantalla en la mayor&iacute;a de los equipos Unix.</P>
<P STYLE="margin-bottom: 0cm">La Shell es solo un proceso de usuario
sin nada en particular. El espera la pulsaci&oacute;n del teclado,
escuchando (a trav&eacute;s del kernel) al puerto I/O del teclado.
Tal como el kernel los ve, los repite en su pantalla. Cuando el
kernel recibe la pulsaci&oacute;n de la tecla 'Enter' el pasa su
linea de texto al shell. El shell intenta interpretar estas teclas
como comandos.</P>
<P STYLE="margin-bottom: 0cm">Vamos a decir que usted teclea 'ls' y
pulsa la tecla 'Enter' para invocar el listador de directorios de
Unix. La shell aplica sus reglas preestablecidas para entender que
usted desea correr el comando u orden de ejecuci&oacute;n en el
archivo /bin/ls. El comando hace una llamada de sistema solicitando
al kernel iniciar /bin/ls como un nuevo proceso hijo d&aacute;ndole
acceso a la pantalla y el teclado a trav&eacute;s del kernel.
Entonces la shell duerme esperando que ls termine. 
</P>
<P STYLE="margin-bottom: 0cm">Cuando la orden /bin/ls esta hecha, le
avisa al kernel que ha terminado emitiendo al sistema una petici&oacute;n
de salida. El kernel entonces despierta la shell dici&eacute;ndole
que puede continuar. La shell emite otro aviso y espera por otra
entrada.</P>
<P STYLE="margin-bottom: 0cm">Sin embargo otras cosas pueden estar
sucediendo mientras su orden 'ls' es ejecutada (tenemos que suponer
que usted esta listando un directorio muy largo). Usted puede cambiar
a otra consola virtual, registrarse en ella, e iniciar por ejemplo un
juego de Quake. O suponiendo que usted esta enganchado a la Internet.
Su maquina puede estar enviando o recibiendo email mientras /bin/ls
corre.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">6. &iquest;como trabajan los dispositivos de
entrada e interrupci&oacute;n?<a name="60" id="60"></a></H1>
<P STYLE="margin-bottom: 0cm">Su teclado es un dispositivo de entrada
muy simple; simple porque genera peque&ntilde;as cantidades de datos
muy lentamente (por un est&aacute;ndar de computaci&oacute;n). Cuando
usted presiona o libera una tecla, el evento es enviado por el cable
del teclado para provocar 'una interrupci&oacute;n de hardware' /
'hardware interrupt'. 
</P>
<P STYLE="margin-bottom: 0cm">Es trabajo del sistema operativo el
atender este tipo de interrupciones. Para cada posible tipo de
interrupci&oacute;n habr&aacute; un 'manipulador de interrupci&oacute;n'
/ ' interrupt handler', como parte del sistema operativo que acoge
cualquier dato asociado con dicho manipulador de interrupci&oacute;n
(como su valor tecleado) hasta que pueda ser procesado. 
</P>
<P STYLE="margin-bottom: 0cm">Lo que el manipulador de interrupciones
hace realmente con su teclado es enviar el valor tecleado dentro del
&aacute;rea del sistema cerca del inicio de la memoria. All&iacute;,
el valor estar&aacute; disponible para cuando el sistema operativo
pase el control a cualquier programa que se supone esta actualmente
leyendo el teclado. 
</P>
<P STYLE="margin-bottom: 0cm">Dispositivos de entrada mas complejos
como los discos o la tarjetas de red trabajan de similar manera.
Anteriormente mi referencia a un controlador de disco que usa el bus
para hacer una petici&oacute;n al disco era suficiente. Lo que
realmente sucede es que el disco recibe una interrupci&oacute;n. El
manipulador de interrupciones del disco entonces copia los datos
recibidos dentro de la memoria para su posterior uso por parte del
programa que ha hecho la petici&oacute;n.</P>
<P STYLE="margin-bottom: 0cm">Cada tipo de interrupci&oacute;n tiene
asociado un 'nivel de prioridad' / 'priority level'. Interrupciones
con prioridades bajas (como los eventos del teclado) tienen que
esperar por/sobre las interrupciones con prioridades altas (como los
tictac del reloj o los eventos del disco. Unix esta dise&ntilde;ado
para dar prioridad al tipo de eventos que necesitan ser procesados
r&aacute;pidamente para mantener libre de problema a las respuestas
que da la maquina.</P>
<P STYLE="margin-bottom: 0cm">En los mensajes que aparecen en el
momento del arranque, usted puede ver referencias a n&uacute;meros
IRQ. Note que una de las t&iacute;picas formas de hacer una
incorrecta configuraci&oacute;n de hardware es teniendo a dos
diferentes dispositivos intentando usar el mismo IRQ, sin entender
exactamente por que. 
</P>
<P STYLE="margin-bottom: 0cm">He aqu&iacute; la respuesta. IRQ es la
abreviatura de “Petici&oacute;n de Interrupci&oacute;n” /
“Interrupt Request”. El sistema operativo necesita saber en el
momento del arranque que numero de interrupci&oacute;n usara cada
dispositivo de hardware, para asociar adecuadamente los manipuladores
de interrupci&oacute;n. Si dos diferentes dispositivos tratan de usar
el mismo IRQ,las interrupciones ser&aacute;n enviadas al manipulador
equivocado. Esto por lo menos inhabilitar&aacute; el dispositivo y
puede algunas veces confundir negativamente al sistema, lo suficiente
como para saturarlo o anularlo. 
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">7. &iquest;Que hace su computador haga varias
cosas a la vez?<a name="70" id="70"></a></H1>
<P STYLE="margin-bottom: 0cm">Realmente el no lo hace. Los
computadores pueden solamente hacer una tarea a la vez. Pero el
computador puede cambiar de tareas muy r&aacute;pidamente y un tonto
podr&iacute;a pensar para sus adentros que hace varias cosas a la
vez. Esto es llamado timesharing / 'tiempo compartido' 
</P>
<P STYLE="margin-bottom: 0cm">Una de las tareas del kernel es
administrar el timesharing. El tiene una parte llamada el
programador, el cual mantiene dentro de si informaci&oacute;n sobre
otros procesos (no kernel). Cada 1/60 de segundo un temporizador se
apaga en el kernel, generando una interrupci&oacute;n en el reloj. El
programador detiene cualquier proceso que actualmente este corriendo,
suspendi&eacute;ndolo en un lugar, y tomando control de otro proceso.</P>
<P STYLE="margin-bottom: 0cm">1/60 de segundo puede no sonar a mucho
tiempo. Pero para los procesadores de hoy es suficiente para correr
decenas de miles de instrucciones de maquina, con las cual puede
hacer mucho trabajo. Si a&uacute;n usted tiene muchos procesadores,
cada uno puede completar un poco en cada uno de sus intervalos de
tiempo.</P>
<P STYLE="margin-bottom: 0cm">En la practica, un programa puede no
lograr usar la totalidad de su intervalo de tiempo. Si una
interrupci&oacute;n llega desde un dispositivo I/O, el kernel
detendr&aacute; la tarea actual, iniciar&aacute; el manipulador de
interrupci&oacute;n y retornar&aacute; a la actual tarea. Una
tormenta de interrupciones de alta prioridad puede exprimir el normal
procesamiento: esta mala conducta es llamada 'thrashing' y por
fortuna es muy dif&iacute;cil de inducir en los modernos Unix</P>
<P STYLE="margin-bottom: 0cm">En efecto, la velocidad de los
programas es solo muy raramente limitada por la cantidad de tiempo
(de maquina) que pueda obtener (hay algunas excepciones a esta regla,
como las tarjetas de sonido y las de generaci&oacute;n de gr&aacute;ficos
3D). Mucho mas a menudo las demoras suceden cuando el programa tiene
que esperar un dato desde una unidad de disco u una conexi&oacute;n
de red.</P>
<P STYLE="margin-bottom: 0cm">Un sistema operativo que soporte
rutinariamente muchos procesos simult&aacute;neamente es llamado
“multitasking” / “multitarea”. Desde sus cimientos, la
familia de sistemas Operativos Unix fueron dise&ntilde;ados para la
multitarea y Unix es muy bueno en ello – Mucho mas efectivo que
Windows o el viejo Mac OS, los cuales ten&iacute;an la multitarea
atornillada dentro de ellos como una idea de &uacute;ltimo momento y
la realizaban de una manera muy pobre. Una eficiente y confiable
multitarea es en gran parte lo que hace a Linux superior para las
redes (networking), las comunicaciones y los servicios web (web
services).</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">8. Que hace que mi computador mantenga procesos
de manera conjunta y organizada?<a name="80" id="80"></a></H1>
<P STYLE="margin-bottom: 0cm">El programador del kernel cuida de
dividir los procesos en el tiempo. Su sistema operativo tambi&eacute;n
tiene que dividir estos procesos en el espacio, de tal forma que los
procesos no puedan montarse unos con otros. Aun si usted supone que
todos los programas intentan trabajar de manera colaborativa, usted
no desear&iacute;a que un bug (error) en uno de ellos sea capaz de
afectar a otros. Las operaciones que su sistema operativo realiza
para resolver este tipo de problemas se llama 'administraci&oacute;n
de memoria' / 'memory management'.</P>
<P STYLE="margin-bottom: 0cm">En su maquina cada proceso necesita su
propia &aacute;rea de memoria, como un lugar donde correr su c&oacute;digo
y mantener sus variables y resultados. Usted puede pensar que este
conjunto de cosas esta compuesta de un segmento de c&oacute;digo de
solo lectura (que contiene las instrucciones de los procesos) y un
segmento de datos escribible (conteniendo todas las variables del
proceso). El segmento de datos es &uacute;nico para cada proceso,
pero si dos procesos est&aacute;n corriendo el mismo c&oacute;digo,
Unix, autom&aacute;ticamente lo organiza para que estos procesos
compartan el mismo segmento de c&oacute;digo, como una medida de
eficiencia.</P>
<H2 CLASS="western">8.1. Memoria virtual: versi&oacute;n simple<a name="81" id="81"></a></H2>
<P STYLE="margin-bottom: 0cm">La eficiencia es importante por que la
memoria tiene un alto costo. Algunas veces usted no tiene la
suficiente memoria para mantener todos los programas que la maquina
esta corriendo, especialmente si usted usa programas de gran tama&ntilde;o
como un servidor X. Para resolver estos casos Unix usa una t&eacute;cnica
llamada Memoria Virtual. El no trata de mantener para un proceso todo
el c&oacute;digo y datos necesarios. En lugar de ello, Unix mantiene
solo un relativamente peque&ntilde;o espacio de trabajo; el resto de
el proceso es dejado en un lugar llamado 'space swap'/'espacio de
intercambio' en su disco duro. 
</P>
<P STYLE="margin-bottom: 0cm">Note que en el pasado el termino
“algunas veces” fue “casi siempre” debido a que el tama&ntilde;o
de la memoria era generalmente peque&ntilde;o en relaci&oacute;n al
tama&ntilde;o de los programas que corr&iacute;an, as&iacute; que el
proceso de swapping era frecuente. Ahora la memoria es mucho menos
costosa y aun las maquinas low-end (de baja categor&iacute;a) tienen
bastante memoria. Una moderna maquina personal de 64 MB de memoria o
mas le es posible correr servidores X y un conjunto de tareas sin
nunca necesitar el swap despu&eacute;s de que se ha cargado en
memoria.</P>
<H2 CLASS="western">8.2. Memoria virtual. Versi&oacute;n detallada<a name="82" id="82"></a></H2>
<P STYLE="margin-bottom: 0cm">Realmente en la ultima secci&oacute;n
se simplificaron las cosas un poco. Si, los programas ven la mayor
parte de la mayor&iacute;a como un grande y plano banco de
direcciones de memoria, que una memoria f&iacute;sica, y aqu&iacute;
un disco con 'memoria de intercambio' es usado para mantener esta
ilusi&oacute;n. En todo caso su hardware no tiene m&aacute;s que
cinco diferentes tipos de memoria dentro de si, y la diferencia entre
estos tipos de memoria puede representar una buena decisi&oacute;n
cuando los programas tienen que funcionar a m&aacute;xima velocidad.
Para entender realmente que sucede dentro de su computador, usted
debe aprender como todas ellas trabaja en conjunto. 
</P>
<P STYLE="margin-bottom: 0cm">Los cinco tipos de memoria son estos:
registros del procesador,cache interno (o en chip), cache externo (o
fuera de chip), memoria principal, y disco. Y la raz&oacute;n de que
sean varios tipos es simple: la velocidad cuesta dinero. He listado
estos tipos de memoria en orden decreciente respecto a el tiempo de
acceso y en orden creciente respecto al costo. La memoria de
registros del procesador es la mas r&aacute;pida y costosa, y puede
ser accedida de manera aleatoria en cerca de un bill&oacute;n de
veces por segundo, mientras que la memoria del disco es la mas lenta
y barata, y puede realizar cerca de 100 accesos aleatorios en un
segundo.</P>
<P STYLE="margin-bottom: 0cm">He aqu&iacute; una lista que refleja
velocidades datadas en el inicio del 2000 de una maquina de
escritorio com&uacute;n. Mientras que la velocidad y la capacidad
crecen los precios van bajando y es posible esperar que este tipo de
proporciones se sostengan de manera constante.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">Disco: Tama&ntilde;o 13000 MB.
Velocidad de acceso: 100KB/sec.</P>
<P STYLE="margin-bottom: 0cm">Memoria principal: Tama&ntilde;o 256
MB. Velocidad de acceso: 100MB/sec.</P>
<P STYLE="margin-bottom: 0cm">Cache Externo: Tama&ntilde;o 512 MB.
Velocidad de acceso: 205MB/sec.</P>
<P STYLE="margin-bottom: 0cm">Cache Interno: Tama&ntilde;o 32KB.
Velocidad de acceso: 500MB/sec.</P>
<P STYLE="margin-bottom: 0cm">Procesador: Tama&ntilde;o 28 bytes.
Velocidad de acceso: 1000MB/sec.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">No es posible construir alguna cosa mas
all&aacute; de estos r&aacute;pidos tipos de memoria, Esto requerir&iacute;a
mucho trabajo (y aun si no lo fuera) por que la memoria r&aacute;pida
es vol&aacute;til. Esto significa que pierde su sustento cuando la
energ&iacute;a desaparece. Y aqu&iacute; hay un gran desequilibrio
entre la velocidad del procesador y la velocidad del disco. Los tres
niveles de en medio de la jerarqu&iacute;a de memorias (cache
interno, cache externo y memoria principal) existen b&aacute;sicamente
para cerrar esta brecha.</P>
<P STYLE="margin-bottom: 0cm">Linux y otros Unix tienen una
caracter&iacute;stica llamada 'memoria virtual' / 'virtual memory'.
Lo que esto significa es que el sistema operativo se comporta como si
tuviera mas memoria de la que realmente tiene. Su verdadera memoria
f&iacute;sica principal se comporta mas como un gran conjunto de
ventanas o valijas (caches) que un gran lugar de memoria “virtual”,
la mayor parte de la cual en un momento dado almacena en disco en una
zona especial llamada 'swap area' / 'zona de intercambio'. Fuera del
alcance de los programas de usuario, el sistema operativo se
encuentra moviendo bloques de datos (llamados “paginas”) entre la
memoria y el disco para mantener esta ilusi&oacute;n. EL resultado
final es que su memoria virtual es mucho mas grande pero no mas lenta
que la memoria real.</P>
<P STYLE="margin-bottom: 0cm">Que tan lenta sea la memoria virtual
depende f&iacute;sicamente de que tanto los algoritmos de swapping
encuentren la forma para que los programas usen la memoria virtual.
Afortunadamente los datos le&iacute;dos y escritos por la memoria que
est&aacute;n cerca en tiempo tambi&eacute;n tienden a estar cerca en
el espacio de memoria. Esta tendencia es llamada 'Localidad' / '
Locality' o mas familiarmente 'localizaci&oacute;n de referencia' ( y
esto es algo bueno). Si las referencias de memoria saltaran alrededor
de la memoria virtual de manera aleatoria, generalmente se tendr&iacute;a
que leer y escribir del/en disco para cada nueva referencia, y la
memoria virtual ser&iacute;a tan lenta como lo es el disco. Pero
porque los programas manifiestan realmente una fuerte localidad, el
sistema operativo puede hacerlo (leer/escribir) con relativos pocos
swaps/intercambios por referencia. 
</P>
<P STYLE="margin-bottom: 0cm">Por experiencia ha sido encontrado que
el mas efectivo m&eacute;todo para un amplio tipo de patrones de uso
de memoria es muy simple: es llamado LRU o el algoritmo del “ultimo
recientemente usado”. El sistema de memoria virtual toma los
bloques del disco dentro de su conjunto de trabajo en la medida que
lo necesite. Cuando &eacute;l corre fuera de la memoria f&iacute;sica
al espacio de trabajo, &eacute;l descarga el bloque 'mas
recientemente usado'. Todos los Unix y la mayor&iacute;a de los otros
sistemas operativos con memoria virtual usan peque&ntilde;as
variaciones del LRU.</P>
<P STYLE="margin-bottom: 0cm">La memoria virtual es el primer vinculo
en el puente entre las velocidades del disco y el procesador. Esta
explicitamente administrada por el sistema operativo. Pero aun hay un
gran espacio entre la velocidad de la memoria principal y la
velocidad en la cual el procesador puede acceder a su memoria de
registro. Las memorias cache internas y externas apuntan a esto
usando una t&eacute;cnica similar a la que hemos descrito sobre la
memoria virtual.</P>
<P STYLE="margin-bottom: 0cm">As&iacute; como la memoria principal se
comporta como un conjunto de ventanas y valijas en el &aacute;rea de
intercambio/swap del disco, el cache externo act&uacute;a como una
ventana sobre la memoria principal. El cache externo es r&aacute;pido
(250M de velocidad de acceso por segundo, en vez de 100M) y peque&ntilde;o,
El hardware (espec&iacute;ficamente el controlador de la memoria de
su computador) hace el LRU en el cache externo sobre los bloques de
datos tra&iacute;dos desde la memoria principal. Por razones
hist&oacute;ricas la unidad de almacenamiento swapping es llamada
'una linea' en vez de 'una pagina'.</P>
<P STYLE="margin-bottom: 0cm">Pero aun no lo hemos logrado. EL cache
interno da el ultimo paso de efectividad en velocidad al almacenar
porciones de la cache externa. Esto aun es mas r&aacute;pido y
peque&ntilde;o. EN efecto esto se sucede en el chip del procesador.</P>
<P STYLE="margin-bottom: 0cm">Si realmente queremos hacer que
nuestros programas sean realmente r&aacute;pidos, nos sera muy &uacute;til
conocer estos detalles. Sus programas logran rapidez cuando tienen
una fuerte localidad, por que esto hace que el caching trabaje mejor.
La mas f&aacute;cil manera de hacer que los programas sean r&aacute;pidos
es, por lo tanto, hacerlos mas peque&ntilde;os. Si un programa no
funciono mas despacio al recibir grandes cantidades de I/O del disco
o esperar eventos de red, &eacute;l usualmente correr&aacute; a la
velocidad del cache mas peque&ntilde;o en el que &eacute;l pueda
ajustarse.</P>
<P STYLE="margin-bottom: 0cm">Si usted no puede hacer que la
totalidad de su programa sea peque&ntilde;o, enfoque los esfuerzos en
ajustar la localidad de las porciones con problemas de velocidad.
Detalles sobre las t&eacute;cnicas para hacer esto van mas all&aacute;
del alcance de este tutorial: En el momento que usted las necesite,
usted habr&aacute; profundizado lo suficiente con alg&uacute;n
compilador para entender por si mismo muchas de las t&eacute;cnicas. 
</P>
<H2 CLASS="western">8.3. La unidad de administraci&oacute;n de
memoria<a name="83" id="83"></a></H2>
<P STYLE="margin-bottom: 0cm">Aun cuando usted tenga suficiente
memoria principal como para evitar el swapping, la parte del sistema
operativo llamada 'administrador de memoria'/'memory manager' tiene
aun importantes cosas que hacer. El tiene que asegurarse que los
programas puedan solamente alterar sus propios segmentos de datos,
esto es prevenir que err&oacute;neos o maliciosos c&oacute;digos
dentro de un programa da&ntilde;en los datos de otro. Para lograr
esto, &eacute;l mantiene una tabla de datos y de segmentos de c&oacute;digo.
La tabla es actualizada siempre que un proceso cualquiera realice una
petici&oacute;n de mas memoria o libere memoria (usualmente cuando el
programa termina). 
</P>
<P STYLE="margin-bottom: 0cm">Esta tabla es usada para pasar ordenes
a una especializada parte esencial del hardware llamada MMU o 'unidad
de administraci&oacute;n de memoria'. Los chips de procesadores
modernos tienen MMUs internamente construidos. La MMU tiene la
especial habilidad de colocar barreras alrededor de las &aacute;reas
de la memoria, de tal forma que una referencia fuera de limite ser&aacute;
rechazada y causara una situaci&oacute;n de interrupci&oacute;n
especial. 
</P>
<P STYLE="margin-bottom: 0cm">Si usted siempre ve un mensaje de Unix
que dice “Segmentation fault”/”falla de segmentaci&oacute;n”,
“core dumped”/”memoria vaciada”, o algo similar, esto es lo
que exactamente esta sucediendo: Un programa en ejecuci&oacute;n ha
hecho una solicitud para acceder a la memoria fuera de su segmento
logrando as&iacute; una interrupci&oacute;n fatal. Esto indica un
error en el c&oacute;digo del programa: el 'vaciado de memoria' deja
tras de si su informaci&oacute;n de diagnostico para ayudar al
programador a detectar el error.</P>
<P STYLE="margin-bottom: 0cm">aqu&iacute; hay otro aspecto para
proteger procesos de los otros adem&aacute;s de limitar sus accesos
de memoria. Usted tambi&eacute;n necesita ser capaz de controlar sus
accesos a archivos para que un malicioso o problem&aacute;tico
programa no corrompa piezas criticas del sistema. Esta es la raz&oacute;n
del por que Unix tiene <A HREF="#105">permisos
de archivos</A>,tema que discutiremos mas adelante.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">9. Que hace que mi computador guarde cosas en
memoria?<a name="90" id="90"></a></H1>
<P STYLE="margin-bottom: 0cm">Usted probablemente sabe que cualquier
cosa en un computador es almacenada como una cadena de bits (d&iacute;gitos
binarios: usted puede pensar en ellos como un gran n&uacute;mero de
peque&ntilde;os cambios de encendido y apagado). aqu&iacute; vamos a
explicar como estos bits son usados para representar las letras y
n&uacute;meros que su computador mastica. 
</P>
<P STYLE="margin-bottom: 0cm">Antes de comenzar con esto, se
necesario entender el “tama&ntilde;o de palabra”/”word size”
de su computador. El tama&ntilde;o de palabra es tama&ntilde;o
preferido de su computador para manipular unidades de informaci&oacute;n:
T&eacute;cnicamente es el ancho del registro de su procesador, &aacute;rea
usada por el procesador para hacer c&aacute;lculos l&oacute;gicos y
matem&aacute;ticos. Cuando la gente escribe sobre computadores que
poseen tama&ntilde;os en bits (llam&aacute;ndolos computadores de
“32-bit” o “64-bit”), esto es lo que significa. 
</P>
<P STYLE="margin-bottom: 0cm">La mayor&iacute;a de computadores
(incluyendo computadores 386, 486 y Pentium) tienen un ancho de
palabra. Los anteriores modelos de maquinas 286 ten&iacute;an un
tama&ntilde;o de palabra de 16: Las viejas mainframes a menudo usaban
palabras de 36-bit. Los AMD opteron, Intel Itanium y los Alpha desde
que estaban en DEC y ahora tiene Compaq tienen 64-bit de palabra.</P>
<P STYLE="margin-bottom: 0cm">El computador ve su memoria como una
secuencia de palabras numerada desde cero hasta alg&uacute;n alto
valor dependiendo del tama&ntilde;o de su memoria. Ese valor esta
limitado por el tama&ntilde;o de palabra. Esa es la raz&oacute;n de
porque los programas en viejas maquinas como las 286 ten&iacute;an
que funcionar mediante dif&iacute;ciles piruetas para dirigir grandes
cantidades de memoria. 
</P>
<H2 CLASS="western">9.1. N&uacute;meros<a name="91" id="91"></a></H2>
<P STYLE="margin-bottom: 0cm">Los n&uacute;meros enteros son
representados como cualquier otra palabra o pares de palabras,
dependiendo de el tama&ntilde;o de palabra de su procesador. Una
maquina con 32-bit de palabra es la mas com&uacute;n representaci&oacute;n
de entero.</P>
<P STYLE="margin-bottom: 0cm">La aritm&eacute;tica del entero es
cercana pero no es realmente matem&aacute;tica base 2. Los bit de
bajo orden son 1, le sigue el 2, el 4 y as&iacute; sucesivamente como
un puro binario. Pero los n&uacute;meros con signo son representados
en la notaci&oacute;n de “<A HREF="http://es.wikipedia.org/wiki/Complemento_a_dos">complemento
a dos</A>”. Los bits de mas alto orden son un bit con signo, lo
cual hace que la cantidad sea negativa y cada numero negativo puede
obtener su correspondiente positivo valor al invertir todos los bits
y sumando uno. Es por esto que los enteros en una maquina de 32-bit
tienen el rango de -231 to 231 – 1. Ese 32 avo bit esta siendo
usado para el signo: 0 significa un n&uacute;mero positivo y 1
significa un numero negativo.</P>
<P STYLE="margin-bottom: 0cm">Algunos lenguajes de computaci&oacute;n
permiten usar la aritm&eacute;tica sin singo, lo que significa base 2
con cero y n&uacute;meros positivos solamente.</P>
<P STYLE="margin-bottom: 0cm">La mayor&iacute;a de los procesadores y
algunos lenguajes pueden hacer operaciones con 'n&uacute;meros de
punto flotante'/'Flotating-point number' (esta capacidad esta
preestablecida dentro de los chips de procesadores mas recientes).
Los n&uacute;meros de punto flotante le dan a usted m&aacute;s
amplios rangos de valores que los enteros y permiten ser expresados
en fracciones. La forma en la cual esto es realizado varia y ser&iacute;a
muy complicada de discutir ahora en detalle, pero en ideas generales
se refiere a la 'notaci&oacute;n cient&iacute;fica', donde uno podr&iacute;a
escribir 1.234 * 1023; la codificaci&oacute;n de el numero es
dividida en una mantisa (<A HREF="http://www.wordreference.com/definicion/mantisa">parte
decimal de la fracci&oacute;n</A>. n del t.) y la parte del exponente
(23) para la potencia decimal (lo que significa que el n&uacute;mero
multiplicado resultante podr&iacute;a tener 20 ceros. 23 menos los
tres lugares decimales.</P>
<H2 CLASS="western">9.2. Caracteres<a name="92" id="92"></a></H2>
<P STYLE="margin-bottom: 0cm">Los caracteres son normalmente
representados como cadenas de siete bits cada car&aacute;cter en una
codificaci&oacute;n llamada ASCII (American Standard Code for
Information Interchange / Estandard Americano de C&oacute;digo para
el Intercambio de Informaci&oacute;n): en las maquinas modernas, cada
uno de los 128 caracteres ASCII son los &uacute;ltimos (los mas
bajos) siete bits de un octeto o byte de 8 bits: los octetos son
empaquetados dentro de las palabras de memoria, as&iacute; que (por
ejemplo) una cadena de seis caracteres solo puede tomar dos palabras
de memoria. Para ver un listado con los c&oacute;digos ASCII escriba
'man ascii' en su ventana de Unix.</P>
<P STYLE="margin-bottom: 0cm">El anterior p&aacute;rrafo estuvo
equivocado en dos formas. La menor de ellas es que el termino
'octeto' es formalmente correcto pero raramente es verdaderamente
usado: la mayor&iacute;a de las personas se refieren a un octeto como
un byte y espera que tengan 8 bits de longitud. Estrictamente
hablando, el termino 'byte' es m&aacute;s general: es usado para, por
ejemplo maquinas de 36-bits como 9-bit de bytes (aunque esto
probablemente nunca suceder&aacute; de nuevo)</P>
<P STYLE="margin-bottom: 0cm">La mayor de ellas es que no esta
permitido que todas las palabras usen ASCII. En efecto, muchas de las
palabras no pueden ser ASCII. Esto puede no ser importante par el
Ingles Americano, pero los acentos y tambi&eacute;n otros caracteres
especiales son necesarios para los usuarios que usan otros lenguajes.
Inclusive el Ingles Brit&aacute;nico tiene problemas con la ausencia
del s&iacute;mbolo usado para el s&iacute;mbolo de la moneda Libra.</P>
<P STYLE="margin-bottom: 0cm">han existido varios intentos de
corregir este problema. Todo uso de bits de mayor tama&ntilde;o que
no esta en ASCII, haci&eacute;ndolo en la mitad inferior del conjunto
de 256 caracteres. El mayor uso de esta t&eacute;cnica es llamado
'conjunto de caracteres Latin-1 (mas familiarmente llamado ISO
8859-1). Este es el conjunto de caracteres por defecto para Linux,
HTML y X. Microsoft Windows usa una versi&oacute;n cambiada de
Latin-1 adicion&aacute;ndole caracteres como las dobles comillas
derecha e izquierda en lugares donde el propio Latin-1 ha dejado sin
asignar por hist&oacute;ricas razones (para profundizar sobre los
problemas que esto causa visite la pagina <A HREF="http://www.fourmilab.ch/webtools/demoroniser/">demoroniser</A>
)</P>
<P STYLE="margin-bottom: 0cm">Los soportes para lenguajes de Europa
Occidental, incluyendo el Ingles, franc&eacute;s, Alem&aacute;n,
Espa&ntilde;ol, Italiano, Alem&aacute;n, Noruego, Suizo, y el Danes.
Sin embargo esto no es suficiente, y como resultado ahora hay series
del latin-2 por medio de -9 conjuntos de caracteres para apoyar
caracteres del griego, &Aacute;rabe, Hebreo, Esperanto y
serbo-croacia. Para mayores detalles visite la pagina <A HREF="http://www.utia.cas.cz/user_data/vs/documents/ISO-8859-X-charsets.html">Sopa
del alfabeto ISO</A> . 
</P>
<P STYLE="margin-bottom: 0cm">La &uacute;ltima soluci&oacute;n es un
gran estandard llamado Unicode (y su gemelo id&eacute;ntico ISO/IEC
10646-1:1993). Unicode es id&eacute;ntico al Latin-1 en los 256
casilla mas bajos. Sobre estos hay un espacio de 16 bits que incluye
el Griego, Cirilico, Armenio, Hebreo, Arabe, Devanagari, Bengali,
Gurmukhi, Gujarati, Oriya, Tamil, Telugu, Kannada, Malayalam, Thai,
Lao, Georgian, Tibetan, Kana japones, el completo conjunto de
caracteres del Hangul Coreano y el unificado conjunto de caracteres
para los ideogramas Chinos/Japoneses/Koreanos (CJK). Para mayores
detalles visite la pagina de <A HREF="http://www.unicode.org/">Unicode.</A>
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">10. &iquest;Que hace mi computador cuando
almacena cosas en el disco?<a name="100" id="100"></a></H1>
<P STYLE="margin-bottom: 0cm">Cuando usted mira un disco duro bajo
Unix, usted observa un &aacute;rbol de directorios y archivos con
nombre. Normalmente usted no necesita profundizar en su estructura,
pero &eacute;l se ha convertido en algo muy &uacute;til para saber
que sucedi&oacute; en detalle si usted tiene un disco da&ntilde;ado y
necesita recuperar los archivos. Desafortunadamente, no es una buena
forma describir la organizaci&oacute;n del disco desde el nivel
inferior del mismo, as&iacute; que lo describiremos desde el mismo
hardware hacia arriba. 
</P>
<H2 CLASS="western">10.1. Nivel inferior del disco y el sistema de
archivos<a name="101" id="101"></a></H2>
<P STYLE="margin-bottom: 0cm">El &aacute;rea de superficie de su
disco, donde &eacute;l almacena la informaci&oacute;n, esta dividida
en algo similar a un tablero de dardos – dentro de circulares
pistas las cuales como las partes de un pastel. Debido a que las
pistas cercanas a la parte exterior tienen mas &aacute;rea que
aquellas cercanas al centro del disco, las pistas del exterior est&aacute;n
divididas en mas sectores que las pistas del interior. Cada sector (o
bloque de disco) tiene el mismo tama&ntilde;o, el cual bajo los
modernos Unix es generalmente 1 KB binario (1024 palabras de 8 bits).
Cada bloque de disco tiene su &uacute;nica direcci&oacute;n o 'disk
block number'/'numero de bloque del disco'.</P>
<P STYLE="margin-bottom: 0cm">Unix divide el disco dentro de
'particiones de disco'. Cada partici&oacute;n es un continuo campo de
bloques que son usados separadamente de cualquier otra partici&oacute;n,
cada uno como un sistema de archivos o espacio swap aparte. La raz&oacute;n
original para tener particiones es la de recuperar los da&ntilde;os
en un mundo de discos muy lentos y susceptibles a errores; los
limites entre estas particiones reducen la fracci&oacute;n de su
disco que probablemente lo har&iacute;a inaccesible o corrupto debido
a un mala lectura del disco. Hoy en d&iacute;a es m&aacute;s
importante que las particiones puedan ser declaradas como
'solo-lectura' (previniendo a un intruso el modificar archivos
cr&iacute;ticos del sistema o compartirlas sobre una red de varias
maneras que no discutiremos aqu&iacute;. La partici&oacute;n con el
n&uacute;mero m&aacute;s bajo es a menudo tratada de manera especial
como la partici&oacute;n de arranque'/'boot partition' donde usted
puede colocar el kernel para que sea iniciado. 
</P>
<P STYLE="margin-bottom: 0cm">Cada partici&oacute;n es implementada
como espacio swap (usado para implementar la <A HREF="#81">memoria
virtual)</A> o un sistema de archivos para almacenar archivos. Las
particiones swap corresponden a una secuencia lineal de bloques. De
otra mano, el sistema de archivos necesita una forma de
mapear(relacionar) los nombres de los archivos a secuencias de
bloques del disco. Debido a que los archivos crecen o disminuyen de
tama&ntilde;o y/o cambian con el tiempo, un bloque de datos de
archivos no ser&iacute;a una secuencia lineal de estos sino mas bien
todos estar&iacute;an de manera dispersa a lo largo de su partici&oacute;n.
(desde donde quiera que el sistema operativo pueda encontrar un
bloque libre cuando lo necesite). Este efecto de dispersi&oacute;n se
llama 'fragmentaci&oacute;n'.</P>
<H2 CLASS="western">10.2. Nombres de archivos y directorios<a name="102" id="102"></a></H2>
<P STYLE="margin-bottom: 0cm">Dentro de cada sistema de archivos, el
proceso de mapeo de nombres a bloques es manipulado a trav&eacute;s
de una estructura llamada 'i-node'. Hay un conjunto de ellos cerca de
la parte inferior (los n&uacute;meros m&aacute;s bajos de bloque) de
cada sistema de archivos (los m&aacute;s bajos de ellos son usados
para proteger y etiquetar prop&oacute;sitos que no describiremos
aqu&iacute;). Cada I-node describe un solo archivo. Los bloques de
datos de archivos (incluyendo directorios) se encuentran sobre los
i-nodes (los n&uacute;meros m&aacute;s altos del bloque)</P>
<P STYLE="margin-bottom: 0cm">Cada I-node contiene una lista de
n&uacute;meros de bloque del disco en el archivo que &eacute;l
describe (Actualmente esto no es del todo cierto, solo es correcto
para archivos peque&ntilde;os, pero el resto de los detalles no es
importante conocerlos aqu&iacute;). Note que cada i-node no contiene
el nombre del archivo.</P>
<P STYLE="margin-bottom: 0cm">Los nombres de los archivos se
encuentran en la 'estructura de directorios'. Una 'estructura de
directorios' solo mapea los nombres hacia los n&uacute;meros i-node.
Esto sucede porque, en Unix, un archivo puede tener m&uacute;ltiples
nombres y todos verdaderos (a esto se le llama Links Duros): Estos
son solo m&uacute;ltiples entradas de directorios que apuntan al
mismo i-node. 
</P>
<H2 CLASS="western">10.3. Puntos de montaje<a name="103" id="103"></a></H2>
<P STYLE="margin-bottom: 0cm">En la m&aacute;s simple situaci&oacute;n,
su entrada en el sistema de archivos de Unix se encuentra en una sola
partici&oacute;n. Esto es inusual aun cuando usted vea esto en
algunos peque&ntilde;os sistemas personales Unix. Es m&aacute;s
t&iacute;pico que est&eacute;n regados a lo largo de varias
particiones, posiblemente en diferentes discos f&iacute;sicos. As&iacute;
que, por ejemplo, su sistema puede tener una peque&ntilde;a partici&oacute;n
donde se encuentra el kernel, una partici&oacute;n ligeramente mayor
donde se encuentran las utilidades del sistema operativo, y una
partici&oacute;n mucho m&aacute;s grande donde se encuentran ubicados
los archivos del usuario.</P>
<P STYLE="margin-bottom: 0cm">La &uacute;nica partici&oacute;n a la
cual se tiene acceso inmediatamente despu&eacute;s de arrancar el
sistema se llama la 'partici&oacute;n raiz'/'root partition', la cual
es (la mayor&iacute;a de las veces)la &uacute;nica desde la cual
usted puede arrancar. En ella se encuentra le directorio ra&iacute;z
del sistema de archivos, el nodo superior bajo cual cualquier otra
cosa se encuentra.</P>
<P STYLE="margin-bottom: 0cm">Las otras particiones en el sistema
tienen que ser adjuntadas a la partici&oacute;n root para que la
totalidad del sistema de m&uacute;ltiples particiones pueda ser
accesible. &Eacute;l montar&aacute; cada una de las particiones sobre
un directorio en la partici&oacute;n root.</P>
<P STYLE="margin-bottom: 0cm">Por ejemplo, si usted tiene un
directorio Unix llamado /usr, es probable que &eacute;l sea un punto
de montaje que apunta a una partici&oacute;n que contiene muchos
programas que han sido instalados con el Unix pero que no son
requeridos durante el proceso de arranque.</P>
<H2 CLASS="western">10.4. Como un archivo logra ser visto<a name="104" id="104"></a></H2>
<P STYLE="margin-bottom: 0cm">Ahora podemos dar una mirada al sistema
de archivos desde arriba. Cuando usted abre un archivo (por ejemplo:
/home/esr/WWW/ldp/fundamentals.xml) esto es lo que sucede. 
</P>
<P STYLE="margin-bottom: 0cm">El kernel arranca en la ra&iacute;z el
sistema de archivos de Unix (en la partici&oacute;n ra&iacute;z). &Eacute;l
busca un directorio llamado 'home'. Usualmente 'home' es un punto de
montaje para la partici&oacute;n de usuario que esta ubicada en
cualquier otro lugar, as&iacute; que &eacute;l (el kernel) va hacia
ese lugar. En el nivel superior de la estructura del directorio de
dicha partici&oacute;n de usuario el kernel busca una entada llamada
'esr' y extrae un n&uacute;mero i-node. El kernel entonces se dirige
a dicho i-node, advirtiendo que dicho i-node esta asociado a un
bloque de datos de archivos correspondiente a una estructura de
archivos. Aqu&iacute; busca 'WWW', extrae el n&uacute;mero i-node y
se dirige al correspondiente subdirectorio, buscando ahora 'lpd'.
Aqu&iacute; hay otro i-node de directorio, abri&eacute;ndolo &eacute;l
encuentra el numero i-node para 'fundamentals-xml'. Ese i-node no es
un directorio, en lugar de ello dicho i-node contiene la lista de
bloques del disco asociados con el archivo. 
</P>
<H2 CLASS="western">10.5. Propietario, permisos y seguridad de
archivo<a name="105" id="105"></a></H2>
<P STYLE="margin-bottom: 0cm">para mantener a los programas alejados
de accidentes o malas situaciones al tomar datos que no debe usar,
Unix tiene caracter&iacute;sticas de permisos. Estas caracter&iacute;sticas
fueron originalmente dise&ntilde;adas para soportar el timesharing
(compartici&oacute;n del tiempo) al proteger en la misma maquina a
m&uacute;ltiples usuarios de entre si. en la &eacute;poca en la que
Unix funcionaba principalmente en costosos minicomputadores
compartidos. 
</P>
<P STYLE="margin-bottom: 0cm">Para entender el concepto de archivos
de permisos es necesario recordar la descripci&oacute;n de usuarios y
grupos en la secci&oacute;n <A HREF="#40">&iquest;Que
pasa cuando usted se registra en el sistema?.</A> Cada archivo tiene
un usuario propietario y un grupo propietario. Inicialmente estos
permisos son los del creador del archivo: ellos pueden ser cambiados
con los programas chown(1) y chgrp(1).</P>
<P STYLE="margin-bottom: 0cm">Los permisos b&aacute;sicos que pueden
ser asociados con un archivo son 'lectura'/'read' (permiso para leer
sus datos), 'escribir/'write' (permisos para modificar lo) y
'ejecutar'/'execute' (permisos para correr como un programa). Cada
archivo tiene tres conjuntos de permisos: uno para su usuario
propietario, uno para su grupo propietario, y uno para los dem&aacute;s.
Los 'privilegios' que usted logra cuando se registra en el sistema
son solo la capacidad de lectura, escritura y ejecuci&oacute;n de
aquellos archivos para los cuales los bits de permisos est&aacute;n
asignados a su 'identificador de usuario'/'user ID' o a uno de los
grupos a los que pertenece, o archivos que han sido adecuados como
accesibles para todo el mundo. 
</P>
<P STYLE="margin-bottom: 0cm">Para observar como estos permisos
interactuan y como Unix los despliega vamos a mirar una lista de
archivos en un hipot&eacute;tico sistema Unix.</P>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P STYLE="margin-bottom: 0cm">snark:~$ ls -l notes</P>
			<P>-rw-r--r-- 1 esr users 2993 Jun 17 11:00 notes</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0cm">Este es un archivo ordinario de datos.
La lista nos indica que &eacute;l pertenece al usuario 'esr' y fue
creado dentro de su grupo propietario 'users'. Probablemente la
maquina en la que estamos ubico por defecto en ese grupo a cada
usuario ordinario: otros grupos de usuario que com&uacute;nmente
usted podr&aacute; ver son 'staff', 'admin', 'wheel' (por obvias
razones los grupos no son muy importantes en computadores personales
o estaciones de trabajo unipersonales). Su sistema Unix puede usar un
grupo por defecto distinto. Quiz&aacute;s alguno nombrado despu&eacute;s
de su identificador de Usuario.</P>
<P STYLE="margin-bottom: 0cm">La cadena ‘-rw-r—r--’ representa
los bits de permisos para el archivo. El primer bit es la posici&oacute;n
para el bit del directorio: &eacute;l puede mostrar 'd' si el archivo
es un directorio, o mostrar 'l' si el archivo es un link simb&oacute;lico.
Los tres siguientes bit son los permisos del usuario, los tres
contiguos son los permisos de grupo, y los tres &uacute;ltimos son
los permisos para los dem&aacute;s (a menudo llamados 'permisos para
todo el mundo'). En este archivo el usuario propietario 'esr' puede
leer o escribir el archivo, otras personas en el grupo 'users' pueden
leer el archivo y cualquier otra persona en el mundo puede leerlo.
Estos son los t&iacute;picos conjuntos de permisos para un archivo
ordinario de datos.</P>
<P STYLE="margin-bottom: 0cm">Ahora vamos a mirar un archivo con unos
permisos muy diferentes. Este archivo es el GCC (el compilador GNU
del lenguaje de programaci&oacute;n C) 
</P>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P STYLE="margin-bottom: 0cm">snark:~$ ls -l /usr/bin/gcc</P>
			<P>-rwxr-xr-x 3 root bin 64796 Mar 21 16:41 /usr/bin/gcc</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0cm">Este archivo pertenece al usuario
llamado 'root' y a un grupo llamado 'bin': este archivo puede ser
escrito (modificado) solo por el usuario 'root',pero le&iacute;do o
ejecutado por cualquier otro. Esta es una t&iacute;pica titularidad y
configuraci&oacute;n de permisos para un comando pre-instalado en el
sistema. El grupo 'bin' existe en algunos Unix para agrupar juntos a
los comandos del sistema (el nombre es una reliquia hist&oacute;rica,
es la abreviatura para 'binario'). En vez de el grupo 'usr' el
sistema Unix podr&iacute;a usar el grupo 'root' (no es exactamente lo
mismo que el usuario 'root'). 
</P>
<P STYLE="margin-bottom: 0cm">El usuario 'root' es el nombre
convencional para el usuario con el numero de identificaci&oacute;n
0, que es una especial y privilegiada cuenta que puede sobrescribir
todos los privilegios. El acceso a la ra&iacute;z es &uacute;til pero
peligrosa: un error al teclear mientras se esta como 'root' adentro
del sistema puede alterar archivos cr&iacute;ticos del sistema que un
usuario ordinario no podr&iacute;a tocar usando el mismo comando. 
</P>
<P STYLE="margin-bottom: 0cm">Debido a que la cuenta root es muy
poderosa, el acceso a ella debe ser protegido cuidadosamente. La
clave del usuario 'root' es la pieza m&aacute;s cr&iacute;tica de
seguridad en su sistema y es lo que muchos crackers e intrusos
siempre desean conseguir.</P>
<P STYLE="margin-bottom: 0cm">Sobre claves: No la deje escrita y no
escoja claves que f&aacute;cilmente puedan ser adivinadas, como el
primer nombre de su novio/a esposo/a. Esta es una mala practica muy
com&uacute;n que ayuda a los crackers a no parar. En general no
escoja ninguna palabra del diccionario: hay programas llamados
'diccionarios de crackers' que funcionan buscando claves probables a
trav&eacute;s de listas de comunes elecciones. Una buena t&eacute;cnica
e escoger una combinaci&oacute;n consistente en una palabra, un
d&iacute;gito, y otra palabra, como por ejemplo 'shark6cider' o
'jump3joy': esto har&aacute; que el tiempo necesario de b&uacute;squeda
para un diccionario de b&uacute;squeda sea muy largo. No use estos
ejemplos, se puede esperar que los crackers despu&eacute;s de leer
este documento incorporen estos ejemplos en sus diccionarios. 
</P>
<P STYLE="margin-bottom: 0cm">Ahora veamos un tercer caso:</P>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P STYLE="margin-bottom: 0cm">snark:~$ ls -ld ~</P>
			<P STYLE="margin-bottom: 0cm">drwxr-xr-x 89 esr users 9216 Jun 27
			11:29 /home2/esr</P>
			<P>snark:~$ 
			</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0cm">Este archivo es un directorio (note el
'd' en el primer espacio de permisos). Observamos que el archivo
puede ser escrito por esr pero le&iacute;do y ejecutado por cualquier
otro.</P>
<P STYLE="margin-bottom: 0cm">El permiso de lectura sobre un
directorio le da la habilidad de listar el directorio – esto es
mirar los nombres de los archivos y directorios que &eacute;l
contiene. El permiso de escritura da la habilidad de crear y borrar
archivos en el directorio. Estas reglas tienen sentido si usted
recuerda que el directorio incluye una lista de nombres de los
archivos y subdirectorios que contiene.</P>
<P STYLE="margin-bottom: 0cm">Los permisos de ejecuci&oacute;n en un
directorio significa que es posible entrar en el directorio para
abrir los archivos y los directorios contenidos en &eacute;l. En
efecto, &eacute;l le da permisos para acceder a los i-nodes en el
directorio. Un directorio sin ning&uacute;n permiso de ejecuci&oacute;n
puede ser in&uacute;til.</P>
<P STYLE="margin-bottom: 0cm">Ocasionalmente usted podr&iacute;a ver
un directorio que es ejecutable para los usuarios 'world' pero no es
legible para estos mismos usuarios: Esto significa que un usuario
aleatorio pude acceder a los archivos y directorios inferiores pero
solo conociendo sus nombres exactos (el directorio no puede ser
listado).</P>
<P STYLE="margin-bottom: 0cm">Es importante recordar que leer,
escribir o ejecutar permisos en un directorio es independiente de los
permisos en los archivos y directorios que contiene. En particular,
la posibilidad de escritura en un directorio no da autom&aacute;ticamente
acceso a los archivos existentes. 
</P>
<P STYLE="margin-bottom: 0cm">Finalmente vamos a ver los permisos del
programa login.</P>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P STYLE="margin-bottom: 0cm">snark:~$ ls -l /bin/login</P>
			<P>-rwsr-xr-x 1 root bin 20164 Apr 17 12:57 /bin/login</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0cm">Este programa tiene los permisos que
podr&iacute;amos esperar para un comando de sistema – excepto por
la 's' donde el permiso de ejecuci&oacute;n para el propietario
deber&iacute;a estar. Esta es la manifestaci&oacute;n visible de un
permiso especial llamado el 'set-user-id' o 'setuid bit' 
</P>
<P STYLE="margin-bottom: 0cm">El bit setuid es normalmente adjuntado
a programas que necesitan dar privilegios de root a usuarios
ordinarios, pero de una forma controlada. Cuando este permiso es
definido en un programa ejecutable usted logra los privilegios de el
propietario de el archivo del programa mientras el programa corra por
parte suya, sean o no de su propiedad.</P>
<P STYLE="margin-bottom: 0cm">Como la cuenta root misma, los
programas setuid son &uacute;tiles pero peligrosos. Cualquiera quien
pueda subvertir o modificar un programa setuid propiedad del root
puede usarlo para generar una ventana de sesi&oacute;n con
privilegios de usuario. Por esta raz&oacute;n abrir un archivo en la
mayor&iacute;a de los Unix para escribir hace que dicho archivo
desactive su bit setuid. Muchos ataques a la seguridad de Unix tratan
de explotar bugs en los programas setuid buscando aprovecharse de
ellos. Por eso administradores de seguridad de sistemas est&aacute;n
consientes de estos programas tomando cuidadosas medidas y reacios a
instalar nuevos.</P>
<P STYLE="margin-bottom: 0cm">Debemos resaltar un par de importantes
detalles de lo que hemos visto ahora: A saber, como el grupo
propietario y sus permisos son asignados cuando un archivo o
directorio es creado por primera vez. El tema de grupos es de cuidado
porque los usuarios pueden ser miembros de m&uacute;ltiples grupos,
pero uno de ellos (especificado en la entrada del usuario en
/etc/passwd) es el grupo por defecto para el usuario y normalmente
ser&aacute; el propietario de los archivos creados por el usuario.</P>
<P STYLE="margin-bottom: 0cm">La historia detr&aacute;s de los bits
de permisos con los que inicia un archivo es un poco mas complicada.
Un programa que crea un archivo normalmente especificar&aacute; los
permisos con los que dicho archivo comenzar&aacute;. Pero estos
permisos ser&aacute;n modificados por una variable de entorno del
usuario llamada el 'umask'. El umask especifica cuales bit de
permisos ser&aacute;n desactivados cuando es creado un archivo: El
valor m&aacute;s com&uacute;n, y que esta establecido por defecto en
la mayor&iacute;a de sistemas es -------w- or 002,el cual desactiva
el bit de la escritura para todo el mundo. Para mayores detalles mire
la documentaci&oacute;n del comando umask en su ventana de sesi&oacute;n.
</P>
<P STYLE="margin-bottom: 0cm">El grupo inicial para un directorio es
tambi&eacute;n un poco mas complicado. En algunos sistemas Unix un
nuevo directorio obtiene el grupo por defecto del usuario creador
(esta es una convenci&oacute;n del sistema V): en otros, &eacute;l
obtiene el grupo propietario del directorio padre en el cual ha sido
creado (esta es la convenci&oacute;n BSD). En algunos modernos Unix,
incluyendo Linux, la conducta definitiva puede ser seleccionada al
configurar el set-group-ID en el directorio (chmod g+s).</P>
<H2 CLASS="western">10.6. Como las cosas pueden andar mal<a name="106" id="106"></a></H2>
<P STYLE="margin-bottom: 0cm">Anteriormente se alud&iacute;a que los
sistemas de archivos eran fr&aacute;giles. Ahora sabemos que para
obtener un archivo usted tiene que saltar a trav&eacute;s de lo que
podr&iacute;a ser una arbitraria y larga cadena de directorios y
referencias de i-node. Ahora supongamos que su disco duro produce un
mal salto.</P>
<P STYLE="margin-bottom: 0cm">Si usted tiene suerte, solo desechar&aacute;
algunos datos de archivo. Si no tiene suerte, se podr&iacute;a
corromper una estructura de directorio o un numero i-node y dejar en
el limbo a la totalidad del &aacute;rbol de un subdirectorio, o peor
a&uacute;n, resultar en una estructura corrompida que apunta
m&uacute;ltiples rutas a un mismo bloque de disco o i-node. Tal da&ntilde;o
puede ser propagado como una normal operaci&oacute;n de archivo,
desechando datos que no estaban en el lugar donde inicio el salto
equivocado. 
</P>
<P STYLE="margin-bottom: 0cm">Afortunadamente, este tipo de
contingencias se han convertido en algo poco com&uacute;n as&iacute;
como el hardware de los discos se han vuelto m&aacute;s confiables.
Aun m&aacute;s, esto significa que Unix buscar&aacute; revisar
peri&oacute;dicamente la integridad del sistema de archivos para
asegurarse que todo funcione correctamente. Los Unix modernos
realizan r&aacute;pidamente dicha revisi&oacute;n de integridad en
cada partici&oacute;n en el momento del arranque, justo antes de
montarlas. Cada pocos re inicios suceder&aacute; la revisi&oacute;n
de integridad de manera mas detallada, tom&aacute;ndose unos pocos
minutos de duraci&oacute;n. 
</P>
<P STYLE="margin-bottom: 0cm">Si todo esto suena a que Unix es
terriblemente complejo y susceptible de fallas, entonces puede sonar
tranquilizador saber que estas revisiones en el momento del arranque
com&uacute;nmente detectan y corrigen problemas normales antes de que
ellos se conviertan en problemas realmente desastrosos. Otros
sistemas operativos no tienen estas facilidades, lo cual aligera un
poco el tiempo de arranque pero puede dejarlo a usted mas seriamente
afectado cuando intente recuperarlo a mano (inclusive asumiendo que
usted tiene una copia de las utilidades de Norton o cualquier otra
cosa que este a primera mano) 
</P>
<P STYLE="margin-bottom: 0cm">Una de las tendencias en los dise&ntilde;os
de los actuales Unix es el 'registro diario del sistema de
archivos'/'journalling file systems'. Este sistema organiza el
tr&aacute;fico para el disco garantizando que el disco se encuentre
en un consistente estado al cual pueda regresar. Esto hace que la
revisi&oacute;n detallada sea mas r&aacute;pida en el momento del
arranque.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">11. &iquest;Como trabajan los lenguajes de
programaci&oacute;n?<a name="110" id="110"></a></H1>
<P STYLE="margin-bottom: 0cm">Ya hemos discutido sobre <A HREF="#50">como
los programas son corridos.</A> En ultimas cada programa tiene que
ser ejecutado como un flujo de datos que son instrucciones en el
lenguaje maquina de su computador. Pero los seres humanos no manejan
muy bien el lenguaje de maquina: hacer esto se ha convertido en un
raro y oscuro arte aun entre hackers.</P>
<P STYLE="margin-bottom: 0cm">hoy en d&iacute;a casi todo el c&oacute;digo
de Unix esta escrito en un 'lenguaje de alto nivel'/'high-level
language' excepto una peque&ntilde;a cantidad de interfaces directas
de hardware soportadas en el kernel mismo (el termino 'alto nivel' es
un viejo termino usado para distinguir los 'lenguajes
ensamblador'/'assembler languajes' de 'bajo nivel'/''low-level, los
cuales son b&aacute;sicamente peque&ntilde;os envoltorios alrededor
del c&oacute;digo de maquina. 
</P>
<P STYLE="margin-bottom: 0cm">Existen varios diferentes tipos de
lenguajes de alto nivel. Para hablar acerca de ellos es &uacute;til
tener en mente que el 'c&oacute;digo fuente'/'source code' de un
programa (la versi&oacute;n editable creada por un ser humano) tiene
que ir a trav&eacute;s de alg&uacute;n tipo de traducci&oacute;n al
c&oacute;digo maquina que la maquina pueda realmente correr.</P>
<H2 CLASS="western">11.1. Lenguajes Compilados<a name="111" id="111"></a></H2>
<P STYLE="margin-bottom: 0cm">La mayor&iacute;a de los tipos de
lenguaje convencionales son lenguajes compilados. Los lenguajes
compilados son traducidos a archivos ejecutables de maquina (en
c&oacute;digo binario) por un programa especial llamado (l&oacute;gicamente)
el compilador. Una vez ha sido generado el binario, usted puede
hacerlo correr directamente sin tener que mirar de nuevo el c&oacute;digo
fuente (la mayor&iacute;a del software es entregado en binarios
compilados hechos desde c&oacute;digo que usted no ve). 
</P>
<P STYLE="margin-bottom: 0cm">Los lenguajes compilados tienden a dar
un excelente desempe&ntilde;o y a tener un mas completo acceso al
sistema Operativo, pero tambi&eacute;n hay dificultad en programar en
&eacute;l.</P>
<P STYLE="margin-bottom: 0cm">C, el lenguaje en el que Unix esta
escrito es de lejos es el mas importante de ellos (con su variante
C++). FORTRAN es otro lenguaje compilado que a&uacute;n es usado
entre ingenieros y cient&iacute;ficos pero con a&ntilde;os de haber
sido creado y mucho mas primitivo. En el mundo Unix estos son los
lenguajes compilados que principalmente se usan: Fuera de ellos,
COBOL es ampliamente usado para software de finanzas y negocios. 
</P>
<P STYLE="margin-bottom: 0cm">Antes eran usados muchos otros
lenguajes compilados, pero la mayor&iacute;a de ellos se han extinto
o son estrictamente usados en herramientas de investigaci&oacute;n.
Si usted es un nuevo desarrollador de Unix usando un lenguaje
compilado, estar&aacute; probablemente usando C o C++. 
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<H2 CLASS="western">11.2. Lenguajes Interpretados<a name="112" id="112"></a></H2>
<P STYLE="margin-bottom: 0cm">Un lenguaje interpretado depende de un
programa interprete que lea el c&oacute;digo fuente y lo traduzca
inmediatamente en c&oacute;mputos y llamadas del sistema. El c&oacute;digo
fuente debe ser reinterpretado (y el interprete debe esta presente)
cada vez que el c&oacute;digo es ejecutado.</P>
<P STYLE="margin-bottom: 0cm">Los lenguajes interpretados tienden a
ser mas lentos que los lenguajes compilados, y a menudo tienen
limitado acceso al hardware y a partes importantes del sistema
operativo. De otra parte estos lenguajes tienden a ser f&aacute;ciles
para programar y menos estrictos que los lenguajes compilados</P>
<P STYLE="margin-bottom: 0cm">Muchas utilidades de Unix, inlcuyendo
la shell, bc, sed y awk son de hecho peque&ntilde;os interpretes de
lenguajes. BASICs es usualmente interpretado, de igual manera Tcl.
Hist&oacute;ricamente, el m&aacute;s importante lenguaje interpretado
ha sido LISP (con mayores mejoras sobre la mayor&iacute;a de sus
sucesores). Hoy, las shells de Unix y el Lisp que se encuentra dentro
del editor Emacs son probablemente los mas importantes lenguajes
interpretados puros. 
</P>
<H2 CLASS="western">11.3. Lenguajes Pseudoc&oacute;digo<a name="113" id="113"></a></H2>
<P STYLE="margin-bottom: 0cm">Desde 1990 ha tomado creciente
importancia un tipo de lenguaje h&iacute;brido que usa la compilaci&oacute;n
y la interpretaci&oacute;n. los lenguajes P-code son como los
lenguajes compilados por que la fuente es traducida a un binario
compacto que es lo que usted realmente ejecuta, pero no es un c&oacute;digo
maquina. En lugar de ellos es un pseudoc&oacute;digo (o c&oacute;digo-p)
que usualmente es bastante mas simple pero mas poderoso que un
lenguaje real de m&aacute;quina. Cuando usted corre el programa se
interpreta el p-c&oacute;digo.</P>
<P STYLE="margin-bottom: 0cm">El pseudoc&oacute;digo puede correr
casi tan r&aacute;pido como un binario compilado (los interpretes de
seudoc&oacute;digo pueden ser simples sencillos y r&aacute;pidos).
Los lenguajes seudoc&oacute;digo pueden mantener la flexibilidad y
poder de un lenguaje interpretado. 
</P>
<P STYLE="margin-bottom: 0cm">Importantes lenguajes seudoc&oacute;digo
son Python, Perl y Java.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">12. Que hace que Internet trabaje?<a name="120" id="120"></a></H1>
<P STYLE="margin-bottom: 0cm">Para ayudar a entender como Internet
trabaja vamos a mirar las cosas que suceden cuando usted hace una
tarea normal en Internet – Llegar con el navegador hasta la p&aacute;gina
de inicio de este documento en el sitio web del Proyecto de
documentaci&oacute;n de Linux (Linux Documentation Project - LDP).
Este documento es: 
</P>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P>http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0cm">Lo que significa que el se encuentra en
el archivo HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html
accesible en la telara&ntilde;a mundial (World Wide Web – WWW) en
el host www.tldp.org</P>
<H2 CLASS="western">12.1. Nombres y Ubicaciones<a name="121" id="121"></a></H2>
<P STYLE="margin-bottom: 0cm">La primer cosa que su navegador tiene
que hacer es establecer una conexi&oacute;n con la maquina donde el
documento se encuentra (el host. n. del t.), Para hacer esto el
primero debe buscar en la red la ubicaci&oacute;n de el host
<A HREF="http://www.tldp.org/">www.tldp.org</A> ('host' se usa para
abreviar 'maquina anfitriona'/'host machine' o 'red
anfitriona'/'network host': <A HREF="http://www.tlpd.org/">www.tlpd.org</A>
es un com&uacute;n nombre de host). Su ubicaci&oacute;n corresponde
realmente a un n&uacute;mero llamado 'direcci&oacute;n IP'/'IP
adress' (explicaremos que significa IP m&aacute;s adelante).</P>
<P STYLE="margin-bottom: 0cm">Para hacer esto el navegador interroga
a un programa llamado 'Servidor de nombres'/'name server'. El
servidor de nombres puede encontrarse en su maquina, pero es mas
probable que funcione en una maquina de servicios a la cual el
navegador establece la conexi&oacute;n. Cuando usted ingresa con un
ISP (Proveedor de servicios de internet / Internet Service Provider .
ISP. n del t.), parte del procedimiento de configuraci&oacute;n la
mayor&iacute;a de las veces involucrar&aacute; indicarle al navegador
la direcci&oacute;n IP del servidor de nombres en la red. 
</P>
<P STYLE="margin-bottom: 0cm">Los servidores de nombres ubicados en
diferentes maquinas hablan entre si, intercambiando informaci&oacute;n
y manteniendo actualizada toda la informaci&oacute;n que necesitan
para resolver los nombres de host (relacionarlos con las direcciones
IP). El servidor de nombres que usted usa, en el proceso de resolver
la ubicaci&oacute;n de www.tldp.org puede consultar a tres o cuatro
diferentes sitios a trav&eacute;s de la red, pero esto usualmente
sucede muy r&aacute;pido (en menos de un segundo). Veremos en detalle
a los servidores de nombres en la pr&oacute;xima secci&oacute;n.</P>
<P STYLE="margin-bottom: 0cm">El servidor de nombres le dir&aacute; a
su navegador que la direcci&oacute;n IP del host <A HREF="http://www.tldp.org/">www.tldp.org</A>
es 152.19.254.81: conociendo esto el navegador nuestra maquina ser&aacute;
capaz de intercambiar bits directamente con www.tldp.org.</P>
<H2 CLASS="western">12.2. El Sistema de Nombres de Dominio<a name="122" id="122"></a></H2>
<P STYLE="margin-bottom: 0cm">La totalidad de los programas y bases
de datos de red que cooperan en resolver los nombres de host a
direcciones IP son llamados 'DNS' (Sistema de Nombres de Dominio).
Cuando usted ve referencias a un 'servidor DNS'/'DNS Server' esto
significa que estamos hablando de un servidor de dominios. Ahora
vamos a ver como funciona todo esto.</P>
<P STYLE="margin-bottom: 0cm">En internet los nombres de host est&aacute;n
compuestos de partes separadas por puntos. Un 'dominio'/'domain' es
una colecci&oacute;n de maquinas que comparten un sufijo como nombre
en com&uacute;n. Los Dominios pueden estar dentro de otros dominios.
Por ejemplo, la maquina <A HREF="http://www.tlpd.org/">www.tldp.org</A>
se encuentra en la maquina .tldp.org subdomino del dominio .org.</P>
<P STYLE="margin-bottom: 0cm">Cada dominio esta definido por un
servidor de nombres autorizado que conoce la direcci&oacute;n IP de
las otras maquinas en el dominio. El servidor autorizado (o primario)
de nombres puede tener backups en caso de alguna falla: si usted ve
referencias a un 'servidor de nombres secundario'/'sencondary name
server' (o 'secundario DNS'/'secondary DNS') es que se esta hablando
de uno de esos bakups. Estos servidores secundarios a menudo
refrescan su informaci&oacute;n desde sus servidores primarios cada
pocas horas, as&iacute;, un cambio hecho en el servidor primario a la
relaci&oacute;n nombre de host-IP ser&aacute; autom&aacute;ticamente
propagado.</P>
<P STYLE="margin-bottom: 0cm">Ahora, aqu&iacute; esta la parte
importante. Los servidores de nombres de un dominio no tienen que
saber la ubicaci&oacute;n de todas las maquinas en otros dominios
(incluyendo sus propios subdominios): &eacute;l solo tiene que saber
la ubicaci&oacute;n de los servidores de nombres. En nuestro ejemplo,
el servidor de nombres autorizado para administrar el dominio .org
sabe la direcci&oacute;n IP de el servidor de nombres para .tlpd.org
pero no la direcci&oacute;n de todas las dem&aacute;s maquinas en el
dominio .tlpd.org.</P>
<P STYLE="margin-bottom: 0cm">Los dominios en el sistema DNS est&aacute;n
organizados como un gran &aacute;rbol invertido. En la cima se
encuentran los 'servidores ra&iacute;z'/'root servers' (administran
los dominios .org .com. net, etc. n del t): ellos est&aacute;n
conectados a su software DNS. El servidor ra&iacute;z sabe las
direcciones IP de los servidores de dominio para los 'dominios de
nivel superior'/'top-levels domains' (tlpd.org, example.org, etc. n.
del t.). Cada servidor de dominios de nivel superior conoce donde se
encuentran los servidores de dominios directamente bajo ellos, y as&iacute;
sucesivamente. 
</P>
<P STYLE="margin-bottom: 0cm">DNS esta cuidadosamente dise&ntilde;ada
para que cada maquina pueda funcionar con independencia con la m&iacute;nima
cantidad de conocimientos que necesite sobre la forma del &aacute;rbol
y para que los cambios locales a los arboles inferiores puedan ser
hechos de manera simple al cambiar en la base de datos de un servidor
de nombres autorizado las relaciones 'nombre de host'-'direcci&oacute;n
IP'.</P>
<P STYLE="margin-bottom: 0cm">Cuando su navegador hace la consulta
sobre la direcci&oacute;n IP de <A HREF="http://www.tlpd.org/">www.tlpd.org</A>
lo que sucede realmente es: primero su servidor de nombres (quiz&aacute;s
el servidor del ISP de su cuenta de acceso a Internet. n. del t.
)pregunta al servidor ra&iacute;z para saber donde puede ubicar los
servidores de nombres para los dominios .org. Una vez conoce esto, &eacute;l
entonces pregunta al servidor de nombres del dominio .org para saber
donde la direcci&oacute;n IP de el servidor de nombres de .tldp.org.
Una vez se ha hecho esto &eacute;l pregunta al servidor de nombres
.tldp.org para saber la direcci&oacute;n del host www.tldp.org.</P>
<P STYLE="margin-bottom: 0cm">La mayor&iacute;a de las veces, su
servidor de nombres no tiene que trabajar tan duro. Los servidores de
nombres realizan mucho cache: cuando su servidor resuelve un nombre
de host, el mantiene en memoria por un momento la asociaci&oacute;n
con la direcci&oacute;n IP resultante. Esto sucede por que, cuando
usted navega un nuevo sitio web usualmente usted ve un mensaje de su
navegador que indica 'buscando'/'looking up' el host para la primera
p&aacute;gina que usted encontr&oacute;. Eventualmente el proceso de
mapeo nombre-a-direcci&oacute;n expira y su DNS tiene que solicitar
nuevamente este proceso – esto es importante para que no se
conserve la antigua (e invalida) informaci&oacute;n cuando un nombre
de host cambie de direcci&oacute;n. La direcci&oacute;n IP cacheada
de un sitio web no ser&aacute; desplegada si el host es inalcanzable.
</P>
<H2 CLASS="western">12.3. Paquetes y enrutadores<a name="123" id="123"></a></H2>
<P STYLE="margin-bottom: 0cm">Lo que el navegador desea hacer es
enviar un comando al servidor web en <A HREF="http://www.tldp.org/">www.tldp.org</A>
se parece a esto.</P>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P>GET /LDP/HOWTO/Fundamentals.html HTTP/1.0</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0cm">Esto es lo que sucede. El comando es
preparado dentro de un 'paquete'/'packet', un bloque de bits como un
telegrama que es empaquetado con tres importantes cosas: La direcci&oacute;n
origen (la direcci&oacute;n de su maquina), la direcci&oacute;n
destino (152.19.254.81), y un n&uacute;mero de servicio o n&uacute;mero
de puerto (80 en este caso) que indica que es una solicitud hecha
para la telara&ntilde;a mundial World Wide Web. 
</P>
<P STYLE="margin-bottom: 0cm">Su maquina entonces env&iacute;a el
paquete por medio del cable (la conexi&oacute;n de su ISP o red
local) hasta que llega a una maquina especializada llamada
'enrutador'/'router'. El enrutador tiene un mapa de Internet en su
memoria – no siempre completo, pero describe por completo el
vecindario de su red y sabe como conseguir los enrutadores de otros
vecindarios en la Internet.</P>
<P STYLE="margin-bottom: 0cm">Su paquete puede pasar a trav&eacute;s
de varios enrutadores en la direcci&oacute;n de su destino. Los
enrutadores son inteligentes. Ellos observan cuanto tardan otros
enrutadores en avisar que han recibido un paquete. Ellos tambi&eacute;n
usan esa informaci&oacute;n para dirigir el tr&aacute;fico sobre
conexiones r&aacute;pidas. Los enrutadores usan estas conexiones para
advertir cuando otro enrutador(o un cable) ha ca&iacute;do en la red
y compensar dicha ca&iacute;da encontrando otro enrutador.</P>
<P STYLE="margin-bottom: 0cm">Hay una leyenda urbana que dice que la
Internet fue dise&ntilde;ada para sobrevivir a una guerra nuclear.
Esto no es cierto, pero el dise&ntilde;o de la Internet es
extremadamente bueno en conseguir un desempe&ntilde;o confiable sobre
hardware problem&aacute;ticos y condiciones inciertas. Esto es
principalmente debido al hecho de que su inteligencia esta
distribuida a trav&eacute;s de miles de enrutadores en lugar de estar
concentrada en unos pocos gigantes interruptores (como en la red
telef&oacute;nica). Esto significa que las fallas tienden a ser bien
localizadas y la red puede pasar al rededor de estas fallas.</P>
<P STYLE="margin-bottom: 0cm">Una vez que su paquete logra llegar a
la maquina destino, esta maquina usa el numero de servicio para
introducir el paquete al servidor web. El servidor web puede saber a
donde responder al revisar en el paquete la orden con la direcci&oacute;n
IP origen. Cuando el servidor web devuelve este documento (el que
estas leyendo. n del t.), este documento sera dividido en paquetes
que han sido numerados. El tama&ntilde;o de los paquetes variar&aacute;
seg&uacute;n el medio de transmisi&oacute;n en la red y el tipo de
servicio. 
</P>
<H2 CLASS="western">12.4. TCP e IP<a name="124" id="124"></a></H2>
<P STYLE="margin-bottom: 0cm">Para entender como sucede la
transmisi&oacute;n de m&uacute;ltiples paquetes, usted necesita saber
que la Internet actualmente usa dos protocolos (maneras de negociar e
intercambiar la informaci&oacute;n n.del t.), organizados uno sobre
otro.</P>
<P STYLE="margin-bottom: 0cm">En el nivel inferior, el IP ('Protocolo
de Internet' /'Internet Protocol'), es el responsable de etiquetar
individualmente los paquetes con las direcciones fuente y destino de
dos computadores que intercambian informaci&oacute;n sobre una red.
Por ejemplo, cuando usted accede a <A HREF="http://www.tldp.org/">http://www.tldp.org</A>
el paquete que usted envi&oacute; tiene la direcci&oacute;n IP de su
computador, como 192.168.0.101 y la direcci&oacute;n 152.19.254.81
del computador de <A HREF="http://www.tldp.org/">www.tldp.org</A>.
Estas direcciones trabajan de la misma manera como la direcci&oacute;n
de su casa trabaja cuando alguien env&iacute;a a usted una carta. La
oficina postal puede leer la direcci&oacute;n y determinar donde
usted se encuentra y la mejor ruta para hacerle llegar su carta, como
lo hace un enrutador con el trafico de Internet.</P>
<P STYLE="margin-bottom: 0cm">En el nivel superior, TCP (Protocolo de
Control de Transmisi&oacute;n'/'Transmission Control Protocol') da la
confiabilidad. Cuando dos maquinas negocian una conexi&oacute;n TCP
(la cual hacen usando el protocolo IP), el receptor sabe que debe
enviar acuses de recibo de el paquete que recibir&aacute; del
remitente. Si el remitente no ve un acuse de recibo del paquete en un
tiempo de espera determinado, &eacute;l reenv&iacute;a el paquete.
Adicionalmente, el remitente da a cada paquete TCP una secuencia de
n&uacute;meros, la cual el receptor puede usar para rearmar los
paquetes en caso de que ellos lleguen en desorden (esto f&aacute;cilmente
puede suceder si la velocidad de red var&iacute;a durante la
conexi&oacute;n).</P>
<P STYLE="margin-bottom: 0cm">Los paquetes IP tambi&eacute;n
contienen un checksum (procedimiento de comprobaci&oacute;n o suma de
comprobaci&oacute;n. n. del t.) para facilitar la detecci&oacute;n de
datos corruptos debido a problemas en la red (El checksum es
calculado de el resto del paquete para saber si el resto del paquete
o el checksum est&aacute;n corruptos; rehaciendo el calculo y
comparando el checksum recibido es muy probable reconocer un error).
As&iacute;, desde el punto de vista de cualquiera que usa TPC/IP y
los servidores de nombre, esta parece una confiable manera de enviar
flujos de bytes usando parejas de nombre-de-host/numero-de-servicio.
Las personas que escriben protocolos de red casi nunca tienen que
pensar sobre la definici&oacute;n del tama&ntilde;o del paquete, como
se rearma el paquete, la revisi&oacute;n de errores, el procedimiento
checksum y la retransmisi&oacute;n que sucede bajo su nivel. 
</P>
<H2 CLASS="western">12.5. HTTP, un protocolo de aplicaci&oacute;n<a name="125" id="125"></a></H2>
<P STYLE="margin-bottom: 0cm">Ahora vamos a regresar a nuestro
ejemplo. Los navegadores y servidores web hablan un 'protocolo de
aplicaci&oacute;n'/'application protocol' que funciona encima de
TCP/IP, us&aacute;ndolo simplemente como una forma de enviar y
recibir flujos de bytes. Este protocolo se llama HTTP ('Protocolo de
Transferencia de Hipertexto'/'Hypertext Transfer Protocol') y ya
hemos visto un comando de &eacute;l – el GET mostrado
anteriormente.</P>
<P STYLE="margin-bottom: 0cm">Cuando el comando GET interactua con es
servidor web de <A HREF="http://www.tldp.org/">www.tldp.org</A> con
el servicio n&uacute;mero 80, &eacute;l ser&aacute; despachado a un
'servidor demonio'/'server daemon' que escucha en el puerto 80. La
mayor&iacute;a de los servicios de Internet son implementados por
servidores demonio que no hacen m&aacute;s que escuchar en puertos,
esperando por la llegada de un comando de ejecuci&oacute;n.</P>
<P STYLE="margin-bottom: 0cm">Si el dise&ntilde;o de la Internet
tiene una regla por sobre todas, esta es que todas las partes deben
ser tan simples y accesibles a seres humanos como sea posible. HTTP y
sus parientes (como el Simple Mail Transfer Protocol SMTP, que es
usado para mover electr&oacute;nica mente mails entre host) tienden a
usar simples comandos de texto de impresi&oacute;n que terminan con
un a entrada de retorno de linea. 
</P>
<P STYLE="margin-bottom: 0cm">Esto es ligeramente ineficiente: en
algunas circunstancias usted puede lograr m&aacute;s velocidad al
usar un protocolo de c&oacute;digo estrictamente binario. Pero la
experiencia ha mostrado que los beneficios de tener comandos f&aacute;ciles
de describir y entender por seres humanos sobrepasa cualquier
beneficio en eficiencia que usted puede lograr con el costo de hacer
las cosas dif&iacute;ciles y opacas.</P>
<P STYLE="margin-bottom: 0cm">De esta manera lo que el servidor
demonio env&iacute;a de regreso a usted v&iacute;a TCP/IP tambi&eacute;n
es texto. El comienzo de la respuesta se parecer&aacute; a algo como
esto:</P>
<TABLE WIDTH=100% BORDER=1 BORDERCOLOR="#000000" CELLPADDING=3 CELLSPACING=0>
	<COL WIDTH=256*>
	<TR>
		<TD WIDTH=100% VALIGN=TOP>
			<P STYLE="margin-bottom: 0cm">HTTP/1.1 200 OK</P>
			<P STYLE="margin-bottom: 0cm">Date: Sat, 10 Oct 1998 18:43:35 GMT</P>
			<P STYLE="margin-bottom: 0cm">Server: Apache/1.2.6 Red Hat</P>
			<P STYLE="margin-bottom: 0cm">Last-Modified: Thu, 27 Aug 1998
			17:55:15 GMT</P>
			<P STYLE="margin-bottom: 0cm">Content-Length: 2982</P>
			<P>Content-Type: text/html</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0cm">Estas cabeceras ser&aacute; seguida por
una l&iacute;nea en blanco y el texto de la p&aacute;gina web
(despu&eacute;s de lo cual la conexi&oacute;n es terminada). Su
navegador solo desplegar&aacute; la pagina. Las cabeceras le
indicar&aacute;n al navegador como (en particular, la cabecera
Content-Type indica que el dato regresado es realmente html. 
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<a href="#inicio" style="float:left">inicio</a><br />
<H1 CLASS="western">13. Para aprender m&aacute;s<a name="130" id="130"></a></H1>
<P STYLE="margin-bottom: 0cm">Esta es una <A HREF="http://www.tldp.org/HOWTO/Reading-List-HOWTO/">lista
de lecturas de HOWTO</A> que contiene libros que usted puede leer
para aprender m&aacute;s sobre los t&oacute;picos que hemos tocado
aqu&iacute;. Quiz&aacute;s tambi&eacute;n quiera leer el documento
<A HREF="http://www.catb.org/%7Eesr/faqs/hacker-howto.html">Como
convertirse en un Hacker</A>.</P>
</BODY>
</HTML>
