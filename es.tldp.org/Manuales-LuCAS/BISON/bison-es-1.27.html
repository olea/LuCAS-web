<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from bison-es-1.27.texinfo on 23 May 1999 -->

<TITLE>Bison 1.27</TITLE>
</HEAD>
<BODY>
<H1>Bison</H1>
<H2>El Generador de Analizadores Sintácticos compatible con YACC.</H2>
<H2>12 Febrero 1999, Bison Versión 1.27</H2>
<ADDRESS>por Charles Donnelly y Richard Stallman</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="bison-es-1.27.html#SEC1">Introducción</A>
<LI><A NAME="TOC2" HREF="bison-es-1.27.html#SEC2">Conditions for Using Bison</A>
<LI><A NAME="TOC3" HREF="bison-es-1.27.html#SEC3">Condiciones para el uso de Bison</A>
<LI><A NAME="TOC4" HREF="bison-es-1.27.html#SEC4">GNU GENERAL PUBLIC LICENSE</A>
<UL>
<LI><A NAME="TOC5" HREF="bison-es-1.27.html#SEC5">Preamble</A>
<LI><A NAME="TOC6" HREF="bison-es-1.27.html#SEC6">TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</A>
<LI><A NAME="TOC7" HREF="bison-es-1.27.html#SEC7">How to Apply These Terms to Your New Programs</A>
</UL>
<LI><A NAME="TOC8" HREF="bison-es-1.27.html#SEC8">LICENCIA PÚBLICA GENERAL GNU</A>
<UL>
<LI><A NAME="TOC9" HREF="bison-es-1.27.html#SEC9">Preámbulo</A>
<LI><A NAME="TOC10" HREF="bison-es-1.27.html#SEC10">TÉRMINOS Y CONDICIONES PARA LA COPIA, DISTRIBUCIÓN Y MODIFICACIÓN</A>
<LI><A NAME="TOC11" HREF="bison-es-1.27.html#SEC11">Cómo aplicar estos términos a sus nuevos programas.</A>
</UL>
<LI><A NAME="TOC12" HREF="bison-es-1.27.html#SEC12">Los Conceptos de Bison</A>
<UL>
<LI><A NAME="TOC13" HREF="bison-es-1.27.html#SEC13">Lenguajes y Gramáticas independientes del Contexto</A>
<LI><A NAME="TOC14" HREF="bison-es-1.27.html#SEC14">De las Reglas Formales a la Entrada de Bison</A>
<LI><A NAME="TOC15" HREF="bison-es-1.27.html#SEC15">Valores Semánticos</A>
<LI><A NAME="TOC16" HREF="bison-es-1.27.html#SEC16">Acciones Semánticas</A>
<LI><A NAME="TOC17" HREF="bison-es-1.27.html#SEC17">La Salida de Bison: el Archivo del Analizador</A>
<LI><A NAME="TOC18" HREF="bison-es-1.27.html#SEC18">Etapas en el Uso de Bison</A>
<LI><A NAME="TOC19" HREF="bison-es-1.27.html#SEC19">El Formato Global de una Gramática de Bison</A>
</UL>
<LI><A NAME="TOC20" HREF="bison-es-1.27.html#SEC20">Ejemplos</A>
<UL>
<LI><A NAME="TOC21" HREF="bison-es-1.27.html#SEC21">Calculadora de Notación Polaca Inversa</A>
<UL>
<LI><A NAME="TOC22" HREF="bison-es-1.27.html#SEC22">Declaraciones para <CODE>rpcalc</CODE></A>
<LI><A NAME="TOC23" HREF="bison-es-1.27.html#SEC23">Reglas Gramaticales para <CODE>rpcalc</CODE></A>
<UL>
<LI><A NAME="TOC24" HREF="bison-es-1.27.html#SEC24">Explicación para <CODE>input</CODE></A>
<LI><A NAME="TOC25" HREF="bison-es-1.27.html#SEC25">Explicación para <CODE>line</CODE></A>
<LI><A NAME="TOC26" HREF="bison-es-1.27.html#SEC26">Explicación para <CODE>expr</CODE></A>
</UL>
<LI><A NAME="TOC27" HREF="bison-es-1.27.html#SEC27">El Analizador Léxico de <CODE>rpcalc</CODE></A>
<LI><A NAME="TOC28" HREF="bison-es-1.27.html#SEC28">La Función de Control</A>
<LI><A NAME="TOC29" HREF="bison-es-1.27.html#SEC29">La Rutina de Informe de Errores</A>
<LI><A NAME="TOC30" HREF="bison-es-1.27.html#SEC30">Ejecutando Bison para Hacer el Analizador</A>
<LI><A NAME="TOC31" HREF="bison-es-1.27.html#SEC31">Compilando el Archivo del Analizador</A>
</UL>
<LI><A NAME="TOC32" HREF="bison-es-1.27.html#SEC32">Calculadora de Notación Infija: <CODE>calc</CODE></A>
<LI><A NAME="TOC33" HREF="bison-es-1.27.html#SEC33">Recuperación de Errores Simple</A>
<LI><A NAME="TOC34" HREF="bison-es-1.27.html#SEC34">Calculadora Multi-Función: <CODE>mfcalc</CODE></A>
<UL>
<LI><A NAME="TOC35" HREF="bison-es-1.27.html#SEC35">Declaraciones para <CODE>mfcalc</CODE></A>
<LI><A NAME="TOC36" HREF="bison-es-1.27.html#SEC36">Reglas Gramaticales para <CODE>mfcalc</CODE></A>
<LI><A NAME="TOC37" HREF="bison-es-1.27.html#SEC37">La Tabla de Símbolos de <CODE>mfcalc</CODE></A>
</UL>
<LI><A NAME="TOC38" HREF="bison-es-1.27.html#SEC38">Ejercicios</A>
</UL>
<LI><A NAME="TOC39" HREF="bison-es-1.27.html#SEC39">Archivos de Gramática de Bison</A>
<UL>
<LI><A NAME="TOC40" HREF="bison-es-1.27.html#SEC40">Resumen de una Gramática de Bison</A>
<UL>
<LI><A NAME="TOC41" HREF="bison-es-1.27.html#SEC41">La Sección de Declaraciones en C</A>
<LI><A NAME="TOC42" HREF="bison-es-1.27.html#SEC42">La Sección de Declaraciones de Bison</A>
<LI><A NAME="TOC43" HREF="bison-es-1.27.html#SEC43">La Sección de Reglas Gramaticales</A>
<LI><A NAME="TOC44" HREF="bison-es-1.27.html#SEC44">La Sección de Código C Adicional</A>
</UL>
<LI><A NAME="TOC45" HREF="bison-es-1.27.html#SEC45">Símbolos, Terminales y No Terminales</A>
<LI><A NAME="TOC46" HREF="bison-es-1.27.html#SEC46">Sintaxis de las Reglas Gramaticales</A>
<LI><A NAME="TOC47" HREF="bison-es-1.27.html#SEC47">Reglas Recursivas</A>
<LI><A NAME="TOC48" HREF="bison-es-1.27.html#SEC48">Definiendo la Semántica del Lenguaje</A>
<UL>
<LI><A NAME="TOC49" HREF="bison-es-1.27.html#SEC49">Tipos de Datos para Valores Semánticos</A>
<LI><A NAME="TOC50" HREF="bison-es-1.27.html#SEC50">Más de Un Tipo de Valor</A>
<LI><A NAME="TOC51" HREF="bison-es-1.27.html#SEC51">Acciones</A>
<LI><A NAME="TOC52" HREF="bison-es-1.27.html#SEC52">Tipos de Datos de Valores en Acciones</A>
<LI><A NAME="TOC53" HREF="bison-es-1.27.html#SEC53">Acciones a Media Regla</A>
</UL>
<LI><A NAME="TOC54" HREF="bison-es-1.27.html#SEC54">Declaraciones de Bison</A>
<UL>
<LI><A NAME="TOC55" HREF="bison-es-1.27.html#SEC55">Nombres de Tipo de Token</A>
<LI><A NAME="TOC56" HREF="bison-es-1.27.html#SEC56">Precedencia de Operadores</A>
<LI><A NAME="TOC57" HREF="bison-es-1.27.html#SEC57">La Colección de Tipos de Valores</A>
<LI><A NAME="TOC58" HREF="bison-es-1.27.html#SEC58">Símbolos No Terminales</A>
<LI><A NAME="TOC59" HREF="bison-es-1.27.html#SEC59">Suprimiendo Advertencias de Conflictos</A>
<LI><A NAME="TOC60" HREF="bison-es-1.27.html#SEC60">El Símbolo de Arranque</A>
<LI><A NAME="TOC61" HREF="bison-es-1.27.html#SEC61">Un Analizador Puro (Reentrante)</A>
<LI><A NAME="TOC62" HREF="bison-es-1.27.html#SEC62">Sumario de Declaraciones de Bison</A>
</UL>
<LI><A NAME="TOC63" HREF="bison-es-1.27.html#SEC63">Múltiples Analizadores en el Mismo Programa</A>
</UL>
<LI><A NAME="TOC64" HREF="bison-es-1.27.html#SEC64">Interfaz del Analizador en Lenguaje C</A>
<UL>
<LI><A NAME="TOC65" HREF="bison-es-1.27.html#SEC65">La Función del Analizador <CODE>yyparse</CODE></A>
<LI><A NAME="TOC66" HREF="bison-es-1.27.html#SEC66">La Funcion del Analizador Léxico <CODE>yylex</CODE></A>
<UL>
<LI><A NAME="TOC67" HREF="bison-es-1.27.html#SEC67">Convención de Llamada para <CODE>yylex</CODE></A>
<LI><A NAME="TOC68" HREF="bison-es-1.27.html#SEC68">Valores Semánticos de los Tokens</A>
<LI><A NAME="TOC69" HREF="bison-es-1.27.html#SEC69">Posiciones en el Texto de los Tokens</A>
<LI><A NAME="TOC70" HREF="bison-es-1.27.html#SEC70">Convenciones de Llamada para Analizadores Puros</A>
</UL>
<LI><A NAME="TOC71" HREF="bison-es-1.27.html#SEC71">La Función de Informe de Errores <CODE>yyerror</CODE></A>
<LI><A NAME="TOC72" HREF="bison-es-1.27.html#SEC72">Propiedades Especiales para su Uso en Acciones</A>
</UL>
<LI><A NAME="TOC73" HREF="bison-es-1.27.html#SEC73">El Algoritmo del Analizador de Bison</A>
<UL>
<LI><A NAME="TOC74" HREF="bison-es-1.27.html#SEC74">Tokens de Preanálisis</A>
<LI><A NAME="TOC75" HREF="bison-es-1.27.html#SEC75">Conflictos de Desplazamiento/Reducción</A>
<LI><A NAME="TOC76" HREF="bison-es-1.27.html#SEC76">Precedencia de Operadores</A>
<UL>
<LI><A NAME="TOC77" HREF="bison-es-1.27.html#SEC77">Cuándo se Necesita la Precedencia</A>
<LI><A NAME="TOC78" HREF="bison-es-1.27.html#SEC78">Especificando Precedencia de Operadores</A>
<LI><A NAME="TOC79" HREF="bison-es-1.27.html#SEC79">Ejemplos de Precedencia</A>
<LI><A NAME="TOC80" HREF="bison-es-1.27.html#SEC80">Cómo Funciona la Precedencia</A>
</UL>
<LI><A NAME="TOC81" HREF="bison-es-1.27.html#SEC81">Precedencia Dependiente del Contexto</A>
<LI><A NAME="TOC82" HREF="bison-es-1.27.html#SEC82">Estados del Analizador</A>
<LI><A NAME="TOC83" HREF="bison-es-1.27.html#SEC83">Conflictos de Reducción/Reducción</A>
<LI><A NAME="TOC84" HREF="bison-es-1.27.html#SEC84">Conflictos Misteriosos de Reducción/Reducción</A>
<LI><A NAME="TOC85" HREF="bison-es-1.27.html#SEC85">Desbordamiento de Pila, y Cómo Evitarlo</A>
</UL>
<LI><A NAME="TOC86" HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>
<LI><A NAME="TOC87" HREF="bison-es-1.27.html#SEC87">Manejando Dependencias del Contexto</A>
<UL>
<LI><A NAME="TOC88" HREF="bison-es-1.27.html#SEC88">Información Semántica en Tipos de Tokens</A>
<LI><A NAME="TOC89" HREF="bison-es-1.27.html#SEC89">Ligaduras Léxicas</A>
<LI><A NAME="TOC90" HREF="bison-es-1.27.html#SEC90">Ligaduras Léxicas y Recuperación de Errores</A>
</UL>
<LI><A NAME="TOC91" HREF="bison-es-1.27.html#SEC91">Depurando Su Analizador</A>
<LI><A NAME="TOC92" HREF="bison-es-1.27.html#SEC92">Invocando a Bison</A>
<UL>
<LI><A NAME="TOC93" HREF="bison-es-1.27.html#SEC93">Opciones de Bison</A>
<LI><A NAME="TOC94" HREF="bison-es-1.27.html#SEC94">Clave Cruzada de Opciones</A>
<LI><A NAME="TOC95" HREF="bison-es-1.27.html#SEC95">Invocando Bison bajo VMS</A>
</UL>
<LI><A NAME="TOC96" HREF="bison-es-1.27.html#SEC96">Símbolos de Bison</A>
<LI><A NAME="TOC97" HREF="bison-es-1.27.html#SEC97">Glosario</A>
<LI><A NAME="TOC98" HREF="bison-es-1.27.html#SEC98">Índice</A>
</UL>
<P><HR><P>


<H1><A NAME="SEC1" HREF="bison-es-1.27.html#TOC1">Introducción</A></H1>
<P>
<A NAME="IDX1"></A>

</P>
<P>
<STRONG>Bison</STRONG> es un generador de analizadores sintácticos de propósito general
que convierte una descripción gramatical para una gramática independiente del
contexto LALR(1) en un programa en C que analice esa gramática.  Una vez
que sea un experimentado en Bison, podría utilizarlo para desarollar un amplio
rango de analizadores de lenguajes, desde aquellos usados en simples
calculadoras de escritorio hasta complejos lenguajes de programación.

</P>
<P>
Bison es compatible hacia arriba con Yacc: todas la gramáticas escritas
apropiadamente para Yacc deberían funcionar con Bison sin ningún cambio.
Cualquiera que esté familiarizado con Yacc debería ser capaz de utilizar
Bison con pocos problemas.  Necesita ser fluente programando en C
para poder utilizar Bison o para comprender este manual.

</P>
<P>
Comenzaremos con capítulos introductorios que explican los conceptos básicos
del uso de Bison y muestran tres ejemplos comentados, cada uno construido sobre
el anterior.  Si no conoce Bison o Yacc, comience leyendo estos capítulos. 
A continuación se encuentran los capítulos de referencia que describen
los aspectos específicos de Bison en detalle.

</P>
<P>
Bison fue escrito originalmente por Robert Corbett; Richard Stallman lo hizo
compatible con Yacc.  Wilfred Hansen de la Universidad de Carnegie Mellon
añadió los literales de cadenas multicaracter y otras características.

</P>
<P>
Esta edición corresponde a la versión 1.27 de Bison.

</P>
<P>
<STRONG>Nota:</STRONG> las secciones tituladas "Licencia Pública General GNU",
"Condiciones para el uso de Bison" y el aviso de permiso son
traducciones libres de las secciones originales en inglés "GNU General
Public License", "Conditions for Using Bison" y el permiso original.
Ninguna de estas traducciones ha sido aprobada por la Free Software
Foundation oficialmente y se han incluído solamente para facilitar su
entendimiento.  Si desea estar seguro de si sus actuaciones están
permitidas, por favor acuda a la versión original inglesa.

</P>
<P>
La Free Software Foundation recomienda fervientemente no usar estas
traducciones como los términos oficiales de distribución para sus programas;
en su lugar, por favor use las versiones inglesas originales, tal y como están
publicadas por la Free Software Foundation.

</P>
<P>
@language=@ingles

</P>



<H1><A NAME="SEC2" HREF="bison-es-1.27.html#TOC2">Conditions for Using Bison</A></H1>

<P>
As of Bison version 1.24, we have changed the distribution terms for
<CODE>yyparse</CODE> to permit using Bison's output in non-free programs.
Formerly, Bison parsers could be used only in programs that were free
software.

</P>
<P>
The other GNU programming tools, such as the GNU C compiler, have never
had such a requirement.  They could always be used for non-free
software.  The reason Bison was different was not due to a special
policy decision; it resulted from applying the usual General Public
License to all of the Bison source code.

</P>
<P>
The output of the Bison utility--the Bison parser file--contains a
verbatim copy of a sizable piece of Bison, which is the code for the
<CODE>yyparse</CODE> function.  (The actions from your grammar are inserted
into this function at one point, but the rest of the function is not
changed.)  When we applied the GPL terms to the code for <CODE>yyparse</CODE>,
the effect was to restrict the use of Bison output to free software.

</P>
<P>
We didn't change the terms because of sympathy for people who want to
make software proprietary.  <STRONG>Software should be free.</STRONG>  But we
concluded that limiting Bison's use to free software was doing little to
encourage people to make other software free.  So we decided to make the
practical conditions for using Bison match the practical conditions for
using the other GNU tools.
@language=@espanol

</P>


<H1><A NAME="SEC3" HREF="bison-es-1.27.html#TOC3">Condiciones para el uso de Bison</A></H1>

<P>
Al igual que en la versión 1.24 de Bison, hemos cambiado los términos de la
distribución de <CODE>yyparse</CODE> para permitir el uso de la salida de Bison en
programas no-libres.  En otro tiempo, los analizadores generados por Bison
solamente podían utilizarse en programas que fuesen software libre.

</P>
<P>
Las otras herramientas GNU de programación, tales como el compilador de C GNU,
nunca han tenido tal tipo de requisito.  Estas herramientas siempre podían
utilizarse para software no-libre.  La razón de que con Bison fuera diferente
no fue debido a una decisión política especial; ello resultó de la aplicación
de la Licencia Pública General usual a todo el código fuente de Bison.

</P>
<P>
La salida de la utilidad Bison--el archivo del analizador de Bison--contiene
una copia literal de un considerable fragmento de Bison, que es el código
para la función <CODE>yyparse</CODE>.  (Las acciones de tu gramática se insertan
dentro de esta función en un punto, pero el resto de la función no se
modifica.) Cuando aplicamos los términos de la GPL al código fuente para
<CODE>yyparse</CODE>, el efecto fue la restricción del uso de la salida de Bison en
software libre.

</P>
<P>
No cambiamos los términos debido a simpatía con la gente que quiere hacer
software propietario.  <STRONG>El software debería ser libre.</STRONG>  Pero hemos
concluido que limitando el uso de Bison en software libre era hacer poco por
alentar a la gente a hacer otro software libre.  Así que hemos decidido hacer
que concuerden las condiciones prácticas para el uso de Bison con las
condiciones prácticas para usar las otras utilidades GNU.

</P>


<H1><A NAME="SEC4" HREF="bison-es-1.27.html#TOC4">GNU GENERAL PUBLIC LICENSE</A></H1>
<P>
@language=@ingles
Version 2, June 1991

</P>

<PRE>
Copyright (C) 1989, 1991 Free Software Foundation, Inc.
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</PRE>



<H2><A NAME="SEC5" HREF="bison-es-1.27.html#TOC5">Preamble</A></H2>

<P>
  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

</P>
<P>
  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

</P>
<P>
  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

</P>
<P>
  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

</P>
<P>
  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

</P>
<P>
  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

</P>
<P>
  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

</P>
<P>
  The precise terms and conditions for copying, distribution and
modification follow.

</P>


<H2><A NAME="SEC6" HREF="bison-es-1.27.html#TOC6">TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</A></H2>


<OL>
<LI>

This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

<LI>

You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

<LI>

You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:


<OL>
<LI>

You must cause the modified files to carry prominent notices
stating that you changed the files and the date of any change.

<LI>

You must cause any work that you distribute or publish, that in
whole or in part contains or is derived from the Program or any
part thereof, to be licensed as a whole at no charge to all third
parties under the terms of this License.

<LI>

If the modified program normally reads commands interactively
when run, you must cause it, when started running for such
interactive use in the most ordinary way, to print or display an
announcement including an appropriate copyright notice and a
notice that there is no warranty (or else, saying that you provide
a warranty) and that users may redistribute the program under
these conditions, and telling the user how to view a copy of this
License.  (Exception: if the Program itself is interactive but
does not normally print such an announcement, your work based on
the Program is not required to print an announcement.)
</OL>

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

<LI>

You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:


<OL>
<LI>

Accompany it with the complete corresponding machine-readable
source code, which must be distributed under the terms of Sections
1 and 2 above on a medium customarily used for software interchange; or,

<LI>

Accompany it with a written offer, valid for at least three
years, to give any third party, for a charge no more than your
cost of physically performing source distribution, a complete
machine-readable copy of the corresponding source code, to be
distributed under the terms of Sections 1 and 2 above on a medium
customarily used for software interchange; or,

<LI>

Accompany it with the information you received as to the offer
to distribute corresponding source code.  (This alternative is
allowed only for noncommercial distribution and only if you
received the program in object code or executable form with such
an offer, in accord with Subsection b above.)
</OL>

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

<LI>

You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

<LI>

You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

<LI>

Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

<LI>

If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

<LI>

If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

<LI>

The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

<LI>

If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.



<P><STRONG>NO WARRANTY</STRONG></P>

<LI>

BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

<LI>

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
</OL>


<H2>END OF TERMS AND CONDITIONS</H2>



<H2><A NAME="SEC7" HREF="bison-es-1.27.html#TOC7">How to Apply These Terms to Your New Programs</A></H2>

<P>
  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

</P>
<P>
  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

</P>

<PRE>
<VAR>one line to give the program's name and a brief idea of what it does.</VAR>
Copyright (C) 19<VAR>yy</VAR>  <VAR>name of author</VAR>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.
</PRE>

<P>
Also add information on how to contact you by electronic and paper mail.

</P>
<P>
If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

</P>

<PRE>
Gnomovision version 69, Copyright (C) 19<VAR>yy</VAR> <VAR>name of author</VAR>
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details 
type `show w'.
This is free software, and you are welcome to redistribute it
under certain conditions; type `show c' for details.
</PRE>

<P>
The hypothetical commands <SAMP>`show w'</SAMP> and <SAMP>`show c'</SAMP> should show
the appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than <SAMP>`show w'</SAMP> and
<SAMP>`show c'</SAMP>; they could even be mouse-clicks or menu items--whatever
suits your program.

</P>
<P>
You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

</P>

<PRE>
Yoyodyne, Inc., hereby disclaims all copyright interest in the program
`Gnomovision' (which makes passes at compilers) written by James Hacker.

<VAR>signature of Ty Coon</VAR>, 1 April 1989
Ty Coon, President of Vice
</PRE>

<P>
This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
@language=@espanol

</P>


<H1><A NAME="SEC8" HREF="bison-es-1.27.html#TOC8">LICENCIA PÚBLICA GENERAL GNU</A></H1>
<P>
Versión 2, Junio de 1991

</P>

<PRE>
Copyright (C) 1989, 1991 Free Software Foundation, Inc.
675 Mass Ave, Cambridge, MA 02139, EEUU

Se permite a todo el mundo la copia y distribución de copias literales
de este documento de licencia, pero no se permite su modificación.
</PRE>



<H2><A NAME="SEC9" HREF="bison-es-1.27.html#TOC9">Preámbulo</A></H2>

<P>
Las licencias que cubren la mayor parte del software están diseñadas
para quitarle a usted la libertad de compartirlo y modificarlo.  Por el
contrario, la Licencia Pública General GNU pretende garantizarle
la libertad de compartir y modificar software libre--para asegurar que el
software es libre para todos sus usuarios.  Esta Licencia Pública
General se aplica a la mayor parte del software de la Free Software
Foundation y a cualquier otro programa cuyos autores se comprometen a
utilizarla.  (Alguna parte del software de la Free Software Foundation
está cubierto por la Licencia Pública General GNU para Librerías).
Usted también la puede aplicar a sus programas.

</P>
<P>
Cuando hablamos de software libre, estamos refiriéndonos a la libertad,
no al precio.  Nuestras Licencias Públicas Generales están diseñadas para
asegurarnos de que tenga la libertad de distribuir copias de 
software libre (y cobrar por ese servicio si quiere), que reciba
el código fuente o que pueda conseguirlo si lo quiere, que
pueda modificar el software o usar fragmentos de él en nuevos
programas libres, y que sepa que puede hacer todas estas cosas.

</P>
<P>
Para proteger sus derechos necesitamos algunas restricciones que
prohiban a cualquiera negarle a usted estos derechos o pedirle que renuncie a
ellos.  Estas restricciones se traducen en ciertas obligaciones que le
afectan si distribuye copias del software, o si lo modifica.

</P>
<P>
Por ejemplo, si distribuye copias de uno de estos programas, sea
gratuitamente, o a cambio de una contraprestación, debe dar a los
receptores todos los derechos que tiene.  Debe asegurarse de que
ellos también reciben, o pueden conseguir, el código fuente. Y
debe mostrarles estas condiciones de forma que conozcan sus derechos.

</P>
<P>
Protegemos sus derechos con la combinación de dos medidas:
(1) ponemos el software bajo copyright y
(2) le ofrecemos esta licencia, que le da permiso legal para copiar,
distribuir y/o modificar el software.

</P>
<P>
También, para la protección de cada autor y la nuestra propia,
queremos asegurarnos de que todo el mundo comprende que no se
proporciona ninguna garantía para este software libre.  Si el software
es modificado por cualquiera y éste a su vez lo distribuye, queremos
que sus receptores sepan que lo que tienen no es el original, de forma
que cualquier problema introducido por otros no afecte a la reputación
de los autores originales.

</P>
<P>
Por último, cualquier programa libre está constantemente amenazado
por patentes sobre el software.  Queremos evitar el riesgo de que los
redistribuidores de un programa libre individualmente obtengan
patentes, haciendo el programa propietario a todos los efectos.
Para prevenir esto, hemos dejado claro que cualquier patente debe ser
concedida para el uso libre de cualquiera, o no ser concedida en absoluto.

</P>
<P>
Los términos exactos y las condiciones para la copia, distribución y
modificación se exponen a continuación.

</P>


<H2><A NAME="SEC10" HREF="bison-es-1.27.html#TOC10">TÉRMINOS Y CONDICIONES PARA LA COPIA, DISTRIBUCIÓN Y MODIFICACIÓN</A></H2>


<OL>
<LI>

Esta Licencia se aplica a cualquier programa u otra obra que contenga
un aviso colocado por el propietario del copyright diciendo que puede
ser distribuido bajo los términos de esta Licencia Pública General.  En
adelante, "Programa" se referirá a cualquier programa u obra de esta
clase y "una obra basada en el Programa" se referirá
bien al Programa o a cualquier obra derivada de este según la ley de
copyright.  Esto es, una obra que contenga el programa o una porción de
este, bien en forma literal o con modificaciones y/o traducido en otro
lenguaje.  Por lo tanto, la traducción está incluida sin limitaciones en
el término "modificación". Cada propietario de una licencia será
tratado como "usted".

Cualquier otra actividad que no sea la copia, distribución o
modificación no está cubierta por esta Licencia, está fuera de su
ámbito.  El acto de ejecutar el Programa no está restringido, y los
resultados del Programa están cubiertos únicamente si sus contenidos
constituyen una obra basada en el Programa, independientemente de
haberlo producido mediante la ejecución del programa.  Que esto se
cumpla, depende de lo que haga el programa.

<LI>

Usted puede copiar y distribuir copias literales del código fuente
del Programa, tal y como lo recibió, por cualquier medio, supuesto que
de forma adecuada y bien visible publique en cada copia un anuncio de
copyright adecuado y una renuncia de garantía, mantenga intactos todos
los anuncios que se refieran a esta Licencia y a la ausencia de
garantía, y proporcione a cualquier otro receptor del programa una
copia de esta Licencia junto con el Programa.

Puede cobrar un precio por el acto físico de transferir una copia, y
puede a su elección ofrecer garantía a cambio de unos honorarios.
   
<LI>

Usted puede modificar su copia o copias del Programa o cualquier
porción de él, formando de esta manera una obra basada en el
Programa, y copiar y distribuir esa modificación u obra bajo los
términos del apartado 1 anterior, siempre que además cumpla las
siguientes condiciones:


<OL>
<LI>

Debe procurar que los ficheros modificados incluyan notificaciones
destacadas manifestando que los ha cambiado y la fecha de cualquier
cambio.

<LI>

Usted debe procurar que cualquier obra que distribuya o publique,
que en todo o en parte contenga o sea derivada del Programa o de
cualquier parte de él, sea licenciada como un todo, sin cargo
alguno para terceras partes bajo los términos de esta Licencia.

<LI>

Si el programa modificado lee normalmente órdenes
interactivamente cuando al ejecutarse, debe hacer que cuando
comience su ejecución para ese uso interactivo de la forma más
habitual, muestre o escriba un mensaje que incluya un anuncio de
copyright y un anuncio de que no se ofrece ninguna garantía (o por
el contrario que sí se ofrece garantía) y que los usuarios pueden
redistribuir el programa bajo estas condiciones, e indicando al
usuario cómo ver una copia de esta licencia. (Excepción: si el
propio programa es interactivo pero normalmente no muestra ese
anuncio, no está obligado a que su obra basada en el Programa
muestre ningún anuncio).
</OL>

    
Estos requisitos se aplican a la obra modificada como un todo. Si
algunas secciones claramente identificables de esa obra no están
derivadas del Programa, y pueden razonablemente ser consideradas como
obras independientes y separados por sí mismas, entonces esta Licencia y
sus términos no se aplican a esas partes cuando sean distribuidas como
trabajos separados.  Pero cuando distribuya esas mismas secciones como
partes de un todo que es una obra basada en el Programa, la distribución
de ese todo debe cumplir los términos de esta Licencia, cuyos permisos para
otros licenciatarios se extienden al todo completo, y por lo tanto a
todas y cada una de sus partes, con independencia de quién la escribió.

Por lo tanto, no es intención de este apartado reclamar derechos u
oponerse a sus derechos sobre obras escritas enteramente por usted;
sino que la intención es ejercer el derecho de controlar la distribución de
obras derivadas o colectivas basadas en el Programa.

Además, el simple hecho de reunir otro trabajo no basado en el Programa
con el Programa (o con un trabajo basado en el Programa) en un medio
de almacenamiento o en un medio de distribución no hace que dicho
trabajo entre dentro del ámbito cubierto por esta Licencia.

<LI>

Usted puede copiar y distribuir el Programa (o una obra basada en él,
según se especifica en la Sección 2) en forma de código objeto o 
ejecutable bajo los términos de las Secciones 1 y 2 anteriores mientras
cumpla además una de las siguientes condiciones:


<OL>
<LI>

Acompañarlo con el código fuente completo correspondiente en
formato legible para un ordenador, que debe ser distribuido bajo los
términos de las Secciones 1 y 2 anteriores en un medio utilizado
habitualmente para el intercambio de programas, o

<LI>

Acompañarlo con una oferta por escrito, válida durante al menos
tres años,  por un coste no mayor que el de realizar físicamente la
distribución del fuente, de proporcionar a cualquier tercera parte una copia
completa en formato legible para un ordenador del código fuente
correspondiente, que será distribuido bajo las condiciones descritas en
las Secciones 1 y 2 anteriores, en un medio utilizado habitualmente
para el intercambio de programas, o

<LI>

Acompañarlo con la información que usted recibió referida al ofrecimiento
de distribuir el código fuente correspondiente.  (Esta opción se
permite sólo para la distribución no comercial y sólo si usted
recibió el programa como código objeto o en formato ejecutable con
una oferta de este tipo, de acuerdo con la Sección b anterior).
</OL>

    
Se entiende por código fuente de un trabajo a la forma preferida de la
obra para hacer modificaciones sobre este.  Para una obra ejecutable,
se entiende por código fuente completo todo el código fuente para
todos los módulos que contiene, más cualquier fichero asociado de
definición de interfaces, más los guiones utilizados para controlar la
compilación e instalación del ejecutable.  Como excepción especial el
código fuente distribuido no necesita incluir nada que sea distribuido
normalmente (ya sea en formato fuente o binario) con los
componentes fundamentales (compilador, kernel y similares) del sistema
operativo en el cual funciona el ejecutable, a no ser que el propio
componente acompañe al ejecutable.

Si la distribución del ejecutable o del código objeto se realiza ofreciendo
acceso a una copia desde un lugar designado, entonces se
considera el ofrecimiento del acceso para copiar el código fuente del mismo
lugar como distribución del código fuente, incluso aunque terceras
partes no estén obligadas a copiar el fuente junto al código objeto.

<LI>

No puede copiar, modificar, sublicenciar o distribuir el Programa
excepto como está expresamente permitido por esta Licencia.  Cualquier
intento de copiar, modificar sublicenciar o distribuir el Programa de
otra forma es inválido, y hará que cesen automáticamente los derechos que le
proporciona esta Licencia.  En cualquier caso, las partes que hayan
recibido copias o derechos bajo esta Licencia no verán sus Licencias
calceladas, mientras esas partes continúen cumpliéndo totalmente la Licencia.

<LI>

No está obligado a aceptar esta licencia, ya que no la ha firmado.
Sin embargo, no hay hada más que le proporcione permiso para modificar
o distribuir el Programa o sus trabajos derivados.  Estas acciones
están prohibidas por la ley si no acepta esta Licencia.  Por lo tanto,
si modifica o distribuye el Programa (o cualquier trabajo basado en el
Programa), está indicando que acepta esta Licencia para poder hacerlo,
y todos sus términos y condiciones para copiar, distribuir o modificar
el Programa o trabajos basados en él.

<LI>

Cada vez que redistribuya el Programa (o cualquier trabajo basado
en el Programa), el receptor recibe automáticamente una licencia del
licenciatario original para copiar, distribuir o modificar el
Programa, de forma sujeta a estos términos y condiciones. No puede
imponer al receptor ninguna restricción más sobre el ejercicio de los
derechos aquí garantizados.  No es usted responsable de hacer cumplir
esta licencia por terceras partes.

<LI>

Si como consecuencia de una resolución judicial o de una alegación
de infracción de patente o por cualquier otra razón (no limitada a
asuntos relacionados con patentes) se le imponen condiciones (ya sea
por mandato judicial, por acuerdo o por cualquier otra causa) que
contradigan las condiciones de esta Licencia, ello no le exime de
cumplir las condiciones de esta Licencia.  Si no puede realizar
distribuciones de forma que se satisfagan simultáneamente sus
obligaciones bajo esta licencia y cualquier otra obligación pertinente
entonces, como consecuencia, no puede distribuir el Programa de
ninguna forma.  Por ejemplo, si una patente no permite la
redistribución libre de derechos de autor del Programa por parte de
todos aquellos que reciban copias directa o indirectamente a través de
usted, entonces la única forma en que podría satisfacer tanto esa
condición como esta Licencia sería evitar completamente la
distribución del Programa.

Si cualquier porción de este apartado se considera no válido o
imposible de cumplir bajo cualquier circunstancia particular ha de
cumplirse el resto y la sección por entero ha de cumplirse en
cualquier otra circunstancia.

No es el propósito de este apartado inducirle a infringir ninguna
patente ni ningún otro derecho de propiedad o
impugnar la validez de ninguna de dichas reclamaciones.  Este
apartado tiene el único propósito de proteger la integridad del
sistema de distribución de software libre, que se realiza mediante
prácticas de licencia pública.  Mucha gente ha hecho contribuciones
generosas a la gran variedad de software distribuido mediante ese
sistema con la confianza de que el sistema se aplicará
consistentemente.  Será el autor/donante quien decida si quiere
distribuir software mediante cualquier otro sistema y una licencia no
puede imponer esa elección.

Este apartado pretende dejar completamente claro lo que se cree que es
una consecuencia del resto de esta Licencia.

<LI>

Si la distribución y/o uso de el Programa está restringido en
ciertos países, bien por patentes o por interfaces bajo copyright, el
poseedor del copyright que coloca este Programa bajo esta Licencia
puede añadir una limitación explícita de distribución geográfica
excluyendo esos países, de forma que la distribución se permita sólo
en o entre los países no excluidos de esta manera. En ese caso, esta
Licencia incorporará la limitación como si estuviese escrita en el
cuerpo de esta Licencia.

<LI>

La Free Software Foundation puede publicar versiones revisadas y/o
nuevas de la Licencia Pública General de tiempo en tiempo. Dichas
versiones nuevas serán similares en espíritu a la presente versión,
pero pueden ser diferentes en detalles para considerar nuevos
problemas o situaciones.

Cada versión recibe un número de versión que la distingue de otras. Si
el Programa especifica un número de versión de esta Licencia que se
aplica a ella y a "cualquier versión posterior", tiene la opción
de seguir los términos y condiciones, bien de esa versión, bien de
cualquier versión posterior publicada por la Free Software Foundation.
Si el Programa no especifica un número de versión de esta Licencia,
puede escoger cualquier versión publicada por la Free Software Foundation.

<LI>

Si usted desea incorporar partes del Programa en otros programas libres
cuyas condiciones de distribución son diferentes, escriba al autor
para pedirle permiso. Si el software tiene copyright de la Free
Software Foundation, escriba a la Free Software Foundation: algunas
veces hacemos excepciones en estos casos.  Nuestra decisión estará
guiada por el doble objetivo de preservar la libertad de todos los
derivados de nuestro software libre y promover el que se comparta y
reutilice el software en general.



<P><STRONG>AUSENCIA DE GARANTÍA</STRONG></P>

<LI>

YA QUE EL PROGRAMA SE LICENCIA LIBRE DE CARGAS, NO SE OFRECE NINGUNA
GARANTÍA SOBRE EL PROGRAMA, HASTA LO PERMITIDO POR LAS LEYES APLICABLES.
EXCEPTO CUANDO SE INDIQUE LO CONTRARIO POR ESCRITO, LOS POSEEDORES DEL
COPYRIGHT Y/U OTRAS PARTES PROVEEN EL PROGRAMA "TAL Y COMO ESTÁ", SIN
GARANTÍA DE NINGUNA CLASE, YA SEA EXPRESA O IMPLÍCITA, INCLUYENDO, PERO
NO LIMITÁNDOSE A, LAS GARANTÍAS IMPLÍCITAS DE COMERCIABILIDAD Y APTITUD
PARA UN PROPÓSITO PARTICULAR. TODO EL RIESGO EN CUANTO A LA CALIDAD Y 
FUNCIONAMIENTO DEL PROGRAMA LO ASUME USTED.  SI EL PROGRAMA SE COMPROBARA QUE
ESTÁ DEFECTUOSO, USTED ASUME EL COSTO DE TODO SERVICIO, REPARACIÓN O
CORRECCIÓN QUE SEA NECESARIO.

<LI>

EN NINGÚN CASO, A NO SER QUE SE REQUIERA POR LAS LEYES APLICABLES O SE
ACUERDE POR ESCRITO, PODRÁ NINGÚN POSEEDOR DE COPYRIGHT O CUALQUIER
OTRA PARTE QUE HAYA MODIFICADO Y/O REDISTRIBUIDO EL PROGRAMA, SER
RESPONSABLE ANTE USTED POR DAÑOS O PERJUICIOS, INCLUYENDO CUALQUIER
DAÑO GENERAL, ESPECIAL, INCIDENTAL O CONSECUENTE DEBIDO AL USO O
LA IMPOSIBILIDAD DE PODER USAR EL PROGRAMA (INCLUYENDO PERO NO LIMITÁNDOSE
A LA PÉRDIDA DE DATOS O LA PRODUCCIÓN DE DATOS INCORRECTOS O PÉRDIDAS
SUFRIDAS POR USTED O POR TERCERAS PARTES O LA IMPOSIBILIDAD DEL PROGRAMA
DE OPERAR JUNTO A OTROS PROGRAMAS), INCLUSO SI EL POSEEDOR DEL 
COPYRIGHT U OTRA PARTE HA SIDO AVISADO DE LA POSIBILIDAD DE TALES
DAÑOS.
</OL>


<H2>FIN DE TÉRMINOS Y CONDICIONES</H2>



<H2><A NAME="SEC11" HREF="bison-es-1.27.html#TOC11">Cómo aplicar estos términos a sus nuevos programas.</A></H2>

<P>
Si usted desarrolla un nuevo Programa, y quiere que sea del mayor uso
posible para el público en general, la mejor forma de conseguirlo es
convirtiéndolo en software libre que cualquiera pueda redistribuir y
cambiar bajo estos términos.

</P>
<P>
Para hacerlo, añada los siguientes avisos al programa. Lo más seguro
es añadirlos al principio de cada fichero fuente para comunicar lo
más efectivamente posible la ausencia de garantía.  Además cada fichero
debería tener al menos la línea de "copyright" y una indicación del
lugar donde se encuentra la notificación completa.

</P>

<PRE>
<VAR>una línea para indicar el nombre del programa y una rápida idea de
lo que hace.</VAR>
Copyright (C) 19<VAR>aa</VAR> <VAR>nombre del autor</VAR>

Este programa es software libre; usted puede redistribuirlo y/o modificarlo
bajo los términos de la Licencia Pública General GNU tal y como está
publicada por la Free Software Foundation; ya sea la versión 2 de la
Licencia o (a su elección) cualquier versión posterior.

Este programa se distribuye con la esperanza de que sea útil, pero SIN
NINGUNA GARANTÍA; ni siquiera la garantía implícita de COMERCIABILIDAD o
APTITUD PARA UN PROPÓSITO ESPECÍFICO. Vea la Licencia Pública General
GNU para más detalles.

Usted debería haber recibido una copia de la Licencia Pública General junto
con este programa. Si no ha sido así, escriba a la Free Software
Foundation, Inc., en 675 Mass Ave, Cambridge, MA 02139, EEUU.
</PRE>

<P>
Añada también información sobre cómo contactar con usted mediante
correo electrónico y postal.

</P>
<P>
Si el programa es interactivo, haga que muestre un pequeño anuncio
como el siguiente, cuando comience a funcionar en modo interactivo:

</P>

<PRE>
Gnomovision versión 69, Copyright (C) 19<VAR>aa</VAR> <VAR>nombre del autor</VAR>
Gnomovision no ofrece ABSOLUTAMENTE NINGUNA GARANTÍA; para más
detalles escriba `show w'.
Esto es software libre, y se le invita a redistribuirlo bajo ciertas
condiciones. Escriba `show c' para más detalles.
</PRE>

<P>
Los comandos hipotéticos <SAMP>`show w'</SAMP> y <SAMP>`show c'</SAMP> deberían mostrar las
partes adecuadas de la Licencia Pública General.  Por supuesto, los
comandos que use pueden llamarse de cualquier otra manera. Podrían
incluso ser pulsaciones del ratón o elementos de un menú---lo que sea
apropiado para su programa).

</P>
<P>
También debería conseguir que el empresario (si trabaja como
programador) o su centro académico, si es el caso, firme una "renuncia de
copyright" para el programa, si es necesario. A continuación se
ofrece un ejemplo, cambie los nombres:

</P>

<PRE>
Yoyodyne, Inc. con la presente renuncia a cualquier interés de
derechos de copyright con respecto al programa `Gnomovision' (que hace
pasadas a compiladores) escrito por Pepe Programador.

<VAR>firma de Pepito Grillo</VAR>, 20 de diciembre de 1996
Pepito Grillo, Presidente de Asuntillos Varios.
</PRE>

<P>
Esta Licencia Pública General no permite incorporar su programa a
programas propietarios.  Si su programa es una librería de
subrutinas, puede considerar más útil el permitir el enlazado de
aplicaciones propietarias con la librería.  Si este es el caso, use
la Licencia Pública General GNU para Librerías en lugar de esta
Licencia.

</P>


<H1><A NAME="SEC12" HREF="bison-es-1.27.html#TOC12">Los Conceptos de Bison</A></H1>

<P>
Este capítulo introduce muchos de los conceptos básicos sin los que
no tendrán sentido los detalles de Bison.  Si no conoce ya cómo utilizar
Bison o Yacc, le sugerimos que comience por leer este capítulo atentamente.

</P>



<H2><A NAME="SEC13" HREF="bison-es-1.27.html#TOC13">Lenguajes y Gramáticas independientes del Contexto</A></H2>

<P>
<A NAME="IDX2"></A>
<A NAME="IDX3"></A>
Para que Bison analice un lenguaje, este debe ser descrito por una
<STRONG>gramática independiente del contexto</STRONG>.  Esto quiere decir que debe
especificar uno o más <STRONG>grupos sintácticos</STRONG> y dar reglas para contruirlos
desde sus partes.  Por ejemplo, en el lenguaje C, un tipo de agrupación son
las llamadas `expresiones'.  Una regla para hacer una expresión sería,
"Una expresión puede estar compuesta de un signo menos y otra expresión".
Otra regla sería, "Una expresión puede ser un entero".  Como puede ver, las
reglas son a menudo recursivas, pero debe haber al menos una regla que lleve
fuera la recursión.

</P>
<P>
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>
El sistema formal más común de presentar tales reglas para ser leidas por los
humanos es la <STRONG>Forma de Backus-Naur</STRONG> o "BNF", que fue desarrollada para
especificar el lenguaje Algol 60.  Cualquier gramática expresada en BNF es una 
gramática independiente del contexto.  La entrada de Bison es en esencia una
BNF legible por la máquina.

</P>
<P>
No todos los lenguajes independientes del contexto pueden ser manejados
por Bison, únicamente aquellos que sean LALR(1).  Brevemente, esto
quiere decir que debe ser posible decir cómo analizar cualquier porción
de una cadena de entrada con un solo token de preanálisis.  Hablando
estrictamente, esto es una descripción de una gramática LR(1), y la
LALR(1) implica restricciones adicionales que son difíciles de explicar
de manera sencilla; pero es raro en la práctica real que se encuentre
una gramática LR(1) que no sea LALR(1).  See section <A HREF="bison-es-1.27.html#SEC84">Conflictos Misteriosos de Reducción/Reducción</A>, para más información a cerca
de esto.

</P>
<P>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
<A NAME="IDX8"></A>
<A NAME="IDX9"></A>
En las reglas gramaticales formales para un lenguaje, cada tipo de unidad
sintáctica o agrupación se identifica por un <STRONG>símbolo</STRONG>.  Aquellos que son
construidos agrupando construcciones más pequeñas de acuerdo a reglas
gramaticales se denominan <STRONG>símbolos no terminales</STRONG>; aquellos que no pueden
subdividirse se denominan <STRONG>símbolos terminales</STRONG> o <STRONG>tipos de tokens</STRONG>.
Denominamos <STRONG>token</STRONG> a un fragmento de la entrada
que corresponde a un solo símbolo terminal, y <STRONG>grupo</STRONG> a un fragmento 
que corresponde a un solo símbolo no terminal.
</P>
<P>
Podemos utilizar el lenguaje C como ejemplo de qué significan los símbolos,
terminales y no terminales.  Los tokens de C son los identificadores,
constantes (numéricas y cadenas de caracteres), y las diversas palabras
reservadas, operadores aritméticos y marcas de puntuación.  Luego los símbolos
terminales de una 
gramática para C incluyen `identificador', `número', `cadena de caracteres',
más un símbolo para cada palabra reservada, operador o marca de puntuación:
`if', `return', `const', `static', `int', `char', `signo-más', `llave-abrir',
`llave-cerrar', `coma' y muchos más.  (Estos tokens se pueden subdividir en
caracteres, pero eso es una cuestión léxica, no gramatical.) 

</P>
<P>
Aquí hay una función simple en C subdividida en tokens:

</P>

<PRE>
int             /* palabra reservada `int' */
cuadrado (x)    /* identificador, paréntesis-abrir */
                /* identificador, paréntesis-cerrar */
     int x;     /* palabra reservada `int', identificador, punto y coma */
{               /* llave-abrir */
  return x * x; /* palabra reservada `return', identificador, */
                /* asterisco, identificador, punto y coma */
}               /* llave-cerrar */
</PRE>

<P>
Las agrupaciones sintácticas de C incluyen a las expresiones, las sentencias,
las declaraciones, y las definiciones de funciones.  Estas se representan en la
gramática de C por los símbolos no terminales `expresión', `sentencia',
`declaración' y `definición de función'.  La gramática completa utiliza docenas
de construcciones del lenguaje adicionales, cada uno con su propio símbolo no
terminal, de manera que exprese el significado de esos cuatro.  El ejemplo
anterios es la definición de una función; contiene una declaración, y una
sentencia. En la sentencia, cada <SAMP>`x'</SAMP> es una expresión y también lo es
<SAMP>`x * x'</SAMP>.

</P>
<P>
Cada símbolo no terminal debe poseer reglas gramaticales mostrando cómo está
compuesto de construcciones más simples.  Por ejemplo, un tipo de
sentencia en C es la sentencia <CODE>return</CODE>; esta sería descrita
con una regla gramatical que interpretada informalmente sería así:

</P>

<BLOCKQUOTE>
<P>
Una `sentencia' puede estar compuesta de una parabra clave `return', una
`expresión' y un `punto y coma'.
</BLOCKQUOTE>

<P>
Aquí existirían muchas otras reglas para `sentencia', una para cada tipo
de sentencia en C.

</P>
<P>
<A NAME="IDX10"></A>
Se debe distinguir un símbolo no terminal como el símbolo especial que define
una declaración completa en el lenguaje.  Este se denomina <STRONG>símbolo de
arranque</STRONG>.  En un compilador, este representa un programa completo.  En el
lenguaje C, el símbolo no terminal `secuencia de definiciones y declaraciones'
juega este papel.

</P>
<P>
Por ejemplo, <SAMP>`1 + 2'</SAMP> es una expresión válida en C--una parte válida de un
programa en C--pero no es válida como un programa en C <EM>completo</EM>.  En la
gramática independiente del contexto de C, esto se refleja en el hecho de que 
`expresión' no es el símbolo de arranque.

</P>
<P>
El analizador de Bison lee una secuencia de tokens como entrada, y agrupa
los tokens utilizando las reglas gramaticales.  Si la entrada es válida,
el resultado final es que la secuencia de tokens entera se reduce a una
sola agrupación cuyo símbolo es el símbolo de arranque de la gramática.
Si usamos una gramática para C, la entrada completa debe ser una 
`secuencia de definiciones y declaraciones'.  Si no, el analizador
informa de un error de sintaxis.

</P>


<H2><A NAME="SEC14" HREF="bison-es-1.27.html#TOC14">De las Reglas Formales a la Entrada de Bison</A></H2>
<P>
<A NAME="IDX11"></A>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>

</P>
<P>
Una gramática formal es una construcción matemática.  Para definir el lenguaje
para Bison, debe escribir un archivo expresando la gramática con la sintaxis de
Bison: un archivo de <STRONG>gramática de Bison</STRONG>.  See section <A HREF="bison-es-1.27.html#SEC39">Archivos de Gramática de Bison</A>.

</P>
<P>
Un símbolo no terminal en la gramática formal se representa en la entrada
de Bison como un identificador, similar a un identificador en C.  Por
convención, deberían estar en minúsculas, tales como <CODE>expr</CODE>, <CODE>stmt</CODE> o
<CODE>declaracion</CODE>.

</P>
<P>
La representación en Bison para un símbolo terminal se llama también un
<STRONG>tipo de token</STRONG>.  Los tipos de tokens también se pueden representar como
identificadores al estilo de C.  Por convención, estos identificadores deberían
estar en mayúsculas para distinguirlos de los no terminales: por ejemplo,
<CODE>INTEGER</CODE>, <CODE>IDENTIFICADOR</CODE>, <CODE>IF</CODE> o <CODE>RETURN</CODE>.  Un símbolo
terminal que represente una palabra clave en particular en el lenguaje debería
bautizarse con el nombre después de pasarlo a mayúsculas.  El símbolo terminal
<CODE>error</CODE> se reserva para la recuperación de errores.
See section <A HREF="bison-es-1.27.html#SEC45">Símbolos, Terminales y No Terminales</A>.

</P>
<P>
Un símbolo terminal puede representarse también como un caracter literal,
al igual que una constante de caracter en C.  Debería hacer esto siempre que un
token sea simplemente un único caracter (paréntesis, signo-más, etc.): use
el mismo caracter en un literal que el símbolo terminal para ese token.

</P>
<P>
Una tercera forma de representar un símbolo terminal es con una cadena
de caracteres de C conteniendo varios caracteres.  See section <A HREF="bison-es-1.27.html#SEC45">Símbolos, Terminales y No Terminales</A>, para más
información.

</P>
<P>
Las reglas gramaticales tienen también una expresión en la sintaxis de
Bison.  Por ejemplo, aquí está la regla en Bison para una sentencia
<CODE>return</CODE> de C.  El punto y coma entre comillas es un token de caracter
literal, representando parte de la sintaxis de C para la sentencia; el
punto y coma al descubierto, y los dos puntos, es puntuación de Bison que se
usa en todas las reglas. 

</P>

<PRE>
stmt:   RETURN expr ';'
        ;
</PRE>

<P>
See section <A HREF="bison-es-1.27.html#SEC46">Sintaxis de las Reglas Gramaticales</A>.

</P>


<H2><A NAME="SEC15" HREF="bison-es-1.27.html#TOC15">Valores Semánticos</A></H2>
<P>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>

</P>
<P>
Una gramática formal selecciona tokens únicamente por sus clasificaciones: por
ejemplo, si una regla menciona el símbolo terminal `constante entera', quiere
decir que <EM>cualquier</EM> constante entera es gramaticalmente válida en esa
posición.  El valor preciso de la constante es irrelevante en cómo se analiza
la entrada: si <SAMP>`x+4'</SAMP> es gramatical entonces <SAMP>`x+1'</SAMP> o <SAMP>`x+3989'</SAMP> es
igualmente gramatical.
</P>
<P>
Pero el valor preciso es muy importante para lo que significa la entrada una
vez que es analizada. ¡Un compilador es inservible si no puede distinguir
entre 4, 1 y 3989 como constantes en el programa!  Por lo tanto, cada token en
una gramática de Bison tiene ambos, un tipo de token y un <STRONG>valor
semántico</STRONG>.  See section <A HREF="bison-es-1.27.html#SEC48">Definiendo la Semántica del Lenguaje</A>, 
para detalles.

</P>
<P>
El tipo de token es un símbolo terminal definido en la gramática, tal como
<CODE>INTEGER</CODE>, <CODE>IDENTIFICADOR</CODE> o <CODE>','</CODE>.  Este dice todo lo que se
necesita para saber decidir dónde podría aparecer válidamente el token y cómo
agruparlo con los otros tokens.  Las reglas gramaticales no saben nada acerca
de los tokens excepto de sus tipos.
</P>
<P>
El valor semántico tiene todo el resto de información a cerca del 
significado del token, tal como el valor de un entero, o el nombre de un
identificador. (Un token tal como <CODE>','</CODE> que es solo un signo de
puntuación no necesita tener ningún valor semántico.)

</P>
<P>
Por ejemplo, un token de entrada podría clasificarse como un tipo de token
<CODE>INTEGER</CODE> y tener el valor semántico 4.  Otro token de entrada podría
tener el mismo tipo de token <CODE>INTEGER</CODE> pero valor 3989.  Cuando una regla
gramatical dice que se admite un <CODE>INTEGER</CODE>, cualquiera de estos tokens se
acepta porque cada uno es un <CODE>INTEGER</CODE>.  Cuando el analizador acepta el
token, este no pierde la pista del valor semántico del token.

</P>
<P>
Cada agrupación puede tener también un valor semántico al igual que
su símbolo no terminal.  Por ejemplo, en una calculadora, una expresión
típicamente tiene un valor semántico que es un número.  En un compilador
para un lenguaje de programación, una expresión típicamente tiene un
valor semántico que es una estructura en árbol describiendo el
significado de la expresión.

</P>


<H2><A NAME="SEC16" HREF="bison-es-1.27.html#TOC16">Acciones Semánticas</A></H2>
<P>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>

</P>
<P>
Para que sea útil, un programa debe hacer algo más que analizar la
entrada; este debe producir también alguna salida basada en la entrada.
En una gramática de Bison, una regla gramatical puede tener una
<STRONG>acción</STRONG> compuesta de sentencias en C.  Cada vez que el analizador
reconozca una correspondencia para esa regla, se ejecuta la acción.
See section <A HREF="bison-es-1.27.html#SEC51">Acciones</A>.
        
La mayor parte del tiempo, el propósito de una acción es computar el
valor semántico de la construcción completa a partir de los valores
semánticos de sus partes.  Por ejemplo, suponga que tenemos una regla que
dice que una expresión puede ser la suma de dos expresiones.  Cuando el
analizador reconozca tal suma, cada una de las subexpresiones posee un
valor semántico que describe cómo fueron elaboradas.  La acción para
esta regla debería crear un tipo de valor similar para la expresión
mayor que se acaba de reconocer.

</P>
<P>
Por ejemplo, he aquí una regla que dice que una expresión puede ser
la suma de dos subexpresiones:

</P>

<PRE>
expr: expr '+' expr   { $$ = $1 + $3; }
        ;
</PRE>

<P>
La acción dice cómo producir el valor semántico de la expresión suma
a partir de los valores de las dos subexpresiones.

</P>


<H2><A NAME="SEC17" HREF="bison-es-1.27.html#TOC17">La Salida de Bison: el Archivo del Analizador</A></H2>
<P>
<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
<A NAME="IDX20"></A>
<A NAME="IDX21"></A>

</P>
<P>
Cuando ejecuta Bison, usted le da un archivo de gramática de Bison como
entrada.  La salida es un programa fuente en C que analiza el lenguaje
descrito por la gramática.  Este archivo se denomina un <STRONG>analizador
de Bison</STRONG>.  Tenga en cuenta que la utilidad Bison y el analizador de
Bison son dos programas distintos: la utilidad Bison es un programa cuya
salida es el analizador de Bison que forma parte de su programa.

</P>
<P>
El trabajo del analizador de Bison es juntar tokens en agrupaciones de acuerdo
a las reglas gramaticales--por ejemplo, construir expresiones con
identificadores y operadores.  A medida que lo hace, este ejecuta las
acciones de las reglas gramaticales que utiliza.

</P>
<P>
Los tokens provienen de una función llamada el <STRONG>analizador léxico</STRONG>
que usted debe proveer de alguna manera (por ejemplo escribiéndola en C). El
analizador de Bison llama al analizador léxico cada vez que quiera un
nuevo token.  Este no sabe qué hay "dentro" de los tokens (aunque sus
valores semánticos podrían reflejarlo).  Típicamente el analizador
léxico construye los tokens analizando los caracteres del texto, pero
Bison no depende de ello. See section <A HREF="bison-es-1.27.html#SEC66">La Funcion del Analizador Léxico <CODE>yylex</CODE></A>. 

</P>
<P>
El fichero del analizador de Bison es código C que define una función llamada
<CODE>yyparse</CODE> que implementa esa gramática.  Esta función no forma
un programa completo en C: debe proveer algunas funciones
adicionales.  Una es el analizador léxico.  Otra es una función de informe
de errores a la que el analizador llama para informar de un error.  Además,
un programa completo en C debe comenzar con una función llamada
<CODE>main</CODE>; debe facilitarla, y colocar en esta una llamada a
<CODE>yyparse</CODE> o el analizador no será ejecutado nunca.
See section <A HREF="bison-es-1.27.html#SEC64">Interfaz del Analizador en Lenguaje C</A>.

</P>
<P>
A parte de los nombres de tipo de token y los símbolos en las
acciones que escriba, todos los nombres de variable y funciones usados
en el archivo del analizador de Bison comienzan con <SAMP>`yy'</SAMP> o <SAMP>`YY'</SAMP>.
Esto incluye las funciones de interfaz tales como la función del
analizador léxico <CODE>yylex</CODE>, la función de informe de errores
<CODE>yyerror</CODE> y la propia función del analizador <CODE>yyparse</CODE>.
Esto también incluye un gran número de identificadores utilizados
para uso interno.  Por lo tanto, debería evitar utilizar identificadores
de C que comiencen con <SAMP>`yy'</SAMP> o <SAMP>`YY'</SAMP> en el archivo de la gramática
de Bison excepto para aquellos definidos en este manual.

</P>


<H2><A NAME="SEC18" HREF="bison-es-1.27.html#TOC18">Etapas en el Uso de Bison</A></H2>
<P>
<A NAME="IDX22"></A>
<A NAME="IDX23"></A>

</P>
<P>
El proceso real de diseño de lenguajes utilizando Bison, desde
la especificación de la gramática hasta llegar a un compilador o intérprete
funcional, se compone de estas etapas:

</P>

<OL>
<LI>

Especificar formalmente la gramática en un formato que reconozca Bison
(see section <A HREF="bison-es-1.27.html#SEC39">Archivos de Gramática de Bison</A>).  Para
cada regla gramatical en el lenguaje, describir la acción que se va a
tomar cuando una instancia de esa regla sea reconocida.  La acción se
descibe por una secuencia de sentencias en C.

<LI>

Escribir un analizador léxico para procesar la entrada y pasar tokens al
analizador sintáctico.  El analizador léxico podría escribirse a mano en C
(see section <A HREF="bison-es-1.27.html#SEC66">La Funcion del Analizador Léxico <CODE>yylex</CODE></A>).  Este puede
también generarse utilizando Lex, pero el uso de Lex no se trata en este
manual.

<LI>

Escibir una función de control que llame al analizador producido por Bison.

<LI>

Escribir las rutinas de infome de errores.
</OL>

<P>
Para hacer que este código fuente escrito se convierta en un programa
ejecutable, debe seguir estos pasos:

</P>

<OL>
<LI>

Ejecutar Bison sobre la gramática para producir el analizador.

<LI>

Compilar el código de salida de Bison, al igual que cualquier otro
fichero fuente.

<LI>

Enlazar los ficheros objeto para producir el producto final.
</OL>



<H2><A NAME="SEC19" HREF="bison-es-1.27.html#TOC19">El Formato Global de una Gramática de Bison</A></H2>
<P>
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>
<A NAME="IDX26"></A>
<A NAME="IDX27"></A>

</P>
<P>
El fichero de entrada para la utilidad Bison es un <STRONG>archivo de
gramatica de Bison</STRONG>.  La forma general de una gramática de Bison es la
siguiente: 

</P>

<PRE>
%{
<VAR>declaraciones en C</VAR>
%}

<VAR>Declaraciones de Bison</VAR>

%%
<VAR>Reglas gramaticales</VAR>
%%
<VAR>Código C adicional</VAR>
</PRE>

<P>
Los <SAMP>`%%'</SAMP>, <SAMP>`%{'</SAMP> y <SAMP>`%}'</SAMP> son signos de puntuación que aparecen
en todo archivo de gramática de Bison para separar las secciones.

</P>
<P>
Las declaraciones en C podrían definir tipos y variables utilizadas en
las acciones.  Puede también usar comandos del preprocesador para
definir macros que se utilicen ahí, y utilizar <CODE>#include</CODE> para
incluir archivos de cabecera que realicen cualquiera de estas cosas.

</P>
<P>
Las declaraciones de Bison declaran los nombres de los símbolos terminales
y no terminales, y también podrían describir la precedencia de operadores y
los tipos de datos de los valores semánticos de varios símbolos.

</P>
<P>
Las reglas gramaticales definen cómo construir cada símbolo no terminal
a partir de sus partes.

</P>
<P>
El código C adicional puede contener cualquier código C que desee
utilizar.  A menudo suele ir la definición del analizador léxico
<CODE>yylex</CODE>, más subrutinas invocadas por las acciones en la reglas
gramaticales.  En un programa simple, todo el resto del programa puede ir aquí.

</P>


<H1><A NAME="SEC20" HREF="bison-es-1.27.html#TOC20">Ejemplos</A></H1>
<P>
<A NAME="IDX28"></A>

</P>
<P>
Ahora presentaremos y explicaremos tres programas de ejemplo escritos
utilizando Bison; una calculadora de notación polaca inversa, una
calculadora de notación algebraica (infija), y una calculadora
multi-función.  Los tres han sido comprobados bajo BSD Unix 4.3; cada
uno produce una utilizable, aunque limitada, calculadora de escritorio.

</P>
<P>
Estos ejemplos son simples, pero las gramáticas de Bison para lenguajes
de programación reales se escriben de la misma manera.

</P>



<H2><A NAME="SEC21" HREF="bison-es-1.27.html#TOC21">Calculadora de Notación Polaca Inversa</A></H2>
<P>
<A NAME="IDX29"></A>
<A NAME="IDX30"></A>
<A NAME="IDX31"></A>
<A NAME="IDX32"></A>

</P>
<P>
El primer ejemplo es el de una simple calculadora de doble precisión de
<STRONG>notación polaca inversa</STRONG> (una calculadora que utiliza operadores
postfijos).  Este ejemplo provee un buen punto de partida, ya que no hay
problema con la precedencia de operadores.  El segundo ejemplo ilustrará
cómo se maneja la precendencia de operadores.

</P>
<P>
El código fuente para esta calculadora se llama <TT>`rpcalc.y'</TT>. La
extensión <SAMP>`.y'</SAMP> es una convención utilizada para los archivos
de entrada de Bison.

</P>



<H3><A NAME="SEC22" HREF="bison-es-1.27.html#TOC22">Declaraciones para <CODE>rpcalc</CODE></A></H3>

<P>
Aqui están las declaraciones de C y Bison para la calculadora de notación
polaca inversa.  Como en C, los comentarios se colocan entre
<SAMP>`/*...*/'</SAMP>.

</P>

<PRE>
/* Calculadora de notación polaca inversa. */

%{
#define YYSTYPE double
#include &#60;math.h&#62;
%}

%token NUM

%% /* A continuación las reglas gramaticales y las acciones */
</PRE>

<P>
La sección de declaraciones en C (see section <A HREF="bison-es-1.27.html#SEC41">La Sección de Declaraciones en C</A>) contiene dos directivas del preprocesador.

</P>
<P>
La directiva <CODE>#define</CODE> define la macro <CODE>YYSTYPE</CODE>, de este modo
se especifica el tipo de dato de C para los valores semánticos de ambos,
tokens y agrupaciones (see section <A HREF="bison-es-1.27.html#SEC49">Tipos de Datos para Valores Semánticos</A>).
El analizador de Bison utilizará cualquier tipo que se defina 
para <CODE>YYSTYPE</CODE>; si no lo define, por defecto es <CODE>int</CODE>.
Como hemos especificado <CODE>double</CODE>, cada token y cada expresión
tiene un valor asociado, que es un número en punto flotante.

</P>
<P>
La directiva <CODE>#include</CODE> se utiliza para declarar la función de
exponenciación <CODE>pow</CODE>.

</P>
<P>
La segunda sección, declaraciones de Bison, provee información a Bison a cerca
de los tipos de tokens (see section <A HREF="bison-es-1.27.html#SEC42">La Sección de Declaraciones de Bison</A>).
Cada símbolo terminal que no sea un caracter literal simple debe
ser declarado aquí (Los caracteres literales simples no necesitan ser
declarados.)  En este ejemplo, todos los operadores aritméticos se
designan por un caracter literal simple, así que el único símbolo
terminal que necesita ser declarado es <CODE>NUM</CODE>, el tipo de token para
las constantes numéricas.

</P>


<H3><A NAME="SEC23" HREF="bison-es-1.27.html#TOC23">Reglas Gramaticales para <CODE>rpcalc</CODE></A></H3>

<P>
Aquí están las reglas gramaticales para una calculadora de notación
polaca inversa.

</P>

<PRE>
input:    /* vacío */
        | input line
;

line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;

exp:      NUM             { $$ = $1;         }
        | exp exp '+'     { $$ = $1 + $2;    }
        | exp exp '-'     { $$ = $1 - $2;    }
        | exp exp '*'     { $$ = $1 * $2;    }
        | exp exp '/'     { $$ = $1 / $2;    }
      /* Exponenciación */
        | exp exp '^'     { $$ = pow ($1, $2); }
      /* Menos unario   */
        | exp 'n'         { $$ = -$1;        }
;
%%
</PRE>

<P>
Las agrupaciones del "lenguaje" de rpcalc definidas aquí son la expresión
(con el nombre <CODE>exp</CODE>), la línea de entrada (<CODE>line</CODE>), y la
transcripción completa de la entrada (<CODE>input</CODE>).  Cada uno de estos
símbolos no terminales tiene varias reglas alternativas, unidas por el
puntuador <SAMP>`|'</SAMP> que se lee como "o". Las siguientes secciones explican
lo que significan estas reglas.

</P>
<P>
La semántica del lenguaje se determina por las acciones que se toman cuando
una agrupación es reconocida.  Las acciones son el código C que aparecen
entre llaves.  See section <A HREF="bison-es-1.27.html#SEC51">Acciones</A>.

</P>
<P>
Debe especificar estas acciones en C, pero Bison facilita la forma de
pasar valores semánticos entre las reglas.  En cada acción, la
pseudo-variable <CODE>$$</CODE> representa el valor semántico para la agrupación
que la regla va a construir.  El trabajo principal de la mayoría de las
acciones es la asignación de un valor para <CODE>$$</CODE>.  Se accede al valor
semántico de los componentes de la regla con <CODE>$1</CODE>, <CODE>$2</CODE>, y
así sucesivamente. 

</P>



<H4><A NAME="SEC24" HREF="bison-es-1.27.html#TOC24">Explicación para <CODE>input</CODE></A></H4>

<P>
Considere la definición de <CODE>input</CODE>:

</P>

<PRE>
input:    /* vacío */
        | input line
;
</PRE>

<P>
Esta definición se interpreta así: "Una entrada completa es o una cadena
vacía, o una entrada completa seguida por una línea de entrada".  Note que
"entrada completa" se define en sus propios términos.  Se dice que esta
definición es <STRONG>recursiva por la izquierda</STRONG> ya que <CODE>input</CODE> aparece
siempre como el símbolo más a la izquierda en la
secuencia.   See section <A HREF="bison-es-1.27.html#SEC47">Reglas Recursivas</A>.

</P>
<P>
La primera alternativa está vacía porque no hay símbolos entre
los dos puntos y el primer <SAMP>`|'</SAMP>; esto significa que <CODE>input</CODE> puede
corresponder con una cadena de entrada vacía (sin tokens).  Escribimos estas
reglas de esa manera porque es legítimo escribir <KBD>Ctrl-d</KBD> después de
arrancar la calculadora.  Es clásico poner una alternativa vacía
al principio y escribir en esta el comentario <SAMP>`/* vacío */'</SAMP>.

</P>
<P>
La segunda alternativa de la regla (<CODE>input line</CODE>) maneja toda la entrada
no trivial.  Esta significa, "Después de leer cualquier número de
líneas, leer una más si es posible".  La recursividad por la izquierda
convierte esta regla en un bucle.  Ya que la primera alternativa concuerda
con la entrada vacía, el bucle se puede ejecutar cero o más veces.

</P>
<P>
La función <CODE>yyparse</CODE> del analizador continúa con el procesamiento de la
entrada hasta que se encuentre con un error gramatical o el analizador diga
que no hay más tokens de entrada; convendremos que esto último sucederá
al final del fichero.

</P>


<H4><A NAME="SEC25" HREF="bison-es-1.27.html#TOC25">Explicación para <CODE>line</CODE></A></H4>

<P>
Ahora considere la definición de <CODE>line</CODE>:

</P>

<PRE>
line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;
</PRE>

<P>
La primera alternativa es un token que es un caracter de nueva-línea; esta
quiere decir que rpcalc acepta un línea en blanco (y la ignora, ya que no
hay ninguna acción).  La segunda alternativa es una expresión seguida de
una línea nueva.  Esta es la alternativa que hace que rpcalc sea útil.  El
valor semántico de la agrupación <CODE>exp</CODE> es el valor de <CODE>$1</CODE> porque
la <CODE>exp</CODE> en cuestión es el primer símbolo en la alternativa.  La acción
imprime este valor, que es el resultado del cálculo que solicitó el usuario.

</P>
<P>
Esta acción es poco común porque no asigna un valor a <CODE>$$</CODE>.  Como
consecuencia, el valor semántico asociado con <CODE>line</CODE> está sin
inicializar (su valor será impredecible).  Se trataría de un error si
ese valor se utilizara, pero nosotros no lo utilizaremos: una vez que
rpcalc haya imprimido el valor de la línea de entrada del usuario, ese
valor no se necesitará más.

</P>


<H4><A NAME="SEC26" HREF="bison-es-1.27.html#TOC26">Explicación para <CODE>expr</CODE></A></H4>

<P>
La agrupación <CODE>exp</CODE> tiene varias reglas, una para cada tipo de
expresión.  La primera regla maneja la expresiones más simples: aquellas
que son solamente números.  La segunda maneja una expresión de adición,
que tiene el aspecto de dos expresiones seguidas de un signo más.  La tercera
maneja la resta, y así sucesivamente.

</P>

<PRE>
exp:      NUM
        | exp exp '+'     { $$ = $1 + $2;    }
        | exp exp '-'     { $$ = $1 - $2;    }
        ...
        ;
</PRE>

<P>
Hemos utilizado <SAMP>`|'</SAMP> para unir las tres reglas de <CODE>exp</CODE>, pero
igualmente podríamos haberlas escrito por separado:

</P>

<PRE>
exp:      NUM ;
exp:      exp exp '+'     { $$ = $1 + $2;    } ;
exp:      exp exp '-'     { $$ = $1 - $2;    } ;
        ...
</PRE>

<P>
La mayoría de las reglas tienen acciones que computan el valor de la expresión
en términos del valor de sus componentes.  Por ejemplo, en la regla de la
adición, <CODE>$1</CODE> hace referencia al primer componenete <CODE>exp</CODE> y
<CODE>$2</CODE> hace referencia al segundo.  El tercer componente, <CODE>'+'</CODE>,
no tiene un valor semántico asociado con significado, pero si tuviese
alguno podría hacer referencia a este con <CODE>$3</CODE>.  Cuando
<CODE>yyparse</CODE> reconoce una expresión de suma usando esta regla, la suma
de los valores de las dos subexpresiones producen el valor de toda la
expresión.  See section <A HREF="bison-es-1.27.html#SEC51">Acciones</A>.

</P>
<P>
Usted no tiene de dar una acción para cada regla.  Cuando una regla no
tenga acción, por defecto Bison copia el valor de <CODE>$1</CODE> en <CODE>$$</CODE>.
Esto es lo que sucede en la primera regla (la que usa <CODE>NUM</CODE>).

</P>
<P>
El formato mostrado aquí es la convención recomendada, pero Bison no lo
requiere.  Puede añadir o cambiar todos los espacios en blanco que desee.
Por ejemplo, esto:

</P>

<PRE>
exp   : NUM | exp exp '+' {$$ = $1 + $2; } | ...
</PRE>

<P>
expresa lo mismo que esto:

</P>

<PRE>
exp:      NUM
        | exp exp '+'    { $$ = $1 + $2; }
        | ...
</PRE>

<P>
El último, sin embargo, es mucho más legible.

</P>


<H3><A NAME="SEC27" HREF="bison-es-1.27.html#TOC27">El Analizador Léxico de <CODE>rpcalc</CODE></A></H3>
<P>
<A NAME="IDX33"></A>
<A NAME="IDX34"></A>
<A NAME="IDX35"></A>

</P>
<P>
El trabajo del analizador léxico es el análisis a bajo nivel: la conversión
de los caracteres o secuencia de caracteres en tokens.  El analizador de Bison
obtiene sus tokens llamando al analizador léxico.
See section <A HREF="bison-es-1.27.html#SEC66">La Funcion del Analizador Léxico <CODE>yylex</CODE></A>. 

</P>
<P>
Solamente se necesita un analizador léxico sencillo para la calculadora
RPN.  Este analizador léxico ignora los espacios en blanco y los
tabuladores, luego lee los números como <CODE>double</CODE> y los devuelve
como tokens <CODE>NUM</CODE>.  Cualquier otro caracter que no forme parte de un
número es un token por separado.  Tenga en cuenta que el código del token
para un token de caracter simple es el propio caracter.

</P>
<P>
El valor de retorno de la función de análisis léxico es un código numérico
que representa el tipo de token.  El mismo texto que se utilizó en las reglas
de Bison para representar el tipo de token también es una expresión en C con el
valor numérico del tipo.  Esto funciona de dos maneras.  Si el tipo de token es
un caracter literal, entonces su código numérico es el código ASCII
de ese caracter; puede usar el mismo caracter literal en el analizador léxico
para expresar el número.  Si el tipo de token es un identificador, ese
identificador lo define Bison como una macro en C cuya definición es un
número apropiado.  En este ejemplo, por lo tanto, <CODE>NUM</CODE> se convierte
en una macro para que la use <CODE>yylex</CODE>.

</P>
<P>
El valor semántico del token (si tiene alguno) se almacena en la variable
global <CODE>yylval</CODE>, que es donde el analizador de Bison lo buscará.
(El tipo de datos de C para <CODE>yylval</CODE> es <CODE>YYSTYPE</CODE>, que se definió
al principio de la gramática; see section <A HREF="bison-es-1.27.html#SEC22">Declaraciones para <CODE>rpcalc</CODE></A>.)

</P>
<P>
Se devuelve un código de tipo de token igual a cero cuando se llega al final
del fichero.  (Bison reconoce cualquier valor no positivo como indicador
del final del fichero de entrada.)

</P>
<P>
Aquí está el código para el analizador léxico:

</P>

<PRE>
/* El analizador léxico devuelve un número en coma
   flotante (double) en la pila y el token NUM, o el
   caracter ASCII leído si no es un número.  Ignora
   todos los espacios en blanco y tabuladores,
   devuelve 0 como EOF. */

#include &#60;ctype.h&#62;

yylex ()
{
  int c;

  /* ignora los espacios en blanco */
  while ((c = getchar ()) == ' ' || c == '\t')  
    ;
  /* procesa números   */
  if (c == '.' || isdigit (c))                
    {
      ungetc (c, stdin);
      scanf ("%lf", &#38;yylval);
      return NUM;
    }
  /* devuelve fin-de-fichero  */
  if (c == EOF)                            
    return 0;
  /* devuelve caracteres sencillos */
  return c;                                
}
</PRE>



<H3><A NAME="SEC28" HREF="bison-es-1.27.html#TOC28">La Función de Control</A></H3>
<P>
<A NAME="IDX36"></A>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>

</P>
<P>
Para continuar acordes a este ejemplo, la función de control
se mantiene escueta al mínimo.  El único requisito es que llame a
<CODE>yyparse</CODE> para comenzar el proceso de análisis.

</P>

<PRE>
main ()
{
  yyparse ();
}
</PRE>



<H3><A NAME="SEC29" HREF="bison-es-1.27.html#TOC29">La Rutina de Informe de Errores</A></H3>
<P>
<A NAME="IDX39"></A>
<A NAME="IDX40"></A>

</P>
<P>
Cundo <CODE>yyparse</CODE> detecta un error de sintaxis, realiza una llamada a la
función de informe de errores <CODE>yyerror</CODE> para que imprima un mensaje
de error (normalmente pero no siempre un <CODE>"parse error"</CODE>).  Es cosa
del programador el proveer <CODE>yyerror</CODE> (see section <A HREF="bison-es-1.27.html#SEC64">Interfaz del Analizador en Lenguaje C</A>), luego aquí está la definición que utilizaremos:

</P>

<PRE>
#include &#60;stdio.h&#62;

yyerror (s)  /* Llamada por yyparse ante un error */
     char *s;
{
  printf ("%s\n", s);
}
</PRE>

<P>
Después de que <CODE>yyerror</CODE> retorne, el analizador de Bison podría
recuperarse del error y continuar analizando si la gramática contiene una
regla de error apropiada (see section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>).  De otra
manera, <CODE>yyparse</CODE> devolverá un valor distinto de cero.  No hemos
escrito ninguna regla de error en este ejemplo, así que una entrada no
válida provocará que termine el programa de la calculadora.  Este no es
el comportamiento adecuado para una calculadora real, pero es adecuado
en el primer ejemplo.

</P>


<H3><A NAME="SEC30" HREF="bison-es-1.27.html#TOC30">Ejecutando Bison para Hacer el Analizador</A></H3>
<P>
<A NAME="IDX41"></A>

</P>
<P>
Antes de ejecutar Bison para producir un analizador, necesitamos decidir
cómo ordenar todo en código fuente en uno o más ficheros fuente.  Para
un ejemplo tan sencillo, la manera más fácil es poner todo en un archivo.
Las definiciones de <CODE>yylex</CODE>, <CODE>yyerror</CODE> y <CODE>main</CODE> van al final,
en la sección de "código C adicional" del fichero.
(see section <A HREF="bison-es-1.27.html#SEC19">El Formato Global de una Gramática de Bison</A>).

</P>
<P>
Para un proyecto más grande, probablemente tendría varios ficheros fuente, y
utilizaría <CODE>make</CODE> para ordenar la recompilación de estos.

</P>
<P>
Con todo el fuente en un único archivo, utilice el siguiente comando para
convertirlo en el fichero del analizador:

</P>

<PRE>
bison <VAR>nombre_archivo</VAR>.y
</PRE>

<P>
En este ejemplo el archivo se llamó <TT>`rpcalc.y'</TT> (de "Reverse Polish
CALCulator", "Calculadora Polaca Inversa").  Bison produce un archivo
llamado <TT>`<VAR>nombre_archivo</VAR>.tab.c'</TT>, 
quitando el <SAMP>`.y'</SAMP> del nombre del fichero original.  El fichero de salida
de Bison contiene el código fuente para <CODE>yyparse</CODE>.  Las funciones
adicionales en el fichero de entrada (<CODE>yylex</CODE>, <CODE>yyerror</CODE> y
<CODE>main</CODE>) se copian literalmente a la salida.

</P>


<H3><A NAME="SEC31" HREF="bison-es-1.27.html#TOC31">Compilando el Archivo del Analizador</A></H3>
<P>
<A NAME="IDX42"></A>

</P>
<P>
Aquí está la forma de compilar y ejecutar el archivo del analizador:

</P>

<PRE>
# Lista los archivos en el directorio actual.
% ls
rpcalc.tab.c  rpcalc.y

# Compila el analizador de Bison.
# <SAMP>`-lm'</SAMP> le dice al compilador que busque la librería math para <CODE>pow</CODE>.
% cc rpcalc.tab.c -lm -o rpcalc

# Lista de nuevo los archivos.
% ls
rpcalc  rpcalc.tab.c  rpcalc.y
</PRE>

<P>
El archivo <TT>`rpcalc'</TT> contiene ahora el código ejecutable.  He aquí
una sesión de ejemplo utilizando <CODE>rpcalc</CODE>.

</P>

<PRE>
% rpcalc
4 9 +
13
3 7 + 3 4 5 *+-
-13
3 7 + 3 4 5 * + - n              Note el menos unario, <SAMP>`n'</SAMP>
13
5 6 / 4 n +
-3.166666667
3 4 ^                            Exponenciación
81
^D                               Indicador de Fin-de-fichero
%
</PRE>



<H2><A NAME="SEC32" HREF="bison-es-1.27.html#TOC32">Calculadora de Notación Infija: <CODE>calc</CODE></A></H2>
<P>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>
<A NAME="IDX45"></A>

</P>
<P>
Ahora modificaremos rpcalc para que maneje operadores infijos en lugar
de postfijos.  La notación infija trae consigo el concepto de la
precedencia de operadores y la necesidad de paréntesis anidados de
profundidad arbitraria.  Aquí está el código de Bison para
<TT>`calc.y'</TT>, una calculadora infija de escritorio.

</P>

<PRE>
/* Calculadora de notación infija--calc */

%{
#define YYSTYPE double
#include &#60;math.h&#62;
%}

/* Declaraciones de BISON */
%token NUM
%left '-' '+'
%left '*' '/'
%left NEG     /* negación--menos unario */
%right '^'    /* exponenciación         */

/* A continuación la gramática */
%%
input:    /* cadena vacía */
        | input line
;

line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;

exp:      NUM                { $$ = $1;         }
        | exp '+' exp        { $$ = $1 + $3;    }
        | exp '-' exp        { $$ = $1 - $3;    }
        | exp '*' exp        { $$ = $1 * $3;    }
        | exp '/' exp        { $$ = $1 / $3;    }
        | '-' exp  %prec NEG { $$ = -$2;        }
        | exp '^' exp        { $$ = pow ($1, $3); }
        | '(' exp ')'        { $$ = $2;         }
;
%%
</PRE>

<P>
Las funciones <CODE>yylex</CODE>, <CODE>yyerror</CODE> y <CODE>main</CODE> pueden ser
las mismas de antes.

</P>
<P>
Hay dos propiedades nuevas importantes presentadas en este código.

</P>
<P>
En la segunda sección (declaraciones de Bison), <CODE>%left</CODE> declara
tipos de tokens y dice que son operadores asociativos por la izquierda.
Las declaraciones <CODE>%left</CODE> y <CODE>%right</CODE> (asociatividad por la derecha)
toma el lugar de <CODE>%token</CODE> que se utiliza para declarar un nombre de
tipo de token sin asociatividad.  (Estos tokens son caracteres literales
simples, que de forma ordinaria no tienen que ser declarados.  Los 
declaramos aquí para especificar la asociatividad.)

</P>
<P>
La precedencia de operadores se determina por el orden de línea
de las declaraciones; cuanto más alto sea el número de línea
de la declaración (esta esté más baja en la página o en la pantalla), 
más alta será la precedencia.  Por tanto, la exponenciación
tiene la precedencia más alta, el menos unario (<CODE>NEG</CODE>) es el
siguiente, seguido por <SAMP>`*'</SAMP> y <SAMP>`/'</SAMP>, y
así sucesivamente.  See section <A HREF="bison-es-1.27.html#SEC76">Precedencia de Operadores</A>.

</P>
<P>
La otra propiedad nueva importante es el <CODE>%prec</CODE> en la sección de
la gramática para el operador menos unario.  El <CODE>%prec</CODE> simplemente
le dice a Bison que la regla <SAMP>`| '-' exp'</SAMP> tiene la misma precedencia
que <CODE>NEG</CODE>---en este caso la siguiente
a la más alta.  See section <A HREF="bison-es-1.27.html#SEC81">Precedencia Dependiente del Contexto</A>.

</P>
<P>
Aquí hay un ejemplo de la ejecución de <TT>`calc.y'</TT>:

</P>

<PRE>
% calc
4 + 4.5 - (34/(8*3+-3))
6.880952381
-56 + 2
-54
3 ^ 2
9
</PRE>



<H2><A NAME="SEC33" HREF="bison-es-1.27.html#TOC33">Recuperación de Errores Simple</A></H2>
<P>
<A NAME="IDX46"></A>

</P>
<P>
Hasta este punto, este manual no ha tratado el tema de la <STRONG>recuperación
de errores</STRONG>---cómo continuar analizando después de que el analizador detecte
un error de sintaxis.  Todo lo que hemos manejado es el informe de errores con
<CODE>yyerror</CODE>. Tenga presente que por defecto <CODE>yyparse</CODE> retorna
después de llamar a <CODE>yyerror</CODE>.  Esto quiere decir que una línea de
entrada errónea hace que el programa de la calculadora finalice.  Ahora
mostraremos cómo rectificar esta deficiencia.

</P>
<P>
El lenguaje de Bison por sí mismo incluye la palabra reservada
<CODE>error</CODE>, que podría incluirse en las reglas de la gramática.  En el
siguiente ejemplo esta se ha añadido a una de las alternativas para <CODE>line</CODE>:

</P>

<PRE>
line:     '\n'
        | exp '\n'   { printf ("\t%.10g\n", $1); }
        | error '\n' { yyerrok;                  }
;
</PRE>

<P>
Esta ampliación a la gramática permite una recuperación de errores simple
en caso de un error de análisis.  Si se lee una expresión que no puede
ser evaluada, el error será reconocido por la tercera regla de <CODE>line</CODE>, y
el análisis continuará.  (La función <CODE>yyerror</CODE> aún se sigue llamando para
imprimir su mensaje también.)  La acción ejecuta la sentencia
<CODE>yyerrok</CODE>, una macro definida automáticamente por Bison; su
significado es que la recuperación de errores ha terminado
(see section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>).  Note la diferencia entre
<CODE>yyerrok</CODE> y <CODE>yyerror</CODE>; no se trata de ninguna errata.
</P>
<P>
Esta forma de recuperación de errores trata con errores sintácticos.  Existe
otro tipo de errores; por ejemplo, la división entre cero, que conlleva
una señal de excepción que normalmente es fatal.  Una calculadora real
debe tratar esta señal y utilizar <CODE>longjmp</CODE> para retornar a <CODE>main</CODE>
y reanudar el análisis de líneas de entrada; también tendría que descartar
el resto de la línea de entrada actual.  No discutiremos esta cuestión
más allá porque no es específica de los programas de Bison.

</P>


<H2><A NAME="SEC34" HREF="bison-es-1.27.html#TOC34">Calculadora Multi-Función: <CODE>mfcalc</CODE></A></H2>
<P>
<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
<A NAME="IDX49"></A>

</P>
<P>
Ahora que se han explicado los conceptos básicos de Bison, es tiempo
de movernos a problemas más avanzados.  Las calculadoras anteriores
ofrecían solamente cinco funciones, <SAMP>`+'</SAMP>, <SAMP>`-'</SAMP>, <SAMP>`*'</SAMP>,
<SAMP>`/'</SAMP> y <SAMP>`^'</SAMP>.  Sería bueno tener una calculadora que
dispusiera de otras funciones matemáticas tales como <CODE>sin</CODE>,
<CODE>cos</CODE>, etc.

</P>
<P>
Es fácil añadir nuevos operadores a la calculadora infija siempre que
estos sean únicamente caracteres literales simples. El analizador léxico
<CODE>yylex</CODE> pasa todos lo caracteres no numéricos como tokens, luego
basta con nuevas reglas gramaticales para añadir un nuevo operador.  Pero
lo que queremos es algo más flexible: funciones incorporadas cuya
sintaxis tenga la siguiente forma:

</P>

<PRE>
<VAR>nombre_función</VAR> (<VAR>argumento</VAR>)
</PRE>

<P>
Al mismo tiempo, añadiremos memoria a la calculadora, permitiéndole
crear variables con nombre, almacenar valores en ellas, y utilizarlas
más tarde.  Aquí hay una sesión de ejemplo con la calculadora
multi-función:

</P>

<PRE>
% mfcalc
pi = 3.141592653589
3.1415926536
sin(pi)
0.0000000000
alpha = beta1 = 2.3
2.3000000000
alpha
2.3000000000
ln(alpha)
0.8329091229
exp(ln(beta1))
2.3000000000
%
</PRE>

<P>
Note que están permitidas las asignaciones múltiples y las funciones anidadas.

</P>



<H3><A NAME="SEC35" HREF="bison-es-1.27.html#TOC35">Declaraciones para <CODE>mfcalc</CODE></A></H3>

<P>
Aquí están las declaraciones de C y Bison para la calculadora multi-función.

</P>

<PRE>
%{
#include &#60;math.h&#62;  /* Para funciones matemáticas, cos(), sin(), etc. */
#include "calc.h"  /* Contiene definición de `symrec'                */
%}
%union {
double     val;  /* Para devolver números                            */
symrec  *tptr;   /* Para devolver punteros a la tabla de símbolos    */
}

%token &#60;val&#62;  NUM        /* Número simple en doble precisión         */
%token &#60;tptr&#62; VAR FNCT   /* Variable y Función                       */
%type  &#60;val&#62;  exp

%right '='
%left '-' '+'
%left '*' '/'
%left NEG     /* Negación--menos unario */
%right '^'    /* Exponenciación        */

/* A continuación la gramática */

%%
</PRE>

<P>
La gramática anterior introduce únicamente dos nuevas propiedades del
lenguaje de Bison.  Estas propiedades permiten que los valores semánticos
tengan varios tipos de datos. (see section <A HREF="bison-es-1.27.html#SEC50">Más de Un Tipo de Valor</A>).

</P>
<P>
La declaración <CODE>%union</CODE> especifica la lista completa de tipos posibles;
esta se encuentra en lugar de la definición de <CODE>YYSTYPE</CODE>.  Los tipos
permisibles son ahora double (para <CODE>exp</CODE> y <CODE>NUM</CODE>) y
puntero a entrada en la tabla de símbolos.  See section <A HREF="bison-es-1.27.html#SEC57">La Colección de Tipos de Valores</A>.

</P>
<P>
Ya que ahora los valores pueden tener varios tipos, es necesario asociar
un tipo con cada símbolo gramatical cuyo valor semántico se utilice.  Estos
símbolos son <CODE>NUM</CODE>, <CODE>VAR</CODE>, <CODE>FNCT</CODE>, y <CODE>exp</CODE>.  Sus
declaraciones aumentan con la información a cerca de su tipo de dato
(que se encuentra entre ángulos).

</P>
<P>
La construcción de Bison <CODE>%type</CODE> se utiliza para la declaración de
símbolos no terminales, al igual que <CODE>%token</CODE> se utiliza para
declarar tipos de tokens.  No hemos usado <CODE>%type</CODE> anteriormente
porque los símbolos no terminales se declaran implícitamente por las
reglas que los definen.  Pero <CODE>exp</CODE> debe ser declarado
explícitamente para poder especificar el tipo de su valor.  See section <A HREF="bison-es-1.27.html#SEC58">Símbolos No Terminales</A>.

</P>


<H3><A NAME="SEC36" HREF="bison-es-1.27.html#TOC36">Reglas Gramaticales para <CODE>mfcalc</CODE></A></H3>

<P>
Aquí están las reglas gramaticales para la calculadora multi-función.
La mayoría de ellas han sido copiadas directamente de <CODE>calc</CODE>; tres
reglas, aquellas que mencionan a <CODE>VAR</CODE> o <CODE>FNCT</CODE>, son nuevas.

</P>

<PRE>
input:   /* vacío */
        | input line
;

line:
          '\n'
        | exp '\n'   { printf ("\t%.10g\n", $1); }
        | error '\n' { yyerrok;                  }
;

exp:      NUM                { $$ = $1;                         }
        | VAR                { $$ = $1-&#62;value.var;              }
        | VAR '=' exp        { $$ = $3; $1-&#62;value.var = $3;     }
        | FNCT '(' exp ')'   { $$ = (*($1-&#62;value.fnctptr))($3); }
        | exp '+' exp        { $$ = $1 + $3;                    }
        | exp '-' exp        { $$ = $1 - $3;                    }
        | exp '*' exp        { $$ = $1 * $3;                    }
        | exp '/' exp        { $$ = $1 / $3;                    }
        | '-' exp  %prec NEG { $$ = -$2;                        }
        | exp '^' exp        { $$ = pow ($1, $3);               }
        | '(' exp ')'        { $$ = $2;                         }
;
/* Fin de la gramática */
%%
</PRE>



<H3><A NAME="SEC37" HREF="bison-es-1.27.html#TOC37">La Tabla de Símbolos de <CODE>mfcalc</CODE></A></H3>
<P>
<A NAME="IDX50"></A>

</P>
<P>
La calculadora multi-función requiere una tabla de símbolos para
seguir la pista de los nombres y significado de las variables y funciones.
Esto no afecta a las reglas gramaticales (excepto para las acciones) o las
declaraciones de Bison, pero requiere algunas funciones de apoyo
adicionales en C.

</P>
<P>
La tabla de símbolos de por sí contiene un lista enlazada de
registros.  Su definición, que está contenida en la cabecera
<TT>`calc.h'</TT>, es la siguiente.  Esta provee que, ya sean funciones o
variables, sean colocadas en la tabla.

</P>

<PRE>
/* Tipo de datos para enlaces en la cadena de símbolos.      */
struct symrec
{
  char *name;  /* nombre del símbolo                 */
  int type;    /* tipo del símbolo: bien VAR o FNCT  */
  union {
    double var;           /* valor de una VAR        */
    double (*fnctptr)();  /* valor de una FNCT       */
  } value;
  struct symrec *next;    /* campo de enlace         */
};

typedef struct symrec symrec;

/* La tabla de símbolos: una cadena de `struct symrec'.     */
extern symrec *sym_table;

symrec *putsym ();
symrec *getsym ();
</PRE>

<P>
La nueva versión de <CODE>main</CODE> incluye una llamada a <CODE>init_table</CODE>, una
función que inicializa la tabla de símbolos.  Aquí está esta, y también
<CODE>init_table</CODE>:

</P>

<PRE>
#include &#60;stdio.h&#62;

main ()
{
  init_table ();
  yyparse ();
}

yyerror (s)  /* Llamada por yyparse ante un error */
     char *s;
{
  printf ("%s\n", s);
}

struct init
{
  char *fname;
  double (*fnct)();
};

struct init arith_fncts[]
  = {
      "sin", sin,
      "cos", cos,
      "atan", atan,
      "ln", log,
      "exp", exp,
      "sqrt", sqrt,
      0, 0
    };

/* La tabla de símbolos: una cadena de `struct symrec'.  */
symrec *sym_table = (symrec *)0;

init_table ()  /* pone las funciones aritméticas en una tabla. */
{
  int i;
  symrec *ptr;
  for (i = 0; arith_fncts[i].fname != 0; i++)
    {
      ptr = putsym (arith_fncts[i].fname, FNCT);
      ptr-&#62;value.fnctptr = arith_fncts[i].fnct;
    }
}
</PRE>

<P>
Mediante la simple edición de la lista de inicialización y añadiendo los
archivos de inclusión necesarios, puede añadir funciones adicionales a la
calculadora.

</P>
<P>
Dos funciones importantes permiten la localización e inserción de símbolos
en la tabla de símbolos.  A la función <CODE>putsym</CODE> se le pasa un nombre y
el tipo (<CODE>VAR</CODE> o <CODE>FNCT</CODE>) del objeto a insertar.  El objeto se enlaza
por la cabeza de la lista, y devuelve un puntero al objeto.  A la función
<CODE>getsym</CODE> se le pasa el nombre del símbolo a localizar.  Si se encuentra,
se devuelve un punteo a ese símbolo; en caso contrario se devuelve un cero.

</P>

<PRE>
symrec *
putsym (sym_name,sym_type)
     char *sym_name;
     int sym_type;
{

  ptr = (symrec *) malloc (sizeof (symrec));
  ptr-&#62;name = (char *) malloc (strlen (sym_name) + 1);
  strcpy (ptr-&#62;name,sym_name);
  ptr-&#62;type = sym_type;
  ptr-&#62;value.var = 0; /* pone valor a 0 incluso si es fctn.  */
  ptr-&#62;next = (struct symrec *)sym_table;
  sym_table = ptr;
  return ptr;
}

symrec *
getsym (sym_name)
     char *sym_name;
{
  symrec *ptr;
  for (ptr = sym_table; ptr != (symrec *) 0;
       ptr = (symrec *)ptr-&#62;next)
    if (strcmp (ptr-&#62;name,sym_name) == 0)
      return ptr;
  return 0;
}
</PRE>

<P>
La función <CODE>yylex</CODE> debe reconocer ahora variables, valores numéricos, y
los operadores aritméticos de caracter simple.  Las cadenas de caracteres
alfanuméricas que no comiencen con un dígito son reconocidas como
variables o funciones dependiendo de lo que la tabla de símbolos diga
de ellas.

</P>
<P>
La cadena de caracteres se le pasa a <CODE>getsym</CODE> para que la localice en la
tabla de símbolos.  Si el nombre aparece en la tabla, se devuelve a
<CODE>yyparse</CODE> un puntero a su localización y su tipo (<CODE>VAR</CODE> o
<CODE>FNCT</CODE>). Si no está ya en la tabla, entonces se inserta como
<CODE>VAR</CODE> utilizando <CODE>putsym</CODE>.  De nuevo, se devuelve a
<CODE>yyparse</CODE> un puntero y su tipo (que debería ser <CODE>VAR</CODE>).
</P>
<P>
No se necesita ningún cambio en <CODE>yylex</CODE> para manejar los valores
numéricos y los operadores aritméticos.

</P>

<PRE>
#include &#60;ctype.h&#62;
yylex ()
{
  int c;

  /* Ignora espacios en blanco, obtiene el primer caracter */
  while ((c = getchar ()) == ' ' || c == '\t');

  if (c == EOF)
    return 0;

  /* Comienza un número =&#62; analiza el número.    */
  if (c == '.' || isdigit (c))
    {
      ungetc (c, stdin);
      scanf ("%lf", &#38;yylval.val);
      return NUM;
    }

  /* Comienza un identificador =&#62; lee el nombre. */
  if (isalpha (c))
    {
      symrec *s;
      static char *symbuf = 0;
      static int length = 0;
      int i;

      /* Inicialmente hace el buffer lo suficientemente
         largo para un nombre de símbolo de 40 caracteres. */
      if (length == 0)
        length = 40, symbuf = (char *)malloc (length + 1);

      i = 0;
      do
        {
          /* Si el buffer esta lleno, hacerlo mayor.       */
          if (i == length)
            {
              length *= 2;
              symbuf = (char *)realloc (symbuf, length + 1);
            }
          /* Añadir este caracter al buffer.               */
          symbuf[i++] = c;
          /* Obtiene otro caracter.                        */
          c = getchar ();
        }
      while (c != EOF &#38;&#38; isalnum (c));

      ungetc (c, stdin);
      symbuf[i] = '\0';

      s = getsym (symbuf);
      if (s == 0)
        s = putsym (symbuf, VAR);
      yylval.tptr = s;
      return s-&#62;type;
    }

  /* Cualquier otro caracter es un token por sí mismo. */
  return c;
}
</PRE>

<P>
Este programa es por ambos lados potente y flexible.  Usted podría fácilmente
añadir nuevas funciones, y es un trabajo sencillo modificar este código para
introducir también variables predefinidas tales como <CODE>pi</CODE> o <CODE>e</CODE>. 

</P>


<H2><A NAME="SEC38" HREF="bison-es-1.27.html#TOC38">Ejercicios</A></H2>
<P>
<A NAME="IDX51"></A>

</P>

<OL>
<LI>

Añada algunas nuevas funciones de <TT>`math.h'</TT> a la lista de inicialización.

<LI>

Añada otro array que contenga constantes y sus valores.  Entonces
modifique <CODE>init_table</CODE> para añadir estas constantes a la tabla
de símbolos.  Será mucha más fácil darle a las constantes el 
tipo <CODE>VAR</CODE>.

<LI>

Hacer que el programa muestre un error si el usuario hace
referencia a una variable sin inicializar de cualquier manera
excepto al almacenar un valor en ella.
</OL>



<H1><A NAME="SEC39" HREF="bison-es-1.27.html#TOC39">Archivos de Gramática de Bison</A></H1>

<P>
Bison toma como entrada la especificación de una gramática independiente
del contexto y produce una función en lenguaje C que reconoce las
instancias correctas de la gramática.

</P>
<P>
El archivo de entrada de la gramática de Bison tiene un nombre que finaliza
por convención en <SAMP>`.y'</SAMP>.

</P>



<H2><A NAME="SEC40" HREF="bison-es-1.27.html#TOC40">Resumen de una Gramática de Bison</A></H2>

<P>
Un archivo de gramática de Bison tiene cuatro secciones principales,
mostradas aquí con los delimitadores apropiados:

</P>

<PRE>
%{
<VAR>Declaraciones en C</VAR>
%}

<VAR>Declaraciones en Bison</VAR>

%%
<VAR>Reglas Gramaticales</VAR>
%%

<VAR>Código C adicional</VAR>
</PRE>

<P>
Los comentarios encerrados entre <SAMP>`/* ... */'</SAMP> pueden aparecer en
cualquiera de las secciones.

</P>



<H3><A NAME="SEC41" HREF="bison-es-1.27.html#TOC41">La Sección de Declaraciones en C</A></H3>
<P>
<A NAME="IDX52"></A>
<A NAME="IDX53"></A>

</P>
<P>
La sección de <VAR>declaraciones en C</VAR> contiene definiciones de macros
y declaraciones de funciones y variables que se utilizan en las acciones en
las reglas de la gramática.  Estas se copian al principio del archivo del
analizador de manera que precedan la definición de <CODE>yyparse</CODE>.  Puede
utlilizar <SAMP>`#include'</SAMP> para obtener las declaraciones de un archivo de
cabecera.  Si no necesita ninguna declaración en C, puede omitir los
delimitadores <SAMP>`%{'</SAMP> y <SAMP>`%}'</SAMP> que delimitan esta sección.

</P>


<H3><A NAME="SEC42" HREF="bison-es-1.27.html#TOC42">La Sección de Declaraciones de Bison</A></H3>
<P>
<A NAME="IDX54"></A>
<A NAME="IDX55"></A>

</P>
<P>
La sección de <VAR>declaraciones de Bison</VAR> contiene declaraciones que definen
símbolos terminales y no terminales, especifica la precedencia, etc.
En algunas gramáticas simples puede que no necesite ninguna de las 
declaraciones. See section <A HREF="bison-es-1.27.html#SEC54">Declaraciones de Bison</A>.

</P>


<H3><A NAME="SEC43" HREF="bison-es-1.27.html#TOC43">La Sección de Reglas Gramaticales</A></H3>
<P>
<A NAME="IDX56"></A>
<A NAME="IDX57"></A>

</P>
<P>
La sección de las <STRONG>reglas gramaticales</STRONG> contiene una o más
reglas gramaticales, y nada más.  See section <A HREF="bison-es-1.27.html#SEC46">Sintaxis de las Reglas Gramaticales</A>.

</P>
<P>
Debe haber siempre al menos una regla gramatical, y el primer
<SAMP>`%%'</SAMP> (que precede a las reglas gramaticales) no puede ser
omitido nunca incluso si es la primera cosa en el fichero.

</P>


<H3><A NAME="SEC44" HREF="bison-es-1.27.html#TOC44">La Sección de Código C Adicional</A></H3>
<P>
<A NAME="IDX58"></A>
<A NAME="IDX59"></A>

</P>
<P>
La sección de <VAR>código C adicional</VAR> se copia al pie de la letra a la
salida del fichero del analizador, al igual que la sección de
<VAR>declaraciones en C</VAR> que se copia al principio.  Este es el
lugar más conveniente para poner cualquier cosa que quiera
tener en el archivo del analizador pero que no deba venir antes
que la definición de <CODE>yyparse</CODE>.  Por ejemplo, las definiciones
de <CODE>yylex</CODE> e <CODE>yyerror</CODE>
a menudo van ahí.  See section <A HREF="bison-es-1.27.html#SEC64">Interfaz del Analizador en Lenguaje C</A>.

</P>
<P>
Si la última sección está vacía, puede omitir el <SAMP>`%%'</SAMP> que
los separa de las reglas gramaticales.

</P>
<P>
El analizador de Bison en sí contiene muchas variables estáticas
cuyos nombres comienzan con <SAMP>`yy'</SAMP> y muchas macros cuyos nombres
comienzan con <SAMP>`YY'</SAMP>.  Es una buena idea evitar el uso de cualquiera
de estos nombres (excepto aquellos documentados en este menual) en la
sección de código C adicional del archivo de la gramática.

</P>


<H2><A NAME="SEC45" HREF="bison-es-1.27.html#TOC45">Símbolos, Terminales y No Terminales</A></H2>
<P>
<A NAME="IDX60"></A>
<A NAME="IDX61"></A>
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>

</P>
<P>
Los <STRONG>símbolos</STRONG> en las gramáticas de Bison representan las
clasificaciones gramaticales del lenguaje.

</P>
<P>
Un <STRONG>símbolo terminal</STRONG> (también conocido como un <STRONG>tipo de token</STRONG>)
representa una clase de tokens equivalentes sintácticamente.  Usted utiliza
el símbolo en las reglas de la gramática para indicar que está permitido
un token en esa clase.  El símbolo se representa
en el analizador de Bison por un código numérico, y la función
<CODE>yylex</CODE> devuelve un código de tipo de token para indicar qué
tipo de token se ha leído.  Usted no necesita conocer cual es el valor
del código; puede utilizar el símbolo para representarlo.

</P>
<P>
Un <STRONG>símbolo no terminal</STRONG> representa una clase de agrupaciones
sintácticamente equivalentes.  El nombre del símbolo se utiliza para
escribir las reglas gramaticales.  Por convención, todos deberían
escribirse en minúsculas.

</P>
<P>
Los nombres de los símbolos pueden contener letras, dígitos
(no al principio), subrayados y puntos.  Los puntos tienen
sentido únicamente en no-terminales.

</P>
<P>
Hay tres maneras de escribir símbolos terminales en la gramática:

</P>

<UL>
<LI>

Un <STRONG>tipo de token designado</STRONG> se escribe con un identifiacador, de la
misma manera que un identificador en C.  Por convención, debería estar
todo en mayúsculas.  Cada uno de estos nombres debe definirse con una
declaración de Bison tal como <CODE>%token</CODE>.  See section <A HREF="bison-es-1.27.html#SEC55">Nombres de Tipo de Token</A>.

<LI>

<A NAME="IDX64"></A>
<A NAME="IDX65"></A>
<A NAME="IDX66"></A>
Un <STRONG>tipo de token de caracter</STRONG> (o <STRONG>token de caracter literal</STRONG>) se
escribe en la gramática utilizando la misma sintaxis usada en C para
las constantes de un caracter; por ejemplo, <CODE>'+'</CODE> es un tipo de token
de caracter.  Un tipo de token de caracter no necesita ser declarado
a menos que necesite especificar el tipo de datos de su valor
semántico (see section <A HREF="bison-es-1.27.html#SEC49">Tipos de Datos para Valores Semánticos</A>),
asociatividad, o precedencia (see section <A HREF="bison-es-1.27.html#SEC76">Precedencia de Operadores</A>).

Por convención, un tipo de token de caracter se utiliza únicamente
para representar un token que consista de ese caracter en particular.
De este modo, el tipo de token <CODE>'+'</CODE> se utiliza para representar el
caracter <SAMP>`+'</SAMP> como un token.  No hay nada que obligue a seguir esta
convención, pero si no lo hace, su programa será confuso para otros
lectores.

Todas las secuencias usuales de escape que se utilizan en caracteres literales
en C pueden ser utilizadas igualmente en Bison, pero
no debe usar el caracter nulo como un caracter literal porque
su codigo ASCII, el cero, es el código que <CODE>yylex</CODE> devuelve
para el final de la entrada (see section <A HREF="bison-es-1.27.html#SEC67">Convención de Llamada para <CODE>yylex</CODE></A>).

<LI>

<A NAME="IDX67"></A>
<A NAME="IDX68"></A>
<A NAME="IDX69"></A>
Un <STRONG>token de cadena literal</STRONG> se escribe como un
string constante de C; por ejemplo, <CODE>"&#60;="</CODE> es un token de cadena
literal.  Un token de cadena literal no necesita ser declarado a menos
que desee especificar el tipo de dato de su valor semántico
(see section <A HREF="bison-es-1.27.html#SEC49">Tipos de Datos para Valores Semánticos</A>), asociatividad, precedencia (see section <A HREF="bison-es-1.27.html#SEC76">Precedencia de Operadores</A>).

Puede asociar el token de cadena literal con un nombre simbólico como
un alias, utilizando la declaración <CODE>%token</CODE> (see section <A HREF="bison-es-1.27.html#SEC55">Nombres de Tipo de Token</A>).  
Si no lo hace, el analizador léxico debe recuperar el número del token
para el token de cadena literal desde la tabla
<CODE>yytname</CODE> (see section <A HREF="bison-es-1.27.html#SEC67">Convención de Llamada para <CODE>yylex</CODE></A>).

<STRONG>ADVERTENCIA</STRONG>: los tokens de cadena literal no funcionan en YACC.

Por convención, un token de cadena literal se utiliza únicamente para
representar un token que consiste en esa cadena en particular.  Así,
debería utilizar el tipo de token <CODE>"&#60;="</CODE> para representar la
cadena <SAMP>`&#60;='</SAMP> como un token.  Bison no impone esta convención, pero
si se aparta de ella, la gente que lea su programa se verá confusa.

Todas las secuencias de escape utilizadas en las cadenas de literales de
C pueden usarse igualmente en Bison.  Un token de cadena literal debe contener
dos o más caracteres; para un token que contenga un solo caracter, utilice
un token de caracter (ver lo anterior).
</UL>

<P>
El cómo se escoge la manera de escribir un símbolo no tiene efecto
en su significado gramatical.  Esto depende únicamente de dónde aparece
en las reglas y cuándo la función de análisis sintáctico devuelve ese
símbolo.

</P>
<P>
El valor devuelto por <CODE>yylex</CODE> es siempre uno de los símbolos
terminlaes (ó 0 para el fin de la entrada).  Sea cual sea la manera en
la que escriba
el tipo de token en las reglas gramaticales, escríbala de la misma
manera en la definición de <CODE>yylex</CODE>.  El código numérico para
un tipo de token de caracter es simplemente el codigo ASCII para el
caracter, así que <CODE>yylex</CODE> puede utilizar la constante idéntica
del caracter para generar el código requerido.  Cada tipo de token
denominado se convierte en una macro en C en el fichero del analizador,
de manera que <CODE>yylex</CODE> puede utilizar el nombre para hacer referencia
al código.  (Esta es la razón por la que los puntos no tienen sentido
en los símbolos terminales.)
See section <A HREF="bison-es-1.27.html#SEC67">Convención de Llamada para <CODE>yylex</CODE></A>.

</P>
<P>
Si se define <CODE>yylex</CODE> en un archivo aparte, debe prepararlo para que
las definiciones de las macros de los tipos de tokens estén disponibles allí.
Utilice la opción <SAMP>`-d'</SAMP> cuando ejecute Bison, de esta forma se escribirán
estas definiciones de las macros en un archivo de cabecera por separado
<TT>`<VAR>nombre</VAR>.tab.h'</TT> que puede incluir en los otros archivos fuente
que lo necesite.  See section <A HREF="bison-es-1.27.html#SEC92">Invocando a Bison</A>.

</P>
<P>
El símbolo <CODE>error</CODE> es un símbolo terminal reservado para la
recuperación de errores (see section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>); no debería
utilizarlo para cualquier otro propósito.  En particular, <CODE>yylex</CODE>
nunca debería devolver este valor.

</P>


<H2><A NAME="SEC46" HREF="bison-es-1.27.html#TOC46">Sintaxis de las Reglas Gramaticales</A></H2>
<P>
<A NAME="IDX70"></A>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>

</P>
<P>
Una regla gramatical de Bison tiene la siguiente forma general:

</P>

<PRE>
<VAR>resultado</VAR>: <VAR>componentes</VAR>...
        ;
</PRE>

<P>
donde <VAR>resultado</VAR> es el símbolo no terminal que describe esta
regla y <VAR>componentes</VAR> son los diversos símbolos terminales y no
terminales que están reunidos por esta regla (see section <A HREF="bison-es-1.27.html#SEC45">Símbolos, Terminales y No Terminales</A>).  

</P>
<P>
Por ejemplo,

</P>

<PRE>
exp:      exp '+' exp
        ;
</PRE>

<P>
dice que dos agrupaciones de tipo <CODE>exp</CODE>, con un token <SAMP>`+'</SAMP> en medio,
puede combinarse en una agrupación mayor de tipo <CODE>exp</CODE>.

</P>
<P>
Los espacios en blanco en las reglas son significativos únicamente para
separar símbolos.  Puede añadir tantos espacios en blanco extra como desee.

</P>
<P>
Distrubuídos en medio de los componentes pueden haber <VAR>acciones</VAR> que
determinan la semántica de la regla.  Una acción tiene el siguiente aspecto:

</P>

<PRE>
{<VAR>sentencias en C</VAR>}
</PRE>

<P>
Normalmente hay una única acción que sigue a los componentes.
See section <A HREF="bison-es-1.27.html#SEC51">Acciones</A>.

</P>
<P>
<A NAME="IDX73"></A>
Se pueden escribir por separado varias reglas para el mismo <VAR>resultado</VAR>
o pueden unirse con el caracter de barra vertical <SAMP>`|'</SAMP> así:

</P>

<PRE>
<VAR>resultado</VAR>:    <VAR>compoenentes-regla1</VAR>...
        | <VAR>componentes-regla2</VAR>...
        ...
        ;
</PRE>

<P>
Estas aún se consideran reglas distintas incluso cuando se unen de esa manera.
Si los <VAR>componentes</VAR> en una regla están vacíos, significa que
<VAR>resultado</VAR> puede concordar con la cadena vacía. Por ejemplo, aquí
aparece cómo definir una secuencia separada por comas de cero o más
agrupaciones <CODE>exp</CODE>:

</P>

<PRE>
expseq:   /* vacío */
        | expseq1
        ;

expseq1:  exp
        | expseq1 ',' exp
        ;
</PRE>

<P>
Es habitual escribir el comentario <SAMP>`/* vacío */'</SAMP> en cada regla
sin componentes.

</P>


<H2><A NAME="SEC47" HREF="bison-es-1.27.html#TOC47">Reglas Recursivas</A></H2>
<P>
<A NAME="IDX74"></A>

</P>
<P>
Una regla se dice <STRONG>recursiva</STRONG> cuando su no-terminal <VAR>resultado</VAR>
aparezca también en su lado derecho.  Casi todas las gramáticas de Bison
hacen uso de la recursión, ya que es la única manera de definir una
secuencia de cualquier número de cosas.  Considere esta definición
recursiva de una secuencia de una o más expresiones:

</P>

<PRE>
expseq1:  exp
        | expseq1 ',' exp
        ;
</PRE>

<P>
<A NAME="IDX75"></A>
<A NAME="IDX76"></A>
Puesto que en el uso recursivo de <CODE>expseq1</CODE> este es el símbolo
situado más a la izquierda del lado derecho, llamaremos a esto
<STRONG>recursión por la izquierda</STRONG>.  Por contraste, aquí se define la
misma construcción utilizando <STRONG>recusión por la derecha</STRONG>:

</P>

<PRE>
expseq1:  exp
        | exp ',' expseq1
        ;
</PRE>

<P>
Cualquier tipo de secuencia se puede definir utilizando ya sea
la recursión por la izquierda o recursión por la derecha, pero
debería utilizar siempre recursión por la izquierda, porque
puede analizar una secuencia de elementos sin ocupar espacio
de pila.  La recursión por la derecha utiliza espacio en la pila
de Bison en proporción al número de elementos en la secuencia,
porque todos los elementos deben ser desplazados en la pila
antes de que la regla pueda aplicarse incluso una única vez.
  See section <A HREF="bison-es-1.27.html#SEC73">El Algoritmo del Analizador de Bison</A>, para
una explicación adicional a cerca de esto.

</P>
<P>
<A NAME="IDX77"></A>
La recursión <STRONG>indirecta</STRONG> o <STRONG>mutua</STRONG> sucede cuando el resultado
de la regla no aparece directamente en su lado derecho, pero
aparece en las reglas de otros no terminales que aparecen en su lado
derecho.

</P>
<P>
Por ejemplo:

</P>

<PRE>
expr:     primario
        | primario '+' primario
        ;

primario:  constante
        | '(' expr ')'
        ;
</PRE>

<P>
define dos no-terminales recursivos mutuamente, ya que cada uno
hace referencia al otro.

</P>


<H2><A NAME="SEC48" HREF="bison-es-1.27.html#TOC48">Definiendo la Semántica del Lenguaje</A></H2>
<P>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>

</P>
<P>
Las reglas gramaticales para un lenguaje determinan únicamente la 
sintaxis.  La semántica viene determinada por los valores semánticos
asociados con varios tokens y agrupaciones, y por las acciones tomadas
cuando varias agrupaciones son reconocidas.

</P>
<P>
Por ejemplo, la calculadora calcula bien porque el
valor asociado con cada expresión es el número apropiado; ésta
suma correctamente porque la acción para la agrupación
<SAMP>`<VAR>x</VAR> + <VAR>y</VAR>'</SAMP> es sumar los números asociados con
<VAR>x</VAR> e <VAR>y</VAR>.

</P>



<H3><A NAME="SEC49" HREF="bison-es-1.27.html#TOC49">Tipos de Datos para Valores Semánticos</A></H3>
<P>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>
<A NAME="IDX82"></A>
<A NAME="IDX83"></A>

</P>
<P>
En un programa sencillo podría ser suficiente con utilizar el mismo
tipo de datos para los valores semánticos de todas las construcciones
del lenguaje.  Esto fue cierto en los ejemplos de calculadora RPN e
infija (see section <A HREF="bison-es-1.27.html#SEC21">Calculadora de Notación Polaca Inversa</A>).

</P>
<P>
Por defecto Bison utiliza el tipo <CODE>int</CODE> para todos los valores
semánticos.  Para especificar algún otro tipo, defina <CODE>YYSTYPE</CODE>
como una macro, de esta manera:

</P>

<PRE>
#define YYSTYPE double
</PRE>

<P>
Esta definición de la macro debe ir en la sección de declaraciones en C
del fichero de la gramática (see section <A HREF="bison-es-1.27.html#SEC40">Resumen de una Gramática de Bison</A>).

</P>


<H3><A NAME="SEC50" HREF="bison-es-1.27.html#TOC50">Más de Un Tipo de Valor</A></H3>

<P>
En la mayoría de los programas, necesitará diferentes tipos de datos
para diferentes clases de tokens y agrupaciones.  Por ejemplo, una
constante numérica podría necesitar el tipo
<CODE>int</CODE> o <CODE>long</CODE>, mientras que una cadena constante necesita
el tipo <CODE>char *</CODE>, y un identificador podría necesitar un puntero
a la tabla de símbolos.

</P>
<P>
Para utilizar más de un tipo de datos para los valores semánticos en
un analizador, Bison le pide dos cosas:

</P>

<UL>
<LI>

Especificar la colección completa de tipos de datos posibles, con la
declaración de Bison <CODE>%union</CODE> (see section <A HREF="bison-es-1.27.html#SEC57">La Colección de Tipos de Valores</A>).

<LI>

Elegir uno de estos tipos para cada símbolo (terminal o no terminal)
para los valores semánticos que se utilicen.  Esto se hace para los tokens
con la declaración de Bison <CODE>%token</CODE>
 (see section <A HREF="bison-es-1.27.html#SEC55">Nombres de Tipo de Token</A>) y para las agrupaciones con la
declaración de Bison <CODE>%type</CODE> (see section <A HREF="bison-es-1.27.html#SEC58">Símbolos No Terminales</A>).
</UL>



<H3><A NAME="SEC51" HREF="bison-es-1.27.html#TOC51">Acciones</A></H3>
<P>
<A NAME="IDX84"></A>
<A NAME="IDX85"></A>
<A NAME="IDX86"></A>

</P>
<P>
Una acción acompaña a una regla sintáctica y contiene código C a ser
ejecutado cada vez que se reconoce una instancia de esa regla.  La tarea
de la mayoría de las acciones es computar el valor semántico para
la agrupación construida por la regla a partir de los valores
semánticos asociados a los tokens o agrupaciones más pequeñas.

</P>
<P>
Una acción consiste en sentencias de C rodeadas por llaves, muy
parecido a las sentencias compuestas en C.  Se pueden situar en
cualquier posición dentro de la regla; esta se ejecuta en esa posición.
La mayoría de las reglas tienen sólo una acción al final de la regla,
a continuación de todos los componentes.  Las acciones en medio de una
regla son difíciles y se utilizan únicamente para propósitos especiales
(see section <A HREF="bison-es-1.27.html#SEC53">Acciones a Media Regla</A>).

</P>
<P>
El código C en una acción puede hacer referencia a los valores
semánticos de los componentes reconocidos por la regla con la construcción
<CODE>$<VAR>n</VAR></CODE>, que hace referencia al valor de la componente <VAR>n</VAR>-ésima.
El valor semántico para la agrupación que se está construyendo es <CODE>$$</CODE>.
(Bison traduce ambas construcciones en referencias a elementos de un array
cuando copia las acciones en el fichero del analizador.)

</P>
<P>
Aquí hay un ejemplo típico:

</P>

<PRE>
exp:    ...
        | exp '+' exp
            { $$ = $1 + $3; }
</PRE>

<P>
Esta regla contruye una <CODE>exp</CODE> de dos agrupaciones <CODE>exp</CODE> más
pequeñas conectadas por un token de signo más.  En la acción, <CODE>$1</CODE>
y <CODE>$3</CODE> hacen referencia a los valores semánticos de las dos
agrupaciones <CODE>exp</CODE> componentes, que son el primer y
tercer símbolo en el lado derecho de la regla.  La suma se almacena
en <CODE>$$</CODE> de manera que se convierte en el valor semántico de
la expresión de adición reconocida por la regla.  Si hubiese un
valor semántico útil asociado con el token <SAMP>`+'</SAMP>, debería
hacerse referencia con <CODE>$2</CODE>.
</P>
<P>
<A NAME="IDX87"></A>
Si no especifica una acción para una regla, Bison suministra una por defecto:
<CODE>$$ = $1</CODE>.  De este modo, el valor del primer símbolo en la regla
se convierte en el valor de la regla entera.  Por supuesto, la regla por
defecto solo es válida si concuerdan los dos tipos de datos.  No hay una regla
por defecto con significado para la regla vacía; toda regla vacía
debe tener una acción explícita a menos que el valor de la regla
no importe.

</P>
<P>
<CODE>$<VAR>n</VAR></CODE> con <VAR>n</VAR> cero o negativo se admite para hacer referencia
a tokens o agrupaciones sobre la pila <EM>antes de</EM> aquellas que empareja la
regla actual.  Esta es una práctica muy arriesgada, y para utilizarla de
forma fiable debe estar seguro del contexto en el que se aplica la
regla. Aquí hay un donde puede utilizar esto de forma fiable:

</P>

<PRE>
foo:      expr bar '+' expr  { ... }
        | expr bar '-' expr  { ... }
        ;

bar:      /* vacío */
        { previous_expr = $0; }
        ;
</PRE>

<P>
Siempre que <CODE>bar</CODE> se utilice solamente de la manera mostrada aquí,
<CODE>$0</CODE> siempre hace referencia a la <CODE>exp</CODE> que precede a <CODE>bar</CODE> en 
la definición de <CODE>foo</CODE>.

</P>


<H3><A NAME="SEC52" HREF="bison-es-1.27.html#TOC52">Tipos de Datos de Valores en Acciones</A></H3>
<P>
<A NAME="IDX88"></A>
<A NAME="IDX89"></A>

</P>
<P>
Si ha elegido un tipo de datos único para los valores semánticos, las 
construcciones <CODE>$$</CODE> y <CODE>$<VAR>n</VAR></CODE> siempre tienen ese tipo de datos.

</P>
<P>
Si ha utilizado <CODE>%union</CODE> para especificar una variedad de tipos de datos,
entonces debe declarar la elección de entre esos tipos para cada símbolo
terminal y no terminal que puede tener un valor semántico.  Entonces
cada vez que utilice <CODE>$$</CODE> o <CODE>$<VAR>n</VAR></CODE>, su tipo de datos
se determina por el símbolo al que hace referencia en la regla.  En este
ejemplo,
</P>

<PRE>
exp:    ...
        | exp '+' exp
            { $$ = $1 + $3; }
</PRE>

<P>
<CODE>$1</CODE> y <CODE>$3</CODE> hacen referencia a instancias de <CODE>exp</CODE>, de manera
que todos ellos tienen el tipo de datos declarado para el símbolo no terminal
<CODE>exp</CODE>.  Si se utilizase <CODE>$2</CODE>, tendría el tipo de datos declarado para
el símbolo terminal <CODE>'+'</CODE>, cualquiera que pudiese ser.
</P>
<P>
De forma alternativa, puede especificar el tipo de datos cuando se hace
referencia al valor, insertando <SAMP>`&#60;<VAR>tipo</VAR>&#62;'</SAMP> después del <SAMP>`$'</SAMP> al
comienzo de la referencia.  Por ejemplo, si ha definido los tipos como se
muestra aquí:

</P>

<PRE>
%union {
  int tipoi;
  double tipod;
}
</PRE>

<P>
entonces puede escribir <CODE>$&#60;tipoi&#62;1</CODE> para hacer referencia a la
primera subunidad de la regla como un entero, o <CODE>$&#60;tipod&#62;1</CODE> para
referirse a este como un double.

</P>


<H3><A NAME="SEC53" HREF="bison-es-1.27.html#TOC53">Acciones a Media Regla</A></H3>
<P>
<A NAME="IDX90"></A>
<A NAME="IDX91"></A>

</P>
<P>
Ocasionalmente es de utilidad poner una acción en medio de una regla.
Estas acciones se escriben como las acciones al final de la regla, pero
se ejecutan antes de que el analizador llegue a reconocer los
componentes que siguen.

</P>
<P>
Una acción en mitad de una regla puede hacer referencia a los
componentes que la preceden utilizando <CODE>$<VAR>n</VAR></CODE>, pero
no puede hacer referencia a los componentes subsecuentes porque
esta se ejecuta antes de que sean analizados.

</P>
<P>
Las acciones en mitad de una regla por sí mismas cuentan como uno de los
componentes de la regla.  Esto produce una diferencia cuando hay otra
acción más tarde en la misma regla (y normalmente hay otra al final): debe
contar las acciones junto con los símbolos cuando quiera saber qué número
<VAR>n</VAR> debe utilizar en <CODE>$<VAR>n</VAR></CODE>.

</P>
<P>
La acción en la mitad de una regla puede también tener un valor semántico.
La acción puede establecer su valor con una asignación a <CODE>$$</CODE>, y
las acciones posteriores en la regla pueden hacer referencia al valor
utilizando <CODE>$<VAR>n</VAR></CODE>. Ya que no hay un símbolo que identifique la
acción, no hay manera de declarar por adelantado un tipo de datos para
el valor, luego debe utilizar la construcción <SAMP>`$&#60;...&#62;'</SAMP> para
especificar un tipo de datos cada vez que haga referencia a este valor.

</P>
<P>
No hay forma de establecer el valor de toda la regla con una
acción en medio de la regla, porque las asignaciones a <CODE>$$</CODE> no
tienen ese efecto.  La única forma de establecer el valor para toda
la regla es con una acción corriente al final de la regla.

</P>
<P>
Aquí hay un ejemplo tomado de un compilador hipotético, manejando
una sentencia <CODE>let</CODE> de la forma <SAMP>`let (<VAR>variable</VAR>)
<VAR>sentencia</VAR>'</SAMP> y sirve para crear una variable denominada
<VAR>variable</VAR> temporalmente durante la duración de la
<VAR>sentencia</VAR>. Para analizar esta construcción, debemos poner
<VAR>variable</VAR> dentro de la tabla de símbolos mientras se analiza
<VAR>sentencia</VAR>, entonces se quita después. Aquí está cómo se hace:

</P>

<PRE>
stmt:   LET '(' var ')'
                { $&#60;contexto&#62;$ = push_contexto ();
                  declara_variable ($3); }
        stmt    { $$ = $6;
                  pop_contexto ($&#60;contexto&#62;5); }
</PRE>

<P>
Tan pronto como <SAMP>`let (<VAR>variable</VAR>)'</SAMP> se haya reconocido, se
ejecuta la primera acción. Esta guarda una copia del contexto
semántico actual (la lista de variables accesibles) como su
valor semántico, utilizando la alternativa <CODE>contexto</CODE> de
la union de tipos de datos.  Entonces llama a <CODE>declara_variable</CODE>
para añadir una nueva variable a la lista.  Una vez que finalice
la primera acción, la sentencia inmersa en <CODE>stmt</CODE> puede ser
analizada.  Note que la acción en mitad de la regla es la componente
número 5, así que <SAMP>`stmt'</SAMP> es la componente número 6.

</P>
<P>
Después de que la sentencia inmersa se analice, su valor semántico
se convierte en el valor de toda la sentencia <CODE>let</CODE>.  Entonces el
valor semántico de la acción del principio se utiliza para recuperar
la lista anterior de variables.  Esto hace quitar la variable temporal
del <CODE>let</CODE> de la lista de manera que esta no parecerá que exista
mientras el resto del programa se analiza.

</P>
<P>
Tomar una acción antes de que la regla sea reconocida completamente a
veces induce a conflictos ya que el analizador debe llegar a un análisis
para poder ejecutar la acción.  Por ejemplo, las dos reglas siguientes,
sin acciones en medio de ellas, pueden coexistir en un analizador
funcional porque el analizador puede desplazar el token de llave-abrir
y ver qué sigue antes de decidir si hay o no una declaración:

</P>

<PRE>
compuesta: '{' declaracion sentencias '}'
         | '{' sentencias '}'
         ;
</PRE>

<P>
Pero cuando añadimos una acción en medio de una regla como a continuación,
la regla se vuelve no funcional:

</P>

<PRE>
compuesta: { prepararse_para_variables_locales (); }
          '{' declaraciones sentencias '}'
        | '{' sentencias '}'
        ;
</PRE>

<P>
Ahora el analizador se ve forzado a decidir si ejecuta la acción en
medio de la regla cuando no ha leído más alla de la llave-abrir.  En
otras palabras, debe decidir si utilia una regla u otra, sin información
suficiente para hacerlo correctamente.  (El token llave-abrir es lo que
se llama el token <STRONG>de preanálisis</STRONG> en este momento, ya que el analizador
está decidiendo aún qué hacer con él.  See section <A HREF="bison-es-1.27.html#SEC74">Tokens de Preanálisis</A>.)

</P>
<P>
Podría pensar que puede corregir el problema poniendo acciones
idénticas en las dos reglas, así:

</P>

<PRE>
compuesta: { prepararse_para_variables_locales (); }
           '{' declaraciones sentencias '}'
         | { prepararse_para_variables_locales (); }
           '{' sentencias '}'
        ;
</PRE>

<P>
Pero esto no ayuda, porque Bison no se da cuenta de que las dos acciones
son idénticas.  (Bison nunca intenta comprender el código C de una acción.)

</P>
<P>
Si la gramática es tal que una declaración puede ser distinguida de
una sentencia por el primer token (lo que es cierto en C), entonces una
solución que funciona es poner la acción después de la llave-abrir, así:

</P>

<PRE>
compuesta: '{' { prepararse_para_variables_locales (); }
           declaraciones sentencias '}'
         | '{' sentencias '}'
         ;
</PRE>

<P>
Ahora el primer token de la siguiente declaración o sentencia,
que en cualquier caso diría a Bison la regla a utilizar,
puede hacerlo aún.

</P>
<P>
Otra solución es introducir la acción dentro de un símbolo no terminal
que sirva como una subrutina:

</P>

<PRE>
subrutina: /* vacío */
         { prepararse_para_variables_locales (); }
       ;

compuesta: subrutina
           '{' declaraciones sentencias '}'
         | subrutina
           '{' sentencias '}'
        ;
</PRE>

<P>
Ahora Bison puede ejecutar la acción en la regla para <CODE>subrutina</CODE> sin
decidir qué regla utilzará finalmente para <CODE>compuesta</CODE>.  Note que la
acción está ahora al final de su regla.  Cualquier acción en medio de
una regla puede convertirse en una acción al final de la regla de
esta manera, y esto es lo que Bison realmente hace para implementar
acciones en mitad de una regla.

</P>


<H2><A NAME="SEC54" HREF="bison-es-1.27.html#TOC54">Declaraciones de Bison</A></H2>
<P>
<A NAME="IDX92"></A>
<A NAME="IDX93"></A>

</P>
<P>
La sección de <STRONG>declaraciones de Bison</STRONG> de una gramática de Bison
define los símbolos utilizados en la formulación de la gramática y los
tipos de datos de los valores semánticos.
See section <A HREF="bison-es-1.27.html#SEC45">Símbolos, Terminales y No Terminales</A>.

</P>
<P>
Todos los nombres de tipos de tokens (pero no los tokens de caracter literal
simple tal como <CODE>'+'</CODE> y <CODE>'*'</CODE>) se deben declarar.  Los símbolos
no terminales deben ser declarados si necesita especificar el tipo de dato
a utilizar para los valores 
semánticos (see section <A HREF="bison-es-1.27.html#SEC50">Más de Un Tipo de Valor</A>).

</P>
<P>
La primera regla en el fichero también especifica el símbolo de arranque,
por defecto.  Si desea que otro símbolo sea el símbolo de arranque, lo
debe declarar
explícitamente (see section <A HREF="bison-es-1.27.html#SEC13">Lenguajes y Gramáticas independientes del Contexto</A>).

</P>



<H3><A NAME="SEC55" HREF="bison-es-1.27.html#TOC55">Nombres de Tipo de Token</A></H3>
<P>
<A NAME="IDX94"></A>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>
<A NAME="IDX97"></A>

</P>
<P>
La forma básica de declarar un nombre de tipo de token (símbolo terminal)
es como sigue:

</P>

<PRE>
%token <VAR>nombre</VAR>
</PRE>

<P>
Bison convertirá esto es una directiva <CODE>#define</CODE> en
el analizador, así que la función <CODE>yylex</CODE> (si está en
este fichero) puede utilizar el nombre <VAR>nombre</VAR> para representar
el código de este tipo de token.

</P>
<P>
De forma alternativa, puede utilizar <CODE>%left</CODE>, <CODE>%right</CODE>, o
<CODE>%nonassoc</CODE> en lugar de <CODE>%token</CODE>, si desea especificar
la precedencia. See section <A HREF="bison-es-1.27.html#SEC56">Precedencia de Operadores</A>.

</P>
<P>
Puede especificar explícitamente el código numérico para un token
añadiendo un valor entero en el campo que sigue inmediatamente
al nombre del token:

</P>

<PRE>
%token NUM 300
</PRE>

<P>
Es generalmente lo mejor, sin embargo, permitir a Bison elegir los
códigos numéricos para todos los tipos de tokens.  Bison automáticamente
seleccionará  los códigos que no provoquen conflictos unos con otros
o con caracteres ASCII.

</P>
<P>
En el caso de que el tipo de la pila sea una union, debe aumentar
<CODE>%token</CODE> u otra declaración de tokens para incluir la
opción de tipo de datos delimitado por
ángulos (see section <A HREF="bison-es-1.27.html#SEC50">Más de Un Tipo de Valor</A>).  

</P>
<P>
Por ejemplo:

</P>

<PRE>
%union {              /* define el tipo de la pila */
  double val;
  symrec *tptr;
}
%token &#60;val&#62; NUM       /* define el token NUM y su tipo */
</PRE>

<P>
Puede asociar un token de cadena literal con un nombre
de tipo de token escribiendo la cadena literal al final de la
declaración <CODE>%type</CODE> que declare el nombre.  Por ejemplo:

</P>

<PRE>
%token arrow "=&#62;"
</PRE>

<P>
Por ejemplo, una gramática para el lenguaje C podría especificar estos
nombres con los tokens de cadena literal equivalente:

</P>

<PRE>
%token  &#60;operator&#62;  OR      "||"
%token  &#60;operator&#62;  LE 134  "&#60;="
%left  OR  "&#60;="
</PRE>

<P>
Una vez que iguale la cadena literal y el nombre del token, puede
utilizarlo indistintamente en ulteriores declaraciones en reglas
gramaticales.  La función <CODE>yylex</CODE> puede utilizar el nombre del
token o la cadena literal para obtener el número de código del
tipo de token (see section <A HREF="bison-es-1.27.html#SEC67">Convención de Llamada para <CODE>yylex</CODE></A>).

</P>


<H3><A NAME="SEC56" HREF="bison-es-1.27.html#TOC56">Precedencia de Operadores</A></H3>
<P>
<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<A NAME="IDX100"></A>

</P>
<P>
Use las declaraciones <CODE>%left</CODE>, <CODE>%right</CODE> o <CODE>%nonassoc</CODE>
para declarar un token y especificar su precedencia y asociatividad,
todo a la vez.  Estas se llaman <STRONG>declaraciones de precedencia</STRONG>.
See section <A HREF="bison-es-1.27.html#SEC76">Precedencia de Operadores</A>, para información general
a cerca de la precedencia de operadores.

</P>
<P>
La sintaxis de una declaración de precedencia es la misma que
la de <CODE>%token</CODE>: bien

</P>

<PRE>
%left <VAR>símbolos</VAR>...
</PRE>

<P>
o

</P>

<PRE>
%left &#60;<VAR>tipo</VAR>&#62; <VAR>símbolos</VAR>...
</PRE>

<P>
Y realmente cualquiera de estas declaraciones sirve para los mismos
propósitos que <CODE>%token</CODE>.  Pero además, estos especifican la
asociatividad y precedencia relativa para todos los <VAR>símbolos</VAR>:

</P>

<UL>
<LI>

La asociatividad de un operador <VAR>op</VAR> determina cómo se
anidan los repetidos usos de un operador: si <SAMP>`<VAR>x</VAR> <VAR>op</VAR>
<VAR>y</VAR> <VAR>op</VAR> <VAR>z</VAR>'</SAMP> se analiza agrupando <VAR>x</VAR> con <VAR>y</VAR>
primero o agrupando <VAR>y</VAR> con <VAR>z</VAR> primero.  <CODE>%left</CODE> especifica
asociatividad por la izquierda (agrupando <VAR>x</VAR> con <VAR>y</VAR> primero) y
<CODE>%right</CODE> especifica asociatividad por la derecha (agrupando
<VAR>y</VAR> con <VAR>z</VAR> primero).  <CODE>%nonassoc</CODE> especifica no asociatividad,
que significa que <SAMP>`<VAR>x</VAR> <VAR>op</VAR> <VAR>y</VAR> <VAR>op</VAR> <VAR>z</VAR>'</SAMP> se
considera como un error de sintaxis.

<LI>

La precedencia de un operador determina cómo se anida con otros
operadores.  Todos los tokens declarados en una sola declaración de
precedencia tienen la misma precedencia y se anidan conjuntamente de acuerdo
a su asociatividad.  Cuando dos tokens declarados asocian declaraciones de
diferente precedencia, la última en ser declarada tiene la mayor
precedencia y es agrupada en primer lugar.
</UL>



<H3><A NAME="SEC57" HREF="bison-es-1.27.html#TOC57">La Colección de Tipos de Valores</A></H3>
<P>
<A NAME="IDX101"></A>
<A NAME="IDX102"></A>
<A NAME="IDX103"></A>

</P>
<P>
La declaración <CODE>%union</CODE> especifica la colección completa de posibles
tipos de datos para los valores semánticos.  La palabra clave <CODE>%union</CODE>
viene seguida de un par de llaves conteniendo lo mismo que va dentro de una
<CODE>union</CODE> en C.

</P>
<P>
Por ejemplo:

</P>

<PRE>
%union {
  double val;
  symrec *tptr;
}
</PRE>

<P>
Esto dice que los dos tipos de alternativas son <CODE>double</CODE> y
<CODE>symrec *</CODE>.  Se les ha dado los nombres <CODE>val</CODE> y <CODE>tptr</CODE>;
estos nombres se utilizan en las declaraciones de <CODE>%token</CODE> y
<CODE>%type</CODE> para tomar uno de estos tipos para un símbolo terminal o no
terminal (see section <A HREF="bison-es-1.27.html#SEC58">Símbolos No Terminales</A>).

</P>
<P>
Note que, a diferencia de hacer una declaración de una <CODE>union</CODE> en C,
no se escribe un punto y coma después de la llave que cierra.

</P>


<H3><A NAME="SEC58" HREF="bison-es-1.27.html#TOC58">Símbolos No Terminales</A></H3>
<P>
<A NAME="IDX104"></A>
<A NAME="IDX105"></A>
<A NAME="IDX106"></A>

</P>
<P>
Cuando utilice <CODE>%union</CODE> para especificar varios tipos de valores, debe
declarar el tipo de valor de cada símbolo no terminal para los valores
que se utilicen.  Esto se hace con una declaración <CODE>%type</CODE>, como esta:

</P>

<PRE>
%type &#60;<VAR>tipo</VAR>&#62; <VAR>noterminal</VAR>...
</PRE>

<P>
Aquí <VAR>noterminal</VAR> es el nombre de un símbolo no terminal, y <VAR>tipo</VAR>
es el nombre dado en la <CODE>%union</CODE> a la alternativa que desee
(see section <A HREF="bison-es-1.27.html#SEC57">La Colección de Tipos de Valores</A>).  Puede dar
cualquier número de símbolos no terminales en la misma declaración
<CODE>%type</CODE>, si tienen el mismo tipo de valor.  Utilice espacios para
separar los nombres de los símbolos.

</P>
<P>
Puede también declarar el tipo de valor de un símbolo terminal.  Para
hacer esto, utilice la misma construcción <CODE>&#60;<VAR>tipo</VAR>&#62;</CODE> en una
declaración para el símbolo terminal.  Todos las clases de declaraciones
de tipos permiten <CODE>&#60;<VAR>tipo</VAR>&#62;</CODE>.

</P>


<H3><A NAME="SEC59" HREF="bison-es-1.27.html#TOC59">Suprimiendo Advertencias de Conflictos</A></H3>
<P>
<A NAME="IDX107"></A>
<A NAME="IDX108"></A>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
<A NAME="IDX111"></A>

</P>
<P>
Bison normalmente avisa si hay algún conflicto en la gramática
(see section <A HREF="bison-es-1.27.html#SEC75">Conflictos de Desplazamiento/Reducción</A>),
pero la mayoría de las gramáticas reales tienen confictos
desplazamiento/reducción inofensivos que se resuelven de una manera
predecible y serían muy difíciles de eliminar.  Es deseable suprimir los
avisos a cerca de estos conflictos a menos que el número de conflictos
cambie. Puede hacer esto con la declaración <CODE>%expect</CODE>.

</P>
<P>
La declaración tiene este aspecto:

</P>

<PRE>
%expect <VAR>n</VAR>
</PRE>

<P>
Aquí <VAR>n</VAR> es un entero decimal.  La declaración dice que no deben haber
avisos si hay <VAR>n</VAR> conflictos de desplazamiento/reducción y ningún
conflicto reducción/reducción.  Los avisos usuales se dan si hay más
o menos conflictos, o si hay algún conflicto reducción/reducción.

</P>
<P>
En general, el uso de <CODE>%expect</CODE> implica estos pasos:

</P>

<UL>
<LI>

Compilar su gramática sin <CODE>%expect</CODE>.  Utilice la opción <SAMP>`-v'</SAMP>
para obtener una lista amplia de dónde ocurrieron los conflictos.  Bison
también imprimirá el número de conflictos.

<LI>

Comprobar cada uno de los conflictos para estar seguro de que
la resolución por defecto de Bison es lo que realmente quiere.
Si no, reescriba la gramática y vuelva al principio.

<LI>

Añada una declaración <CODE>%expect</CODE>, copiando el número <VAR>n</VAR> a
partir del número que imprime Bison.
</UL>

<P>
Ahora Bison dejará de molestarle con los conflictos que ha comprobado, pero
le avisará de nuevo si cambia el resultado de la gramática con
conflictos adicionales.

</P>


<H3><A NAME="SEC60" HREF="bison-es-1.27.html#TOC60">El Símbolo de Arranque</A></H3>
<P>
<A NAME="IDX112"></A>
<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>

</P>
<P>
Bison asume por defecto que el símbolo de arranque para la gramática es
el primer no terminal que se encuentra en la sección de especificación de
la gramática.  El programador podría anular esta restricción con
la declaración <CODE>%start</CODE> así:

</P>

<PRE>
%start <VAR>símbolo</VAR>
</PRE>



<H3><A NAME="SEC61" HREF="bison-es-1.27.html#TOC61">Un Analizador Puro (Reentrante)</A></H3>
<P>
<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
<A NAME="IDX118"></A>

</P>
<P>
Un programa <STRONG>reentrante</STRONG> es aquel que no cambia en el curso de la
ejecución; en otras palabras, consiste enteramente de código <STRONG>puro</STRONG>
(de sólo lectura).  La reentrancia es importante siempre que la
ejecución asíncrona sea posible; por ejemplo, un programa no reentrante
podría no ser seguro al ser llamado desde un gestor de señales.  En
sistemas con múltiples hilos de control, un programa no reentrante
debe ser llamado únicamente dentro de interbloqueos.

</P>
<P>
Normalmente, Bison genera un analizador que no es reentrante.  Esto es
apropiado para la mayoria de los casos, y permite la compatibilidad
con YACC.  (Los interfaces estandares de YACC son inherentemente no
reentrantes, porque utilizan variables asignadas estáticamente para la
comunicación con <CODE>yylex</CODE>, incluyendo <CODE>yylval</CODE> y
<CODE>yylloc</CODE>.)

</P>
<P>
Por otra parte, puede generar un analizador puro, reentrante.  La
declaración de Bison <CODE>%pure_parser</CODE> dice que desea que el
analizador sea reentrante.  Esta aparece así:

</P>

<PRE>
%pure_parser
</PRE>

<P>
El resultado es que las variables de comunicación <CODE>yylval</CODE> y
<CODE>yylloc</CODE> se convierten en variables locales en <CODE>yyparse</CODE>, y se
utiliza una convención de llamada diferente para la función del
analizador léxico <CODE>yylex</CODE>. See section <A HREF="bison-es-1.27.html#SEC70">Convenciones de Llamada para Analizadores Puros</A>, para los detalles a cerca de esto.  La
variable <CODE>yynerrs</CODE> también se convierte en local en <CODE>yyparse</CODE>
(see section <A HREF="bison-es-1.27.html#SEC71">La Función de Informe de Errores <CODE>yyerror</CODE></A>).
 La convención para llamar a <CODE>yyparse</CODE> no cambia. 

</P>
<P>
Que el analizador sea o no puro no depende de las reglas gramaticales. 
Puede generar indistintamente un analizador puro o un
analizador no reentrante a partir de cualquier gramática válida.

</P>


<H3><A NAME="SEC62" HREF="bison-es-1.27.html#TOC62">Sumario de Declaraciones de Bison</A></H3>
<P>
<A NAME="IDX119"></A>
<A NAME="IDX120"></A>

</P>
<P>
Aquí hay un sumario de todas las declaraciones de Bison:

</P>
<DL COMPACT>

<DT><CODE>%union</CODE>
<DD>
Declara la colección de tipos de datos que los valores semánticos
pueden poseer
(see section <A HREF="bison-es-1.27.html#SEC57">La Colección de Tipos de Valores</A>).

<DT><CODE>%token</CODE>
<DD>
Declara un símbolo terminal (nombre de tipo de token) sin precedencia
o asociatividad especificada (see section <A HREF="bison-es-1.27.html#SEC55">Nombres de Tipo de Token</A>).

<DT><CODE>%right</CODE>
<DD>
Declara un símbolo terminal (nombre de tipo de token) que es asociativo
por la derecha
(see section <A HREF="bison-es-1.27.html#SEC56">Precedencia de Operadores</A>).

<DT><CODE>%left</CODE>
<DD>
Declara un símbolo terminal (nombre de tipo de token) que es
asociativo por la izquierda.
(see section <A HREF="bison-es-1.27.html#SEC56">Precedencia de Operadores</A>).

<DT><CODE>%nonassoc</CODE>
<DD>
Declara un símbolo terminal (nombre de tipo de token) que es
no asociativo (utilizándolo de una forma que sería asociativo es un
error de sintaxis)
(see section <A HREF="bison-es-1.27.html#SEC56">Precedencia de Operadores</A>).

<DT><CODE>%type</CODE>
<DD>
Declara el tipo de valor semántico para un símbolo no terminal.
(see section <A HREF="bison-es-1.27.html#SEC58">Símbolos No Terminales</A>).

<DT><CODE>%start</CODE>
<DD>
Especifica el símbolo de arranque de la gramática (see section <A HREF="bison-es-1.27.html#SEC60">El Símbolo de Arranque</A>).

<DT><CODE>%expect</CODE>
<DD>
Declara el número esperado de conflictos desplazamiento-reducción
(see section <A HREF="bison-es-1.27.html#SEC59">Suprimiendo Advertencias de Conflictos</A>).

<DT><CODE>%pure_parser</CODE>
<DD>
Solicita un programa de análisis puro (reentrante) (see section <A HREF="bison-es-1.27.html#SEC61">Un Analizador Puro (Reentrante)</A>).

<DT><CODE>%no_lines</CODE>
<DD>
No genera ningún comando <CODE>#line</CODE> del proprocesador en el
fichero del analizador.  Normalmente Bison escribe estos comandos
en el archivo del analizador de manera que el compilador de C y 
los depuradores asociarán los errores y el código objeto con
su archivo fuente (el archivo de la gramática).  Esta directiva
provoca que asocien los errores con el archivo del analizador, tratándolo
como un archivo fuente independiente por derecho propio.

<DT><CODE>%raw</CODE>
<DD>
El archivo de salida <TT>`<VAR>nombre</VAR>.h'</TT> normalmente define los tokens
con los números de token compatible con Yacc.  Si se especifica esta opción,
se utilizarán los números internos de Bison en su lugar. (Los números
compatibles con Yacc comienzan en 257 excepto para los tokens de caracter
simple; Bison asigna números de token secuencialmente
para todos los tokens comenzando por 3.)

<DT><CODE>%token_table</CODE>
<DD>
Genera un array de nombres de tokens en el archivo del analizador.  El
nombre del array es <CODE>yytname</CODE>; <CODE>yytname[<VAR>i</VAR>]</CODE> es el nombre
del token cuyo número de código de token interno de Bison es <VAR>i</VAR>.  Los
primeros tres elementos de <CODE>yytname</CODE> son siempre <CODE>"$"</CODE>,
<CODE>"error"</CODE>, e <CODE>"$illegal"</CODE>; después de estos vienen los símbolos
definidos en el archivo de la gramática.

Para tokens de caracter literal y tokens de cadena literal, el
nombre en la tabla incluye los caracteres entre comillas simples o dobles:
por ejemplo, <CODE>"'+'"</CODE> es un literal de caracter simple y <CODE>"\"&#60;=\""</CODE>
es un token de cadena literal.  Todos los caracteres del token de cadena
literal aparecen textualmente en la cadena encontrada en la tabla; incluso
los caracteres de comillas-dobles no son traducidos.  Por ejemplo, si el token
consiste de tres caracteres <SAMP>`*"*'</SAMP>, su cadena en <CODE>yytname</CODE>
contiene <SAMP>`"*"*"'</SAMP>. (En C, eso se escribiría como <CODE>"\"*\"*\""</CODE>).

Cuando especifique <CODE>%token_table</CODE>, Bison también generará definiciones
para las macros <CODE>YYNTOKENS</CODE>, <CODE>YYNNTS</CODE>, y <CODE>YYNRULES</CODE> y
<CODE>YYNSTATES</CODE>;

<DL COMPACT>

<DT><CODE>YYNTOKENS</CODE>
<DD>
El número de token más alto, más uno.
<DT><CODE>YYNNTS</CODE>
<DD>
El número de símbolos no terminales.
<DT><CODE>YYNRULES</CODE>
<DD>
El número de reglas gramaticales,
<DT><CODE>YYNSTATES</CODE>
<DD>
El número de estados del analizador (see section <A HREF="bison-es-1.27.html#SEC82">Estados del Analizador</A>).
</DL>
</DL>



<H2><A NAME="SEC63" HREF="bison-es-1.27.html#TOC63">Múltiples Analizadores en el Mismo Programa</A></H2>

<P>
La mayoría de los programa que usan Bison analizan sólo un lenguaje
y por lo tanto contienen sólo un analizador de Bison.  Pero , ¿qué pasa
si desea analizar más de un lenguaje con el mismo programa?  Entonces
necesita evitar un conflicto de nombres entre diferentes definiciones
de <CODE>yyparse</CODE>, <CODE>yylval</CODE>, etc.

</P>
<P>
La manera más fácil de hacer esto es utilizar la opción <SAMP>`-p <VAR>prefijo</VAR>'</SAMP>
(see section <A HREF="bison-es-1.27.html#SEC92">Invocando a Bison</A>).  Esta renombra las funciones
de interfaz y variables del analizador de Bison para comenzar con
<VAR>prefijo</VAR> en lugar de <SAMP>`yy'</SAMP>.  Puede utilizarlo para darle a
cada analizador nombres diferentes que no provoquen conflicto.

</P>
<P>
La lista precisa de símbolos renombrados es <CODE>yyparse</CODE>, <CODE>yylex</CODE>,
<CODE>yyerror</CODE>, <CODE>yynerrs</CODE>, <CODE>yylval</CODE>, <CODE>yychar</CODE> e
<CODE>yydebug</CODE>.  Por ejemplo, si utiliza <SAMP>`-p c'</SAMP>, los nombres se convierten
em <CODE>cparse</CODE>, <CODE>clex</CODE>, etc.

</P>
<P>
<STRONG>El resto de las variables y macros asociadas con Bison no se
renombran.</STRONG>  Estas otras no son globales.  Por ejemplo, <CODE>YYSTYPE</CODE> no se
renombra, pero definirla de diferente forma en analizadores diferentes
no provoca confusión (see section <A HREF="bison-es-1.27.html#SEC49">Tipos de Datos para Valores Semánticos</A>).

</P>
<P>
La opción <SAMP>`-p'</SAMP> funciona añadiendo definiciones de macros al comienzo
del archivo fuente del analizador, definiendo <CODE>yyparse</CODE> como
<CODE><VAR>prefijo</VAR></CODE>parse, etc.  Esto sustituye efectivamente un nombre
por el otro en todo el fichero del analizador.

</P>


<H1><A NAME="SEC64" HREF="bison-es-1.27.html#TOC64">Interfaz del Analizador en Lenguaje C</A></H1>
<P>
<A NAME="IDX121"></A>
<A NAME="IDX122"></A>

</P>
<P>
El analizador de Bison es en realidad una función en C llamada <CODE>yyparse</CODE>.
Aquí describimos las convenciones de interfaz de <CODE>yyparse</CODE> y las otras
funciones que éste necesita usar.

</P>
<P>
Tenga en cuenta que el analizador utiliza muchos identificadores en C
comenzando con <SAMP>`yy'</SAMP> e <SAMP>`YY'</SAMP> para propósito interno.  Si utiliza 
tales identificadores (a parte de aquellos en este manual) en una acción o
en codigo C adicional en el archivo de la gramática, es probable que
se encuentre con problemas.

</P>



<H2><A NAME="SEC65" HREF="bison-es-1.27.html#TOC65">La Función del Analizador <CODE>yyparse</CODE></A></H2>
<P>
<A NAME="IDX123"></A>

</P>
<P>
Se llama a la función <CODE>yyparse</CODE> para hacer que el análisis
comience.  Esta función lee tokens, ejecuta acciones, y por último
retorna cuando se encuentre con el final del fichero o un error de
sintaxis del que no puede recuperarse.  Usted puede también escribir
acciones que ordenen a <CODE>yyparse</CODE> retornar inmediatamente
sin leer más allá.

</P>
<P>
El valor devuelto por <CODE>yyparse</CODE> es 0 si el análisis tuvo éxito 
(el retorno se debe al final del fichero).

</P>
<P>
El valor es 1 si el análisis falló (el retorno es debido a un error
de sintaxis).

</P>
<P>
En una acción, puede provocar el retorno inmediato de <CODE>yyparse</CODE>
utilizando estas macros:

</P>
<DL COMPACT>

<DT><CODE>YYACCEPT</CODE>
<DD>
<A NAME="IDX124"></A>
Retorna inmediatamente con el valor 0 (para indicar éxito).

<DT><CODE>YYABORT</CODE>
<DD>
<A NAME="IDX125"></A>
Retorna inmediatamente con el valor 1 (para indicar fallo).
</DL>



<H2><A NAME="SEC66" HREF="bison-es-1.27.html#TOC66">La Funcion del Analizador Léxico <CODE>yylex</CODE></A></H2>
<P>
<A NAME="IDX126"></A>
<A NAME="IDX127"></A>

</P>
<P>
La función del <STRONG>analizador léxico</STRONG>, <CODE>yylex</CODE>, reconoce tokens
desde el flujo de entrada y se los devuelve al analizador.  Bison no crea
esta función automáticamente; usted debe escribirla de manera que
<CODE>yyparse</CODE> pueda llamarla.  A veces se hace referencia a la función como
el scanner léxico.

</P>
<P>
En programas simples, <CODE>yylex</CODE> se define a menudo al final del archivo
de la gramática de Bison.  Si <CODE>yylex</CODE> se define en un archivo fuente
por separado, necesitará que las definiciones de las macros de tipos de
tokens estén disponibles ahí.  Para hecer esto, utilice la opción <SAMP>`-d'</SAMP>
cuando ejecute Bison, de manera que éste escribirá esas definiciones de macros
en un archivo de cabecera por separado 
<TT>`<VAR>nombre</VAR>.tab.h'</TT> que puede incluir en otros ficheros fuente que lo
necesiten.  See section <A HREF="bison-es-1.27.html#SEC92">Invocando a Bison</A>.
</P>



<H3><A NAME="SEC67" HREF="bison-es-1.27.html#TOC67">Convención de Llamada para <CODE>yylex</CODE></A></H3>

<P>
El valor que <CODE>yylex</CODE> devuelve debe ser un código numérico para el
tipo de token que se ha encontrado, o 0 para el final de la entrada.

</P>
<P>
Cuando se hace referencia a un token en las reglas gramaticales con
un nombre, ese nombre en el archivo del analizador se convierte en una
macro de C cuya definición es el valor numérico apropiado para
ese tipo de token.  De esta manera <CODE>yylex</CODE> puede utilizar el
nombre para indicar ese tipo.  See section <A HREF="bison-es-1.27.html#SEC45">Símbolos, Terminales y No Terminales</A>.

</P>
<P>
Cuando se hace referencia a un token en las reglas gramaticales por un
caracter literal, el código numérico para ese caracter también es el código
para el tipo de token.  Así <CODE>yylex</CODE> puede simplemente devolver ese
código de caracer.  El caracter nulo no debe utilizarse de esta manera,
porque su código es el cero y eso es lo que simboliza el final de la entrada.

</P>
<P>
Aquí hay un ejemplo mostrando estas cosas:

</P>

<PRE>
yylex ()
{
  ...
  if (c == EOF)    /* Detecta el fin de fichero. */
    return 0;
  ...
  if (c == '+' || c == '-')
    return c;      /* Asume que el tipo de token para `+' es '+'. */
  ...
  return INT;      /* Devuelve el tipo del token. */
  ...
}
</PRE>

<P>
Este interfaz se ha diseñado para que la salida de la utilidad
<CODE>lex</CODE> pueda utilizarse sin cambios como definición de <CODE>yylex</CODE>.

</P>
<P>
Si la gramática utiliza tokens de cadena literal, hay dos maneras
por las que <CODE>yylex</CODE> puede determianr los códigos de tipo de token
para estos:

</P>

<UL>
<LI>

Si la gramática define nombres de token simbólicos como alias para
los tokens de cadena literal, <CODE>yylex</CODE> puede utilizar estos
nombres simbólicos como los demás.  En este caso, el uso de tokens de
cadena literal en el archivo de la gramática no tiene efecto sobre
<CODE>yylex</CODE>.

<LI>

<CODE>yylex</CODE> puede encontrar el token multi-caracter en la tabla 
<CODE>yytname</CODE>.  El índice del token en la tabla es el código del
tipo de token.  El nombre de un token multi-caracter se almacena
en <CODE>yytname</CODE> con una comilla doble, los caracteres del token, y otra
comilla doble.  Los caracteres del token no son traducidos de ninguna
forma; ellos aparecen textualmente en el contenido de la cadena
dentro de la tabla.

Aquí está el código para localizar un token en <CODE>yytname</CODE>, asumiendo
que los caracteres del token se almacenan en <CODE>token_buffer</CODE>.


<PRE>
for (i = 0; i &#60; YYNTOKENS; i++)
  {
    if (yytname[i] != 0
        &#38;&#38; yytname[i][0] == '"'
        &#38;&#38; strncmp (yytname[i] + 1, token_buffer,
                    strlen (token_buffer))
        &#38;&#38; yytname[i][strlen (token_buffer) + 1] == '"'
        &#38;&#38; yytname[i][strlen (token_buffer) + 2] == 0)
      break;
  }
</PRE>

La tabla <CODE>yytname</CODE> se genera sólo si se utiliza la declaración
<CODE>%token_table</CODE>.  See section <A HREF="bison-es-1.27.html#SEC62">Sumario de Declaraciones de Bison</A>.
</UL>



<H3><A NAME="SEC68" HREF="bison-es-1.27.html#TOC68">Valores Semánticos de los Tokens</A></H3>

<P>
<A NAME="IDX128"></A>
En un analizador ordinario (no reentrante), los valores semánticos del
token deben almacenarse en la variable global <CODE>yylval</CODE>.  Cuando esté
usando un solo tipo de valores semánticos, <CODE>yylval</CODE> tiene ese tipo.
Así, si el tipo es <CODE>int</CODE> (por defecto), podría escribir esto en
<CODE>yylex</CODE>:

</P>

<PRE>
  ...
  yylval = valor;  /* Pone valor en la pila de Bison. */
  return INT;      /* Devuelve el tipo del token. */
  ...
</PRE>

<P>
Cuando esté utilizando varios tipos de datos, el tipo de <CODE>yylval</CODE> es una
union compuesta a partir de la declaración 
<CODE>%union</CODE> (see section <A HREF="bison-es-1.27.html#SEC57">La Colección de Tipos de Valores</A>).
Así cuando almacene un valor de token, debe utilizar el miembro
apropiado de la union.  Si la declaración <CODE>%union</CODE> tiene el
siguiente aspecto: 

</P>

<PRE>
%union {
  int intval;
  double val;
  symrec *tptr;
}
</PRE>

<P>
entonces el código en <CODE>yylex</CODE> podría ser así:

</P>

<PRE>
  ...
  yylval.intval = valor; /* Pone el valor en la pila de Bison. */
  return INT;            /* Devuelve el tipo del token. */
  ...
</PRE>



<H3><A NAME="SEC69" HREF="bison-es-1.27.html#TOC69">Posiciones en el Texto de los Tokens</A></H3>

<P>
<A NAME="IDX129"></A>
Si está usando la propiedad <SAMP>`@<VAR>n</VAR>'</SAMP> (see section <A HREF="bison-es-1.27.html#SEC72">Propiedades Especiales para su Uso en Acciones</A>) en
acciones para seguir la pista de las posiciones en el texto de los tokens
y agrupaciones, entonces debe proveer esta información en <CODE>yylex</CODE>.  La
función <CODE>yyparse</CODE> espera encontrar la posición en el texto de
un token que se acaba de analizar en la variable global <CODE>yylloc</CODE>.
Por ello <CODE>yylex</CODE> debe almacenar el dato apropiado en esa variable.
El valor de <CODE>yylloc</CODE> es una estructura y solo tiene que inicializar
los miembros que vayan a ser utilizados por las acciones.  Los cuatro
miembros se denominan <CODE>first_line</CODE>, <CODE>first_column</CODE>,
<CODE>last_line</CODE> y <CODE>last_column</CODE> <A NAME="DOCF1" HREF="bison-es-1.27.html#FOOT1">(1)</A>.  Note que el
uso de estas características hacen al analizador notablemente más lento.

</P>
<P>
<A NAME="IDX130"></A>
El tipo de dato de <CODE>yylloc</CODE> tiene el nombre <CODE>YYLTYPE</CODE>.

</P>


<H3><A NAME="SEC70" HREF="bison-es-1.27.html#TOC70">Convenciones de Llamada para Analizadores Puros</A></H3>

<P>
Cuando utilice la declaración <CODE>%pure_parser</CODE> para solicitar un
analizador puro, reentrante, las variables globales de comunicación
<CODE>yylval</CODE> y <CODE>yylloc</CODE> no pueden usarse.  (See section <A HREF="bison-es-1.27.html#SEC61">Un Analizador Puro (Reentrante)</A>.)  
En tales analizadores las dos variables globales se reemplazan
por punteros pasados como parámetros a <CODE>yylex</CODE>.  Debe declararlos
como se muestra aquí, y pasar la información de nuevo almacenándola
a través de esos punteros.

</P>

<PRE>
yylex (lvalp, llocp)
     YYSTYPE *lvalp;
     YYLTYPE *llocp;
{
  ...
  *lvalp = valor;  /* Pone el valor en la pila de Bison.  */
  return INT;      /* Devolver el tipo del token.  */
  ...
}
</PRE>

<P>
Si el archivo de la gramática no utiliza la construcción <SAMP>`@'</SAMP> para
hacer referencia a las posiciones del texto, entonces el tipo <CODE>YYLTYPE</CODE>
no será definido.  En este caso, omitir el segundo argumento; <CODE>yylex</CODE>
será llamado con solo un argumento.

</P>
<P>
<A NAME="IDX131"></A>
Si utiliza un analizador reentrante, puede opcionalmente pasar 
información de parámetros adicional de forma reentrante.  Para hacerlo, 
defina la macro <CODE>YYPARSE_PARAM</CODE> como un nombre de variable.  Esto
modifica la función <CODE>yyparse</CODE> para que acepte un argumento, de tipo
<CODE>void *</CODE>, con ese nombre.

</P>
<P>
Cuando llame a <CODE>yyparse</CODE>, pase la dirección de un objeto, haciendo
una conversión de tipos de la dirección a <CODE>void *</CODE>.  Las acciones
gramaticales pueden hacer referencia al contenido del objeto haciendo
una conversión del valor del puntero a su tipo apropiado y entonces
derreferenciándolo.  Aquí hay un ejemplo.  Escriba esto en el analizador:

</P>

<PRE>
%{
struct parser_control
{
  int nastiness;
  int randomness;
};

#define YYPARSE_PARAM parm
%}
</PRE>

<P>
Entonces llame al analizador de esta manera:

</P>

<PRE>
struct parser_control
{
  int nastiness;
  int randomness;
};

...

{
  struct parser_control foo;
  ...  /* Almacena los datos apropiados en <CODE>foo</CODE>.  */
  value = yyparse ((void *) &#38;foo);
  ...
}
</PRE>

<P>
En las acciones gramaticales, utilice expresiones como ésta para hacer
referencia a los datos:

</P>

<PRE>
((struct parser_control *) parm)-&#62;randomness
</PRE>

<P>
<A NAME="IDX132"></A>
Si desea pasar los datos de parámetros adicionales a <CODE>yylex</CODE>,
defina la macro <CODE>YYLEX_PARAM</CODE> como <CODE>YYPARSE_PARAM</CODE>, tal
como se muestra aquí:

</P>

<PRE>
%{
struct parser_control
{
  int nastiness;
  int randomness;
};

#define YYPARSE_PARAM parm
#define YYLEX_PARAM parm
%}
</PRE>

<P>
Debería entonces definir <CODE>yylex</CODE> para que acepte un argumento
adicional--el valor de <CODE>parm</CODE>.  (Este hace uno o tres argumentos
en total, dependiendo de si se le pasa un argumento de tipo <CODE>YYLTYPE</CODE>.)
Puede declarar el argumento como un puntero al tipo de objeto apropiado, o
puede declararlo como <CODE>void *</CODE> y acceder al contenido como se mostró antes.

</P>
<P>
Puede utilizar <SAMP>`%pure_parser'</SAMP> para solicitar un analizador reentrante
sin usar también <CODE>YYPARSE_PARAM</CODE>.  Entonces debería llamar a
<CODE>yyparse</CODE> sin argumentos, como es usual.

</P>


<H2><A NAME="SEC71" HREF="bison-es-1.27.html#TOC71">La Función de Informe de Errores <CODE>yyerror</CODE></A></H2>
<P>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>
<A NAME="IDX135"></A>
<A NAME="IDX136"></A>
<A NAME="IDX137"></A>

</P>
<P>
El analizador de Bison detecta un <STRONG>error de análisis</STRONG> o <STRONG>error
de sintaxis</STRONG> siempre que lea un token que no puede satisfacer ninguna
regla sintáctica.  Una acción en la gramática puede también
explícitamente declarar un error, utilizando la macro
<CODE>YYERROR</CODE> (see section <A HREF="bison-es-1.27.html#SEC72">Propiedades Especiales para su Uso en Acciones</A>).

</P>
<P>
El analizador de Bison espera advertir del error llamando a una
función de informe de errores denominada <CODE>yyerror</CODE>, que se debe
proveer.  Esta es llamada por <CODE>yyparse</CODE> siempre que encuentre
un error sintáctico, y ésta recibe un argumento.  Para un error de
análisis, la cadena normalmente es <CODE>"parse error"</CODE>.

</P>
<P>
<A NAME="IDX138"></A>
Si define la macro <CODE>YYERROR_VERBOSE</CODE> en la sección de 
declaraciones de Bison (see section <A HREF="bison-es-1.27.html#SEC42">La Sección de Declaraciones de Bison</A>),
entonces Bison facilita una cadena de mensaje de error mas locuaz y específica
que el simple <CODE>"parse error"</CODE>.  No importa qué definiciones
utilice para <CODE>YYERROR_VERBOSE</CODE>, si ya lo define.

</P>
<P>
El analizador puede detectar otro tipo de error: desbordamiento de pila.  Esto
sucede cuando la entrada contiene construcciones que son profundamente
anidadas.  No parece que vaya a encontrarse con esto, ya que el analizador
de Bison extiende su pila automáticamente hasta un límite muy largo.  Pero
si el desbordamiento sucede, <CODE>yyparse</CODE> llama a <CODE>yyerror</CODE> de la
manera usual, excepto que la cadena del argumento es <CODE>"parser stack
overflow"</CODE>.

</P>
<P>
La siguiente definición es suficiente para programas simples:

</P>

<PRE>
yyerror (s)
     char *s;
{
  fprintf (stderr, "%s\n", s);
}
</PRE>

<P>
Después <CODE>yyerror</CODE> retorna a <CODE>yyparse</CODE>, este último intentará
la recuperación de errores si ha escrito reglas gramaticales de recuperación
de errores apropiadas (see section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>).
Si la recuperación es imposible, <CODE>yyparse</CODE> devolverá inmediatamente un 1.

</P>
<P>
<A NAME="IDX139"></A>
La variable <CODE>yynerrs</CODE> contiene el número de errores sintácticos
hasta ahora.  Normalmente esta variable es global; pero si solicita un
analizador puro (see section <A HREF="bison-es-1.27.html#SEC61">Un Analizador Puro (Reentrante)</A>)
entonces es una variable local a la que sólo las acciones pueden acceder. 

</P>


<H2><A NAME="SEC72" HREF="bison-es-1.27.html#TOC72">Propiedades Especiales para su Uso en Acciones</A></H2>
<P>
<A NAME="IDX140"></A>
<A NAME="IDX141"></A>

</P>
<P>
Aquí hay una tabla de construcciones, variables y macros que
son útiles en las acciones.

</P>
<DL COMPACT>

<DT><SAMP>`$$'</SAMP>
<DD>
Actúa como una variable que contiene el valor semántico para
la agrupación construida por la regla actual.  See section <A HREF="bison-es-1.27.html#SEC51">Acciones</A>.

<DT><SAMP>`$<VAR>n</VAR>'</SAMP>
<DD>
Actúa como una variable que contiene el valor semántico para
la componente <VAR>n</VAR>-ésima de la regla actual.  See section <A HREF="bison-es-1.27.html#SEC51">Acciones</A>.

<DT><SAMP>`$&#60;<VAR>alttipo</VAR>&#62;$'</SAMP>
<DD>
Como <CODE>$$</CODE> pero especifica la alternativa <VAR>alttipo</VAR> en la
union especificada por la declaración
<CODE>%union</CODE>. See section <A HREF="bison-es-1.27.html#SEC52">Tipos de Datos de Valores en Acciones</A>.

<DT><SAMP>`$&#60;<VAR>alttipo</VAR>&#62;<VAR>n</VAR>'</SAMP>
<DD>
Como <CODE>$<VAR>n</VAR></CODE> pero especifica la alternativa <VAR>alttipo</VAR>
en la union especificada por la declaración <CODE>%union</CODE>.
See section <A HREF="bison-es-1.27.html#SEC52">Tipos de Datos de Valores en Acciones</A>.
<DT><SAMP>`YYABORT;'</SAMP>
<DD>
Retorna inmediatamente desde <CODE>yyparse</CODE>, indicando fallo.
See section <A HREF="bison-es-1.27.html#SEC65">La Función del Analizador <CODE>yyparse</CODE></A>.

<DT><SAMP>`YYACCEPT;'</SAMP>
<DD>
Retorna inmediatamente desde <CODE>yyparse</CODE>, indicando éxito.
See section <A HREF="bison-es-1.27.html#SEC65">La Función del Analizador <CODE>yyparse</CODE></A>.

<DT><SAMP>`YYBACKUP (<VAR>token</VAR>, <VAR>valor</VAR>);'</SAMP>
<DD>
<A NAME="IDX142"></A>
Deshace el desplazamiento de un token.  Esta macro se permite únicamente para
reglas que reducen un valor sencillo, y sólo donde no hay
un token de preanálisis.  Esta inserta un token de preanálisis
con un tipo de token <VAR>token</VAR> y valor semántico <VAR>valor</VAR>;
entonces se descarta el valor que iba a ser reducido por esta
regla.

Si la macro se utiliza cuando no es válida, tal como cuando ya hay
un token de preanálisis, entonces se produce un error de sintaxis
con el mensaje <SAMP>`cannot back up'</SAMP> y realiza la recuperación de
errores ordinaria.

En cualquier caso, el resto de la acción no se ejecuta.

<DT><SAMP>`YYEMPTY'</SAMP>
<DD>
<A NAME="IDX143"></A>
El valor almacenado en <CODE>yychar</CODE> cuando no hay un token
de preanálisis.

<DT><SAMP>`YYERROR;'</SAMP>
<DD>
<A NAME="IDX144"></A>
Produce un error de sintaxis inmediatamente.  Esta sentencia inicia
la recuperación de errores como si el analizador hubiese detectado
un error; sin embargo, no se llama a <CODE>yyerror</CODE>, y no imprime
ningún mensaje.  Si quiere que imprima un mensaje de error,  llame
a <CODE>yyerror</CODE> explícitamente antes de la sentencia <SAMP>`YYERROR'</SAMP>.
See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

<DT><SAMP>`YYRECOVERING'</SAMP>
<DD>
Esta macro representa una expresión que tiene el valor 1 cuando el
analizador se está recuperando de un error de sintaxis, y 0 durante
el resto del tiempo.
See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

<DT><SAMP>`yychar'</SAMP>
<DD>
Variable que contiene el token actual de preanálisis.  (En un analizador
puro, esto es realmente una variable local dentro de <CODE>yyparse</CODE>.)  
Cuando no hay un token de preanálisis, el valor de <CODE>YYEMPTY</CODE> se
almacena en la variable.  See section <A HREF="bison-es-1.27.html#SEC74">Tokens de Preanálisis</A>.

<DT><SAMP>`yyclearin;'</SAMP>
<DD>
Descarta el token actual de preanálisis.  Esto es útil principalmente
en las reglas de error.  See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

<DT><SAMP>`yyerrok;'</SAMP>
<DD>
Deja de generar mensajes de error inmediatamente para los errores
de sintaxis subsecuentes.  Esto es útil principalmente en las reglas
de error.
See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

<DT><SAMP>`@<VAR>n</VAR>'</SAMP>
<DD>
<A NAME="IDX145"></A>
Actúa como una variable estructurada conteniendo información de los
números de línea y columna de la componente <VAR>n</VAR>-ésima de la
regla actual.  La estructura tiene cuatro miembros, así:


<PRE>
struct {
  int first_line, last_line;
  int first_column, last_column;
};
</PRE>

De esta manera, para obtener el número de línea de comienzo del tercer
componente, utilizaría <SAMP>`@3.first_line'</SAMP>.

Para que los miembros de esta estructura contengan información válida,
debe hacer que <CODE>yylex</CODE> facilite esta información para cada token.
Si solo necesita de ciertos miembros, entonces <CODE>yylex</CODE> necesita
únicamente rellenar esos miembros.

El uso de esta característica hace al analizador notablemente
más lento.
</DL>



<H1><A NAME="SEC73" HREF="bison-es-1.27.html#TOC73">El Algoritmo del Analizador de Bison</A></H1>
<P>
<A NAME="IDX146"></A>
<A NAME="IDX147"></A>
<A NAME="IDX148"></A>
<A NAME="IDX149"></A>
<A NAME="IDX150"></A>
<A NAME="IDX151"></A>

</P>
<P>
A medida que Bison lee tokens, los va insertando en una pila junto
con su valor semántico.  La pila se denomina <STRONG>pila del analizador</STRONG>.
El insertar un token tradicionalmente se denomina <STRONG>desplazamiento</STRONG>.

</P>
<P>
Por ejemplo, suponga que la calculadora infija ha leído <SAMP>`1 + 5 *'</SAMP>, con
un <SAMP>`3'</SAMP> por venir.  La pila contendrá cuatro elementos, uno para
cada token que fue desplazado.

</P>
<P>
Pero la pila no siempre contiene un elemento para cada token leído.  Cuando
los últimos <VAR>n</VAR> tokens y agrupaciones desplazadas concuerden con los
componentes de una regla gramatical, estos pueden combinarse de acuerdo
a esa regla.  A esto se le denomina <STRONG>reducción</STRONG>.  Esos tokens y
agrupaciones se reemplazan en la pila por una sola agrupación cuyo símbolo
es el resultado (lado izquierdo) de esa regla.  La ejecución de la acción
de la regla es parte del proceso de reducción, porque ésta es la que
computa el valor semántico de la agrupación resultante.

</P>
<P>
Por ejemplo, si el analizador de la calculadora infija contiene esto:

</P>

<PRE>
1 + 5 * 3
</PRE>

<P>
y el siguiente token de entrada es un caracter de nueva línea, entonces
los tres últimos elementos pueden reducirse a 15 mediante la regla:

</P>

<PRE>
expr: expr '*' expr;
</PRE>

<P>
Entonces la pila contiene exactamente estos tres elementos:

</P>

<PRE>
1 + 15
</PRE>

<P>
En este punto, se puede realizar otra reducción, resultando en el valor 16.
Entonces el token de nueva línea se puede desplazar.

</P>
<P>
El analizador intenta, mediante desplazamientos y reducciones, reducir la
entrada completa a una sola agrupación cuyo símbolo es el símbolo de
arranque de la gramática
(see section <A HREF="bison-es-1.27.html#SEC13">Lenguajes y Gramáticas independientes del Contexto</A>).

</P>
<P>
Este tipo de analizador se conoce en la literatura como analizador
ascendente.

</P>



<H2><A NAME="SEC74" HREF="bison-es-1.27.html#TOC74">Tokens de Preanálisis</A></H2>
<P>
<A NAME="IDX152"></A>

</P>
<P>
El analizador de Bison <EM>no</EM> siempre reduce inmediatamente tan pronto
como los últimos <VAR>n</VAR> tokens y agrupaciones se correspondan con una
regla.  Esto es debido a que es inadecuada una estrategia tan simple para
manejar la mayoría de los lenguajes.  En su lugar, cuando es posible
una reducción, el analizador algunas veces "mira hacia delante" al
próximo token para decidir qué hacer.

</P>
<P>
Cuando se lee un token, este no se desplaza inmediatamente; primero
se convierte en el <STRONG>token de preanálisis</STRONG>, que no se pone sobre la pila.
Ahora el analizador puede realizar una o más reducciones de tokens y
agrupaciones sobre la pila, mientras que el token de preanálisis se
mantiene fuera a un lado.  Esto no significa que se han realizado
todas las posibles reducciones; dependiendo del tipo de token del token
de preanálisis, algunas reglas podrían escoger retrasar su aplicación.

</P>
<P>
Aquí hay un caso simple donde se necesita el token de preanálisis.  Estas
tres reglas definen expresiones que contienen operadores de suma binaria y
operaciones factoriales unarios postfijos (<SAMP>`!'</SAMP>), y se permiten los
paréntesis para agrupar.

</P>

<PRE>
expr:     term '+' expr
        | term
        ;

term:     '(' expr ')'
        | term '!'
        | NUMBER
        ;
</PRE>

<P>
Suponga que se ha leído el token <SAMP>`1 + 2'</SAMP> y ha sido desplazado;
¿qué debería hacerse?  Si el próximo token es <SAMP>`)'</SAMP>, entonces los
primeros tres tokens deberían reducirse para formar una <CODE>expr</CODE>.  Este es
el único camino válido, porque el desplazamiento de <SAMP>`)'</SAMP> produciría
una secuencia de símbolos <CODE>term ')'</CODE>, y ninguna regla lo permite.

</P>
<P>
Si el siguiente token es <SAMP>`!'</SAMP>, entonces debe ser desplazado inmediatamente
de manera que <SAMP>`2 !'</SAMP> se pueda reducir para hacer un <CODE>term</CODE>.  Si
en su lugar el analizador fuera a reducir antes de desplazar,
<SAMP>`1 + 2'</SAMP> se convertiría en una <CODE>expr</CODE>.  Sería entonces
imposible desplazar el <SAMP>`!'</SAMP> porque haciéndolo produciría en la pila
la secuencia de símbolos <CODE>expr '!'</CODE>. Ninguna regla permite esa secuencia.

</P>
<P>
<A NAME="IDX153"></A>
El token de preanálisi actual se almacena en la variable <CODE>yychar</CODE>.
See section <A HREF="bison-es-1.27.html#SEC72">Propiedades Especiales para su Uso en Acciones</A>.

</P>


<H2><A NAME="SEC75" HREF="bison-es-1.27.html#TOC75">Conflictos de Desplazamiento/Reducción</A></H2>
<P>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<A NAME="IDX157"></A>

</P>
<P>
Suponga que estamos analizando un lenguaje que tiene las sentencias
if-then y if-then-else, con un par de reglas como estas:

</P>

<PRE>
if_stmt:
          IF expr THEN stmt
        | IF expr THEN stmt ELSE stmt
        ;
</PRE>

<P>
Aquí asumimos que <CODE>IF</CODE>, <CODE>THEN</CODE> y <CODE>ELSE</CODE> son
símbolos terminales de tokens para palabras clave específicas.

</P>
<P>
Cuando se lea el token <CODE>ELSE</CODE> y se convierta en el token de
preanálisis, el contenido de la pila (asumiendo que la entrada es válida)
está listo para una reducción por la primera regla.  Pero también es
legítimo desplazar el <CODE>ELSE</CODE>, porque eso conllevaría a una redución
provisional por la segunda regla.

</P>
<P>
Esta situación, donde sería válido un desplazamiento o una reducción,
se denomina un <STRONG>conflicto desplazamiento/reducción</STRONG>.  Bison está
diseñado para resolver estos conflictos eligiendo el desplazamiento,
a menos que se le dirija con declaraciones de precedencia de operadores.
Para ver la razón de esto, vamos a contrastarlo con la otra alternativa.

</P>
<P>
Ya que el analizador prefiere desplazar el <CODE>ELSE</CODE>, el resultado sería
ligar la cláusula else con la sentencia if más interior, haciendo que estas
dos entradas sean equivalentes:

</P>

<PRE>
if x then if y then gana (); else pierde;

if x then do; if y then gana (); else pierde; end;
</PRE>

<P>
Pero si el analizador escoge la reducción cuando es posible en lugar
de desplazar, el resultado sería ligar la cláusula else a la sentencia
if más exterior, haciendo que estas dos entradas sean equivalentes:

</P>

<PRE>
if x then if y then gana (); else pierde;

if x then do; if y then gana (); end; else pierde;
</PRE>

<P>
El conflicto existe porque la gramática escrita es ambigua: en todo caso
el análisis de la sentencia if simple anidada es legítima.  La convención
es que estas ambigüedades se resuelvan emparejando la cláusula else a la
sentencia if más interior; esto es lo que Bison consigue eligiendo el
desplazamiento en vez de la reducción.  (Idealmente sería más adecuado 
escribir una gramática no ambigua, pero eso es muy duro de hacer en este
caso.) Esta ambigüedad en particular se encontró en primer lugar en la
especificación de Algol 60 y se denominó la ambiguedad del "balanceado
del <CODE>else</CODE>".

</P>
<P>
Para evitar advertencias de Bison a cerca de los predecibles, legítimos
conflictos de desplazamiento/reducción, utilice la declaración 
<CODE>%expect <VAR>n</VAR></CODE>.  No se producirán avisos mientras el número
de conflictos de desplazamiento/reducción sea exactamente <VAR>n</VAR>.
See section <A HREF="bison-es-1.27.html#SEC59">Suprimiendo Advertencias de Conflictos</A>.

</P>
<P>
La definición de <CODE>if_stmt</CODE> anterior es la única que se va a quejar
del conflicto, pero el conflicto no aparecerá en realidad sin reglas
adicionales.  Aquí hay un fichero de entrada de Bison completo que
manfiesta realmente el conflicto:

</P>

<PRE>
%token IF THEN ELSE variable
%%
stmt:     expr
        | if_stmt
        ;

if_stmt:
          IF expr THEN stmt
        | IF expr THEN stmt ELSE stmt
        ;

expr:     variable
        ;
</PRE>



<H2><A NAME="SEC76" HREF="bison-es-1.27.html#TOC76">Precedencia de Operadores</A></H2>
<P>
<A NAME="IDX158"></A>
<A NAME="IDX159"></A>

</P>
<P>
Otra situación en donde pararecen los conflictos desplazamiento/reducción
es en las expresiones aritméticas.  Aquí el desplazamiento no siempre
es la resolución preferible; las declaraciones de Bison para la
precedencia de operadores le permite especificar cuándo desplazar
y cuando reducir.

</P>



<H3><A NAME="SEC77" HREF="bison-es-1.27.html#TOC77">Cuándo se Necesita la Precedencia</A></H3>

<P>
Considere el siguiente fragmento de gramática ambigua (ambigua porque
la entrada <SAMP>`1 - 2 * 3'</SAMP> puede analizarse de dos maneras):

</P>

<PRE>
expr:     expr '-' expr
        | expr '*' expr
        | expr '&#60;' expr
        | '(' expr ')'
        ...
        ;
</PRE>

<P>
Suponga que el analizador ha visto los tokens <SAMP>`1'</SAMP>, <SAMP>`-'</SAMP> y
<SAMP>`2'</SAMP>; ¿debería reducirlos por la regla del operador de adición?  Esto
depende del próximo token.  Por supuesto, si el siguiente token es un <SAMP>`)'</SAMP>,
debemos reducir; el desplazamiento no es válido porque  ninguna regla
puede reducir la secuencia de tokens <SAMP>`- 2 )'</SAMP> o cualquier cosa
que comience con eso.  Pero si el próximo token es <SAMP>`*'</SAMP> o <SAMP>`&#60;'</SAMP>,
tenemos que elegir: ya sea el desplazamiento o la reducción
permitiría al analizador terminar, pero con resultados diferentes.

</P>
<P>
Para decidir qué debería hacer Bison, debemos considerar los
resultados.  Si el siguiente token de operador <VAR>op</VAR> se
desplaza, entonces este debe ser reducido primero para permitir
otra oportunidad para reducir la suma.  El resultado es (en efecto)
<SAMP>`1 - (2 <VAR>op</VAR> 3)'</SAMP>.  Por otro lado, si se reduce la
resta antes del desplazamiento de <VAR>op</VAR>, el resultado es
<SAMP>`(1 - 2) <VAR>op</VAR> 3'</SAMP>.  Claramente, entonces, la elección
de desplazar o reducir dependerá de la precedencia relativa de
los operadores <SAMP>`-'</SAMP> y <VAR>op</VAR>: <SAMP>`*'</SAMP> debería desplazarse
primero, pero no <SAMP>`&#60;'</SAMP>.

</P>
<P>
<A NAME="IDX160"></A>
¿Qué hay de una entrada tal como <SAMP>`1 - 2 - 5'</SAMP>; debería
ser esta <SAMP>`(1 - 2) - 5'</SAMP> o debería ser <SAMP>`1 - (2 - 5)'</SAMP>?
Para la mayoría de los operadores preferimos la primera, que se
denomina <STRONG>asociación por la izquierda</STRONG>.  La última alternativa,
<STRONG>asociación por la derecha</STRONG>, es deseable para operadores de
asignación.  La elección de la asociación por la izquierda o la
derecha es una cuestión de qué es lo que el analizador elige si
desplazar o reducir cuando la pila contenga <SAMP>`1 - 2'</SAMP> y el
token de preanálisis sea <SAMP>`-'</SAMP>: el desplazamiento produce
asociatividad por la derecha.

</P>


<H3><A NAME="SEC78" HREF="bison-es-1.27.html#TOC78">Especificando Precedencia de Operadores</A></H3>
<P>
<A NAME="IDX161"></A>
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>

</P>
<P>
Bison le permite especificar estas opciones con las declaraciones de
precedencia de operadores <CODE>%left</CODE> y <CODE>%right</CODE>.  Cada una de
tales declaraciones contiene una lista de tokens, que son los operadores
cuya precedencia y asociatividad se está declarando.  La declaración
<CODE>%left</CODE> hace que todos esos operadores sean asociativos por la
izquierda y la declaración <CODE>%right</CODE> los hace asociativos por la
derecha.  Una tercera alternativa es <CODE>%nonassoc</CODE>, que declara
que es un error de sintaxis encontrar el mismo operador dos veces
"en un fila".

</P>
<P>
La precedencia relativa de operadores diferentes se controla por el
orden en el que son declarados.  La primera declaración <CODE>%left</CODE>
o <CODE>%right</CODE> en el fichero declara los operadores cuya precedencia
es la menor, la siguiente de tales declaraciones declara los operadores
cuya precedencia es un poco más alta, etc.

</P>


<H3><A NAME="SEC79" HREF="bison-es-1.27.html#TOC79">Ejemplos de Precedencia</A></H3>

<P>
En nuestro ejemplo, queríamos las siguientes declaraciones:

</P>

<PRE>
%left '&#60;'
%left '-'
%left '*'
</PRE>

<P>
En un ejemplo más completo, que permita otros operadores también,
los declararíamos en grupos de igual precedencia.  Por ejemplo, <CODE>'+'</CODE>
se declara junto con <CODE>'-'</CODE>:

</P>

<PRE>
%left '&#60;' '&#62;' '=' NE LE GE
%left '+' '-'
%left '*' '/'
</PRE>

<P>
(Aquí <CODE>NE</CODE> y el resto representan los operadores para "distinto",
etc.  Asumimos que estos tokens son de más de un caracter de largo y
por lo tanto son representados por nombres, no por caracteres literales.)

</P>


<H3><A NAME="SEC80" HREF="bison-es-1.27.html#TOC80">Cómo Funciona la Precedencia</A></H3>

<P>
El primer efecto de las declaraciones de precedencia es la asignación
de niveles de precedencia a los símbolos terminales declarados.  El
segundo efecto es la asignación de niveles de precedencia a ciertas
reglas: cada regla obtiene su precedencia del último simbolo terminal
mencionado en las componentes.  (También puede especificar explícitamente
la precedencia de una regla.  See section <A HREF="bison-es-1.27.html#SEC81">Precedencia Dependiente del Contexto</A>.)

</P>
<P>
Finalmente, la resolución de conflictos funciona comparando
la precendecia de la regla que está siendo considerada con la
del token de preanálisis.  Si la precedencia del token es más
alta, la elección es desplazar.  Si la precedencia de la regla
es más alta, la elección es reducir.  Si tienen la misma 
precedencia, la elección se hace en base a la asociatividad de
ese nivel de precedencia. El archivo de salida amplia producido por <SAMP>`-v'</SAMP>
(see section <A HREF="bison-es-1.27.html#SEC92">Invocando a Bison</A>) dice cómo fue resuelto cada 
conflicto.

</P>
<P>
No todas las reglas y no todos los tokens tienen precedencia.  Si bien
la regla o el token de preanálisis no tienen precedencia, entonces por
defecto de desplaza.

</P>


<H2><A NAME="SEC81" HREF="bison-es-1.27.html#TOC81">Precedencia Dependiente del Contexto</A></H2>
<P>
<A NAME="IDX164"></A>
<A NAME="IDX165"></A>
<A NAME="IDX166"></A>
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>

</P>
<P>
A menudo la precedencia de un operador depende del contexto.  Esto suena
raro al principio, pero realmente es muy común.  Por ejemplo, un
signo menos típicamente tiene una precedencia muy alta como operador
unario, y una precedencia algo menor (menor que la multiplicación) como
operador binario.

</P>
<P>
Las declaraciones de precedencia de Bison, <CODE>%left</CODE>, <CODE>%right</CODE> y
<CODE>%nonassoc</CODE>, puede utilizarse únicamente para un token dado; de manera
que un token tiene sólo una precedencia declarada de esta manera.  Para la
precedencia dependiente del contexto, necesita utilizar un mecanismo
adicional: el modifidor <CODE>%prec</CODE> para las reglas.
</P>
<P>
El modificador <CODE>%prec</CODE> declara la precedencia de una regla en
particular especificando un símbolo terminal cuya precedencia debe
utilizarse para esa regla.  No es necesario por otro lado que ese
símbolo aparezca en la regla.  La sintaxis del modificador es:

</P>

<PRE>
%prec <VAR>símbolo-terminal</VAR>
</PRE>

<P>
y se escribe despúes de los componentes de la regla.  Su efecto
es asignar a la regla la precedencia de <VAR>símbolo-terminal</VAR>,
imponiéndose a la precedencia que se deduciría de forma ordinaria.  La
precedencia de la regla alterada afecta enconces a cómo se resuelven
los conflictos relacionados con esa regla (see section <A HREF="bison-es-1.27.html#SEC76">Precedencia de Operadores</A>).

</P>
<P>
Aquí está cómo <CODE>%prec</CODE> resuelve el problema del menos unario.  Primero,
declara una precedencia para un símbolo terminal ficticio llamada
<CODE>UMINUS</CODE>.  Aquí no hay tokens de este tipo, pero el símbolo sirve
para representar su precedencia:

</P>

<PRE>
...
%left '+' '-'
%left '*'
%left UMINUS
</PRE>

<P>
Ahora la precedencia de <CODE>UMINUS</CODE> se puede utilizar en
reglas específicas:

</P>

<PRE>
exp:    ...
        | exp '-' exp
        ...
        | '-' exp %prec UMINUS
</PRE>



<H2><A NAME="SEC82" HREF="bison-es-1.27.html#TOC82">Estados del Analizador</A></H2>
<P>
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
<A NAME="IDX171"></A>

</P>
<P>
La función <CODE>yyparse</CODE> se implementa usando una máquina de estado
finito.  Los valores insertados sobre la pila no son únicamente códigos
de tipos de tokens; estos representan toda la secuencia de símbolos
terminales y no terminales en o cerca del tope de la pila.  El estado
actual colecciona toda esta información sobre la entrada anterior
que es relevante para decidir qué hacer a continuación.

</P>
<P>
Cada vez que se lee un token de preanálisis, el estado actual del analizador
junto con el tipo de token de preanálisis se localizan en una tabla.  Esta
entrada en la tabla puede decir, "Desplace el token de preanálisis."  En este
caso, también especifica el nuevo estado del analizador, que se pone sobre el
tope de la pila del analizador.  O puede decir, "Reduzca utilizando la regla 
número <VAR>n</VAR>."  Esto quiere decir que un cierto número de tokens o
agrupaciones se sacan de la pila, y se reemplazan por una agrupación.  En
otras palabras, se extrae ese número de estados de la pila, y se
empuja un nuevo estado.

</P>
<P>
Hay otra alternativa: la tabla puede decir que el token de preanálisis
es erróneo en el estado actual.  Esto provoca que comience el procesamiento de
errores (see section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>).

</P>


<H2><A NAME="SEC83" HREF="bison-es-1.27.html#TOC83">Conflictos de Reducción/Reducción</A></H2>
<P>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>

</P>
<P>
Se produce un conflicto de reducción/reducción si hay dos o más reglas
que pueden aplicarse a la misma secuencia de entrada.  Esto suele indicar
un error serio en la gramática.

</P>
<P>
Por ejemplo, aquí hay un intento fallido de definir una secuencia
de cero o más agrupaciones de <CODE>palabra</CODE>.

</P>

<PRE>
secuencia: /* vacío */
                 { printf ("secuencia vacía\n"); }
         | posiblepalabra
         | secuencia palabra
                 { printf ("palabra añadida %s\n", $2); }
         ;
posiblepalabra: /* vacío */
                { printf ("posiblepalabra vacío\n"); }
        | palabra
                { printf ("palabra sencilla %s\n", $1); }
        ;
</PRE>

<P>
El error es una ambigüedad: hay más de una manera de analizar una
<CODE>palabra</CODE> sencilla en una <CODE>secuencia</CODE>.  Esta podría reducirse
a una <CODE>posiblepalabra</CODE> y entonces en una <CODE>secuencia</CODE> mediante la
segunda regla.  Alternativamente, la cadena vacía se prodría reducir
en una <CODE>secuencia</CODE> mediante la primera regla, y esto prodría
combinarse con la <CODE>palabra</CODE> utilizando la tercera regla para
<CODE>secuencia</CODE>.

</P>
<P>
Existe también más de una manera de reducir la cadena vacía
en una <CODE>secuencia</CODE>.  Esto se puede hacer directamente mediante
la primera regla, o indirectamente mediante <CODE>posiblepalabra</CODE> y
entonces la segunda regla.

</P>
<P>
Podría pensar que esto es una distinción sin ninguna diferencia, porque
esto no cambia si una entrada particular es válida o no.  Pero
sí afecta en las acciones que son ejecutadas.  Una ordenación del análisis
ejecuta la acción de la segunda regla; la otra ejecuta la acción de la
primera regla y la acción de la tercera regla.  En este ejemplo, la
salida del programa cambia.

</P>
<P>
Bison resuelve un conflicto reducción/reducción eligiendo el uso de
la regla que aparece en primer lugar dentro de la gramática, pero es muy
arriesgado contar con esto.  Cada conflicto de reducción/reducción
se debe estudiar y normalmente eliminar.  Aquí está la manera
apropiada de definir <CODE>secuencia</CODE>:

</P>

<PRE>
secuencia: /* vacío */
                 { printf ("secuencia vacía\n"); }
         | secuencia palabra
                 { printf ("palabra añadida %s\n", $2); }
         ;
</PRE>

<P>
Aquí hay otro error común que produce un conflicto reducción/reducción.

</P>

<PRE>
secuencia: /* vacío */
         | secuencia palabras
         | secuencia redirecciones
         ;

palabras: /* vacío */
        | palabras palabra
        ;

redirecciones: /* vacío */
             | redirecciones redireccion
             ;
</PRE>

<P>
La intención aquí es definir una secuencia que pueda contener
ya sea agrupaciones <CODE>palabra</CODE> o <CODE>redireccion</CODE>.  Las definiciones
individuales de <CODE>secuencia</CODE>, <CODE>palabras</CODE> y <CODE>redirecciones</CODE> están
libres de errores, pero las tres juntas producen una ambigüedad sutil:
¡incluso una entrada vacía puede analizarse en una infinidad de maneras
diferentes!

</P>
<P>
Considere esto: la cadena vacía podría ser una <CODE>palabras</CODE>.  O podrían ser
dos <CODE>palabras</CODE> en una fila, o tres, o cualquier número.  Podría igualmente
ser una <CODE>redirecciones</CODE>, o dos, o cualquier número.  O podría ser una
<CODE>palabras</CODE> seguido de tres <CODE>redirecciones</CODE> y otra <CODE>palabras</CODE>. Y así
sucesivamente.

</P>
<P>
Aquí hay dos maneras de corregir estas reglas.  Primero, convertirlo en una
secuencia de un sólo nivel:

</P>

<PRE>
secuencia: /* vacío */
         | secuencia palabra
         | secuencia redireccion
         ;
</PRE>

<P>
Segundo, prevenir bien un <CODE>palabras</CODE> o un <CODE>redireccion</CODE>
de que sea vacío:

</P>

<PRE>
secuencia: /* vacío */
         | secuencia palabras
         | secuencia redirecciones
         ;

palabras: palabra
        | palabras palabra
        ;

redirecciones: redireccion
          | redirecciones redireccion
          ;
</PRE>



<H2><A NAME="SEC84" HREF="bison-es-1.27.html#TOC84">Conflictos Misteriosos de Reducción/Reducción</A></H2>

<P>
Algunas veces con los conflictos reducción/reducción puede suceder que
no parezcan garantizados.  Aquí hay un ejemplo:

</P>

<PRE>
%token ID

%%
def:    espc_param espc_return ','
        ;
espec_param:
             tipo
        |    lista_nombre ':' tipo
        ;
espec_return:
             tipo
        |    nombre ':' tipo
        ;
tipo:        ID
        ;
nombre:        ID
        ;
lista_nombre:
             nombre
        |    nombre ',' lista_nombre
        ;
</PRE>

<P>
Parecería que esta gramática puede ser analizada con sólo un único
token de preanálisis: cuando se está leyendo un <CODE>espc_param</CODE>,
un <CODE>ID</CODE> es un <CODE>nombre</CODE> si le sigue una coma o un punto, o un
<CODE>tipo</CODE> si le sigue otro <CODE>nombre</CODE>.  En otras palabras, esta
gramática es LR(1).

</P>
<P>
<A NAME="IDX174"></A>
<A NAME="IDX175"></A>
Sin embargo, Bison, como la mayoría de los generadores de analizadores
sintácticos, no pueden en realidad manejar todas las gramáticas LR(1).  En
esta gramática, los dos contextos, aquél después de un <CODE>ID</CODE> al principio
de un <CODE>espc_param</CODE> y también al principio de un <CODE>espc_return</CODE>,
son lo suficientemente similares para que Bison asuma que son
el mismo.  Estos parecen similares porque estarían activos el mismo conjunto
de reglas--la regla de reducción a un <CODE>nombre</CODE> y aquella para la
reducción de <CODE>tipo</CODE>.  Bison es incapaz de determinar a ese nivel de
procesamiento que las reglas requerirían diferentes tokens de preanálisis
en los dos contextos, así que construye un solo estado del analizador
para ambos.  Combinando los dos contextos provoca un conflicto más tarde.
En la terminología de los analizadores sintácticos, este suceso
significa que la gramática no es LALR(1).

</P>
<P>
En general, es mejor arreglar las deficiencias que documentarlas.  Pero
esta deficiencia en particular es intrínsecamente difícil de arreglar;
los generadores de analizadores sintácticos que pueden manejar gramáticas
LR(1) son duros de escribir y tienden a producir analizadores que son
muy grandes.  En la práctica, Bison es más útil como es ahora.

</P>
<P>
Cuando el problema aparece, puede a veces arreglarlo identificando los
dos estados del analizador que están siendo confundidos, y añadir algo
para hacerlos pareceer distintos.  En el ejemplo anterior, añadiendo una
regla a <CODE>espc_return</CODE> como a continuación hace que el problema
desaparezca:

</P>

<PRE>
%token BOGUS
...
%%
...
espc_return:
             tipo
        |    nombre ':' tipo
        /* Esta regla nunca se usa.  */
        |    ID BOGUS
        ;
</PRE>

<P>
Esto corrige el problema porque introduce la posibilidad de una
regla activa adicional en el contexto después de <CODE>ID</CODE> al principio
de un <CODE>espc_param</CODE>, así que los dos contextos reciben estados
distinto del analizador.  Siempre que el token <CODE>BOGUS</CODE> no se genere
nunca por <CODE>yylex</CODE>, la regla adicional no podrá alterar la manera
en la que la entrada es analizada.

</P>
<P>
En este ejemplo en particular, hay otra forma de resolver este
problema: reescribir la regla de <CODE>espc_return</CODE> para usar <CODE>ID</CODE>
directamente en lugar de hacerlo a través de <CODE>nombre</CODE>.  Esto también
provoca que los dos contextos confusos tengan conjuntos de reglas activas
distintas, porque la de <CODE>espc_return</CODE> activa la regla alterada para
<CODE>espc_return</CODE> en vez que la de <CODE>nombre</CODE>.

</P>

<PRE>
espc_param:
             tipo
        |    lista_nombre ':' tipo
        ;
espc_return:
             tipo
        |    ID ':' tipo
        ;
</PRE>



<H2><A NAME="SEC85" HREF="bison-es-1.27.html#TOC85">Desbordamiento de Pila, y Cómo Evitarlo</A></H2>
<P>
<A NAME="IDX176"></A>
<A NAME="IDX177"></A>
<A NAME="IDX178"></A>

</P>
<P>
La pila del analizador de Bison puede desbordarse si se desplazan
demasiados tokens y no son reducidos.  Cuando esto sucede, la función
del analizador <CODE>yyparse</CODE> devuelve un valor distinto de cero,
haciendo pausas solamente para llamar a <CODE>yyerror</CODE> para
informar del desbordamiento.

</P>
<P>
<A NAME="IDX179"></A>
Definiendo la macro <CODE>YYMAXDEPTH</CODE>, puede controlar cuán profundo
puede llegar a ser la pila del analizador antes de que suceda un
desbordamiento de la pila.  Defina esta macro con un valor que sea un
entero.  Este valor es el número máximo de tokens que pueden
ser desplazados (y sin ser reducidos) antes de un desbordamiento.
Debe ser una expresión constante cuyo valor se conozca en tiempo de
compilación.

</P>
<P>
El espacio de la pila permitido no es asignado necesariamente.  Si
especifica un valor grande para <CODE>YYMAXDEPTH</CODE>, el analizador
realmente asigna un pequeña pila al principio, y entonces la hace
mayor por etapas a medida que se necesite.  Esta asignación incremental
ocurre automáticamente y silenciosamente.  Por lo tanto,
no necesita hacer a <CODE>YYMAXDEPTH</CODE> angustiosamente pequeño meramente
para ahorrar espacio para entradas ordinarias que no necesitan mucha
pila.

</P>
<P>
<A NAME="IDX180"></A>
El valor por defecto de <CODE>YYMAXDEPTH</CODE>, si no lo define, es
10000.

</P>
<P>
<A NAME="IDX181"></A>
Usted puede controlar cuánta pila se asigna inicialmente definiendo
la macro <CODE>YYINITDEPTH</CODE>.  Este valor también debe ser una constante
entera en tiempo de compilación.  El valor por defecto es 200.

</P>


<H1><A NAME="SEC86" HREF="bison-es-1.27.html#TOC86">Recuperación de Errores</A></H1>
<P>
<A NAME="IDX182"></A>
<A NAME="IDX183"></A>

</P>
<P>
Normalmente no es aceptable que un programa termine ante un error de
análisis.  Por ejemplo, un compilador debería recuperarse lo
suficiente como para que analice el resto del archivo de entrada y
comprobar sus errores; una calculadora debería aceptar otra
expresión.

</P>
<P>
En un analizador de comandos interactivo sencillo donde cada entrada es
una línea, podría ser suficiente con permitir a <CODE>yyparse</CODE> devolver
un 1 ante un error y hacer que la función invocadora ignore el resto de
la línea de entrada cuando suceda (y entonces llamar a <CODE>yyparse</CODE> de
nuevo).  Pero esto es inadecuado para un compilador, porque olvida todo el
contexto sintáctico desde el comienzo hasta donde se encontró el error.
Un error de sintaxis profundo dentro de una función del fichero de entrada
del compilador no debería provocar que el compilador trate la línea
siguiente como el principio de un fichero fuente.

</P>
<P>
<A NAME="IDX184"></A>
Puede definir cómo recuperarse de un error de sintaxis escribiendo
reglas para reconocer el token especial <CODE>error</CODE>.  Este es un símbolo
terminal que siempre se define (no necesita declararlo) y reservado para
tratamiento de errores.  El analizador de Bison genera un token <CODE>error</CODE>
siempre que ocurra un error de sintaxis; si ha facilitado una regla que
reconozca este token en el contexto actual, el analizador puede continuar.

</P>
<P>
Por ejemplo:

</P>

<PRE>
stmnts:  /* cadena vacía */
        | stmnts '\n'
        | stmnts exp '\n'
        | stmnts error '\n'
</PRE>

<P>
La cuarta regla en este ejemplo dice que un error seguido de una nueva
línea forma una adición válida a cualquier <CODE>stmnts</CODE>.

</P>
<P>
¿Qué sucede si aparece un error de sintaxis en medio de una <CODE>exp</CODE>?  La
regla de recuperación de errores, interpretada estrictamente, se aplica
a la secuencia precisa de una <CODE>stmnts</CODE>, un <CODE>error</CODE> y una nueva
línea.  Si aparece un error en medio de una <CODE>exp</CODE>, probablemente
existan tokens adicionales y subexpresiones por leer antes de la nueva línea.
De manera que la regla no es aplicable de la forma habitual.

</P>
<P>
Pero Bison puede forzar la situación para que se ajuste a la regla,
descartando parte del contexto semántico y parte de la entrada.
Primero descarta estados y objetos de la pila hasta que regrese a un
estado en el que el token <CODE>error</CODE> sea aceptable.  (Esto quiere decir
que las subexpresiones ya analizadas son descartadas, retrocediendo
hasta el último <CODE>stmnts</CODE> completo.)  En este punto el token
<CODE>error</CODE> puede desplazarse.  Entonces, si el antiguo token
de preanálisis no es aceptable para ser desplazado, el analizador
lee tokens y los descarta hasta que encuentre un token que sea
aceptable.  En este ejemplo, Bison lee y descarta entrada hasta la
siguiente línea de manera que la cuarta regla puede aplicarse.

</P>
<P>
La elección de reglas de error en la gramática es una elección de
estrategias para la recuperación de errores.  Una estrategia simple y
útil es sencillamente saltarse el resto de la línea de entrada actual
o de la sentencia actual si se detecta un error:

</P>

<PRE>
stmnt: error ';'  /* ante un error, saltar hasta que se lea ';' */
</PRE>

<P>
También es útil recuperar el delimitador de cierre que empareja con un
un delimitador de apertura que ya ha sido analizado.  De otra manera el
delimitador de cierre probablemente aparecerá como sin emparejar, y generará
otro, espúreo mensaje de error:

</P>

<PRE>
primary:  '(' expr ')'
        | '(' error ')'
        ...
        ;
</PRE>

<P>
Las estrategias de recuperación de errores son por fuerza adivinanzas.
Cuando estas adivinan mal, un error de sintaxis a menudo provoca otro.
En el ejemplo anterior, la regla de recuperación de errores sospecha que
el error es debido a una mala entrada en un <CODE>stmnt</CODE>.  Suponga que
en su lugar se inserta un punto y coma accidental en medio de un <CODE>stmt</CODE>
válido.  Después de recuperarse del primer error con la regla de
recuperación de errores, se encontrará otro error de sintaxis directamente,
ya que el texto que sigue al punto y coma accidental también es una
<CODE>stmnt</CODE> inválida.

</P>
<P>
Para prevenir una cascada de mensajes de error, el analizador
no mostrará mensajes de error para otro error de sintaxis que
ocurra poco después del primero; solamente después de que se hayan
desplazado con éxito tres tokens de entrada consecutivos se reanudarán
los mensajes de error.

</P>
<P>
Note que las reglas que aceptan el token <CODE>error</CODE> podrían tener
acciones, al igual que cualquiera de las otras reglas pueden tenerlas.

</P>
<P>
<A NAME="IDX185"></A>
Puede hacer que los mensajes de error se reanuden inmediatamente
usando la macro <CODE>yyerrok</CODE> en una acción.  Si lo hace en
la acción de la regla de error, no se suprimirá ningún mensaje
de error.  Esta macro no requiere ningún argumento;
<SAMP>`yyerrok;'</SAMP> es una sentencia válida de C.

</P>
<P>
<A NAME="IDX186"></A>
El token de preanálisis anterior se reanaliza inmediatamente después de un
error.  Si este no es aceptable, entonces la macro <CODE>yyclearin</CODE> podría
utilizarse para limpiar ese token.  Escriba la sentencia
<SAMP>`yyclearin;'</SAMP> en la acción de la regla de error.

</P>
<P>
Por ejemplo, suponga que ante un error de análisis, se llama a una rutina
de manejo de errores que avanza el flujo de entrada en algún punto donde
el análisis prodría comenzar de nuevo.  El próximo símbolo devuelto
por el analizador léxico será probablemente correcto.  El token de
preanálisis anterior convendría que se descartara con <SAMP>`yyclearin;'</SAMP>.

</P>
<P>
<A NAME="IDX187"></A>
La macro <CODE>YYRECOVERING</CODE> representa una expresión que tiene
el valor 1 cuando el analizador se está recuperando de un error
de sintaxis, y 0 durante el resto del tiempo.  Un valor de 1 indica
que actualmente los mensajes de error se están suprimiendo para
nuevos errores de sintaxis.

</P>


<H1><A NAME="SEC87" HREF="bison-es-1.27.html#TOC87">Manejando Dependencias del Contexto</A></H1>

<P>
El paradigma de Bison es analizar tokens en primer lugar, entonces
agruparlos en unidades sintácticas más grandes.  En muchos lenguajes,
el significado de un token se ve afectado por su contexto.  A pesar de
que esto viola el paradigma de Bison, ciertas técnicas (conocidas como
<STRONG>kludges</STRONG>) podrían permitirle escribir analizadores de Bison para
tales lenguajes.

</P>
<P>
(Realmente, "kludge" significa cualquier técnica que hace su trabajo
pero no de una manera limpia o robusta.)

</P>


<H2><A NAME="SEC88" HREF="bison-es-1.27.html#TOC88">Información Semántica en Tipos de Tokens</A></H2>

<P>
El lenguaje C tiene una dependencia del contexto: la manera en la que
se utiliza un identificador depende de cuál es su significado.  Por
ejemplo, considere esto:

</P>

<PRE>
foo (x);
</PRE>

<P>
Esto parece la sentencia de llamada a una función, pero si <CODE>foo</CODE> es
un nombre de tipo definido, entonces esto realmente es una declaración
de <CODE>x</CODE>.  ¿Cómo puede un analizador de Bison para C decidirse
cómo analizar esta entrada?

</P>
<P>
El método utilizado en GNU C es tener dos tipos diferentes
de tokens, <CODE>IDENTIFIER</CODE> y <CODE>TYPENAME</CODE>.  Cuando <CODE>yylex</CODE>
encuentre un identificador, localiza la declaración actual del identificador
para decidir que tipo de token devolver: <CODE>TYPENAME</CODE> si el identificador
se declara como una definición de tipo, <CODE>IDENTIFIER</CODE> en otro caso.

</P>
<P>
Las reglas gramaticales pueden entonces expresar la dependencia del contexto
eligiendo el tipo de token a reconocer.  <CODE>IDENTIFIER</CODE> se acepta
como una expresión, pero <CODE>TYPENAME</CODE> no lo es.  <CODE>TYPENAME</CODE> puede
empezar una declaración, pero <CODE>TYPENAME</CODE> no.  En contextos donde el
significado del identificador <EM>no</EM> es significativo, tal como en
declaraciones que pueden ocultar nombre de definición de tipo, no se
acepta ni <CODE>TYPENAME</CODE> o <CODE>IDENTIFIER</CODE>---hay una regla para cada
uno de los dos tipos de tokens.

</P>
<P>
Esta técnica es sencilla de usar si la decisión de qué tipos de
identificadores se permiten se hace en un lugar cercano a donde se
analiza el identificador.  Pero en C esto no es siempre así: C permite
en una declaración redeclarar un nombre de tipo definido
siempre que se haya especificado antes un tipo explícito:

</P>

<PRE>
typedef int foo, bar, lose;
static foo (bar);        /* redeclara <CODE>bar</CODE> como variable estática */
static int foo (lose);   /* redeclara <CODE>foo</CODE> como función */
</PRE>

<P>
Por desgracia, el nombre que se está declarando se encuentra separado de la
construcción de la declaración por una estructura sintáctica complicada--el
"declarador".

</P>
<P>
Como resultado, la parte del analizador de Bison para C necesita ser
duplicada, con todos los nombres de los no terminales cambiados: una vez
para el análisis de una declaración en la que se puede redefinir un
nombre de declaración de tipo, y una vez para el análisis de una declaración
en la que no puede hacerse.  Aquí hay parte de la duplicación, con
las acciones omitidas por brevedad:

</P>

<PRE>
initdcl:
          declarator maybeasm '='
          init
        | declarator maybeasm
        ;

notype_initdcl:
          notype_declarator maybeasm '='
          init
        | notype_declarator maybeasm
        ;
</PRE>

<P>
Aquí <CODE>initdcl</CODE> puede redeclarar un nombre de definición de tipo, pero
<CODE>notype_initdcl</CODE> no puede.  La distinción entre <CODE>declarator</CODE> y
<CODE>notype_declarator</CODE> es del mismo tipo.

</P>
<P>
Hay aquí alguna similitud entre esta técnica y una ligadura léxica
(descrita a continuación), en que la información que altera el análisis
léxico se cambia durante el análisis por otras partes del programa.  La
diferencia es que aquí la información es global, y se utiliza para otros
propósitos en el programa.  Una verdadera ligadura léxica tiene una
bandera de propósito especial controlada por el contexto sintáctico.

</P>


<H2><A NAME="SEC89" HREF="bison-es-1.27.html#TOC89">Ligaduras Léxicas</A></H2>
<P>
<A NAME="IDX188"></A>

</P>
<P>
Una manera de manejar las dependencias del contexto es la <STRONG>ligadura
léxica</STRONG>: una bandera que se activa en acciones de Bison, cuyo propósito
es alterar la manera en la que se analizan los tokens.

</P>
<P>
Por ejemplo, soponga que tenemos un lenguaje vagamente parecido a C, pero
con una construcción especial <SAMP>`hex (<VAR>hex-expr</VAR>)'</SAMP>. Después de 
la palabra clave <CODE>hex</CODE> viene una expresión entre paréntesis en el
que todos los enteros son hexadecimales.  En particular, el token <SAMP>`a1b'</SAMP>
debe tratarse como un entero en lugar de como un identificador si aparece
en ese contexto.  He aquí cómo puede hacerlo:

</P>

<PRE>
%{
int hexflag;
%}
%%
...
expr:   IDENTIFIER
        | constant
        | HEX '('
                { hexflag = 1; }
          expr ')'
                { hexflag = 0;
                   $$ = $4; }
        | expr '+' expr
                { $$ = make_sum ($1, $3); }
        ...
        ;

constant:
          INTEGER
        | STRING
        ;
</PRE>

<P>
Aquí asumimos que <CODE>yylex</CODE> mira el valor de <CODE>hexflag</CODE>; cuando no es
cero, todos los enteros se analizan en hexadecimal, y los tokens que comiencen
con letras se analizan como enteros si es posible.

</P>
<P>
La declaración de <CODE>hexflag</CODE> mostrada en la sección de declaraciones en C
del archivo del analizador se necesita para hacerla accesible a las acciones
(see section <A HREF="bison-es-1.27.html#SEC41">La Sección de Declaraciones en C</A>).  Debe
también escribir el código en <CODE>yylex</CODE> para obedecer a la bandera.

</P>


<H2><A NAME="SEC90" HREF="bison-es-1.27.html#TOC90">Ligaduras Léxicas y Recuperación de Errores</A></H2>

<P>
Las ligaduras léxicas hacen demandas estrictas sobre cualquier regla de
recuperación de errores que tenga.
See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

</P>
<P>
La razón de esto es que el propósito de una regla de recuperación
de errores es abortar el análisis de una construcción y reanudar
en una construcción mayor.  Por ejemplo, en lenguajes como C, una
regla típica de recuperación de errores es saltarse los tokens
hasta el siguiente punto y coma, y entonces comenzar una sentencia
nueva, como esta:

</P>

<PRE>
stmt:   expr ';'
        | IF '(' expr ')' stmt { ... }
        ...
        error ';'
                { hexflag = 0; }
        ;
</PRE>

<P>
Si hay aquí un error de sintaxis en medio de una construcción
<SAMP>`hex (<VAR>expr</VAR>)'</SAMP>, esta regla de error se aplicará, y entonces
la acción para la <SAMP>`hex (<VAR>expr</VAR>)'</SAMP> nunca se ejecutará.  Así
que <CODE>hexflag</CODE> continuaría activada durante el resto de la entrada,
o hasta la próxima palabra clave <CODE>hex</CODE>, haciendo que los
identificadores se malinterpreten como enteros.

</P>
<P>
Para evitar este problema la regla de recuperación de errores por sí
misma desactiva <CODE>hexflag</CODE>.

</P>
<P>
Aquí podría existir también una regla de recuperación de errores
que trabaje dentro de expresiones.  Por ejemplo, podría haber una regla
que se aplique dentro de los paréntesis y salte al paréntesis-cerrar:

</P>

<PRE>
expr:   ...
        | '(' expr ')'
                { $$ = $2; }
        | '(' error ')'
        ...
</PRE>

<P>
Si esta regla actúa dentro de la construcción <CODE>hex</CODE>, no se va a
abortar esa construcción (ya que ésta aparece a un nivel más interno
de paréntesis dentro de la construcción).  Por lo tanto, no debería
desactivar la bandera: el resto de la construcción <CODE>hex</CODE> debería
analizarse con la bandera aún activada.

</P>
<P>
¿Qué sucedería si hay una regla de recuperación de errores que
pudiese abortar fuera la construcción <CODE>hex</CODE> o pudiese que no,
dependiendo de las circunstancias?  No hay manera de escribir la
acción para determinar si una construcción <CODE>hex</CODE> está siendo
abortada o no.  De manera que si está utilizando una ligadura léxica,
es mejor que esté seguro que sus reglas de recuperación de errores no
son de este tipo.  Cada regla debe ser tal que pueda estar seguro que
siempre tendrá que tener que limpiar la bandera, o siempre no.

</P>


<H1><A NAME="SEC91" HREF="bison-es-1.27.html#TOC91">Depurando Su Analizador</A></H1>
<P>
<A NAME="IDX189"></A>
<A NAME="IDX190"></A>
<A NAME="IDX191"></A>
<A NAME="IDX192"></A>

</P>
<P>
Si una gramática de Bison compila adecuadamente pero no hace lo que
quiere cuando se ejecuta, la propiedad de traza del analizador <CODE>yydebug</CODE>
puede ayudarle para darse cuenta del por qué.

</P>
<P>
Para activar la compilación de las facilidades de traza, debe definir
la macro <CODE>YYDEBUG</CODE> cuando compile el analizador. Podría utilizar
<SAMP>`-DYYDEBUG=1'</SAMP> como una opción del compilador o podría poner
<SAMP>`#define YYDEBUG 1'</SAMP> en la sección de declaraciones de C del archivo
de la gramática (see section <A HREF="bison-es-1.27.html#SEC41">La Sección de Declaraciones en C</A>).
De forma alternativa, utilice la opción <SAMP>`-t'</SAMP> cuando ejecute Bison
(see section <A HREF="bison-es-1.27.html#SEC92">Invocando a Bison</A>). 
Siempre definiremos <CODE>YYDEBUG</CODE> de manera que la depuración siempre
es posible. 

</P>
<P>
La facilidad de traza utiliza <CODE>stderr</CODE>, de manera que debe añadir
<CODE>#include &#60;stdio.h&#62;</CODE> en la sección de declaraciones de C a menos
que ya esté ahí.

</P>
<P>
Una vez que haya compilado el programa con las facilidades de traza, la
manera de solicitar una traza es almacenar un valor distinto de cero en
la variable <CODE>yydebug</CODE>. Puede hacer esto poniendo código C que lo 
haga (en <CODE>main</CODE>, tal vez), o puede alterar el valor con un depurador
de C.

</P>
<P>
Cada paso tomado por el analizador cuando <CODE>yydebug</CODE> no es cero
produce una línea o dos de información de traza, escrita sobre <CODE>stderr</CODE>.
Los mensajes de traza le cuentan estas cosas:

</P>

<UL>
<LI>

Cada vez que el analizador llama a <CODE>yylex</CODE>, qué tipo de token
ha sido leido.

<LI>

Cada vez que un token se reduce, la profundidad y contenido completo de
la pila de estados. (see section <A HREF="bison-es-1.27.html#SEC82">Estados del Analizador</A>).

<LI>

Cada vez que se reduce una regla, qué regla es, y el contenido posterior
completo de la pila de estados 
</UL>

<P>
Para hacerse una idea de esta información, ayuda el hacer referencia al
listado del archivo producido por la opción <SAMP>`-v'</SAMP> de Bison
(see section <A HREF="bison-es-1.27.html#SEC92">Invocando a Bison</A>).  Este archivo muestra el significado
de cada estado en términos de posición en varias reglas, y también
qué hará cada estado con cada token de entrada posible.  A medida que
lea los mensajes de traza sucesivos, puede ver que el analizador está
fucionando de acuerdo a su especificación en el achivo del listado.
Finalmente llegará al lugar donde sucede algo indeseable, y verá
qué parte de la gramática es la culpable.

</P>
<P>
El archivo del analizador es un programa en C y puede utilizar
depuradores de C con éste, pero no es fácil interpretar lo que está
haciendo.  La función del analizador es un intérprete de una
máquina de estado finito, y aparte de las acciones éste ejecuta
el mismo código una y otra vez.  Solamente los valores de las variables
muestran sobre qué lugar de la gramática se está trabajando.

</P>
<P>
<A NAME="IDX193"></A>
La información de depuración normalmente da el tipo de token de
cada token leído, pero no su valor semántico.  Puede opcionalmente
definir una macro llamada <CODE>YYPRINT</CODE> para facilitar una manera
de imprimir el valor.  Si define <CODE>YYPRINT</CODE>, esta debería
tomar tres argumentos.  El analizador pasará un flujo de
entrada/salida estandar, el valor numérico del tipo de token, y el
valor del token (de <CODE>yylval</CODE>).

</P>
<P>
Aquí hay un ejemplo de <CODE>YYPRINT</CODE> apropiado para la calculadora
multifunción (see section <A HREF="bison-es-1.27.html#SEC35">Declaraciones para <CODE>mfcalc</CODE></A>):

</P>

<PRE>
#define YYPRINT(file, type, value)   yyprint (file, type, value)

static void
yyprint (file, type, value)
     FILE *file;
     int type;
     YYSTYPE value;
{
  if (type == VAR)
    fprintf (file, " %s", value.tptr-&#62;name);
  else if (type == NUM)
    fprintf (file, " %d", value.val);
}
</PRE>



<H1><A NAME="SEC92" HREF="bison-es-1.27.html#TOC92">Invocando a Bison</A></H1>
<P>
<A NAME="IDX194"></A>
<A NAME="IDX195"></A>
<A NAME="IDX196"></A>

</P>
<P>
La manera habitual de invocar a Bison es la siguiente:

</P>

<PRE>
bison <VAR>fichero-entrada</VAR>
</PRE>

<P>
Aquí <VAR>fichero-entrada</VAR> es el nombre del fichero de la gramática, que
normalmente termina en <SAMP>`.y'</SAMP>.  El nombre del archivo del analizador
se construye reemplazando el <SAMP>`.y'</SAMP> con <SAMP>`.tab.c'</SAMP>.  Así,
el nombre de fichero <SAMP>`bison foo.y'</SAMP> produce <TT>`foo.tab.c'</TT>,
y el nombre de fichero <SAMP>`bison hack/foo.y'</SAMP> produce
<TT>`hack/foo.tab.c'</TT>.
</P>



<H2><A NAME="SEC93" HREF="bison-es-1.27.html#TOC93">Opciones de Bison</A></H2>

<P>
Bison soporta las opciones tradicionales de una única letra y nombres
de opción mnemónicos largos.  Los nombres de opción largos se indican
con <SAMP>`--'</SAMP> en lugar de <SAMP>`-'</SAMP>.  Las abreviaciones para los nombres
de opción se permiten siempre que sean únicas.  Cuando una opción
larga toma un argumento, como <SAMP>`--file-prefix'</SAMP>, se conecta el
nombre de la opcion con el argumento con <SAMP>`='</SAMP>.

</P>
<P>
Aquí hay una lista de opciones que puede utilizar con Bison,
alfabetizadas por la opción corta.

</P>
<DL COMPACT>

<DT><SAMP>`-b <VAR>prefijo-fichero</VAR>'</SAMP>
<DD>
<DT><SAMP>`--file-prefix=<VAR>prefijo</VAR>'</SAMP>
<DD>
Especifica un prefijo a ser usado por todos los nombres de archivo
de salida de Bison.  Los nombres se eligen como si el fichero
de entrada se llamase <TT>`<VAR>prefijo</VAR>.c'</TT>.

<DT><SAMP>`-d'</SAMP>
<DD>
<DT><SAMP>`--defines'</SAMP>
<DD>
Escribe un archivo extra de salida conteniendo las definiciones de las
macros para los nombres de tipo de tokens definidos en la gramática
y el tipo de valor semántico <CODE>YYSTYPE</CODE>, además de unas
cuantas declaraciones de variables <CODE>extern</CODE>.

Si el archivo de salida del analizador se llama <TT>`<VAR>name</VAR>.c'</TT>
entonces este archivo se llama <TT>`<VAR>name</VAR>.h'</TT>.
Este archivo de salida es esencial si desea poner las definiciones
de <CODE>yylex</CODE> en un archivo fuente por separado, porque <CODE>yylex</CODE>
necesita ser capaz de hacer referencia a los códigos de tipo de token
y las variables <CODE>yylval</CODE>.  See section <A HREF="bison-es-1.27.html#SEC68">Valores Semánticos de los Tokens</A>.
<DT><SAMP>`-l'</SAMP>
<DD>
<DT><SAMP>`--no-lines'</SAMP>
<DD>
No pone ningún comando <CODE>#line</CODE> del preprocesador en el fichero del
analizador.  Normalmente Bison los pone en el archivo del analizador
de manera que el compilador de C y los depuradores asocien errores
con su fichero fuente, el achivo de la gramática.  Esta opción
hace que asocien los errores con el archivo del analizador, tratándolo
como un archivo fuente independiente por derecho propio.

<DT><SAMP>`-n'</SAMP>
<DD>
<DT><SAMP>`--no-parser'</SAMP>
<DD>
No incluye ningún código C en el archivo del analizador; genera únicamente
las tablas.  El archivo del analizador contiene sólo directivas <CODE>#define</CODE>
y declaraciones de variables estáticas.

Esta opción también le dice a Bison que escriba el código C para
las acciones gramaticales en un archivo llamado <TT>`<VAR>nombrefichero</VAR>.act'</TT>,
en la forma de un cuerpo encerrado entre llaves para formar una
sentencia <CODE>switch</CODE>.

<DT><SAMP>`-o <VAR>fichero-salida</VAR>'</SAMP>
<DD>
<DT><SAMP>`--output-file=<VAR>fichero-salida</VAR>'</SAMP>
<DD>
Especifica el nombre <VAR>fichero-salida</VAR> para el archivo del analizador.

El resto de los nombres de fichero de salida son construidos a
partir de <VAR>fichero-salida</VAR> como se describió bajo las opciones <SAMP>`-v'</SAMP>
y <SAMP>`-d'</SAMP>.

<DT><SAMP>`-p <VAR>prefijo</VAR>'</SAMP>
<DD>
<DT><SAMP>`--name-prefix=<VAR>prefijo</VAR>'</SAMP>
<DD>
Renombra los símbolos externos utilizados en el analizador de manera
que comiencen con <VAR>prefijo</VAR> en lugar de <SAMP>`yy'</SAMP>.  La lista precisa de
símbolos renombrados es <CODE>yyparse</CODE>, <CODE>yylex</CODE>, <CODE>yyerror</CODE>,
<CODE>yynerrs</CODE>, <CODE>yylval</CODE>, <CODE>yychar</CODE> y <CODE>yydebug</CODE>.

Por ejemplo, si utiliza <SAMP>`-p c'</SAMP>, los nombres serán <CODE>cparse</CODE>,
<CODE>clex</CODE>, etc.

See section <A HREF="bison-es-1.27.html#SEC63">Múltiples Analizadores en el Mismo Programa</A>.

<DT><SAMP>`-r'</SAMP>
<DD>
<DT><SAMP>`--raw'</SAMP>
<DD>
Hace que parezca que haya sido especificado <CODE>%raw</CODE>.  See section <A HREF="bison-es-1.27.html#SEC62">Sumario de Declaraciones de Bison</A>.

<DT><SAMP>`-t'</SAMP>
<DD>
<DT><SAMP>`--debug'</SAMP>
<DD>
Produce una definición de la macro <CODE>YYDEBUG</CODE> en el achivo
del analizador, de manera que las facilidades de depuración sean
compiladas.  See section <A HREF="bison-es-1.27.html#SEC91">Depurando Su Analizador</A>.

<DT><SAMP>`-v'</SAMP>
<DD>
<DT><SAMP>`--verbose'</SAMP>
<DD>
Escribe un archivo de salida extra conteniendo descripciones
amplias de los estados del analizador y qué se hace para cada tipo
de token de preanálisis en ese estado.

Este archivo también describe todos los conflictos, aquellos resueltos
por la precedencia de operadores y los no resueltos.

Este nombre de fichero se construye quitando <SAMP>`.tab.c'</SAMP> o <SAMP>`.c'</SAMP>
del nombre de salida del analizador, y añadiendo <SAMP>`.output'</SAMP> en su
lugar.
Por lo tanto, si el archivo de entrada es <TT>`foo.y'</TT>, entonces el
archivo del analizador se llama <TT>`foo.tab.c'</TT> por defecto.  Como
consecuencia, el archivo de salida amplia se llama <TT>`foo.output'</TT>.
<DT><SAMP>`-V'</SAMP>
<DD>
<DT><SAMP>`--version'</SAMP>
<DD>
Imprime el número de versión de Bison y termina.

<DT><SAMP>`-h'</SAMP>
<DD>
<DT><SAMP>`--help'</SAMP>
<DD>
Imprime un sumario de las opciones de línea de comando de Bison y termina.

<DT><SAMP>`-y'</SAMP>
<DD>
<DT><SAMP>`--yacc'</SAMP>
<DD>
<DT><SAMP>`--fixed-output-files'</SAMP>
<DD>
Equivalente a <SAMP>`-o y.tab.c'</SAMP>; el archivo de salida del analizador
se llama <TT>`y.tab.c'</TT>, y el resto de salida se llama <TT>`y.output'</TT>
y <TT>`y.tab.h'</TT>.  El propósito de esta opcion es la de imitar las
convenciones de los nombres de fichero de Yacc.  De este modo, el
siguiente script de comandos puede ser sustituto de Yacc:

<PRE>
bison -y $*
</PRE>

</DL>



<H2><A NAME="SEC94" HREF="bison-es-1.27.html#TOC94">Clave Cruzada de Opciones</A></H2>

<P>
Aquí hay una lista de opciones, alfabetizada por la opcion larga, para
ayudarle a encontrar la opción corta correspondiente.

</P>



<H2><A NAME="SEC95" HREF="bison-es-1.27.html#TOC95">Invocando Bison bajo VMS</A></H2>
<P>
<A NAME="IDX197"></A>
<A NAME="IDX198"></A>

</P>
<P>
La sintaxis de la línea de comandos para Bison sobre VMS es una
variante de la sintaxis del comando de Bison usual--adaptada para
ajustarse a las convenciones de VMS.

</P>
<P>
Para encontrar el equivalente VMS de cualquier opción de Bison,
comience con la opción larga, y sustituya con <SAMP>`/'</SAMP> el
<SAMP>`--'</SAMP> inicial, y sustituya con <SAMP>`_'</SAMP> cada <SAMP>`-'</SAMP> en el
nombre de opción largo.  Por ejemplo, la siguiente invocación
bajo VMS:

</P>

<PRE>
bison /debug/name_prefix=bar foo.y
</PRE>

<P>
es equivalente al siguiente comando bajo POSIX.

</P>

<PRE>
bison --debug --name-prefix=bar foo.y
</PRE>

<P>
El sistema de archivos de VMS no permite nombre de ficheros
tales como <TT>`foo.tab.c'</TT>.  En el ejemplo anterior, el
archivo de salida se llamaría <TT>`foo_tab.c'</TT>.

</P>


<H1><A NAME="SEC96" HREF="bison-es-1.27.html#TOC96">Símbolos de Bison</A></H1>
<P>
<A NAME="IDX199"></A>
<A NAME="IDX200"></A>

</P>
<DL COMPACT>

<DT><CODE>error</CODE>
<DD>
Un nombre de token reservado para la recuperación de errores.  Este
token puede ser utilizado en reglas gramaticales para permitir
al analizador de Bison reconocer un error en la gramática sin
parar el proceso.  En efecto, una sentencia conteniendo un error
podría reconocerse como válida.  Ante un error de análisis, el
token <CODE>error</CODE> llega a ser el token de preanálisis actual.
Las acciones correspondientes a <CODE>error</CODE> se ejecutan entonces, y el
token de preanálisis se reestablace al token que originalmente
provocó la violación.
See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

<DT><CODE>YYABORT</CODE>
<DD>
Macro que pretende que haya ocurrido un error de sintaxis no
recuperable haciendo que <CODE>yyparse</CODE> devuelva un 1 inmediatamente.
La función de informe de errores <CODE>yyerror</CODE> no se llama.
See section <A HREF="bison-es-1.27.html#SEC65">La Función del Analizador <CODE>yyparse</CODE></A>.

<DT><CODE>YYACCEPT</CODE>
<DD>
Macro que pretende que una expresión completa del lenguaje haya
sido leida, haciendo que <CODE>yyparse</CODE> devuelva un 0 inmediatamente.
See section <A HREF="bison-es-1.27.html#SEC65">La Función del Analizador <CODE>yyparse</CODE></A>.

<DT><CODE>YYBACKUP</CODE>
<DD>
Macro para descartar un valor de la pila del analizador y falsificar
un token de preanálisis.  See section <A HREF="bison-es-1.27.html#SEC72">Propiedades Especiales para su Uso en Acciones</A>.

<DT><CODE>YYERROR</CODE>
<DD>
Macro que pretende que un error de sintaxis se haya acabado de detectar:
llama a <CODE>yyerror</CODE> y entonces realiza una recuperación
de errores normal si es posible (see section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>), o
(si la recuperación es imposible) hace que <CODE>yyparse</CODE> devuelva
un 1.  See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

<DT><CODE>YYERROR_VERBOSE</CODE>
<DD>
Macro que usted define con <CODE>#define</CODE> en la sección de declaraciones
de Bison para solicitar cadenas de mensajes de errores amplias, específicas
cuando se llame a <CODE>yyerror</CODE>.

<DT><CODE>YYINITDEPTH</CODE>
<DD>
Macro para especificar el tamaño inicial de la pila del analizador.
See section <A HREF="bison-es-1.27.html#SEC85">Desbordamiento de Pila, y Cómo Evitarlo</A>.

<DT><CODE>YYLEX_PARAM</CODE>
<DD>
Macro para especificar un argumento extra (o lista de argumentos extra)
para que <CODE>yyparse</CODE> los pase a <CODE>yylex</CODE>.  See section <A HREF="bison-es-1.27.html#SEC70">Convenciones de Llamada para Analizadores Puros</A>.

<DT><CODE>YYLTYPE</CODE>
<DD>
Macro para el tipo de datos <CODE>yylloc</CODE>; una estructura con
cuatro componentes.  See section <A HREF="bison-es-1.27.html#SEC69">Posiciones en el Texto de los Tokens</A>.

<DT><CODE>yyltype</CODE>
<DD>
Valor por defecto para YYLTYPE.

<DT><CODE>YYMAXDEPTH</CODE>
<DD>
Macro para especificar el tamaño máximo de la pila del analizador.
See section <A HREF="bison-es-1.27.html#SEC85">Desbordamiento de Pila, y Cómo Evitarlo</A>.

<DT><CODE>YYPARSE_PARAM</CODE>
<DD>
Macro para especificar el nombre de un parámetro que <CODE>yyparse</CODE>
debería aceptar.  See section <A HREF="bison-es-1.27.html#SEC70">Convenciones de Llamada para Analizadores Puros</A>.

<DT><CODE>YYRECOVERING</CODE>
<DD>
Macro cuyo valor indica si el analizador se está recuperando de un
error de sintaxis.  See section <A HREF="bison-es-1.27.html#SEC72">Propiedades Especiales para su Uso en Acciones</A>.

<DT><CODE>YYSTYPE</CODE>
<DD>
Macro para el tipo de datos de los valores semánticos; <CODE>int</CODE>
por defecto. See section <A HREF="bison-es-1.27.html#SEC49">Tipos de Datos para Valores Semánticos</A>.

<DT><CODE>yychar</CODE>
<DD>
Variable entera externa que contiene el valor entero del token
actual de preanálisis.  (En un analizador puro, es una variable
local dentro de <CODE>yyparse</CODE>.)  Las acciones de las reglas de
recuperación de errores podrían examinar esta variable.
See section <A HREF="bison-es-1.27.html#SEC72">Propiedades Especiales para su Uso en Acciones</A>.

<DT><CODE>yyclearin</CODE>
<DD>
Macro utilizada en acciones de reglas de recuperación de errores.
Esta borra el anterior token de preanálisis.  See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

<DT><CODE>yydebug</CODE>
<DD>
Variable entera externa puesta a cero por defecto.  Si se le da a
<CODE>yydebug</CODE> un valor distinto de cero, el analizador sacará
información a cerca de los símbolos de entrada y acciones del
analizador.  See section <A HREF="bison-es-1.27.html#SEC91">Depurando Su Analizador</A>.

<DT><CODE>yyerrok</CODE>
<DD>
Macro que provoca al analizador recuperar su modo normal inmediatamente
después de un error de análisis.  See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

<DT><CODE>yyerror</CODE>
<DD>
Función facilitada por el usuario para ser llamada por <CODE>yyparse</CODE>
ante un error.  La función recibe un argumento, un puntero a una
cadena de caracteres conteniendo un mensaje de error.
See section <A HREF="bison-es-1.27.html#SEC71">La Función de Informe de Errores <CODE>yyerror</CODE></A>.

<DT><CODE>yylex</CODE>
<DD>
Función del analizador léxico facilitada por el usuario, llamada
sin argumentos para obtener el siguiente token.
See section <A HREF="bison-es-1.27.html#SEC66">La Funcion del Analizador Léxico <CODE>yylex</CODE></A>.

<DT><CODE>yylval</CODE>
<DD>
Variable externa en la que <CODE>yylex</CODE> debería poner el
valor semántico asociado con un token.  (En un analizador puro,
es una variable local dentro de <CODE>yyparse</CODE>, y su dirección se
le pasa a <CODE>yylex</CODE>.)  See section <A HREF="bison-es-1.27.html#SEC68">Valores Semánticos de los Tokens</A>.

<DT><CODE>yylloc</CODE>
<DD>
Variable externa en la que <CODE>yylex</CODE> debería poner el número
de línea y columna asociado a un token.  (En un analizador puro,
es una variable local dentro de <CODE>yyparse</CODE>, y su dirección se
le pasa a <CODE>yylex</CODE>.)  Puede ignorar esta variable si no utiliza
la propiedad <SAMP>`@'</SAMP> en las acciones gramaticales.
See section <A HREF="bison-es-1.27.html#SEC69">Posiciones en el Texto de los Tokens</A>.

<DT><CODE>yynerrs</CODE>
<DD>
Variable global que Bison incrementa cada vez que hay un error
de análisis.  (En un analizador puro, es una variable local dentro
de <CODE>yyparse</CODE>.)  See section <A HREF="bison-es-1.27.html#SEC71">La Función de Informe de Errores <CODE>yyerror</CODE></A>.

<DT><CODE>yyparse</CODE>
<DD>
La función del analizador producida por Bison; llame a esta función
para comenzar el análisis.  See section <A HREF="bison-es-1.27.html#SEC65">La Función del Analizador <CODE>yyparse</CODE></A>.

<DT><CODE>%left</CODE>
<DD>
Declaración de Bison para asignar asociatividad por la izquierda a un(varios)
token(s). See section <A HREF="bison-es-1.27.html#SEC56">Precedencia de Operadores</A>.

<DT><CODE>%no_lines</CODE>
<DD>
Declaración de Bison para evitar la generación de directivas <CODE>#line</CODE>
en el fichero del analizador.  See section <A HREF="bison-es-1.27.html#SEC62">Sumario de Declaraciones de Bison</A>.

<DT><CODE>%nonassoc</CODE>
<DD>
Declaración de Bison para asignar no-asociatividad a un(varios) token(s).
See section <A HREF="bison-es-1.27.html#SEC56">Precedencia de Operadores</A>.

<DT><CODE>%prec</CODE>
<DD>
Declaración de Bison para asignar precedencia a una regla
específica.
See section <A HREF="bison-es-1.27.html#SEC81">Precedencia Dependiente del Contexto</A>.

<DT><CODE>%pure_parser</CODE>
<DD>
Declaración de Bison para solicitar un analizador puro (reentrante).
See section <A HREF="bison-es-1.27.html#SEC61">Un Analizador Puro (Reentrante)</A>.

<DT><CODE>%raw</CODE>
<DD>
Declaración de Bison para usar los números de código de token internos
a Bison en las tablas de tokens en lugar de los números de código
de tokens usuales compatibles con Yacc.
See section <A HREF="bison-es-1.27.html#SEC62">Sumario de Declaraciones de Bison</A>.

<DT><CODE>%right</CODE>
<DD>
Declaración de Bison para asignar asociatividad por la derecha a un(varios)
token(s).
See section <A HREF="bison-es-1.27.html#SEC56">Precedencia de Operadores</A>.

<DT><CODE>%start</CODE>
<DD>
Declaraciones de Bison para especificar el símbolo de arranque.
See section <A HREF="bison-es-1.27.html#SEC60">El Símbolo de Arranque</A>.

<DT><CODE>%token</CODE>
<DD>
Declaración de Bison para declarar un(varios) token(s) sin especificar la
precedencia.
See section <A HREF="bison-es-1.27.html#SEC55">Nombres de Tipo de Token</A>.

<DT><CODE>%token_table</CODE>
<DD>
Declaración de Bison para incluir una tabla de nombres de tokens
en el archivo del analizador.
See section <A HREF="bison-es-1.27.html#SEC62">Sumario de Declaraciones de Bison</A>.

<DT><CODE>%type</CODE>
<DD>
Declaración de Bison para declarar no-terminales.
See section <A HREF="bison-es-1.27.html#SEC58">Símbolos No Terminales</A>.

<DT><CODE>%union</CODE>
<DD>
Declaración de Bison para especificar varios tipos de datos posibles
para los valores semánticos.  See section <A HREF="bison-es-1.27.html#SEC57">La Colección de Tipos de Valores</A>.
</DL>

<P>
Estos son los puntuadores y delimitadores utilizados en la
entrada de Bison:

</P>
<DL COMPACT>

<DT><SAMP>`%%'</SAMP>
<DD>
Delimitador utilizado para separar la sección de reglas gramaticales
de la sección de declaraciones de Bison o la sección de código
adicional en C.
See section <A HREF="bison-es-1.27.html#SEC19">El Formato Global de una Gramática de Bison</A>.

<DT><SAMP>`%{ %}'</SAMP>
<DD>
Todo el código listado entre <SAMP>`%{'</SAMP> y <SAMP>`%}'</SAMP> se copia
directamente al archivo de salida sin ser interpretado.  Este
código forma la sección de "declaraciones en C" del archivo de
entrada.  See section <A HREF="bison-es-1.27.html#SEC40">Resumen de una Gramática de Bison</A>.

<DT><SAMP>`/*...*/'</SAMP>
<DD>
Delimitadores de comentarios, como en C.

<DT><SAMP>`:'</SAMP>
<DD>
Separa el resultado de una regla de sus componentes.
See section <A HREF="bison-es-1.27.html#SEC46">Sintaxis de las Reglas Gramaticales</A>.

<DT><SAMP>`;'</SAMP>
<DD>
Finaliza una regla.  See section <A HREF="bison-es-1.27.html#SEC46">Sintaxis de las Reglas Gramaticales</A>.

<DT><SAMP>`|'</SAMP>
<DD>
Separa reglas alternativas para el mismo no-terminal resultante.
See section <A HREF="bison-es-1.27.html#SEC46">Sintaxis de las Reglas Gramaticales</A>.
</DL>



<H1><A NAME="SEC97" HREF="bison-es-1.27.html#TOC97">Glosario</A></H1>
<P>
<A NAME="IDX201"></A>

</P>
<DL COMPACT>

<DT>Agrupación
<DD>
Una construcción del lenguaje que es (en general) gramaticalmente
divisible; por ejemplo, `expresión' o `declaración' en C.  
See section <A HREF="bison-es-1.27.html#SEC13">Lenguajes y Gramáticas independientes del Contexto</A>.

<DT>Análisis de izquierda a derecha
<DD>
Análisis de una frase de un lenguaje analizándolo token a token
de izquierda a derecha.  See section <A HREF="bison-es-1.27.html#SEC73">El Algoritmo del Analizador de Bison</A>.

<DT>Analizador léxico (scanner)
<DD>
Una función que lee un flujo de entrada y devuelve tokens uno por uno.
See section <A HREF="bison-es-1.27.html#SEC66">La Funcion del Analizador Léxico <CODE>yylex</CODE></A>.

<DT>Analizador sintáctico (parser)
<DD>
Una función que reconoce frases válidas de un lenguaje analizando
la estructura sintáctica de un conjunto de tokens pasados desde un
analizador léxico.

<DT>Asignación dinámica
<DD>
Asignación de memoria que ocurre durante la ejecución, en lugar
de en tiempo de compilación, o a la entrada de una función.

<DT>Asociatividad por la izquierda
<DD>
Los operadores que tienen asociatividad por la izquierda se analizan
de izquierda a derecha; <SAMP>`a+b+c'</SAMP> primero se computa <SAMP>`a+b'</SAMP>
y entonces se combina con <SAMP>`c'</SAMP>.  See section <A HREF="bison-es-1.27.html#SEC76">Precedencia de Operadores</A>.

<DT>Cadena vacía
<DD>
Análogo al conjunto vacío en la teoría de conjuntos, la cadena
vacía es una cadena de caracteres de longitud cero.

<DT>Construcción del lenguaje
<DD>
Uno de los típicos esquemas de uso del lenguaje.  Por ejemplo, una de
las construcciones del lenguaje C es la sentencia <CODE>if</CODE>.
See section <A HREF="bison-es-1.27.html#SEC13">Lenguajes y Gramáticas independientes del Contexto</A>.

<DT>Desplazamiento
<DD>
Un analizador se dice que desplaza cuando realiza la elección de
analizar la entrada que proviene del flujo en lugar de reducir
inmediatamente alguna regla ya reconocida.  See section <A HREF="bison-es-1.27.html#SEC73">El Algoritmo del Analizador de Bison</A>.

<DT>Error de análisis
<DD>
Un error encontrado durante el análisis de un flujo de entrada
debido a una sintaxis no válida.  See section <A HREF="bison-es-1.27.html#SEC86">Recuperación de Errores</A>.

<DT>Flujo de entrada
<DD>
Un flujo de datos continuo entre dispositivos y programas.

<DT>Forma de Backus-Naur (BNF)
<DD>
Método formal para la especificación de gramáticas independientes
del contexto.  La BNF se utilizó en primer lugar en el informe de
<CITE>ALGOL-60</CITE>, 1963.  See section <A HREF="bison-es-1.27.html#SEC13">Lenguajes y Gramáticas independientes del Contexto</A>.

<DT>Gramáticas independientes del contexto
<DD>
Gramáticas especificadas como reglas que pueden aplicarse sin
considerar el contexto.  Por lo tanto, si hay una regla que dice
que un entero se puede utilizar como una expresión, los enteros
se permiten <EM>en cualquier lugar</EM> donde una expresión se permita.
See section <A HREF="bison-es-1.27.html#SEC13">Lenguajes y Gramáticas independientes del Contexto</A>.

<DT>LALR(1)
<DD>
La clase de gramáticas independientes del contexto que Bison (como
la mayoría de los otros generadores de analizadores sintácticos)
pueden manejar; un subconjunto de las gramáticas LR(1).
See section <A HREF="bison-es-1.27.html#SEC84">Conflictos Misteriosos de Reducción/Reducción</A>.

<DT>Ligadura léxica
<DD>
Una bandera, activada por las acciones en las reglas gramaticales, que
alteran la manera en la que se analizan los tokens.  See section <A HREF="bison-es-1.27.html#SEC89">Ligaduras Léxicas</A>.

<DT>Literal de caracter simple
<DD>
Un caracter sencillo que se reconoce e interpreta como es.
See section <A HREF="bison-es-1.27.html#SEC14">De las Reglas Formales a la Entrada de Bison</A>.

<DT>LR(1)
<DD>
La clase de gramáticas independientes del contexto en la que al
menos se necesita un token de preanálisis para eliminar la
ambigüedad del análisis de cualquier parte de la entrada.

<DT>Máquina de estado finito basada en pila
<DD>
Una "máquina" que tiene estados discretos los cuales se dice
que existen en cada instante de tiempo.  A medida que la máquina
procesa la entrada, la máquina se mueve de estado a estado como se
especifica en la lógica de la máquina.  En el caso de un analizador
sintáctico, la entrada es el lenguaje que está siendo analizado,
y los estados corresponden a varias etapas en las reglas de la
gramática.  See section <A HREF="bison-es-1.27.html#SEC73">El Algoritmo del Analizador de Bison</A>.

<DT>Notación polaca inversa
<DD>
Un lenguaje en el que todos los operadores son operadores
postfijos.

<DT>Operador infijo
<DD>
Un operador aritmético que se situa entre los operandos sobre los
que realiza alguna operación.

<DT>Operador postfijo
<DD>
Un operador aritmético que se coloca después de los operandos
sobre los que realiza alguna operación.

<DT>Recursión por la derecha
<DD>
Una regla cuyo símbolo resultante es también su componente simbólica
final;  por ejemplo, <SAMP>`expseq1: exp ',' expseq1;'</SAMP>.  See section <A HREF="bison-es-1.27.html#SEC47">Reglas Recursivas</A>.

<DT>Recursión por la izquierda
<DD>
Una regla cuyo símbolo resultante es también su primer símbolo
componente; por ejemplo, <SAMP>`expseq1 : expseq1 ',' exp;'</SAMP>.See section <A HREF="bison-es-1.27.html#SEC47">Reglas Recursivas</A>.

<DT>Reducción
<DD>
Reemplazo de una cadena de no-terminales y/o terminales con un
no-terminal simple, de acuerdo a una regla gramatical.  See section <A HREF="bison-es-1.27.html#SEC73">El Algoritmo del Analizador de Bison</A>.

<DT>Reentrante
<DD>
Un subprograma reentrante es un subprograma que puede ser invocado
cualquier número de veces en paralelo, sin interferir entre las
distintas invocaciones.  See section <A HREF="bison-es-1.27.html#SEC61">Un Analizador Puro (Reentrante)</A>.

<DT>Semántica
<DD>
En los lenguajes de ordenador, la semántica se especifica
con las acciones tomadas para cada instancia del lenguaje,
es decir, el significado de cada sentencia.  See section <A HREF="bison-es-1.27.html#SEC48">Definiendo la Semántica del Lenguaje</A>.

<DT>Símbolo de arranque
<DD>
El símbolo no terminal que representa una expresión completa del
lenguaje que se está analizando.  El símbolo de arranque normalmente
se presenta como el primer símbolo no terminal en la especificación
del lenguaje.
See section <A HREF="bison-es-1.27.html#SEC60">El Símbolo de Arranque</A>.

<DT>Símbolo no terminal
<DD>
Un símbolo de la gramática que representa una contrucción gramatical
que puede expresarse mediante reglas en términos de construcciones
más pequeñas; en otras palabras, una construcción que no es un
token.  See section <A HREF="bison-es-1.27.html#SEC45">Símbolos, Terminales y No Terminales</A>.

<DT>Símbolo terminal
<DD>
Un símbolo de la gramática que no tiene reglas en la gramática
y por lo tanto es gramaticalmente indivisible.  El trozo de texto
que representa es un token.  See section <A HREF="bison-es-1.27.html#SEC13">Lenguajes y Gramáticas independientes del Contexto</A>.

<DT>Tabla de símbolos
<DD>
Una estructura de datos donde los nombres de los símbolos y
datos relacionados se almacenan durante el análisis para permitir
el reconocimiento y uso de información existente en usos repetidos
del un símbolo.  See section <A HREF="bison-es-1.27.html#SEC34">Calculadora Multi-Función: <CODE>mfcalc</CODE></A>.

<DT>Token
<DD>
Una unidad básica, gramaticalmente indivisible de un lenguaje.  El
símbolo que describe un token en la gramática es un símbolo
terminal.  La entrada del analizador de Bison es un flujo de tokens
que proviene del analizador léxico.  See section <A HREF="bison-es-1.27.html#SEC45">Símbolos, Terminales y No Terminales</A>.

<DT>Token de cadena literal
<DD>
Un token que consiste de dos o más caracteres fijos.
See section <A HREF="bison-es-1.27.html#SEC45">Símbolos, Terminales y No Terminales</A>.

<DT>Token de preanálisis
<DD>
Un token que ya ha sido leído pero aún no ha sido desplazado.
See section <A HREF="bison-es-1.27.html#SEC74">Tokens de Preanálisis</A>.
</DL>



<H1><A NAME="SEC98" HREF="bison-es-1.27.html#TOC98">Índice</A></H1>

<P>
<H2>$</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX85">$$</A>
<LI><A HREF="bison-es-1.27.html#IDX86">$<VAR>n</VAR></A>
</DIR>
<H2>%</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX111">%expect</A>
<LI><A HREF="bison-es-1.27.html#IDX161">%left</A>
<LI><A HREF="bison-es-1.27.html#IDX163">%nonassoc</A>
<LI><A HREF="bison-es-1.27.html#IDX168">%prec</A>
<LI><A HREF="bison-es-1.27.html#IDX118">%pure_parser</A>
<LI><A HREF="bison-es-1.27.html#IDX162">%right</A>
<LI><A HREF="bison-es-1.27.html#IDX115">%start</A>
<LI><A HREF="bison-es-1.27.html#IDX97">%token</A>
<LI><A HREF="bison-es-1.27.html#IDX106">%type</A>
<LI><A HREF="bison-es-1.27.html#IDX103">%union</A>
</DIR>
<H2>@</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX145">@<VAR>n</VAR></A>
</DIR>
<H2>a</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX91">Acciones a Media Regla</A>
<LI><A HREF="bison-es-1.27.html#IDX90">acciones en mitad de una regla</A>
<LI><A HREF="bison-es-1.27.html#IDX16">acciones semánticas</A>
<LI><A HREF="bison-es-1.27.html#IDX141">acciones, sumario de propiedades de</A>
<LI><A HREF="bison-es-1.27.html#IDX84">acción</A>
<LI><A HREF="bison-es-1.27.html#IDX109">advertencias, previniendo</A>
<LI><A HREF="bison-es-1.27.html#IDX8">agrupación sintáctica</A>
<LI><A HREF="bison-es-1.27.html#IDX147">algoritmo del analizador</A>
<LI><A HREF="bison-es-1.27.html#IDX21">analizador</A>
<LI><A HREF="bison-es-1.27.html#IDX127">analizador léxico</A>
<LI><A HREF="bison-es-1.27.html#IDX34">analizador léxico, escribiendo un</A>
<LI><A HREF="bison-es-1.27.html#IDX20">analizador léxico, propósito</A>
<LI><A HREF="bison-es-1.27.html#IDX117">analizador puro</A>
<LI><A HREF="bison-es-1.27.html#IDX116">analizador reentrante</A>
<LI><A HREF="bison-es-1.27.html#IDX177">analizador, desbordamiento de pila del</A>
<LI><A HREF="bison-es-1.27.html#IDX151">analizador, pila</A>
<LI><A HREF="bison-es-1.27.html#IDX24">archivo de gramática</A>
<LI><A HREF="bison-es-1.27.html#IDX160">asociatividad</A>
</DIR>
<H2>b</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX157">balanceo del <CODE>else</CODE></A>
<LI><A HREF="bison-es-1.27.html#IDX146">Bison, algoritmo del analizador</A>
<LI><A HREF="bison-es-1.27.html#IDX18">Bison, analizador</A>
<LI><A HREF="bison-es-1.27.html#IDX93">Bison, declaraciones</A>
<LI><A HREF="bison-es-1.27.html#IDX55">Bison, declaraciones (introducción)</A>
<LI><A HREF="bison-es-1.27.html#IDX11">Bison, gramática de</A>
<LI><A HREF="bison-es-1.27.html#IDX195">Bison, invocación</A>
<LI><A HREF="bison-es-1.27.html#IDX199">Bison, tabla de símbolos de</A>
<LI><A HREF="bison-es-1.27.html#IDX19">Bison, utilidad</A>
<LI><A HREF="bison-es-1.27.html#IDX4">BNF</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX44"><CODE>calc</CODE></A>
<LI><A HREF="bison-es-1.27.html#IDX43">calculadora de notación infija</A>
<LI><A HREF="bison-es-1.27.html#IDX30">calculadora de notación polaca</A>
<LI><A HREF="bison-es-1.27.html#IDX47">calculadora multi-función</A>
<LI><A HREF="bison-es-1.27.html#IDX32">calculadora simple</A>
<LI><A HREF="bison-es-1.27.html#IDX45">calculadora, notación infija</A>
<LI><A HREF="bison-es-1.27.html#IDX42">compilando el analizador</A>
<LI><A HREF="bison-es-1.27.html#IDX154">conflictos</A>
<LI><A HREF="bison-es-1.27.html#IDX155">conflictos de desplazamiento/reducción</A>
<LI><A HREF="bison-es-1.27.html#IDX173">conflictos de reducción/reducción</A>
<LI><A HREF="bison-es-1.27.html#IDX110">conflictos, suprimiendo advertencias de</A>
<LI><A HREF="bison-es-1.27.html#IDX37">control, función de</A>
<LI><A HREF="bison-es-1.27.html#IDX59">código C, sección para el</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX92">declaraciones de Bison</A>
<LI><A HREF="bison-es-1.27.html#IDX54">declaraciones de Bison (introducción)</A>
<LI><A HREF="bison-es-1.27.html#IDX98">declaraciones de precedencia</A>
<LI><A HREF="bison-es-1.27.html#IDX53">declaraciones, C</A>
<LI><A HREF="bison-es-1.27.html#IDX120">declaraciones, sumario</A>
<LI><A HREF="bison-es-1.27.html#IDX112">declarando el símbolo de arranque</A>
<LI><A HREF="bison-es-1.27.html#IDX94">declarando nombres de tipo de token</A>
<LI><A HREF="bison-es-1.27.html#IDX99">declarando precedencia de operadores</A>
<LI><A HREF="bison-es-1.27.html#IDX101">declarando tipos de valores</A>
<LI><A HREF="bison-es-1.27.html#IDX104">declarando tipos de valores, de no terminales</A>
<LI><A HREF="bison-es-1.27.html#IDX96">declarando tokens de cadena literal</A>
<LI><A HREF="bison-es-1.27.html#IDX87">default action</A>
<LI><A HREF="bison-es-1.27.html#IDX78">definienfo la semántica del lenguaje</A>
<LI><A HREF="bison-es-1.27.html#IDX166">dependencia del contexto, precedencia</A>
<LI><A HREF="bison-es-1.27.html#IDX191">depurando</A>
<LI><A HREF="bison-es-1.27.html#IDX178">desbordamiento de la pila del analizador</A>
<LI><A HREF="bison-es-1.27.html#IDX176">desbordamiento de pila</A>
<LI><A HREF="bison-es-1.27.html#IDX148">desplazamiento</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX41">ejecutando Bison (introducción)</A>
<LI><A HREF="bison-es-1.27.html#IDX28">ejemplos simples</A>
<LI><A HREF="bison-es-1.27.html#IDX51">ejercicios</A>
<LI><A HREF="bison-es-1.27.html#IDX156"><CODE>else</CODE>, balanceo del</A>
<LI><A HREF="bison-es-1.27.html#IDX184">error</A>
<LI><A HREF="bison-es-1.27.html#IDX136">error de análisis</A>
<LI><A HREF="bison-es-1.27.html#IDX137">error de sintaxis</A>
<LI><A HREF="bison-es-1.27.html#IDX134">errores, función de informe de</A>
<LI><A HREF="bison-es-1.27.html#IDX183">errores, recuperación de</A>
<LI><A HREF="bison-es-1.27.html#IDX40">errores, rutina de informe de</A>
<LI><A HREF="bison-es-1.27.html#IDX33">escribiendo un analizador léxico</A>
<LI><A HREF="bison-es-1.27.html#IDX171">estado (del analizador)</A>
<LI><A HREF="bison-es-1.27.html#IDX170">estado del analizador</A>
<LI><A HREF="bison-es-1.27.html#IDX22">etapas en el uso de Bison</A>
</DIR>
<H2>f</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX5">Forma de Backus-Naur</A>
<LI><A HREF="bison-es-1.27.html#IDX27">formato de la gramática de Bison</A>
<LI><A HREF="bison-es-1.27.html#IDX25">formato del archivo</A>
<LI><A HREF="bison-es-1.27.html#IDX26">formato del archivo de gramática</A>
<LI><A HREF="bison-es-1.27.html#IDX36">función de control</A>
<LI><A HREF="bison-es-1.27.html#IDX133">función de informe de errores</A>
<LI><A HREF="bison-es-1.27.html#IDX38">función main en ejemplo simple</A>
</DIR>
<H2>g</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX201">glosario</A>
<LI><A HREF="bison-es-1.27.html#IDX12">gramática de Bison</A>
<LI><A HREF="bison-es-1.27.html#IDX13">gramática formal</A>
<LI><A HREF="bison-es-1.27.html#IDX2">gramática independiente del contexto</A>
<LI><A HREF="bison-es-1.27.html#IDX3">gramática, independiente del contexto</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX121">intergfaz en lenguaje C</A>
<LI><A HREF="bison-es-1.27.html#IDX1">introducción</A>
<LI><A HREF="bison-es-1.27.html#IDX194">invocando a Bison</A>
<LI><A HREF="bison-es-1.27.html#IDX197">invocando Bison bajo VMS</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX175">LALR(1)</A>
<LI><A HREF="bison-es-1.27.html#IDX122">lenguaje C, interfaz</A>
<LI><A HREF="bison-es-1.27.html#IDX188">ligadura léxica</A>
<LI><A HREF="bison-es-1.27.html#IDX66">literal de caracter sencillo</A>
<LI><A HREF="bison-es-1.27.html#IDX69">literal multi-caracter</A>
<LI><A HREF="bison-es-1.27.html#IDX174">LR(1)</A>
<LI><A HREF="bison-es-1.27.html#IDX35">léxico, escribiendo un analizador</A>
<LI><A HREF="bison-es-1.27.html#IDX180">límite por defecto de la pila</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX48"><CODE>mfcalc</CODE></A>
<LI><A HREF="bison-es-1.27.html#IDX49">multi-función, calculadora</A>
<LI><A HREF="bison-es-1.27.html#IDX169">máquina de estado finito</A>
</DIR>
<H2>n</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX95">nombres de tipo de token, declarando</A>
<LI><A HREF="bison-es-1.27.html#IDX29">notación polaca inversa</A>
</DIR>
<H2>o</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX196">opciones de la invocación de Bison</A>
<LI><A HREF="bison-es-1.27.html#IDX167">operadores unarios, precedencia</A>
<LI><A HREF="bison-es-1.27.html#IDX159">operadores, precedencia</A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX150">pila del analizador</A>
<LI><A HREF="bison-es-1.27.html#IDX158">precedencia de operadores</A>
<LI><A HREF="bison-es-1.27.html#IDX165">precedencia de operadores unarios</A>
<LI><A HREF="bison-es-1.27.html#IDX100">precedencia de operadores, declarando</A>
<LI><A HREF="bison-es-1.27.html#IDX164">precendecia dependiente del contexto</A>
<LI><A HREF="bison-es-1.27.html#IDX108">previniendo advertencias a cerca de conflictos</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX182">recuperación de errores</A>
<LI><A HREF="bison-es-1.27.html#IDX46">recuperación de errores, simple</A>
<LI><A HREF="bison-es-1.27.html#IDX77">recursión mutua</A>
<LI><A HREF="bison-es-1.27.html#IDX76">recursión por la derecha</A>
<LI><A HREF="bison-es-1.27.html#IDX75">recursión por la izquierda</A>
<LI><A HREF="bison-es-1.27.html#IDX149">reducción</A>
<LI><A HREF="bison-es-1.27.html#IDX172">reducción/reducción, conflictos</A>
<LI><A HREF="bison-es-1.27.html#IDX74">reglas recursivas</A>
<LI><A HREF="bison-es-1.27.html#IDX31"><CODE>rpcalc</CODE></A>
<LI><A HREF="bison-es-1.27.html#IDX39">rutina de informe de errores</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX58">sección de código C adicional</A>
<LI><A HREF="bison-es-1.27.html#IDX52">sección de declaraciones en C</A>
<LI><A HREF="bison-es-1.27.html#IDX56">sección de reglas gramaticales</A>
<LI><A HREF="bison-es-1.27.html#IDX57">sección de reglas para la gramática</A>
<LI><A HREF="bison-es-1.27.html#IDX79">semántica del lenguaje, definiendo</A>
<LI><A HREF="bison-es-1.27.html#IDX17">semánticas, acciones</A>
<LI><A HREF="bison-es-1.27.html#IDX81">semántico, tipo de valor</A>
<LI><A HREF="bison-es-1.27.html#IDX15">semántico, valor</A>
<LI><A HREF="bison-es-1.27.html#IDX70">sintaxis de las reglas</A>
<LI><A HREF="bison-es-1.27.html#IDX71">sintaxis de las reglas de la gramática</A>
<LI><A HREF="bison-es-1.27.html#IDX72">sintaxis de reglas gramaticales</A>
<LI><A HREF="bison-es-1.27.html#IDX9">sintáctica, agrupación</A>
<LI><A HREF="bison-es-1.27.html#IDX119">sumario de declaraciones de Bison</A>
<LI><A HREF="bison-es-1.27.html#IDX140">sumario de propiedades de acción</A>
<LI><A HREF="bison-es-1.27.html#IDX107">suprimiendo advertencias de conflictos</A>
<LI><A HREF="bison-es-1.27.html#IDX63">símbolo</A>
<LI><A HREF="bison-es-1.27.html#IDX10">símbolo de arranque</A>
<LI><A HREF="bison-es-1.27.html#IDX114">símbolo de arranque por defecto</A>
<LI><A HREF="bison-es-1.27.html#IDX113">símbolo de arranque, declarando</A>
<LI><A HREF="bison-es-1.27.html#IDX60">símbolo no terminal</A>
<LI><A HREF="bison-es-1.27.html#IDX61">símbolo terminal</A>
<LI><A HREF="bison-es-1.27.html#IDX6">símbolos (resumen)</A>
<LI><A HREF="bison-es-1.27.html#IDX200">símbolos en Bison, tabla de</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX50">tabla de símbolos, ejemplo</A>
<LI><A HREF="bison-es-1.27.html#IDX83">tipo de dato por defecto</A>
<LI><A HREF="bison-es-1.27.html#IDX88">tipo de datos de una acción</A>
<LI><A HREF="bison-es-1.27.html#IDX62">tipo de token</A>
<LI><A HREF="bison-es-1.27.html#IDX80">tipo de valor semántico</A>
<LI><A HREF="bison-es-1.27.html#IDX82">tipos de datos de valores semánticos</A>
<LI><A HREF="bison-es-1.27.html#IDX89">tipos de datos en acciones</A>
<LI><A HREF="bison-es-1.27.html#IDX102">tipos de valores, declarando</A>
<LI><A HREF="bison-es-1.27.html#IDX105">tipos de valores, no terminales, declarando</A>
<LI><A HREF="bison-es-1.27.html#IDX7">token</A>
<LI><A HREF="bison-es-1.27.html#IDX67">token de cadena de caracteres</A>
<LI><A HREF="bison-es-1.27.html#IDX68">token de cadena literal</A>
<LI><A HREF="bison-es-1.27.html#IDX64">token de caracter</A>
<LI><A HREF="bison-es-1.27.html#IDX152">token de preanálisis</A>
<LI><A HREF="bison-es-1.27.html#IDX65">token literal</A>
<LI><A HREF="bison-es-1.27.html#IDX192">trazando el analizador</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX23">utilizando Bison</A>
</DIR>
<H2>v</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX14">valor semántico</A>
<LI><A HREF="bison-es-1.27.html#IDX198">VMS</A>
</DIR>
<H2>y</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX125">YYABORT</A>
<LI><A HREF="bison-es-1.27.html#IDX124">YYACCEPT</A>
<LI><A HREF="bison-es-1.27.html#IDX142">YYBACKUP</A>
<LI><A HREF="bison-es-1.27.html#IDX153">yychar</A>
<LI><A HREF="bison-es-1.27.html#IDX186">yyclearin</A>
<LI><A HREF="bison-es-1.27.html#IDX190">yydebug</A>
<LI><A HREF="bison-es-1.27.html#IDX189">YYDEBUG</A>
<LI><A HREF="bison-es-1.27.html#IDX143">YYEMPTY</A>
<LI><A HREF="bison-es-1.27.html#IDX185">yyerrok</A>
<LI><A HREF="bison-es-1.27.html#IDX135">yyerror</A>
<LI><A HREF="bison-es-1.27.html#IDX144">YYERROR</A>
<LI><A HREF="bison-es-1.27.html#IDX138">YYERROR_VERBOSE</A>
<LI><A HREF="bison-es-1.27.html#IDX181">YYINITDEPTH</A>
<LI><A HREF="bison-es-1.27.html#IDX126">yylex</A>
<LI><A HREF="bison-es-1.27.html#IDX132">YYLEX_PARAM</A>
<LI><A HREF="bison-es-1.27.html#IDX129">yylloc</A>
<LI><A HREF="bison-es-1.27.html#IDX130">YYLTYPE</A>
<LI><A HREF="bison-es-1.27.html#IDX128">yylval</A>
<LI><A HREF="bison-es-1.27.html#IDX179">YYMAXDEPTH</A>
<LI><A HREF="bison-es-1.27.html#IDX139">yynerrs</A>
<LI><A HREF="bison-es-1.27.html#IDX123">yyparse</A>
<LI><A HREF="bison-es-1.27.html#IDX131">YYPARSE_PARAM</A>
<LI><A HREF="bison-es-1.27.html#IDX193">YYPRINT</A>
<LI><A HREF="bison-es-1.27.html#IDX187">YYRECOVERING</A>
</DIR>
<H2>|</H2>
<DIR>
<LI><A HREF="bison-es-1.27.html#IDX73">|</A>
</DIR>

</P>

<P><HR><P>
<H1>Footnotes</H1>
<H3><A NAME="FOOT1" HREF="bison-es-1.27.html#DOCF1">(1)</A></H3>
<P>primera línea, primera
columna, última línea y última columna respectivamente
<P><HR><P>
This document was generated on 23 May 1999 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51.</P>
</BODY>
</HTML>
