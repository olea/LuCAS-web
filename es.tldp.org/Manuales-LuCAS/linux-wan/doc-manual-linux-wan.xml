<?xml version='1.0' encoding='ISO-8859-1'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" 
              "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book id="GuiaRAE" lang="es">
 <bookinfo>
  <title>Guía de Programación de PPP Síncrono y Cisco HDLC</title>
  
  <authorgroup>
   <author>
    <firstname>Alan</firstname>
    <surname>Cox</surname>
    <affiliation>
     <address>
      <email>alan@redhat.com</email>
     </address>
    </affiliation>
   </author>
  </authorgroup>

  <copyright>
   <year>2000</year>
   <holder>Alan Cox</holder>
  </copyright>

  <legalnotice>
<para>
     Esta documentación es software libre; puedes redistrubuirla
     y/o modificarla bajo los términos de la GNU General Public
     License tal como ha sido publicada por la Free Software
     Foundation; por la versión 2 de la licencia, o (a tu elección)
     por cualquier versión posterior.
   </para>

   <para>
    Este programa es distribuido con la esperanza de que sea útil,
    pero SIN NINGUNA GARANTIA; sin incluso la garantía implicada
    de COMERCIABILIDAD o ADECUACCION PARA UN PROPOSITO PARTICULAR.
    Para más detalles refiérase a la GNU General Public License.
   </para>

   <para>
     Debería de haber recibido una copia de la GNU General Public
     License con este programa; si no es así, escriba a la Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>

   <para>
     Para más detalles véase el archivo COPYING en la
     distribución fuente de Linux.
   </para>
  </legalnotice>
 </bookinfo>

<toc></toc>

  <chapter id="intro">
      <title>Introducción</title>
  <para>
	Los controladores syncppp en Linux suministran
	una implementación bastante completa del HDLC de Cisco y una
	mínima implementación de PPP. La meta última es cambiar la capa
	PPP a la interface genérica PPP que es nueva en Linux 2.3.x. La
	API debería de permanecer sin cambios cuando esto haya sido
	realizado, pero el soporte estará entonces disponible para
	IPX, compresión y otras características de PPP.
  </para>
  </chapter>
  <chapter id="bugs">
     <title>Bugs Conocidos y Suposiciones</title>
  <para>
  <variablelist>
    <varlistentry><term>PPP es mínimo</term>
    <listitem>
    <para>
	La actual implementación de PPP es muy básica, aunque suficiente
	para la mayoría de los usos de una red wan.
    </para>
    </listitem></varlistentry>

    <varlistentry><term>Sutilezas del HDLC de Cisco</term>
    <listitem>
    <para>
	Actualmente no finalizamos todos los paquetes con las banderas correctas 
	unicast o multicast de Cisco. No aparenta importar mucho pero debería
	de ser corregido.
    </para>
    </listitem></varlistentry>
  </variablelist>
	
  </para>
  </chapter>

  <chapter id="pubfunctions">
     <title>Funciones Públicas Suministradas</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-input">sppp_input</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_input</refname>
 <refpurpose>
	recibe y procesa un frame PPP WAN
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Sinopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sppp_input </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Argumentos</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
	El dispositivo en el que ha llegado
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
	El buffer a procesar
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Descripción</title>
 <para>
   Puede ser llamado directamente por tarjetas que no tienen 
   restricciones de tiempo, pero normalmente es llamado desde la
   capa de red después de servir la interrupción para procesar
   frames encolados a través de <function>netif_rx</function>.
   </para><para>

   Procesamos las opciones en la tarjeta. Si el frame está destinado
   para la pila de protocolos entonces reencola el frame al nivel
   superior del protocolo. Si es un control para él, entonces es 
   procesado y descargado aquí.    
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-close">sppp_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_close</refname>
 <refpurpose>
      cierra un enlace del HDLC de Cisco o de PPP síncrono 
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Sinopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_close </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Argumentos</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      El dispositivo de red de donde tirar el enlace
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Descripción</title>
 <para>
   Tira la interface lógica al canal. No es realizado de forma
   educada ya que asumimos que también estaremos tirando el DTR.
   Cualesquiera timeouts pendientes son eliminados.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-open">sppp_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_open</refname>
 <refpurpose>
      abre un enlace del HDLC de Cisco o PPP síncrono
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Sinopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_open </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Argumentos</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      	Dispositivo de red a activar
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Descripción</title>
 <para>
   Cierra cualquier sesión síncrona existente y comienza desde
   el principio. En el caso de PPP esto significa el negociado de
   LCP/IPCP y compañía, mientras que para el HDLC de Cisco simplemente
   necesitamos comenzar a enviar keepalives
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-reopen">sppp_reopen</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_reopen</refname>
 <refpurpose>
      notificación de pérdida de enlace físico
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Sinopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_reopen </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Argumentos</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Dispositivo que perdió el enlace
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Descripción</title>
 <para>
   Esta función informa al código del protocolo síncrono que
   el enlace subyacente murió (por ejemplo se tiró el transporte en X.21)
   </para><para>

   Incrementamos los números mágicos para asegurarnos de que si el 
   otro extremo falló en la notificación empezaremos de forma correcta
   una nueva sesión. Esto sucede debido a la naturaleza de los dispositivos
   de telecomunicaciones en los que puedes perder el transporte en
   un sólo extremo.  
   </para><para>

   Habiendo realizado esto volvemos a la negociación. Esta función 
   quizás sea llamada desde un contexto de interrupciones.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-change-mtu">sppp_change_mtu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_change_mtu</refname>
 <refpurpose>
      Cambia el MTU del enlace
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Sinopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_change_mtu </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>new_mtu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Argumentos</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
	Dispositivo en el cual cambiamos el MTU
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_mtu</parameter></term>
   <listitem>
    <para>
      Nuevo MTU
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Descripción</title>
 <para>
   Cambia el MTU en el enlace. Esto sólo puede ser llamado con
   el enlace caído. Devuelve un error si el enlace está activo o
   si el mtu está fuera de rango.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-do-ioctl">sppp_do_ioctl</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_do_ioctl</refname>
 <refpurpose>
      Manejador Ioctl para ppp/hdlc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Sinopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_do_ioctl </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct ifreq * <parameter>ifr</parameter></paramdef>
   <paramdef>int <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Argumentos</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Dispositivo en el cual se realizará la operación ioctl
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ifr</parameter></term>
   <listitem>
    <para>
      Bloque de petición de la interface del usuario
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
      Comando que está siendo emitido
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Descripción</title>
 <para>
   Esta función maneja las ioctls que quizás sean emitidas por 
   el usuario para controlar los parámetros de un enlace PPP/HDLC. 
   Realiza chequeos de seguridad y de si está ocupado. Esta función
   está diseñada para ser envolvida por llamantes que
   desean añadir llamadas ioctls adicionales.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-attach">sppp_attach</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_attach</refname>
 <refpurpose>
      vincula el PPP/HDLC síncrono a un dispositivo
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Sinopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sppp_attach </function></funcdef>
   <paramdef>struct ppp_device * <parameter>pd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Argumentos</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pd</parameter></term>
   <listitem>
    <para>
       	Dispositivo PPP a inicializar
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Descripción</title>
 <para>
   Inicializa el soporte PPP/HDLC en una interfaz. En el momento
   de llamada el elemento dev debe de apuntar al dispositivo de
   red al cual está enlazado esta interfaz. La interfaz aún no debería 
   de estar registrada.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-detach">sppp_detach</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_detach</refname>
 <refpurpose>
      libera los recursos PPP de un dispositivo
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Sinopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sppp_detach </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Argumentos</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
 	Dispositivo de red a liberar
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Descripción</title>
 <para>
   Para y libera cualesquiera recursos PPP/HDLC usados por
   esta interfaz. Debe de ser llamado antes de que
   el dispositivo sea liberado.
 </para>
</refsect1>
</refentry>

  </chapter>

<chapter id="traduccion">
     <title>Sobre la Traducción</title>
        <para>
	Este documento es la traducción de "Synchronous PPP and Cisco HDLC Programming
	Guide", documento que acompaña al código del núcleo de Linux, versión 2.4.18.
	</para>

	<para> 
        Este documento ha sido traducido por Rubén Melcón <email>melkon@terra.es</email>; y
	es publicado por el <ulink url="http://lucas.hispalinux.es">Proyecto Lucas</ulink>
        </para>

        <para>
        Versión de la tradución 0.04 ( Julio de 2002 ).
        </para>

	<para>
	Si tienes comentarios sobre la traducción, ponte en contacto con Rubén Melcón
	<email>melkon@terra.es</email>
	</para>

  </chapter>


</book>
