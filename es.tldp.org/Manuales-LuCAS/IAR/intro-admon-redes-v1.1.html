<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Introducci&oacute;n a la Administraci&oacute;n de una Red Local basada en Internet</TITLE>


</HEAD>
<BODY>
<H1>Introducci&oacute;n a la Administraci&oacute;n de una Red Local basada en Internet</H1>

<H2>Charles L. Hedrick<BR>
 Traducido por Juanjo Mar&iacute;n <CODE>
<A HREF="mailto:juanjo96@arrakis.es">juanjo96@arrakis.es</A></CODE><BR>
 Maquetaci&oacute;n SGML por Paco Brufal <CODE>
<A HREF="mailto:pbrufal@ctv.es">pbrufal@ctv.es</A></CODE> y Fernando <CODE>
<A HREF="mailto:ffddoo@openbank.es">ffddoo@openbank.es</A></CODE></H2>v 1.1, 27 de Julio de 1999
<P><HR>
<EM><B>Introducci&oacute;n para aquellos que pretenden administrar una red basada en
los protocolos de red de Internet (TCP/IP).</B></EM>
<HR>
<H2><A NAME="s1">1. El problema. </A></H2>

<P> 
Este trabajo trata fundamentalmente sobre los
aspectos "l&oacute;gicos" de la arquitectura de red. Lo que puede o no puede hacer
una red est&aacute; generalmente determinado por los protocolos que dicha red
soporta y la calidad de sus implementaciones, m&aacute;s que por la tecnolog&iacute;a
concreta de red usada, como Ethernet, Token Ring, etc. Adem&aacute;s, en la
pr&aacute;ctica, la elecci&oacute;n de la tecnolog&iacute;a de red est&aacute; basada en decisiones
puramente pragm&aacute;ticas: qu&eacute; tipo de red soporta el tipo de ordenadores que
queremos conectar, las distancias entre los equipos, las caracter&iacute;sticas del
cableado, etc. Por regla general, se suele usar Ethernet para sistemas de
media escala, Ethernet o una red basada en el cableado de par trenzado para
peque&ntilde;as redes, o redes de alta velocidad (t&iacute;picamente Token Ring) para la
red principal de un campus y para redes de superordenadores, que ejecutan
aplicaciones de altas prestaciones.
<P>Por tanto, vamos a asumir que hemos llegado a conectar "f&iacute;sicamente" unas
redes individuales, del tipo Ethernet o Token Ring. Ahora nos enfrentamos a
los siguientes problemas interrelacionados:
<P>
<UL>
<LI>configurar el <CODE>software</CODE> necesario, </LI>
<LI>conectar las distintas Redes Ethernet, Token Ring, etc, para formar una &uacute;nica red de forma
coherente,</LI>
<LI> conectar las redes al mundo exterior, o sea, Internet.
</LI>
</UL>
<P>Las anteriores decisiones requieren un peque&ntilde;o an&aacute;lisis. De hecho, la
mayor&iacute;a de las redes necesitan una "arquitectura", que determina la manera
en que se asignan las direcciones, c&oacute;mo se hace el enrutado y otras
elecciones, sobre c&oacute;mo los ordenadores interaccionan con la red. Estas
decisiones deben hacerse para la red en su conjunto, preferiblemente cuando
se esta procediendo a su instalaci&oacute;n inicial.
<P>
<H2>1.1 Terminolog&iacute;a.</H2>

<P>
<P>Vamos a usar el t&eacute;rmino <B>IP</B> para referirnos a las redes dise&ntilde;adas para
trabajar con TCP/IP. IP es el protocolo a nivel de red de la familia de
protocolos TCP/IP, usados en Internet. Es una pr&aacute;ctica com&uacute;n usar el t&eacute;rmino
<B>IP</B> cuando nos referimos a direcciones, enrutamiento y otros elementos a
nivel de red. La distinci&oacute;n muchas veces no es lo suficientemente clara. As&iacute;
que, en la pr&aacute;ctica, los t&eacute;rminos Internet TCP/IP e IP pueden parecer
incluso intercambiables.
<P>Los t&eacute;rminos <B>paquete</B> y <B>datagrama</B> tambi&eacute;n suelen parecer
intercambiables. Conceptualmente, un <B>paquete</B> es la unidad f&iacute;sica de m&aacute;s
bajo nivel, mientras que <B>datagrama</B> se refiere a la unidad de datos a
nivel IP. Sin embargo, en la mayor&iacute;a de las redes no se pueden distinguir
porque coinciden, as&iacute; que la gente suele usar los dos t&eacute;rminos
indistintamente.
<P>Otro t&eacute;rmino <CODE>conflictivo</CODE> es el de <B>pasarela</B> (<CODE>gateway</CODE>) y
<B>enrutador</B> (<CODE>router</CODE>). Pasarela es el t&eacute;rmino original usado en
Internet. Sin embargo, la comunidad OSI empez&oacute; a usar esta palabra con un
significado distinto, as&iacute; que la gente empez&oacute; a usar enrutador para evitar
dicha ambig&uuml;edad. Nosotros, no obstante, seguiremos usando el t&eacute;rmino
<CODE>gateway</CODE>.
<P>
<H2><A NAME="s2">2. Asignaci&oacute;n de direcciones y enrutamiento. </A></H2>

<P> 
<P>Muchas de las decisiones que se necesitan para la configuraci&oacute;n de una red
IP depende del enrutamiento. En general, un datagrama IP pasa a trav&eacute;s de
numerosas redes mientras se desplaza entre el origen y el destino. Veamos un
ejemplo t&iacute;pico:
<P>
<BLOCKQUOTE><CODE>
<PRE>
           Red 1                   Red 2             Red 3
          128.6.4                 128.6.21          128.121
 ==============================  ==========  ====================
    |               |        |    |      |    |         |
 ___|______    _____|____  __|____|__  __|____|____  ___|________
 128.6.4.2     128.6.4.3   128.6.4.1   128.6.21.1    128.121.50.2
                           128.6.21.2  128.121.50.1
 ___________   __________  __________  ____________  ____________
 ordenador A   ordenador B  gateway R    gateway S    ordenador C
</PRE>
</CODE></BLOCKQUOTE>
<P>Este gr&aacute;fico muestra tres ordenadores, 2 <CODE>gateways</CODE> y tres redes. Las
redes pueden ser Ethernet, Token Ring o de cualquier otro tipo. La red 2
podr&iacute;a ser una l&iacute;nea punto a punto que conecta los <CODE>gateways</CODE> R y S.
<P>El ordenador A puede enviar datagramas al B directamente, usando la red 1.
Sin embargo, no puede llegar al ordenador C directamente, puesto que no
est&aacute;n en la misma red. Hay varias maneras de conectar redes. En el gr&aacute;fico
asumimos el uso de <CODE>gateways</CODE> (m&aacute;s adelante veremos otras alternativas).
En este caso, los datagramas que van desde A a C deben ser enviados a trav&eacute;s
del <CODE>gateway</CODE> R, red 2 y <CODE>gateway</CODE> S. Todos los ordenadores que usan
TCP/IP necesitan que se les suministre la informaci&oacute;n y algoritmos
apropiados para que puedan saber cu&aacute;ndo un datagrama debe ser enviado a
trav&eacute;s de un <CODE>gateway</CODE>, y elegir el <CODE>gateway</CODE> apropiado.
<P>El enrutado est&aacute; &iacute;ntimamente relacionado con la asignaci&oacute;n de direcciones.
Podemos apreciar que la direcci&oacute;n de cada ordenador comienza con el n&uacute;mero
de la red a la que pertenece. Por tanto, 128.6.4.2 y 128.6.4.3 se encuentran
en la red 128.6.4. Luego los <CODE>gateways</CODE>, cuyo trabajo es conectar dos
redes, tienen una direcci&oacute;n de ambas redes. Por ejemplo, el <CODE>gateway</CODE> R
conecta la red 128.6.4 y 128.6.21. Su conexi&oacute;n a la red 128.6.4 tiene la
direcci&oacute;n 128.6.4.1. Su conexi&oacute;n a la red 128.6.21 tiene la direcci&oacute;n
128.6.21.2.
<P>Debido a esta relaci&oacute;n entre direcciones y redes, las decisiones de enrutado
deben basarse estrictamente en el n&uacute;mero de red de destino. La informaci&oacute;n
de enrutamiento del ordenador A tendr&aacute; el siguiente aspecto:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      red           gateway       m&eacute;trica
   -----------     ---------      -------
     128.6.4           -             0
     128.6.21      128.6.4.1         1
     128.121       128.6.4.1         2
</PRE>
</CODE></BLOCKQUOTE>
<P>En esta tabla, el ordenador A puede enviar datagramas a los ordenadores de
la red 128.6.4 directamente, y para los datagramas a los ordenadores de las
redes 128.6.21 y 128.121 es necesario usar el <CODE>gateway</CODE> R. La "m&eacute;trica"
ser&aacute; usada por alg&uacute;n tipo de algoritmo de enrutamiento, como medida de la
lejan&iacute;a del destinatario. En nuestro caso, la m&eacute;trica simplemente indica
cuantos diagramas tiene que atravesar para llegar a su destino (conocida
como "cuenta de saltos").
<P>Cuando el ordenador A est&aacute; listo para enviar un datagrama se examina la
direcci&oacute;n del destinatario. Comparamos el inicio de dicha direcci&oacute;n de red
con las direcciones de la tabla de enrutamiento. Las distintas entradas de
la tabla indican si el datagrama debe ser enviado directamente, o a un
<CODE>gateway</CODE>.
<P>Un <CODE>gateway</CODE> consiste simplemente en un ordenador conectado a dos redes
diferentes, y est&aacute; habilitado para enviar datagramas entre ellos. En muchos
casos es m&aacute;s eficiente usar un equipo especialmente dise&ntilde;ado para desempe&ntilde;ar
el papel de <CODE>gateway</CODE>. Sin embargo, es perfectamente posible usar un
ordenador, siempre y cuando tenga m&aacute;s de un interfaz de red y un
<CODE>software</CODE> capaz de enviar datagramas.
<P>Un <CODE>gateway</CODE> tiene varias direcciones, una para cada red a la que est&eacute;
conectado. Aqu&iacute; encontramos una diferencia entre IP y otros protocolos de
red: cada interface de un ordenador tiene una direcci&oacute;n. Con otros
protocolos, cada ordenador tiene una &uacute;nica direcci&oacute;n, aplicable a todos sus
interfaces. Un <CODE>gateway</CODE> entre las redes 128.6.4 y 128.6.21 tendr&aacute; una
direcci&oacute;n que comience por 128.6.4 (por ejemplo, 128.6.4.1). Esta direcci&oacute;n
se refiere a su conexi&oacute;n a la red 128.6.4. Tambi&eacute;n tendr&aacute; una direcci&oacute;n que
comience con 128.6.21 (por ejemplo, 128.6.21.2). Esta se refiere a su
conexi&oacute;n a la red 128.6.21.
<P>El t&eacute;rmino "red" generalmente se suele identificar a dispositivos del tipo
Ethernet, en la cual varias m&aacute;quinas est&aacute;n conectadas. Sin embargo, tambi&eacute;n
se aplica a l&iacute;neas punto a punto. En el gr&aacute;fico anterior, las redes 1 y 3
podr&iacute;an estar en ciudades distintas; la red 2 podr&iacute;a ser una l&iacute;nea serie, un
enlace sat&eacute;lite, u otro tipo de conexi&oacute;n punto a punto. Una l&iacute;nea punto a
punto es tratada como una red que consta s&oacute;lo de dos ordenadores. Como
cualquier otra red, una l&iacute;nea punto a punto tiene una direcci&oacute;n de red (en
este caso, 128.6.21). Los sistemas conectados por la l&iacute;nea (<CODE>gateways</CODE> R
and S) tienen direcciones en dicha red (en este caso, 128.6.21.1 y
128.6.21.2).
<P>Es posible dise&ntilde;ar <CODE>software</CODE> que no necesite distintos n&uacute;meros de red
para cada l&iacute;nea punto a punto. En este caso, el interface entre el
<CODE>gateway</CODE> y la l&iacute;nea punto a punto no tiene una direcci&oacute;n. Esta soluci&oacute;n
es apropiada cuando la red es tan grande que peligra el hecho de que nos
quedemos sin direcciones. Sin embargo, tales "interfaces an&oacute;nimas" pueden
dificultar bastante el manejo de la red. Puesto que no tienen direcci&oacute;n, el
<CODE>software</CODE> de red no tiene manera de referirse a dicho interface, y, por
tanto, no es posible obtener informaci&oacute;n sobre el flujo y los errores de la
interface.
<P>
<H2><A NAME="s3">3. Eligiendo una estructura de direcciones.</A></H2>

<P>
<P>Antes de comenzar a montar una estructura de IP, necesitamos uno o m&aacute;s
n&uacute;meros de red oficiales. Una direcci&oacute;n IP tiene un aspecto como el
siguiente: 128.6.4.3. Esta direcci&oacute;n s&oacute;lo podr&aacute; ser usada por un ordenador
de la Universidad de Marx. La primera parte de dicha direcci&oacute;n, 128.6, es un
n&uacute;mero de red asignado a dicha Universidad por una autoridad central. Por
tanto, antes de asignar direcciones a nuestros ordenadores, deberemos
obtener una direcci&oacute;n oficial de red. Sin embargo, alguna gente configura
sus redes usando, o bien una direcci&oacute;n aleatoria o usando una direcci&oacute;n
gen&eacute;rica suministrada por defecto en el equipo. Esta forma de trabajar
podr&iacute;a funcionar en peque&ntilde;as redes, pero seguramente no lo har&aacute; en una
mayor. Adem&aacute;s, es posible que quisi&eacute;ramos conectar nuestra red con la red de
otra organizaci&oacute;n. Incluso si nuestra organizaci&oacute;n tuviese un gran control
de seguridad, es posible que tuvi&eacute;ramos un ordenador dedicado a la
investigaci&oacute;n que estuviese conectado a una universidad u otra organizaci&oacute;n
investigadora. Esta universidad o entidad estar&iacute;a seguramente conectada a
una red de nivel nacional. Tan pronto como uno de nuestros datagramas salga
de nuestra red local va a provocar un estado de confusi&oacute;n en la organizaci&oacute;n
con la que nos comuniquemos, porque la direcci&oacute;n que aparece en nuestros
datagramas est&aacute; probablemente asignada oficialmente a alguien distinto.
<P>La soluci&oacute;n es simple: obtener una direcci&oacute;n propia desde el principio.
Adem&aacute;s, no cuesta nada.
<P>La decisi&oacute;n m&aacute;s importante que tenemos que hacer para configurar una red es,
sin lugar a dudas, c&oacute;mo asignar las direcciones IP a los ordenadores. Esta
elecci&oacute;n debe de hacerse desde el punto de vista de c&oacute;mo nuestra red puede
crecer. Si no se hiciese as&iacute;, es casi seguro que tendremos que cambiar las
direcciones en un futuro. Y cuando tengamos varios cientos de ordenadores,
cambiar tantas direcciones es casi imposible.
<P>Las direcciones son muy importantes porque los datagramas IP son enrutados
en base a dicha direcci&oacute;n. Por ejemplo, las direcciones de la Universidad
Rutgers tienen una estructura de dos niveles. Una direcci&oacute;n t&iacute;pica
puede ser 128.6.4.3. La direcci&oacute;n 128.6 es la asignada a dicha Universidad.
Visto desde el exterior, 128.6 es una simple red. Cualquier datagrama
enviado desde el exterior, que comience por 128.6, se dirigir&aacute; al
<CODE>gateway</CODE> m&aacute;s cercano de la Universidad Rutgers. Sin embargo, dentro
de Rutgers dividimos el espacio de direcciones en "subredes". Usamos
los siguientes 8 bits de direcci&oacute;n para indicar a qu&eacute; subred pertenece el
ordenador. As&iacute;, 128.6.4.3 pertenece a la subred 128.6.4. Generalmente, las
subredes se corresponden con redes "f&iacute;sicas" o reales, por ejemplo una red
Ethernet; sin embargo, veremos algunas excepciones m&aacute;s adelante. Los
sistemas dentro de Rutgers, a diferencia de los de fuera, contienen
informaci&oacute;n sobre la estructura de subredes de Rutgers. As&iacute;, una vez
que un datagrama para 128.6.4.3 llega a Rutgers, la red de Rutgers
lo enrutar&aacute; hacia la Ethernet, Token Ring o cualquier otro tipo de red del
departamento que tiene asignado la subred 128.6.4.
<P>Cuando queremos configurar una red, hay varias decisiones de
direccionamiento que debemos afrontar:
<P>
<UL>
<LI> ¿Dividimos nuestro espacio de direcciones?</LI>
<LI> Si lo hacemos, ¿usamos subredes o direcciones de clase C?</LI>
<LI> ¿C&oacute;mo debe ser de grande el espacio de direcciones que necesitamos?</LI>
</UL>
<P>
<H2>3.1 ¿Debemos subdividir nuestro espacio en direcciones?</H2>

<P>
<P>No es absolutamente necesario usar subredes. Hay mecanismos que permiten
actuar a un campus o compa&ntilde;&iacute;a completa como una simple y gran Ethernet, as&iacute;
que no es necesario un enrutamiento interno. Si usamos estas tecnolog&iacute;as,
entonces no necesitaremos dividir nuestro espacio de direcciones. En este
caso, la &uacute;nica decisi&oacute;n que tenemos que tomar es la de qu&eacute; clase de
direcci&oacute;n debemos de usar. Sin embargo, recomendamos usar un enfoque de
subredes o cualquier otro m&eacute;todo de subdividir nuestro espacio de direcci&oacute;n
en varias redes:
<P>
<UL>
<LI> En la secci&oacute;n 6.2. discutiremos que los <CODE>gateways</CODE> internos son
recomendables para todas las redes, m&aacute;s all&aacute; de su simplicidad.</LI>
<LI> Incluso si no necesitamos <CODE>gateways</CODE> en estos momentos, podemos
descubrir que tarde o temprano necesitaremos usarlos. De esta manera,
probablemente tiene sentido asignar direcciones como si cada Ethernet o
Token Ring fuera una subred separada. Esto permitir&aacute; hacer conversiones
a subredes reales, si esto es necesario.</LI>
<LI> Por razones de mantenimiento, es conveniente tener direcciones cuya
estructura corresponda con la estructura de la red. Por ejemplo, si
vemos un datagrama extraviado procedente del sistema 128.6.4.3, es de
bastante ayuda saber que todas las direcciones que comienzan por
128.6.4 se en cuentran en un determinado edificio.</LI>
</UL>
                                   
<P>
<H2>3.2 Subredes y m&uacute;ltiples numeros de red</H2>

<P>
<P>Supongamos que estamos convencidos de que es una buena idea imponer alguna
estructura en nuestras direcciones. La siguiente cuesti&oacute;n es cu&aacute;l es la m&aacute;s
adecuada. Hay dos enfoques b&aacute;sicos: subredes y m&uacute;ltiples n&uacute;meros de red.
<P>Los est&aacute;ndares de Internet especifican el formato de las direcciones. Para
las direcciones que comienzan entre 128 y 191 (las m&aacute;s usadas actualmente),
los dos primeros octetos forman el n&uacute;mero de red; por ejemplo, en
140.3.50.1, 140.3 es el n&uacute;mero de red. Los n&uacute;meros de red est&aacute;n asignados a
una organizaci&oacute;n particular. ¿Qu&eacute; hacemos con los dos siguientes octetos que
le siguen?. Podr&iacute;amos optar por hacer al siguiente octeto un n&uacute;mero de
subred, u otro esquema completamente distinto. Los <CODE>gateways</CODE> dentro de
nuestra organizaci&oacute;n deben configurarse para conocer qu&eacute; esquema de divisi&oacute;n
de redes estamos usando. Sin embargo, fuera de la organizaci&oacute;n nadie sabr&aacute;
si 140.3.50 es una subred y 140.3.51 es otra; simplemente, fuera se sabe que
140.3 es una organizaci&oacute;n. Desafortunadamente, esta habilidad de a&ntilde;adir una
estructura adicional a las direcciones, mediante el uso de subredes, no
estaba presente en las especificaciones originales y, por tanto, un
<CODE>software</CODE> antiguo ser&iacute;a incapaz de trabajar con subredes. Si una parte
importante del <CODE>software</CODE> que hemos de usar tiene este problema, entonces
no podremos dividir nuestra red en subredes.
<P>Algunas organizaciones usan un enfoque distinto. Es posible que una
organizaci&oacute;n use varios n&uacute;meros de red. En lugar de dividir un simple n&uacute;mero
de red, por ejemplo 140.3, en varias subredes, como de 140.3.1 a 140.3.10,
podr&iacute;amos usar 10 n&uacute;meros distintos de red. De esta manera har&iacute;amos una
asignaci&oacute;n desde 140.3 hasta 140.12. Todo el <CODE>software</CODE> IP sabr&aacute; que
estas direcciones se corresponden con redes distintas.
<P>A pesar de que usando n&uacute;meros de red distintos todo funciona correctamente
dentro de la organizaci&oacute;n, hay dos serias desventajas. La primera, y menos
importante, es que se malgasta un gran espacio de direcciones. Hay solamente
sobre unas 16.000 posibles direcciones de clase B. No queremos malgastar
diez de ellas en nuestra organizaci&oacute;n, a no ser que sea bastante grande.
Esta objecci&oacute;n es menos seria, porque podr&iacute;amos pedir una direcci&oacute;n C para
este prop&oacute;sito y hay sobre 2 millones de direcciones C.
<P>El problema m&aacute;s serio para usar varias direcciones de red, en lugar de
subredes, es que sobrecarga las tablas de enrutamiento en el resto de
Internet. Como comentamos anteriormente, cuando dividimos nuestro n&uacute;mero de
red en subredes, esta divisi&oacute;n s&oacute;lo es conocida dentro de la organizaci&oacute;n,
pero no fuera. Los sistemas externos a la organizaci&oacute;n s&oacute;lo necesitan una
entrada en sus tablas para ser capaces de llegar. Por tanto, otras
Universidades tienen entradas en sus tablas de enrutamiento para 128.6,
similar al n&uacute;mero de la red de Rutgers. Si usa un rango de redes en
lugar de subredes, dicha divisi&oacute;n ser&aacute; visible en todo Internet. Si usamos
los n&uacute;meros 128.6 a 128.16, en lugar de 128.6, las otras universidades
necesitar&iacute;an tener una entrada para cada uno de estos n&uacute;meros de red en sus
tablas de enrutamiento. La mayor&iacute;a de los expertos de TCP/IP recomiendan el
uso de subredes, en lugar de m&uacute;ltiples redes. La &uacute;nica raz&oacute;n para considerar
m&uacute;ltiples redes es el uso de un <CODE>software</CODE> que no puede manejar subredes.
Esto era un problema hace algunos a&ntilde;os, pero actualmente es poco frecuente.
<P>Una &uacute;ltima indicaci&oacute;n sobre subredes: Las subredes deben ser "adyacentes".
Esto significa que no podemos conectar la subred 128.6.4 con la subred
128.6.5 mediante otra red, como la 128.121. Por ejemplo, Rutgers tiene
campus en Simon City y Garfunken City. Es perfectamente posible conectar
redes en ciudades distintas que sean subred de 128.6. Sin embargo, en este
caso, las l&iacute;neas entre Simon City y Garfunken City deben ser parte de 128.6.
Supongamos que decidimos usar una red regional como la RegionaLnet para
comunicarnos entre dos campus, en lugar de usar su propia l&iacute;nea. Puesto que
RegionaLnet tiene de n&uacute;mero de red 128.121, los <CODE>gateways</CODE> y l&iacute;neas de
serie que usar&iacute;an empezar&iacute;an por 128.121. Esto viola las reglas. No est&aacute;
permitido tener <CODE>gateways</CODE> o l&iacute;neas que son parte de 128.121 conectando
dos partes de 128.6. As&iacute;, si queremos usar RegionaLnet entre nuestros dos
campus, tendr&iacute;amos que obtener diferentes n&uacute;meros de red para los dos
campus. (Esta regla es un resultado de las limitaciones de la tecnolog&iacute;a de
enrutamiento. Eventualmente podr&iacute;a desarrollarse un <CODE>software</CODE> para un
<CODE>gateway</CODE> para manejar configuraciones cuyas redes no son contiguas).
<P>
<H2>3.3 C&oacute;mo asignar las subredes o los numeros de red.</H2>

<P>
<P>Ahora, una vez decidido si vamos a usar subredes o m&uacute;ltiples n&uacute;meros de red,
tenemos que asignarlos. Normalmente es bastante f&aacute;cil. Cada red f&iacute;sica, ya
sea Ethernet o Token Ring, ..., se le asigna un n&uacute;mero distinto de subred.
Sin embargo, existen otras opciones.
<P>En algunos casos, puede que tenga sentido asignar varios n&uacute;meros de subred a
una &uacute;nica red f&iacute;sica. En Rutgers hay una &uacute;nica Ethernet que ocupa tres
edificios, usando repetidores. Est&aacute; claro que a medida que vayamos a&ntilde;adiendo
ordenadores a esta Ethernet se ir&aacute; dividiendo en varias Ethernets separadas.
Para evitar tener que cambiar de direcciones cuando esto suceda, hemos
asignado tres n&uacute;meros de red distintas a esta Ethernet, una por edificio.
(Esto podr&iacute;a ser &uacute;til, incluso, si no hubi&eacute;semos dividido la Ethernet con el
fin de ayudar a localizarlos). Pero, antes de hacer esto, debemos estar muy
seguros de que el <CODE>software</CODE> de todos los ordenadores puede manejar una
red que tiene tres n&uacute;meros de red. Esta pr&aacute;ctica se ver&aacute; m&aacute;s detalladamente
en la secci&oacute;n 3.4.
<P>Tambi&eacute;n hemos de elegir una "m&aacute;scara de subred", que ser&aacute; usada por el
<CODE>software</CODE> del sistema para separar la parte de subred del resto de la
direcci&oacute;n. Hasta ahora hemos asumido que los dos primeros octetos son el
n&uacute;mero de red y el siguiente es el n&uacute;mero de subred. Para las direcciones de
clase B, el est&aacute;ndar especifica que los dos primeros octetos pertenecen al
n&uacute;mero de red. Y, por otro lado, tenemos libertad para establecer el l&iacute;mite
del n&uacute;mero de subred y el resto de la direcci&oacute;n. Es bastante usual utilizar
un octeto de n&uacute;mero de subred, pero no es la &uacute;nica posibilidad. Veamos de
nuevo esta direcci&oacute;n de clase B, 128.6.4.3. Es f&aacute;cil deducir que, si el
tercer octeto es usado como n&uacute;mero de subred, entonces habr&aacute; 256 posibles
subredes y, en cada subred, habr&aacute; 256 posibles direcciones. (En realidad es
m&aacute;s acertado decir que disponemos de 254, ya que no es buena idea usar 0 &oacute;
255 como n&uacute;meros de subred o direcci&oacute;n). Supongamos que sabemos que nunca
vamos a tener m&aacute;s de 128 ordenadores por subred, pero es probable que
necesitemos m&aacute;s de 256 subredes (por ejemplo, un campus con una gran
cantidad de peque&ntilde;os edificios). En ese caso, podr&iacute;amos establecer 9 bits
como n&uacute;mero de red, dejando 7 bits para el direccionamiento de cada subred.
Esta decisi&oacute;n queda plasmada en una m&aacute;scara de bits, usando unos para los
bits usados por los n&uacute;meros de red y de subred y ceros para los bits usados
para el direccionamiento individual. La m&aacute;scara de red m&aacute;s com&uacute;n es
255.255.255.0. Si elegimos 9 bits para el n&uacute;mero de subredes y 7 para las
direcciones, la m&aacute;scara de subred ser&iacute;a 255.255.255.128.
<P>Generalmente, es posible especificar la m&aacute;scara de subred como parte de la
configuraci&oacute;n del <CODE>software</CODE> IP. Los protocolos IP tambi&eacute;n permiten a los
ordenadores que env&iacute;en un mensaje preguntando cu&aacute;l es su m&aacute;scara de subred.
Si nuestra red soporta el env&iacute;o de estos mensajes, y hay, al menos, un
ordenador o <CODE>gateway</CODE> de la red que conoce dicha m&aacute;scara de subred,
posiblemente ser&aacute; innecesario especificarlo en cada uno de los restantes
ordenadores. Pero esta posibilidad puede traer muchos problemas. En caso de
que nuestra implementaci&oacute;n TCP/IP diera una m&aacute;scara de subred err&oacute;nea, se
causar&iacute;a una mala configuraci&oacute;n en toda la red. Por lo tanto, es m&aacute;s seguro
poner cada m&aacute;scara de subred expl&iacute;citamente en cada sistema.
<P>
<H2>3.4 Trabajar con m&uacute;ltiples subredes "virtuales" en una red.</H2>

<P>
<P>La mayor&iacute;a del <CODE>software</CODE> est&aacute; desarrollado bajo el supuesto de que cada
red local tiene el mismo n&uacute;mero de subred. Cuando existe un flujo hacia una
m&aacute;quina con un distinto n&uacute;mero de subred, el <CODE>software</CODE> espera encontrar
un <CODE>gateway</CODE> que pueda dirigirlo hacia esa subred. Veamos detalladamente
qu&eacute; ocurre en este caso. Supongamos que tenemos las subredes 128.6.19 y
128.6.20 en la misma Ethernet. Consideremos las cosas que ocurren desde el
punto de vista de un ordenador con direcci&ograve;n 128.6.19.3. Dicho ordenador no
tendr&aacute; problemas para comunicarse con las m&aacute;quinas de direcci&oacute;n 128.6.19.x.
Estas m&aacute;quinas est&aacute;n en la misma subred, y nuestro ordenador simplemente
deber&aacute; enviar los datagramas al 128.6.20.2. Puesto que esta direcci&oacute;n indica
que est&aacute; en una subred distinta, la mayor&iacute;a del <CODE>software</CODE> esperar&aacute;
encontrar un <CODE>gateway</CODE> que haga de puente entre ambas subredes. Por
supuesto, no existe un <CODE>gateway</CODE> entre las "subredes" 128.6.19 y
128.6.20, puesto que est&aacute;n en la misma Ethernet. De aqu&iacute; se deduce que
tenemos que encontrar una manera de indicarle al <CODE>software</CODE> que el
128.6.20 se encuentra realmente en la misma Ethernet.
<P>La mayor&iacute;a de las implementaciones TCP/IP pueden manejar m&aacute;s de una subred
en la misma red. Por ejemplo, el Berkeley Unix nos permite hacerlo usando
una ligera modificaci&oacute;n del comando usado para definir <CODE>gateways</CODE>. Si,
por ejemplo, queremos que para pasar de la subred 128.6.19 a la subred
128.6.4 se use el <CODE>gateway</CODE> con direcci&oacute;n 128.6.19.1, podemos usar el
comando
<P>
<BLOCKQUOTE><CODE>
<PRE>
route add 128.6.4.0 128.6.19.1 1
</PRE>
</CODE></BLOCKQUOTE>
<P>Esto indica que para llegar a la subred 128.6.4 el flujo debe ser enviado a
trav&eacute;s del <CODE>gateway</CODE> 128.6.19.1. El "1" se refiere a la "m&eacute;trica de
enrutamiento". Si usamos la m&eacute;trica "0", estamos diciendo que la subred de
destino est&aacute; en la misma red y, por consiguiente, no se necesita ning&uacute;n
<CODE>gateway</CODE>. En nuestro ejemplo, deberemos usar en el sistema 128.6.19.3
<P>
<BLOCKQUOTE><CODE>
<PRE>
route add 128.6.20.0 128.6.19.1 0
</PRE>
</CODE></BLOCKQUOTE>
<P>La direcci&oacute;n usada en el lugar de 128.6.19.1 es irrelevante. La m&eacute;trica "0"
nos informa de que no va a usarse ning&uacute;n <CODE>gateway</CODE>, luego no se usar&aacute;
dicha direcci&oacute;n. Sin embargo, deber&aacute; ampliarse una direci&oacute;n legal de la red
local.
<P>
<H3>Otra forma de trabajar con m&uacute;ltiples subredes.</H3>

<P>
<P>Hay otro modo de manejar varias subredes sobre una red f&iacute;sica. Este m&eacute;todo
supone la desconfiguraci&oacute;n de nuestros anfitriones o <CODE>hosts</CODE> y, por ello,
es potencialmente peligrosa, si no sabemos exactamente lo que estamos
haciendo. Sin embargo, puede resultar m&aacute;s c&oacute;modo cuando trabajamos con una
gran cantidad de subredes en una red f&iacute;sica. Un ejemplo de este tipo ser&iacute;a
una instalaci&oacute;n que use <CODE>bridges</CODE>, y usa subredes simplemente por
facilidades de administraci&oacute;n. El truco est&aacute; en configurar el <CODE>software</CODE>
de nuestros <CODE>hosts</CODE> como si no usasen subredes. As&iacute;, nuestros <CODE>hosts</CODE>
no har&aacute;n ninguna distinci&oacute;n entre las distintas subredes y, por tanto, no
habr&aacute; problemas para trabajar con todas ellas. Ahora, el &uacute;nico problema es
c&oacute;mo comunicarnos con subredes que no est&eacute;n en esta red de m&uacute;ltiples
subredes. Pero, si nuestros <CODE>gateways</CODE> manejan <CODE>proxy</CODE> ARP, ellos
resolver&aacute;n este problema por nosotros. Este enfoque est&aacute; especialmente
indicado cuando la misma red contiene m&uacute;ltiples subredes y, particularmente,
si se van a a&ntilde;adir algunas m&aacute;s en un futuro. Desgraciadamente, tiene dos
problemas:
<P>
<OL>
<LI> Si tenemos <CODE>hosts</CODE> con m&uacute;ltiples interfaces, deberemos ser muy
cuidadosos. En primer lugar, s&oacute;lo deber&iacute;a haber m&aacute;quinas con un interface en
la red con m&uacute;ltiples subredes. Por ejemplo, supongamos que disponemos de una
red que consta de varias Ethernets conectadas mediante <CODE>bridges</CODE>; no podemos
tener una m&aacute;quina con interfaces en dos de estas Ethernets, pero podemos
tener un sistema con un interface en esta red de subredes m&uacute;ltiples y otra
en otra subred apartada de &eacute;sta. En segundo lugar, cualquier m&aacute;quina con
m&uacute;ltiples interfaces deber&aacute; conocer la verdadera m&aacute;scara de subred, y
necesitar&aacute; estar informada expl&iacute;citamente de cu&aacute;les de las subredes est&aacute;n en
la red de m&uacute;ltiples subredes. Estas restricciones son consecuencia de que un
sistema con m&uacute;ltiples interfaces tiene que conocer qu&eacute; interface ha de usar
en cada caso.</LI>
<LI> Tambi&eacute;n deberemos prestar atenci&oacute;n a la facilidad ICMP de la
m&aacute;scara de subredes. Esta facilidad permite a los sistemas emitir una
consulta para conocer cu&aacute;l es la m&aacute;scara de subred. Si la mayor&iacute;a de los
<CODE>hosts</CODE> piensan que la red no est&aacute; dispuesta en subredes, pero los
<CODE>gateways</CODE> y los <CODE>hosts</CODE> con varias interfaces piensan lo contrario,
tenemos aqu&iacute; un foco potencial de confusi&oacute;n.  Si un <CODE>gateway</CODE> o
<CODE>hosts</CODE> con varios interfaces env&iacute;a una r&eacute;plica a una ICMP de m&aacute;scara de
red, dando la verdadera m&aacute;scara de subred, alguno de los restantes
<CODE>hosts</CODE> puede interceptarlo. La situaci&oacute;n contraria tambi&eacute;n ser&iacute;a
posible. Esto significa que tendremos que:

<UL>
<LI> deshabilitar las r&eacute;plicas a las ICMP de m&aacute;scara de subred en todos
aquellos sistemas que conocen la m&aacute;scara real de subred (esto es
especialmente f&aacute;cil si solamente los <CODE>gateways</CODE> lo conocen);
     </LI>
<LI> asegurar que nuestros <CODE>hosts</CODE> ignoran las r&eacute;plicas ICMP.
</LI>
</UL>
</LI>
</OL>
<P>A medida que establecemos una m&aacute;scara de subred expl&iacute;citamente, se supone
que los <CODE>hosts</CODE> ignoran los ICMP de m&aacute;scara de subred, as&iacute; que deberemos
ser capaces de establecer diferentes m&aacute;scaras en diferentes <CODE>hosts</CODE> sin
causar ning&uacute;n problema, siempre y cuando podamos establecer la m&aacute;scara
expl&iacute;citamente en todos ellos. Sin embargo, existen implementaciones IP que
cambiar&aacute;n su m&aacute;scara de subred cuando vean una r&eacute;plica de ICMP de m&aacute;scara de
subred.
<P>
<P>
<H3>M&uacute;ltiples subredes: Consecuencias en el Broadcasting.</H3>

<P>
<P>Cuando tenemos m&aacute;s de una subred en una misma red f&iacute;sica, hay que tener
cuidado respecto a las direcciones de <CODE>broadcasting</CODE>. De acuerdo con los
&uacute;ltimos est&aacute;ndares, hay dos formas distintas para que un <CODE>host</CODE> de la
subred 128.6.20 pueda enviar un <CODE>broadcast</CODE> en la red local. Una es usar
la direcci&oacute;n 128.6.20.255. La otra es usar la direcci&oacute;n 255.255.255.255. La
direcci&oacute;n 128.6.20.255 dice, expl&iacute;citamente, "todos los <CODE>hosts</CODE> de la
subred 128.6.20"; la 255.255.255.255 expresa "todos los <CODE>hosts</CODE> de mi red
local". Normalmente, ambas tienen el mismo efecto. Pero no lo tienen cuando
hay varias subredes en una red f&iacute;sica. Si la red 128.6.19 est&aacute; en la misma
red, tambi&eacute;n recibir&aacute; el mensaje enviado a 255.255.255.255. Sin embargo, los
<CODE>hosts</CODE> con n&uacute;meros 128.6.19.x no escuchar&aacute;n los mensajes enviados a
128.6.20.255. El resultado es que ah&iacute; tenemos dos tipos distintos de
direcciones de <CODE>broadcast</CODE> con dos significados distintos. Esto conlleva
que debemos tener cuidado configurando el <CODE>software</CODE> de red, para
asegurarnos de que nuestros <CODE>broadcasting</CODE> llegan a donde queremos que lo
hagan.
<P>
<P>
<H2>3.5 Eligiendo una clase de direcci&oacute;n.</H2>

<P>
<P>Cuando solicitamos un n&uacute;mero oficial de red se nos preguntar&aacute; qu&eacute; clase de
n&uacute;mero de red necesitamos. Las posibles respuestas son A, B y C. La decisi&oacute;n
elegida limitar&aacute; nuestro espacio de direcciones a usar. Las direcciones de
clase A ocupan un octeto; las de clase B, dos octetos, y la clase C, tres
octetos. Luego, hay m&aacute;s direcciones de clase C que direcciones de clase A,
pero las de clase C no pueden tener muchos <CODE>hosts</CODE>. La idea que podemos
sacar de lo anterior es que deber&iacute;a haber pocas grandes redes, un n&uacute;mero
moderado de redes de tama&ntilde;o mediano y bastantes peque&ntilde;as redes. En la
siguiente tabla observamos dicha distinci&oacute;n:
<P>
<BLOCKQUOTE><CODE>
<PRE>
Clase   Rango 1er. octeto    red      resto    direcciones posibles
  A          1 - 126         p        q.r.s        16777214
  B        128 - 191         p.q        r.s        65534
  C        192 - 223         p.q.r        s        254
</PRE>
</CODE></BLOCKQUOTE>
<P>Por ejemplo, la red 10 es de la clase A y por tanto tiene direcciones entre
10.0.0.1 y 10.255.255.254. Esto signfica 2543, que son sobre unos 16
millones de posibles direcciones (realmente, la red 10 tiene algunas
direcciones con octetos a cero, as&iacute; que habr&aacute; algunas direcciones posibles
m&aacute;s). La red 192.12.88, una direcci&oacute;n de clase C, tendr&aacute; sus <CODE>hosts</CODE>
entre el 192.12.88.1 y el 192.12.88.254 y, por lo tanto, habr&aacute; 254 posibles
<CODE>hosts</CODE>.
<P>En general, deberemos elegir la clase menor que nos proporcione suficientes
direcciones capaces de direccionar nuestra red, con sus posibles futuras
ampliaciones. Aquellas organizaciones que usan ordenadores en varios
edificios, probablemente necesitar&aacute;n una direcci&oacute;n de clase B, suponiendo
que vamos a usar subredes. (Y si vamos a tratar con distintos n&uacute;meros de
red, deber&iacute;amos solicitar varias direcciones de clase C). Las direcciones de
clase A, normalmente, s&oacute;lo se usan en grandes redes p&uacute;blicas y algunas pocas
redes de grandes corporaciones.
<P>En la asignaci&oacute;n de Direcciones IP, la autoridad m&aacute;xima es la IANA (Internet
Assigned Number Authority). A escala continental, la IANA delega grandes
bloques de direcciones IP a los denominados registros regionales, de los
que, de momento, existen tres en el mundo:
<P>
<UL>
<LI>El RIPE NCC (RIPE Network Coordination Center) es el registro
delegado de Internet a nivel europeo y se encarga, entre otras tareas, de la
asignaci&oacute;n de bloques de direcciones IP a los proveedores de servicios
Internet en Europa y su &aacute;rea de influencia.
</LI>
<LI>El AP-NIC lleva a cabo la tarea de asignaci&oacute;n de bloques de
direcciones IP a los proveedores de la regi&oacute;n del Asia-Pac&iacute;fico.
</LI>
<LI>El InterNIC se encarga de la asignaci&oacute;n de bloques de direcciones
IP a los proveedores de Internet en Am&eacute;rica del Norte y, de momento, en el
resto del mundo.
</LI>
</UL>
<P>Las organizaciones y usuarios finales han de obtener las direcciones IP
necesarias para conectarse a Internet a trav&eacute;s de su proveedor de acceso a
Internet, quien a su vez las habr&aacute; obtenido bien de su proveedor de
tr&aacute;nsito, bien del registro regional correspondiente.
<P>
<P>
<P>
<H2>3.6 Lineas IP y micro gateways: direcciones asignadas din&aacute;micamente.</H2>

<P>
<P>En la mayor&iacute;a de los casos, cada uno de los ordenadores tendr&aacute; su propia
direcci&oacute;n IP permanente. No obstante, hay algunas situaciones donde tiene
m&aacute;s sentido asignar direcciones din&aacute;micamente. La mayor&iacute;a de los casos que
manejan l&iacute;neas IP constan de <CODE>gateways</CODE> destinados principalmente a
microcomputadoras.
<P>
<H3>L&iacute;neas IP.</H3>

<P>
<P>Es posible usar IP sobre l&iacute;neas telef&oacute;nicas. Uno de los protocolos para
hacer esto es el SLIP ("Serial line IP"). SLIP se usa frecuentemente en, al
menos, dos circunstancias distintas:
<P>
<UL>
<LI>Como una alternativa barata a l&iacute;neas punto a punto
permanentes, para aquellos casos en los que no est&aacute; suficientemente
justificado una l&iacute;nea dedicada.
</LI>
<LI>Como una manera de conectar individualmente un PC a una red,
cuando se encuentran localizados en edificios que no tienen Ethernets o
cualquier otro tipo LAN.
</LI>
</UL>
 
<P>Vamos a usar el t&eacute;rmino "servidor SLIP" para referirnos a un sistema de
ordenador(es) que incluye una serie de modems, con los que otros sistemas
pueden conectarse usando SLIP. Se trata de un sistema que proporciona un
<CODE>gateway</CODE> de nuestra red para usuarios de PC, o para otras redes que se
conectan usando SLIP.
<P>Si tenemos varios PC's conectados mediante SLIP, muchas veces no es pr&aacute;ctico
usar una direcci&oacute;n IP propia para cada PC. Una de las razones puede ser que
no haya suficientes direcciones. Para que el enrutamiento funcione
correctamente, estos sistemas conectados deben tener sus direcciones en la
misma subred que el servidor SLIP. Por lo general, hay solamente del orden
de 256 direcciones disponibles en cada subred. Si el n&uacute;mero de PC's que
pueden conectarse es mayor que esa cifra, no podremos asignarles su propia
direcci&oacute;n. Si, adem&aacute;s, tenemos servidores SLIP en m&aacute;s de una subred, la
asignaci&oacute;n permanente de direcciones se hace a&uacute;n m&aacute;s complicada. Si un
usuario es capaz de llamar a dos servidores, su PC necesitar&iacute;a dos
direcciones, una para cada subred.
<P>Para solucionar estos problemas, la mayor&iacute;a de las implementaciones SLIP
asignan las direcciones din&aacute;micamente. Cuando un PC se conecta con el
servidor SLIP, el servidor busca una direcci&oacute;n IP que no se est&eacute; usando y se
la asigna al PC. La forma m&aacute;s simple de manejar esto es dando a cada
servidor SLIP un rango de direcciones IP que controle y pueda asignar.
<P>Cuando usamos este esquema, el <CODE>software</CODE> SLIP debe comunicar al PC, de
alguna manera, qu&eacute; direcci&oacute;n debe usar. Si cada PC tiene una direcci&oacute;n
permanente, tendr&iacute;amos el problema contrario: cuando un PC se conecta con un
servidor debe de haber alg&uacute;n m&eacute;todo para que el PC comunique al servidor su
direcci&oacute;n. Este problema debe ser estudiado cuidadosamente, porque en otro
caso alguien podr&iacute;a usar la direcci&oacute;n de otro y tener acceso a sus ficheros.
<P>Desafortunadamente, no hay un est&aacute;ndar para manejar estos problemas de
direccionamiento con SLIP. Hay varias implementaciones SLIP que lo hacen,
pero todav&iacute;a no hay un est&aacute;ndar. Hasta que no se elabore &eacute;ste, deberemos
tener cuidado con el <CODE>software</CODE> SLIP. Tenemos que asegurarnos de que
dicha asignaci&oacute;n de direcci&oacute;n se lleva a cabo de la manera que queremos y
que nuestro servidor SLIP y los PC's tienen claro la forma en que se asignan
las direcciones.
<P>Recomendamos dar direcciones permanentes a los PC's en aquellos casos en que
los dem&aacute;s ordenadores tienen que ser capaces de conocer con qu&eacute; PC est&aacute;n
hablando. Este podr&iacute;a ser el caso de un PC para recibir correo privado, o
cualquier otro servicio con transacciones delicadas. Y recomienda el
direccionamiento din&aacute;mico cuando tenemos un gran n&uacute;mero de PC's y las
aplicaciones que utilizan para acceder a la red tienen sus propios
mecanismos de seguridad.
<P>Cuando usemos SLIP para conectar dos redes, hay que considerar tres
elecciones para el manejo de direcciones (teniendo en cuenta que no todo el
<CODE>software</CODE> SLIP puede controlar los tres apartados):
<P>
<UL>
<LI>Tratar a las conexiones SLIP como si se tratasen de l&iacute;neas punto a
punto que no est&aacute;n disponibles permanentemente. Si podemos conectar con
m&aacute;s de un ordenador, cada par de ordenadores que se comunican tienen un
n&uacute;mero de red distinto del que ellos usar&iacute;an cuando se comunican con el
otro.
</LI>
<LI>Usar un <CODE>software</CODE> de enrutamiento que permita interfaces
an&oacute;nimos. En este caso, no ser&iacute;an necesarias las direcciones.
</LI>
<LI>Asignar direcciones din&aacute;micamente cuando la conexi&oacute;n est&aacute; abierta,
tan pronto como el PC haya contactado.
</LI>
</UL>
     
<P>Si hacemos s&oacute;lo una o dos conexiones a otro sistema, es bastante razonable
usar un n&uacute;mero de red para cada conexi&oacute;n. Este m&eacute;todo es f&aacute;cil de usar y
limita los errores estad&iacute;sticos.
<P>Si tenemos muchas conexiones distintas, probablemente es mejor usar
interfaces an&oacute;nimos. Aunque si los sistemas de enrutamiento no lo soportan,
debemos usar asignaci&oacute;n din&aacute;mica.
<P>Al igual que SLIP, PPP "Point to Point Protocol" es un protocolo serie
distinto utilizado para enviar datagramas a trav&eacute;s de una conexi&oacute;n serie,
pero mejora algunas de las carencias del anterior.  El PPP permite a las
partes comunicantes negociar opciones como las direcciones IP y el tama&ntilde;o
m&aacute;ximo de los datagramas al comenzar la conexi&oacute;n, y proporciona permisos de
conexi&oacute;n a los clientes (autorizaciones). Para cada una de estas
capacidades, el PPP tiene un protocolo concreto.
<P>A continuaci&oacute;n, citaremos los elementos b&aacute;sicos que constituyen el PPP. Esta
descripcion esta muy lejos de ser completa; si quiere saber mas sobre el
PPP, lea sus especificaciones en el RFC 1548, asi como en la docena de RFCs
que le acompa&ntilde;an.
<P>En la parte m&aacute;s baja del PPP est&aacute; el protocolo de Control de Conexi&oacute;n de
Datos de Alto-Nivel, abreviadamente HDLC. ( En realidad, el HDLC es un
protocolo mucho m&aacute;s general publicado por la Organizaci&oacute;n Internacional de
Est&aacute;ndares, ISO ) que define los l&iacute;mites de las tramas PPP individuales, y
proporciona un control de errores de 16 bit.  Al contrario de lo que ocurr&iacute;a
en las encapsulaciones SLIP m&aacute;s antiguas, una trama PPP es capaz de llevar
paquetes de otros protocolos distintos al IP, como los IPX de Novell o
Appletalk.  El PPP consigue esto a&ntilde;adiendo a la trama b&aacute;sica HDLC un campo
de control que identifica el tipo de paquete contenido en la trama.
<P>El LCP, Protocolo de Control de Enlace, es utilizado en la parte m&aacute;s alta
del HDLC para negociar las opciones concernientes a la conexi&oacute;n de datos,
tales como la Unidad M&aacute;xima de Recepci&oacute;n (MRU) que establece el tama&ntilde;o
m&aacute;ximo del datagrama que una de las partes de la conexi&oacute;n acepta recibir.
<P>
<P>
<H3>Micro gateways.</H3>

<P>
<P>Es perfectamente posible que un microcomputador forme parte de una red IP.
Pero hay una tendencia de que los micros utilicen distintas tecnolog&iacute;as de
red que la de los grandes sistemas. Esto es debido a que muchos de los
usuarios de micros empiezan a demandar un <CODE>software</CODE> de red dise&ntilde;ado
espec&iacute;ficamente para las necesidades de un micro, incluso para un particular
tipo de micro. Muchos usuarios est&aacute;n interesados en usar TCP/IP sin tener
que abandonar su red especial de micro, a la que est&aacute;n acostumbrados. Por
esta raz&oacute;n, hay un creciente n&uacute;mero de productos, especialmente
<CODE>gateways</CODE>, que dan acceso a los PC's tanto a redes orientadas a micros
como a TCP/IP.
<P>En esta secci&oacute;n vamos a hablar del AppleTalk, de Apple, a modo de ejemplo.
No obstante, existen productos similares para otros tipos de redes de
micros. Hay que aclarar que el t&eacute;rmino AppleTalk se asocia a los protocolos
de red de Apple, mientras que LocalTalk se asocia a una tecnolog&iacute;a
espec&iacute;fica de par trenzado, en la que AppleTalk fue inicialmente
implementada. Por tanto, el AppleTalk es an&aacute;logo a los protocolos TCP/IP,
mientras que LocalTalk es an&aacute;logo a medio Ethernet.
<P>Algunas compa&ntilde;&iacute;as ofrecen <CODE>gateways</CODE> para conectar una red AppleTalk
corriendo sobre LocalTalk, con redes IP corriendo sobre Ethernet. A pesar de
que hay varios productos de este tipo, la mayor&iacute;a de ellos incluyen los
siguientes servicios:
<P>
<UL>
<LI>Las aplicaciones TCP/IP de un PC pueden conectarnos a sistemas
TCP/IP de la Ethernet. Se definen utilidades especiales para
permitirnos llevar datagramas IP desde el PC hasta el <CODE>gateway</CODE>, a
trav&eacute;s del LocalTalk. Las aplicaciones TCP/IP de PC han sido escritas
usando unas librer&iacute;as especiales que mezclan AppleTalk y TCP/IP. Las
utilidades AppleTalk se necesitan para llevar los datagramas hasta el
<CODE>gateway</CODE>, donde se transformar&aacute;n en datagramas 100% TCP/IP, antes
de dejarlos en la Ethernet.
</LI>
<LI>Se pueden escribir aplicaciones AppleTalk para grandes sistemas, de
tal manera que un PC podr&aacute; usarlos como servidores. Dichas aplicaciones
tambi&eacute;n han sido escritas haciendo uso de una librer&iacute;a especial que
mezcla AppleTalk y TCP/IP. Pero, en esta ocasi&oacute;n, son utilidades TCP/IP
para dejar datagramas en el <CODE>gateway</CODE>, donde se transformar&aacute;n
totalmente en AppleTalk, antes de dejarlos en la AppleTalk y lleguen al
PC.
     </LI>
<LI>Una red IP de un campus o una corporaci&oacute;n puede ser usada para
conectar redes AppleTalk. Los <CODE>gateways</CODE> de cada Apple realizar&aacute;n
las conversiones necesarias antes de enviar los datagramas a la red IP.
</LI>
</UL>
     
<P>Adem&aacute;s, algunos <CODE>gateways</CODE> pueden hacer traducciones a nivel de
aplicaci&oacute;n. Por ejemplo, algunos <CODE>gateways</CODE> pueden hacer traducciones
entre el sistema de ficheros de Apple y el sistema de fichero de red de Sun
(NFS). Esto permite a un PC acceder al sistema de ficheros Unix, donde el PC
usa el sistema de ficheros Apple, y el acceso al sistema Unix se hace
mediante el uso del sistema NFS, o sistema de ficheros de red (Network File
System ), de Sun.
<P>Desafortunadamente, la gran flexibilidad de estos productos se traduce en
una gran complejidad. El tema de direcciones es especialmente complicado.
Por las mismas razones que SLIP, y PPP estos <CODE>gateways</CODE> usan
frecuentemente asignaci&oacute;n din&aacute;mica de direcciones IP. Para ello asignaremos
un rango de direcciones IP a cada <CODE>gateway</CODE>. Cuando un PC intenta abrir
una conexi&oacute;n TCP/IP, el <CODE>gateway</CODE> se hace con una direcci&oacute;n IP libre y se
la asigna al PC. Al igual que SLIP, en muchos casos necesitaremos elegir si
queremos que las direcciones se asignen de esta manera, o bien queremos que
cada PC tenga su propia direcci&oacute;n. Otra vez, la elecci&oacute;n depender&aacute; del
n&uacute;mero de PC's que tengamos y de si tenemos aplicaciones capaces de usar la
direcci&oacute;n IP para identificar qu&eacute; PC, en particular, es el que est&aacute;
conectado.
<P>El direccionamiento es mucho m&aacute;s complejo, debido a que AppleTalk tiene su
propia estructura de direcciones. Deberemos establecer una correspondencia
entre direcciones AppleTalk y n&uacute;meros de red IP. Tambi&eacute;n habr&aacute; una
correspondencia entre direcciones IP y AppleTalk, que se establecer&aacute;
din&aacute;micamente en los <CODE>gateways</CODE>.
<P>
<H2><A NAME="s4">4. Servicios a nivel de red, nombres.</A></H2>

<P>
<P>Si vamos a tener una red TCP/IP, hay algunas tareas importantes que
realizar. Algunas de ellas son simplemente de tipo administrativo. La m&aacute;s
importante es crear un registro central de nombres y direcciones IP. Existen
organizaciones que realizan esta labor para toda la red Internet. Si estamos
conectados a Internet, el administrador de nuestro sistema necesita
registrarse a una de estas organizaciones, para que cualquier demanda por
parte de otra instituci&oacute;n sobre nuestros <CODE>hosts</CODE> sean dirigidos a
nuestros servidores.
<P>Queremos mantener una base de datos que contenga la informaci&oacute;n de cada
sistema de la red. Como m&iacute;nimo, necesitaremos el nombre y la direcci&oacute;n IP de
cada sistema. Probablemente, el registro central ser&aacute; el encargado de
asignar las direcciones IP. Si nuestra red est&aacute; estructurada en subredes, o
si usamos varios n&uacute;meros de clase C, el registro posiblemente asignar&aacute; los
n&uacute;meros de red a las nuevas redes o subredes. Pero, habitualmente, se
permitir&aacute; que los propios administradores de los <CODE>hosts</CODE> elijan el nombre
del host. Sin embargo, el registro debe de, al menos, verificar que no haya
nombres duplicados. Si estamos trabajando con una gran red, puede que sea
buena idea delegar algunas de estas tareas a subregistros, posiblemente uno
para cada departamento.
<P>Se recomienda asignar las direcciones de la forma m&aacute;s simple: empezando por
1. As&iacute;, si nuestra red es la 128.6, podr&iacute;amos asignar como 128.6.1 a la
primera subred; 128.6.2, a la segunda, etc. La asignaci&oacute;n de direcciones IP
para <CODE>hosts</CODE> individuales podr&iacute;an empezar por 2. De esta manera
reservamos la direcci&oacute;n 1 de cada subred para que sea usada por el
<CODE>gateway</CODE> correspondiente. Por consiguiente, el primer <CODE>host</CODE> de la
subred 128.6.4 ser&iacute;a el 128.6.4.2; el siguiente ser&iacute;a 128.6.4.3, y as&iacute;
sucesivamente. Hay una raz&oacute;n b&aacute;sica para mantener las direcciones tan cortas
como sean posibles. Si tenemos una gran organizaci&oacute;n, podr&iacute;amos quedarnos
sin n&uacute;meros de subred. Si esto ocurriera, y nuestros <CODE>hosts</CODE> tienen
n&uacute;meros de red bajos, podr&iacute;amos asignar otro bit para el direccionamiento de
las subredes. Si, por ejemplo, usamos el tercer octeto como n&uacute;mero de
subred, en tanto en cuanto nuestros <CODE>hosts</CODE> tengan unos n&uacute;meros
inferiores a 128, podremos ampliar el n&uacute;mero de red a 9 bits. As&iacute;, por
ejemplo, la subred 128.6.4 podr&iacute;a dividirse en dos subredes distintas:
128.6.4.0 y 128.6.4.128. Si hubi&eacute;semos asignado a los <CODE>hosts</CODE> n&uacute;meros por
encima de 128, la divisi&oacute;n habr&iacute;a sido imposible.
<P>La asignaci&oacute;n de nombres de los <CODE>hosts</CODE> no es tan sistem&aacute;tica. Pueden ser
cualquier expresi&oacute;n compuesta de letras, n&uacute;meros y guiones. Es m&aacute;s seguro
que el primer car&aacute;cter sea una letra.  Y, desde el punto de vista de los
usuarios, es recomendable que los nombres sean lo m&aacute;s cortos posibles
(incluso hay <CODE>software</CODE> que tiene problemas trabajando con nombres m&aacute;s
largos de 16 caracteres). Muchas veces, los departamentos o proyectos
eligen un tema o nombre relacionado con ellos. Por ejemplo, las m&aacute;quinas
usadas por los estudiantes de Inform&aacute;tica de Rutgers tienen nombres de
bandas de rock: OASIS, BLUR, IRONMAIDEN, SAVOY, etc. Nuestro departamento de
Matem&aacute;ticas usa el nombre de famosos matem&aacute;ticos: GAUSS, FERMAT, etc. Si la
instituci&oacute;n no tiene ninguna relaci&oacute;n con el mundo exterior, cualquier
nombre es adecuado.
<P>Si estamos conectados a Internet, nuestra organizaci&oacute;n necesitar&aacute; un "nombre
de dominio" (domain name). Al igual que en el caso del espacio de
direcciones IP, la autoridad m&aacute;xima del espacio de nombres de Internet (DNS,
Domain Name System) es la IANA (Internet Assigned Number Authority). La ra&iacute;z
del DNS es gestionada por el InterNIC por delegaci&oacute;n de la IANA. Bajo la
ra&iacute;z se encuentran los distintos dominios de primer nivel (Top Level Domains
o TLD's) gestionados por distintos registros delegados de Internet. Algunos
de ellos son: Dominios "especiales" como COM, ORG, NET, EDU,... controlados
por InterNIC ( nodo central del Network Internet Center ); y dentro de los
dominios nacionales, el dominio ES, correspondiente a Espa&ntilde;a, est&aacute; delegado
a ES-NIC.
<P>A diferencia del n&uacute;mero de red, podremos arregl&aacute;rnosla sin &eacute;l si la red est&aacute;
aislada. Si posteriormente lo necesitamos, es f&aacute;cil de a&ntilde;adir un nombre de
dominio. (Recomendamos usar un n&uacute;mero de red desde el principio, porque
cambiar n&uacute;meros de red posteriormente puede ser traum&aacute;tico). Los nombres de
dominio, normalmente, terminan en .EDU para las instituciones educativas,
.COM, para las compa&ntilde;&iacute;as, etc. Por ejemplo, la Universidad de Rutgers
tiene como nombre de dominio RUTGERS.EDU. El formato de los nombres
completos de dominio consiste en un nombre interno, seguido del nombre de
dominio de la organizaci&oacute;n. As&iacute;, si un ordenador es conocido internamente
como GAUSS, su nombre completo ser&aacute; GAUSS.RUTGERS.EDU. Si tenemos una gran
organizaci&oacute;n, es posible tener subdominios. Por ejemplo, puede que haya un
subdominio para cada departamento; esto a&ntilde;adir&iacute;a otro t&eacute;rmino en los
nombres. Si, por ejemplo, el departamento de Matem&aacute;ticas decide crear su
subdominio, el anterior ordenador se llamar&iacute;a GAUSS.MATHS.RUTGERS.EDU. Una
vez asignado el nombre de dominio, se procede a cambiar los ficheros de
configuraci&oacute;n donde aparece la forma completa del nombre. En algunos casos,
se pueden usar apodos o nombres cortos, de manera que no ser&aacute; necesario
incluir el nombre completo.
<P>Si tenemos m&aacute;s de uno o dos sistemas, necesitaremos tener alg&uacute;n mecanismo
para tener al d&iacute;a la informaci&oacute;n de los distintos <CODE>hosts</CODE>. El
<CODE>software</CODE> TCP/IP necesita ser capaz de traducir nombres de <CODE>hosts</CODE> en
direcciones IP. Cuando un usuario intenta conectarse con otro sistema,
generalmente se referir&aacute; a &eacute;l usando su nombre. El <CODE>software</CODE> tendr&aacute; que
traducir el nombre en una direcci&oacute;n IP, para poder abrir la conexi&oacute;n. La
mayor&iacute;a del <CODE>software</CODE> incluye dos vias para hacer esta traducci&oacute;n: una
tabla est&aacute;tica o un servidor de nombres. La soluci&oacute;n de la tabla est&aacute;
indicada para peque&ntilde;as organizaciones, siempre y cuando no est&eacute;n conectadas
a otra red. Simplemente se crea un fichero que lista los nombres y
direcciones de todos los <CODE>hosts</CODE>. Veamos parte de una tabla de este tipo:
<P>
<BLOCKQUOTE><CODE>
<PRE>
HOST: 128.6.4.2, 128.6.25.2: ARAMIS.RUTGERS.EDU, ARAMIS: SUN-3-280: UNIX :: 
HOST: 128.6.4.3:             GAUSS.RUTGERS.EDU,  GAUSS:  SUN-3-180: UNIX ::
HOST: 128.6.4.4, 128.6.25.4: ATHOS.RUTGERS.EDU,  ATHOS:  SUN-4-280: UNIX ::
</PRE>
</CODE></BLOCKQUOTE>
<P>Como se puede apreciar, el formato es el siguiente: una l&iacute;nea para cada
sistema y listar sus direcciones, nombres y otra informaci&oacute;n sobre &eacute;l. En el
ejemplo, tanto ARAMIS como ATHOS est&aacute;n en dos redes, as&iacute; que tienen dos
direcciones. Adem&aacute;s, ambos tienen un nombre principal, por ejemplo
ARAMIS.RUTGERS.EDU, y apodos, por ejemplo ARAMIS. En caso de estar
conectados a Internet, el nombre principal ser&aacute; el nombre de dominio
completamente especificado. Se incluyen apodos cortos, para facilitar la
tarea a nuestros usuarios. Hay otro formato muy frecuente para las tablas de
<CODE>hosts</CODE>. Veamos un ejemplo:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        128.6.4.2    aramis.rutgers.edu   aramis
        128.6.25.2   aramis.rutgers.edu   aramis
        128.5.4.3    gauss.rutgers.edu    gauss
        128.6.4.4    athos.rutgers.edu    athos
        128.6.25.4   athos.rutgers.edu    athos
</PRE>
</CODE></BLOCKQUOTE>
<P>En este formato, cada l&iacute;nea representa una direcci&oacute;n IP. Si el sistema tiene
dos interfaces, hay dos l&iacute;neas de &eacute;l en la tabla. Se debe procurar poner, en
primer lugar, aquellas direcciones de uso m&aacute;s com&uacute;n. La documentaci&oacute;n de su
sistema le informar&aacute; sobre el formato usado por &eacute;l.
<P>En la configuraci&oacute;n m&aacute;s simple, cada ordenador tiene su propia copia de la
tabla de <CODE>hosts</CODE> en /etc/hosts. En caso de elegir esta configuraci&oacute;n,
deberemos establecer procedimientos para asegurarnos que todas las copias
son actualizadas regularmente. En una red peque&ntilde;a no es dif&iacute;cil mantener una
tabla /etc/hosts en cada m&aacute;quina, y modificarla al agregar, eliminar o
modificar nodos. Aunque resulta complicado cuando hay muchas m&aacute;quinas, ya
que, en principio, cada una necesita una copia de /etc/hosts.
<P>Una soluci&oacute;n a esto es compartir &eacute;sta y otras bases de datos con el NIS, o
sistema de informaci&oacute;n de red ( Network Information System ), desarrollado
por Sun Microsystems y conocido tambi&eacute;n como p&aacute;ginas amarillas o YP. En este
caso, las bases de datos como la de /etc/hosts se mantienen en un servidor
NIS central y los clientes acceder&aacute;n a ellas de forma transparente al
usuario. En todo caso, esta soluci&oacute;n s&oacute;lo es aconsejable para redes peque&ntilde;as
o medianas, ya que implican mantener un fichero central /etc/hosts que puede
crecer mucho, y luego distribuirlo entre los servidores NIS.
<P>En redes grandes, y todos aquellos que est&aacute;n conectados a Internet, debemos
adoptar un nuevo sistema, el DNS o sistema de nombres por dominios (Domain
Name System) dise&ntilde;ado por Paul Mockapetris. T&eacute;cnicamente, el DNS es una
inmensa base de datos distribu&iacute;da jer&aacute;rquicamente por toda la Internet;
existen infinidad de servidores que interact&uacute;an entre si para encontrar y
facilitar a las aplicaciones clientes que los consultan la traducci&oacute;n de un
nombre a su direccion de red IP asociada, con la que poder efectuar la
conexi&oacute;n deseada. Cada parte de la base de datos est&aacute; replicada en, al
menos, dos servidores, lo que asegura una debida redundancia. Un servidor de
nombres es un programa que se ejecuta en algunos de nuestros sistemas para
tener conocimiento de los nombres. Cuando un programa necesita buscar un
nombre, en lugar de hacerlo en una copia de la tabla de <CODE>host</CODE>, env&iacute;a una
petici&oacute;n al servidor de nombres. Este enfoque tiene dos ventajas:
<P>
<UL>
<LI>Para los grandes sistemas, es m&aacute;s f&aacute;cil tener al d&iacute;a las tablas en
algunos servidores de nombres que en todo el sistema.
</LI>
<LI>Si nuestra red est&aacute; conectada a Internet, nuestro servidor de nombres
ser&aacute; capaz de dialogar con los servidores de nombres de otras
organizaciones, para buscar nombres de cualquier sitio.
</LI>
</UL>
    
<P>Usar un servidor de nombres es el &uacute;nico camino para tener un acceso completo
a la informaci&oacute;n del resto de los <CODE>hosts</CODE> de Internet.
<P>Es importante comprender la diferencia entre un servidor de nombres y un
resolvedor. Un servidor de nombres es un programa que tiene acceso a una
base de datos de <CODE>hosts</CODE>, y responde peticiones de otros programas. Un
resolvedor es un conjunto de subrutinas que pueden cargarse con un programa.
El resolvedor genera las peticiones que se enviar&aacute;n al servidor de nombres,
y procesa sus correspondientes respuestas. Cada sistema deber&iacute;a usar un
resolvedor (en general, el resolvedor es cargado por cada programa que va a
hacer uso de la red, puesto que s&oacute;lo es un conjunto de subrutinas). Hay que
recalcar que s&oacute;lo se necesitar&aacute;n unos pocos servidores de nombres. Mucha
gente confunde los dos enfoques y llega a creer que es necesario tener un
servidor de nombres en cada ordenador.
<P>Para usar un resolvedor, cada ordenador necesitar&aacute; un fichero de
configuraci&oacute;n, u otro m&eacute;todo, para especificar la direcci&oacute;n del servidor de
nombres al que enviar nuestras peticiones. Por regla general, se pueden
declarar varios servidores de nombres, para el caso de que alguno de ellos
no funcione correctamente. En el caso de que nuestro sistema no pudiera
contactar satisfactoriamente con ning&uacute;n servidor, la mayor&iacute;a de nuestro
<CODE>software</CODE> empezar&iacute;a a fallar. Por tanto, hay que ser muy cuidadoso y
declarar tantos servidores como podamos para intentar asegurar un buen
funcionamiento.
<P>Los servidores de nombres, generalmente, tienen un conjunto de opciones para
su configuraci&oacute;n. En lugar de dar algunos consejos sobre c&oacute;mo configurar un
servidor de nombres, vamos a recomendar dos documentos oficiales de los
est&aacute;ndares de Internet. El RFC 1032 contiene las instrucciones sobre c&oacute;mo
conseguir un nombre de dominio del Centro de Informaci&oacute;n de Red, incluyendo
los formularios necesarios. El RFC 1033 contiene las instrucciones sobre
c&oacute;mo configurar un servidor de nombres. Todos estos documentos son de tipo
conceptual. Seguramente, tambi&eacute;n necesitar&aacute; documentaci&oacute;n sobre el
<CODE>software</CODE> espec&iacute;fico de su servidor de nombres.
<P>En algunos casos, puede que se necesiten, a la vez, tablas y servidores de
nombres. Si tenemos alguna implementaci&oacute;n de TCP/IP que no incluyan
<CODE>resolvers</CODE>, estamos obligados a instalar tablas de <CODE>hosts</CODE> en estos
sistemas. Si nuestra red est&aacute; conectada a Internet, vamos a tener problemas
con aquellos sistemas que no dispongan de resolvers, ya que Internet es
demasiado grande para tener unas tablas de <CODE>hosts</CODE> de todos sus
<CODE>hosts</CODE>. Por lo tanto, lo que se puede hacer es incluir una tabla de
<CODE>hosts</CODE> con los <CODE>hosts</CODE> que realmente se tiene pensado usar. InterNIC
tiene a su cargo una tabla de <CODE>host</CODE> que puede ser un buen punto de
comienzo, aunque no es completa de ning&uacute;n modo. As&iacute; que tendremos que a&ntilde;adir
los <CODE>hosts</CODE> favoritos de los usuarios. Los sistemas que usan
<CODE>resolvers</CODE> no tendr&aacute;n este problema, puesto que un servidor de nombres
es capaz de traducir cualquier nombre legal de <CODE>host</CODE>.
<P>Los nombres de <CODE>hosts</CODE> y la asignaci&oacute;n de n&uacute;meros son los &uacute;nicos elementos que
deben de tener una estructura centralizada. Sin embargo, puede haber otros
elementos susceptibles de centralizaci&oacute;n. Es bastante frecuente tener uno o
dos ordenadores que se hagan cargo de todo el correo electr&oacute;nico. Si estamos
conectados a Internet, es bastante simple establecer comunicaciones con
otros ordenadores de Internet. No obstante, hay muchas instituciones que
quieren comunicarse con sistemas de otras redes, como Bitnet o Usenet. Hay
<CODE>gateways</CODE> entre varias de estas redes. Pero la elecci&oacute;n del <CODE>gateway</CODE>
correcto, y transformar la direcci&oacute;n de correo electr&oacute;nico correctamente, es
una tarea muy especializada. Por esto, en muchas ocasiones se configura el
<CODE>software</CODE> apropiado s&oacute;lo en un lugar, y todo el correo externo (o todo
el correo externo a <CODE>hosts</CODE> que no est&aacute;n en Internet) se dirige a este
sistema.
<P>
<P>
<H2><A NAME="s5">5. Configurando el enrutamiento de cada ordenador</A></H2>

<P>Todas las implementaciones TCP/IP necesitan alguna configuraci&oacute;n 
en cada <CODE>host</CODE>. En algunos casos, esto se hace durante la 
instalaci&oacute;n  del sistema de forma casi autom&aacute;tica. 
En otros casos, mediante la configuraci&oacute;n de ciertos programas o ficheros. 
Y, por &uacute;ltimo, otros sistemas obtienen la informaci&oacute;n de
configuraci&oacute;n a trav&eacute;s de la red de un "servidor".
<P>A pesar de que los detalles de la configuraci&oacute;n pueden diferir
bastante, existen ciertos datos que deben incluirse en todos los casos.
Entre ellos:
<UL>
<LI>par&aacute;metros que describan a una m&aacute;quina en particular, como su
direcci&oacute;n IP;</LI>
<LI>par&aacute;metros que describan la red, como su subm&aacute;scara de red
(si hubiera);</LI>
<LI><CODE>software</CODE> de enrutamiento y las tablas que use;</LI>
<LI>otros programas necesarios para el funcionamiento de otras tareas
de red.</LI>
</UL>
<P>Antes de que se instale un ordenador en una red, un coordinador
deber&aacute; asignarle un nombre de red  y su direcci&oacute;n IP, como describimos
anteriormente. Una vez otorgado un nombre y una direcci&oacute;n 
estamos en disposici&oacute;n de configurarlo. En numerosas ocasiones, lo que
debemos hacer es poner la direcci&oacute;n y el nombre en un fichero de
configuraci&oacute;n. Sin embargo, algunos ordenadores (especialmente
aquellos que no disponen de un disco propio en el que dicha informaci&oacute;n
pueda ser almacenada) deben obtener esta informaci&oacute;n a trav&eacute;s de la red.
En el momento en que un sistema arranca, se realiza un broadcast a la
red con la petici&oacute;n "¿qui&eacute;n soy?". En el caso de poseer ordenadores de
este tipo, debemos asegurarnos de que nuestra red est&aacute; preparada para
responder adecuadamente. La pregunta l&oacute;gica es: ¿c&oacute;mo otro sistema
sabe qui&eacute;n eres?. Generalmente, esto se soluciona haciendo uso de las
direcciones Ethernet (o las direcciones an&aacute;logas para otro tipo de redes).
Las direcciones Ethernet son asignadas por los fabricantes hardware.
Est&aacute; garantizado que s&oacute;lo una m&aacute;quina en todo el mundo tiene una
determinada direcci&oacute;n Ethernet. Por lo general, dicha direcci&oacute;n est&aacute;
grabada en una ROM en la tarjeta Ethernet de la m&aacute;quina. La m&aacute;quina,
probablemente, no conozca su direcci&oacute;n IP, pero sin duda conoce su
direcci&oacute;n Ethernet. Por esta raz&oacute;n, la petici&oacute;n "¿qui&eacute;n soy?" incluye la
direcci&ograve;n Ethernet. Y habr&aacute; sistemas configurados para responder a
estas peticiones, buscando en una tabla que hace corresponder a cada
direcci&oacute;n Ethernet su direcci&oacute;n IP. Pero, por desgracia, deberemos
configurar y actualizar esta tabla periodicamente. Para este fin se usa el
protocolo de RARP (Reverse Address Resolution Protocol); existe
adem&aacute;s otro protocolo, el BOOTP o protocolo de arranque. En general,
los ordenadores est&aacute;n dise&ntilde;ados de tal manera que muestran su
direcci&oacute;n Ethernet por pantalla, tan pronto como se enciende el mismo.
Y, en la mayor&iacute;a de los casos, disponemos de un comando que muestra
esta informaci&oacute;n del interfaz Ethernet. 
<P>Generalmente, la m&aacute;scara de subred debe especificarse en un
determinado archivo (en los sistemas Unix, el comando <I>ifconfig</I> ,
donde "if" significa interface, se usa para especificar tanto la direcci&oacute;n
Internet como la m&aacute;scara de subred). No obstante, hay previsiones en
los protocolos IP para permitir un broadcast de un ordenador,
preguntando por la m&aacute;scara de red. La subm&aacute;scara de red es un atributo
de la red y, por ello, es el mismo para todos los ordenadores de una
determinada subred. No hay una tabla de subred independiente de la
tabla de las correspondencias Ethernet/Internet, usada para consulta de
direcciones. Idealmente, s&oacute;lo determinados ordenadores contestan
peticiones de la m&aacute;scara de red, pero, en muchas implementaciones
TCP/IP, est&aacute;n dise&ntilde;adas de tal manera que si un ordenador cree conocer
la m&aacute;scara de red debe contestar, y, por tanto, en estas
implementaciones, la mala configuraci&oacute;n de la m&aacute;scara de subred en un
solo ordenador puede causar un mal funcionamiento de la red.
<P>Por regla general, los ficheros de configuraci&oacute;n hacen, a grosso modo,
las siguientes cosas:
<P>
<UL>
<LI>Cargar un driver especial para los dispositivos que sean necesarios 
(esto es bastante usual en los PC's, donde los accesos a red son controlados
por una tarjeta controladora y un <CODE>software</CODE> que no forma parte del sistema
operativo).</LI>
<LI>Habilitar cada interfaz de red (Ethernet, l&iacute;neas serie, etc.).
Normalmente, esto conlleva la especificaci&oacute;n de una direcci&oacute;n Internet
y una m&aacute;scara de red para cada uno, as&iacute; como otras opciones especiales
de cada dispositivo.</LI>
<LI>Establecimiento de la informaci&oacute;n de enrutamiento de la red,
tanto por comandos que establecen rutas, como ejecucando un programa
que las obtiene din&aacute;micamente.</LI>
<LI>Activar el sistema de dominios (usado para buscar nombres y
encontrar la correspondiente direcci&oacute;n Internet -mirar la secci&oacute;n del
sistema de dominio, en la Introducci&oacute;n al TCP/IP-). Los detalles
depender&aacute;n del sistema de dominios usado. En la mayor&iacute;a de los casos, 
s&oacute;lo algunos <CODE>hosts</CODE> deber&aacute;n ejecutar el servidor de nombres de 
dominios. Los otros <CODE>hosts</CODE>, simplemente, necesitan ficheros de 
configuraci&oacute;n, que especifican d&oacute;nde se encuentra el servidor m&aacute;s 
cercano.</LI>
<LI>Establecer otro tipo de informaci&oacute;n necesaria para el sistema
<CODE>software</CODE>, como, por ejemplo, el nombre del propio sistema.</LI>
<LI>Lanzar varios demonios (<CODE>daemons</CODE>). Hay programas que
proveen de servicios de red a otros sistemas de la red, y a los usuarios de
estos sistemas. En el caso de los PC's, que en muchos casos no soportan
el multiproceso, y dichos servicios, se establecen mediante los llamados
"TSR", o mediante los drivers del dispositivo. </LI>
</UL>
<P>
<P>
<H2>5.1 Como enrutar los datagramas</H2>

<P>Si nuestro sistema consiste en una simple Ethernet, o un medio
similar, no ser&aacute; necesario prestar demasiada atenci&oacute;n al enrutamiento.
Pero, para sistemas m&aacute;s complejos, cada una de las m&aacute;quinas necesita
una tabla que contenga el <CODE>gateway</CODE> y el interfaz necesario para cada
posible destino. Vimos un ejemplo simple en una secci&oacute;n anterior, pero
ahora es necesario describir el modo como funciona el enrutamiento,
con un poco m&aacute;s de detalle. En la inmensa mayor&iacute;a de los sistemas, la
tabla de enrutamiento tendr&aacute; un aspecto similar (este ejemplo ha sido
tomado de un sistema con Berkeley Unix, usando el comando <CODE>"netstat
-n -r"</CODE>; algunas columnas que contienen informaci&oacute;n estad&iacute;stica han
sido omitidas):
<P>
<BLOCKQUOTE><CODE>
<PRE>
     Destino            Gateway          Bandera     Interface
    128.6.5.3          128.6.7.1          UHGD         il0
    128.6.5.21         128.6.7.1          UHGD         il0
    127.0.0.1          127.0.0.1          UH           lo0
    128.6.4            128.6.4.61         U            pe0
    128.6.6            128.6.7.26         U            il0
    128.6.7            128.6.7.26         U            il0
    128.6.2            128.6.7.1          UG           il0
    10                 128.6.4.27         UG           pe0
    128.121            128.6.4.27         UG           pe0
    default            128.6.4.27         UG           pe0
</PRE>
</CODE></BLOCKQUOTE>
<P>El sistema del ejemplo est&aacute; conectado a dos Ethernet:
<P>
<BLOCKQUOTE><CODE>
<PRE>
   Controlador    Red      Direccion    Otras Redes
       il0      128.6.7   128.6.7.26     128.6.6
       pe0      128.6.4   128.6.4.61     ninguna
</PRE>
</CODE></BLOCKQUOTE>
<P>La primera columna muestra el nombre de la interface Ethernet; la segunda,
es el n&uacute;mero de red para esa Ethernet; la tercera columna es la direcci&oacute;n
Internet de esa red, y, la &uacute;ltima muestra otras subredes que comparten la
misma red f&iacute;sica.
<P>Estudiemos la tabla de enrutamiento; por el momento, ignoraremos
las tres primeras l&iacute;neas. La mayor parte de la tabla consiste en un
conjunto de entradas describiendo las redes. Para cada red, las otras tres
columnas muestran a d&oacute;nde deben ser enviados los datagramas
destinados a dicha red. Si aparece la bandera "G" en la tercera columna,
los datagramas tienen que enviarse a trav&eacute;s de un <CODE>gateway</CODE>; en caso de
no aparecer, el ordenador est&aacute; directamente conectado a la red en
cuesti&oacute;n. As&iacute; que los datagramas para dichas redes deben enviarse
usando el controlador especificado en la cuarta columna. La bandera
"U", de la tercera columna, s&oacute;lo indica que la ruta especificada por esa
l&iacute;nea est&aacute; activa (generalmente, se asume que estar&aacute; abierta, a no ser
que se produzcan errores tras varios intentos). 
<P>Las tres primera l&iacute;neas muestran "rutas a <CODE>hosts</CODE>", indic&aacute;ndose
con "H" en la tercera columna. Las tablas de enrutamiento,
normalmente, tienen entradas para redes o subredes. Por ejemplo, la
entrada
<P>
<BLOCKQUOTE><CODE>
<PRE>
     128.6.2         128.6.7.1         UG         il0
</PRE>
</CODE></BLOCKQUOTE>
<P>indica que un datagrama para cualquier ordenador de la red 128.6.2 (es
decir, direcciones desde 128.6.2.1hasta 128.6.2.254) debe enviarse al
<CODE>gateway</CODE> 128.6.7.1, para llevarlo a cabo. En algunas ocasiones, se
establecen rutas para un ordenador espec&iacute;fico, en lugar de una red
entera. En este caso, se usa una ruta al <CODE>host</CODE>. En la primera
columna aparece una direcci&oacute;n completa, y la bandera "H" est&aacute; presente
en la columna tres; por ejemplo, la entrada
<P>
<BLOCKQUOTE><CODE>
<PRE>
     128.6.5.21         128.6.7.1         UHGD         il0
</PRE>
</CODE></BLOCKQUOTE>
<P>indica que un datagrama, dirigido en concreto a la direcci&oacute;n 128.6.5.21,
debe ser enviado al <CODE>gateway</CODE> 128.6.7.1. Al igual que en los
enrutamientos a redes, la bandera "G" se usa cuando en el enrutamiento
se ve involucrado un <CODE>gateway</CODE>, y la bandera "D" indica que el
enrutamiento fue a&ntilde;adido din&aacute;micamente, usando un mensaje ICMP de
redirecci&oacute;n desde un <CODE>gateway</CODE> (m&aacute;s adelante daremos m&aacute;s detalles).
<P>El siguiente enrutamiento es especial:
<P>
<BLOCKQUOTE><CODE>
<PRE>
     127.0.0.1         127.0.0.1         UH         lo0
</PRE>
</CODE></BLOCKQUOTE>
<P>donde, 127.0.0.1 es el dispositivo de "lazo cerrado", o <CODE>loopback</CODE>.
Cualquier datagrama enviado a trav&eacute;s de
este dispositivo aparece inmediatamente como entrada. Es muy &uacute;til para
hacer pruebas. Las direcciones de "lazo cerrado" pueden, tambi&eacute;n, ser
usadas para comunicar aplicaciones que est&aacute;n en el propio ordenador.
(¿Por qu&eacute; molestarnos en usar la red para comunicarnos con programas
que se encuentran en la misma
m&aacute;quina?).
<P>Por &uacute;ltimo, hay una ruta por defecto ("default"), como es
<BLOCKQUOTE><CODE>
<PRE>
     default         128.6.4.27    UG         pe0
</PRE>
</CODE></BLOCKQUOTE>
<P>Esta ruta ser&aacute; seguida por aquellos datagramas que no se correspondan
con ninguna de las anteriores. En nuestro ejemplo, se enviar&aacute;n a un
<CODE>gateway</CODE> de direcci&oacute;n 128.6.4.27.
<P>Como &uacute;ltimo ejemplo veamos la tabla de enrutamiento de un sistema
Linux conectado a Internet mediante una linea PPP, usando el comando
"netstat -n -r"; algunas columnas que contienen informaci&oacute;n estad&iacute;stica
han sido omitidas.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    Destino           Gateway        Bandera     Interface
    172.16.1.33       0.0.0.0          UH           ppp0
    128.0.0.1         0.0.0.0          U            l0
    0.0.0.0           172.16.1.33      UG           ppp0     
</PRE>
</CODE></BLOCKQUOTE>
<P>Hay que aclarar que 0.0.0.0 representa al enrutamiento por defecto,
es el valor num&eacute;rico de default. En este ejemplo, al sistema se le ha
asignado la direcci&oacute;n IP 172.16.1.3 de forma din&aacute;mica, de manera que
usa la linea PPP para conectarse con Internet, y 127.0.0.1 es el
dispositivo <CODE>loopback</CODE>. Antes de la conexi&oacute;n PPP solamente estaba activo
el dispositivo de "lazo cerrado", pero una vez establecida la conexi&oacute;n
PPP se activa el interface ppp0 ( 0 indica un identificativo de interface
ppp; es decir, si hubiera otra l&iacute;nea ppp se etiquetar&iacute;a como ppp1, etc), se
usa el sistema del otro lado de la linea como un <CODE>gateway</CODE> por defecto,
como se puede apreciar en la &uacute;ltima linea.     
<P>
<P>En muchos sistemas, los datagramas son enrutados consultando la
direci&oacute;n de destino en una tabla como la que acabamos de describir. Si
la direcci&oacute;n se corresponde con una ruta espec&iacute;fica a un <CODE>host</CODE>,
&eacute;sta ser&aacute; usada; en otro caso, si se corresponde con un enrutamiento a
red, se usar&aacute; &eacute;sta; y, si nada de lo anterior acontece, se usar&aacute; el
enrutamiento por defecto. En caso de no existir uno por defecto,
aparecer&iacute;a un mensaje de tipo "red inalcanzable" ("network is
unreachable").
<P>En las siguientes secciones describiremos varias maneras de
configurar estas tablas de enrutamiento. Generalmente, la operaci&oacute;n de
enviar datagramas no depende del m&eacute;todo usado en la configuraci&oacute;n de
estas tablas. Cuando un datagrama va a ser enviado, su destino es
consultado en la tabla. Los distintos m&eacute;todos de enrutamiento son
simplemente, m&aacute;s o menos, una serie de sofisticadas formas de
configurar y mantener las tablas.
<P>
<P>
<H2>5.2 Rutas fijas</H2>

<P>
<P>La forma m&aacute;s f&aacute;cil de configurar el enrutamiento es usar comandos
que lo fijan. Nuestros archivos de
inicializaci&oacute;n contienen comandos que configuran el enrutamiento. Si es
necesario alg&uacute;n cambio, deber&aacute;
hacerse, normalmente, usando comandos que a&ntilde;aden y borran entradas
de la tabla de enrutamiento (cuando se realice un cambio, no debemos
olvidar actualizar el fichero de inicializaci&oacute;n tambi&eacute;n). Este m&eacute;todo es
pr&aacute;ctico para redes relativamente peque&ntilde;as, especialmente cuando los
cambios no son muy frecuentes.
<P>Muchos ordenadores configuran autom&aacute;ticamente algunas entradas de
enrutamiento por nosotros. Unix a&ntilde;ade una entrada para las redes a las
que estamos directamente conectados. Por ejemplo, un fichero de
inicializaci&oacute;n podr&iacute;a ser
<P>
<BLOCKQUOTE><CODE>
<PRE>
   ifconfig     ie0        128.6.4.4       netmask       255.255.255.0
   ifconfig     ie1        128.6.5.35      netmask       255.255.255.0
</PRE>
</CODE></BLOCKQUOTE>
<P>Este especifica que hay dos interfaces de red y sus direcciones en ellas. 
El sistema crea autom&aacute;ticamente estas entradas en la tabla de enrutamiento
<P>
<BLOCKQUOTE><CODE>
<PRE>
   128.6.4      128.6.4.4           U         ie0
   128.6.5      128.6.5.35          U         ie1
</PRE>
</CODE></BLOCKQUOTE>
<P>y, en &eacute;sta, se especifica que los datagramas para las redes locales 128.6.4
y 128.6.5 deben ser enviados a las corespondientes interfaces.
<P>Adem&aacute;s de &eacute;stos, el fichero de inicializaci&oacute;n podr&iacute;a contener comandos para 
definir rutas a cualquier otra red a la que queramos acceder. Por ejemplo,
<P>
<BLOCKQUOTE><CODE>
<PRE>
   route  add      128.6.2.0       128.6.4.1            1
   route  add      128.6.6.0       128.6.5.35           0
</PRE>
</CODE></BLOCKQUOTE>
<P>Estos comandos determinan que para alcanzar la red 128.6.2 debemos
usar el <CODE>gateway</CODE> de direcci&oacute;n 128.6.5.1, y esa red 128.6.6 es, realmente,
un n&uacute;mero de red adicional para una red f&iacute;sica conectada al
interface 128.6.5.35. Otro tipo de <CODE>software</CODE> puede usar comandos
distintos a estos casos. Unix se diferencia de ellos por el uso de una
m&eacute;trica, que es el n&uacute;mero final del comando. La m&eacute;trica indica cu&aacute;ntos
<CODE>gateways</CODE> tiene que atravesar un datagrama para alcanzar su destino.
Rutas de m&eacute;trica 1 &oacute; m&aacute;s indican que hay en el camino s&oacute;lo un <CODE>gateway</CODE>
hasta el destino. Rutas de m&eacute;trica 0 indican que no hay ning&uacute;n <CODE>gateway</CODE>
implicado -es un n&uacute;mero de red adicional para la red local-.
<P>En &uacute;ltimo lugar, podemos definir un enrutamiento por defecto, usado
cuando el destino no est&aacute; listado expl&iacute;citamente. Normalmente, se suele 
acompa&ntilde;ar de la direcci&oacute;n de un <CODE>gateway</CODE> que tiene suficiente
informaci&oacute;n como para manejar todos los posibles destinos.
<P>Si nuestra red s&oacute;lo dispone de un <CODE>gateway</CODE>, entonces s&oacute;lo
necesitaremos una sola entrada por defecto. En este caso, no deberemos
preocuparnos m&aacute;s de la configuraci&oacute;n del enrutamiento de los
<CODE>hosts</CODE> (el <CODE>gateway</CODE>, en s&iacute;, necesitar&aacute; m&aacute;s atenci&oacute;n, como
veremos). Las siguientes secciones nos ayudar&aacute;n para configurar redes
donde hay varios <CODE>gateways</CODE>.
<P>
<P>
<H2>5.3 Reconducir el enrutamiento</H2>

<P> 
La mayor&iacute;a de los expertos recomiendan dejar las decisiones de
enrutamiento a los <CODE>gateways</CODE>. Por tanto, probablemente, ser&aacute; una
mala idea tener largas tablas est&aacute;ticas de enrutamiento en cada 
ordenador. El problema est&aacute; en que cuando algo cambia en la red tenemos 
que actualizar las tablas en demasiados ordenadores. Si el cambio ocurre
debido a que cae una l&iacute;nea, el servicio no se restablecer&aacute; hasta que
alguien se de cuenta del problema y cambie todas las tablas de
enrutamiento.
<P>La manera m&aacute;s f&aacute;cil de tener actualizado el enrutamiento es depender
s&oacute;lo de un &uacute;nico <CODE>gateway</CODE> y actualizar su tabla de enrutamiento. Este
<CODE>gateway</CODE> debe fijarse como <CODE>gateway</CODE> por defecto. (En Unix esto
significa usar un comando como "route add default 128.6.4.27 1", donde
128.6.4.27 es la direcci&oacute;n del <CODE>gateway</CODE>). Como describimos
anteriormente, el sistema enviar&aacute; todos aquellos datagramas a dicho
<CODE>gateway</CODE> cuando no haya una ruta mejor. En principio, parece que esta
estrategia no es demasiado buena cuando poseemos m&aacute;s de un <CODE>gateway</CODE>;
m&aacute;xime, cuando todo lo que tenemos es s&oacute;lo la entrada por defecto.
¿C&oacute;mo usaremos los otros <CODE>gateways</CODE> en los casos en los que &eacute;stos sean
m&aacute;s recomendables? La respuesta es que los datagramas
correspondientes ser&aacute;n redirigidos a estos <CODE>gateways</CODE> en estos casos. Un
"redireccionamiento" es una clase espec&iacute;fica de mensaje ICMP (Internet
Control Message Protocol), que contiene informaci&oacute;n del tipo "En el
futuro, para llegar a la direcci&oacute;n XXXXX, intenta usar YYYYY en
lugar de m&iacute;". Las implementaciones que cumplen completamente los
protocolos TCP/IP usan estas t&eacute;cnicas de redireccionamiento para a&ntilde;adir
entradas a las tablas de enrutamiento. Supongamos que una tabla
inicialmente es como sigue:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    Destino        Gateway        Bandera        Interface   
+------------------------------------------------------------+
|  127.0.0.1   |  127.0.0.1   |       UH      |      lo0     |
+--------------+--------------+---------------+--------------+
|  128.6.4     |  128.6.4.61  |       U       |      pe0     |
+--------------+--------------+---------------+--------------+
|  default     |  128.6.4.27  |       UG      |      pe0     |
+------------------------------------------------------------+
</PRE>
</CODE></BLOCKQUOTE>
<P>donde hay una entrada para la red local 128.6.4, y una entrada por
defecto del <CODE>gateway</CODE> 128.6.4.27. Supongamos que hay tambi&eacute;n un
<CODE>gateway</CODE> 128.6.4.30, que es el mejor camino para acceder a la red
128.6.7. ¿C&oacute;mo podemos llegar a usar este camino? Supongamos que
tenemos unos datagramas para enviar a 128.6.7.23. El primer datagrama
llegar&aacute; al <CODE>gateway</CODE> por defecto, puesto que es el &uacute;nico que aparece en la
tabla de enrutamiento, y el <CODE>gateway</CODE> se dar&aacute; cuenta de que el mejor
camino debe pasar por 128.6.4.30 (Hay distintos m&eacute;todos para que un
<CODE>gateway</CODE> determine que debe usarse otro para un mejor enrutamiento).
Por tanto, 128.6.4.27 contestar&aacute; con un mensaje de redireccionamiento
especificando que los datagramas para 128.6.7.23 deben enviarse a
trav&eacute;s del <CODE>gateway</CODE> 128.6.4.30. El <CODE>software</CODE> TCP/IP a&ntilde;adir&aacute; una 
entrada a la tabla de enrutamiento
<P>
<BLOCKQUOTE><CODE>
<PRE>
     128.6.7.23   128.6.4.30   UDHG   pe0
</PRE>
</CODE></BLOCKQUOTE>
<P>De esta manera, los restantes datagramas al 128.6.7.23 se enviar&aacute;n
directamente al <CODE>gateway</CODE> apropiado.
<P>Esta estrategia ser&iacute;a perfecta si no fuera por los siguientes tres
problemas:
<P>
<UL>
<LI>Necesita que cada ordenador contenga la direcci&oacute;n de un <CODE>gateway</CODE>
por defecto en los ficheros de configuraci&oacute;n.</LI>
<LI>En caso de que un <CODE>gateway</CODE> falle, las entradas de las tablas de
enrutamiento que usan dicho <CODE>gateway</CODE> no se eliminan.</LI>
<LI>Si la red usa subredes y la implementaci&oacute;n TCP/IP usada no las
maneja, esta estrategia no podr&aacute; emplearse.</LI>
</UL>
<P>El alcance del problema depende del tipo de red de la que
disponemos. Para redes peque&ntilde;as, apenas supondr&aacute; un problema
cambiar los ficheros de configuraci&oacute;n de algunas m&aacute;quinas. Sin
embargo, para algunas organizaciones este trabajo es dif&iacute;cil de llevar a
cabo. Si, por ejemplo, la topolog&iacute;a de la red cambia y un <CODE>gateway</CODE> es
eliminado, cualquier sistema que tenga dicho <CODE>gateway</CODE> por defecto
deber&aacute; ser ajustado. Este problema ser&aacute; especialmente grave si el
personal encargado del mantenimiento de la red es distinto del
encargado de mantener a los sistemas individualmewnte. La soluci&oacute;n
m&aacute;s simple consiste en asegurarnos de que la direcci&oacute;n por defecto
nunca cambiar&aacute;. Por ejemplo, podr&iacute;amos adoptar el convenio de que la
direcci&oacute;n 1 de cada subred se corresponde con el <CODE>gateway</CODE> por defecto
de cada subred; as&iacute;, en la subred 128.6.7, el <CODE>gateway</CODE> por defecto ser&iacute;a
siempre el 128.6.7.1. Si dicho <CODE>gateway</CODE> es eliminado, habr&aacute; que
asignarle dicha direcci&oacute;n a alg&uacute;n otro <CODE>gateway</CODE> (siempre tendr&aacute; que
haber, al menos, un <CODE>gateway</CODE>, puesto que si no es as&iacute; estaremos
completamente incomunicados). 
<P>Hasta ahora hemos visto c&oacute;mo a&ntilde;adir rutas, pero no c&oacute;mo deshacernos
de ellas. ¿Qu&eacute; ocurre si un <CODE>gateway</CODE> no funciona correctamente?.
Nuestro deseo ser&iacute;a que se recondujera a un <CODE>gateway</CODE> operativo, pero
desgraciadamente, un <CODE>gateway</CODE> en mal funcionamiento no tendr&aacute; en
general esta capacidad de redireccionamiento. La soluci&oacute;n m&aacute;s obvia es
usar <CODE>gateways</CODE> fiables. El redireccionamiento puede usarse para
controlar distintos tipos de fallos.
<P>La mejor estrategia para controlar <CODE>gateways</CODE> averiados es que nuestra
implementaci&oacute;n TCP/IP detecte las rutas que no tienen &eacute;xito. TCP
mantiene varios contadores que permiten al <CODE>software</CODE> detectar cu&aacute;ndo
una conexi&oacute;n se ha roto. Cuando esto ocurre, se puede marcar esta ruta
como fallida y volver al <CODE>gateway</CODE> por defecto. Una soluci&oacute;n similar
puede usarse para manejar fallos en el <CODE>gateway</CODE> por defecto. Si
configuramos dos <CODE>gateways</CODE> por defecto, entonces el <CODE>software</CODE> deber&aacute; ser
capaz de cambiar el <CODE>gateway</CODE> cuando las conexiones en uno de ellos
empiecen a fallar. Sin embargo, algunas implementaciones TCP/IP no
pueden marcar rutas como fallidas y empezar a usar otras. En particular,
Berkeley 4.2 Unix no lo hace; pero Berkeley 4.3 Unix s&iacute;, lo que
empieza a hacerse cada vez m&aacute;s com&uacute;n. Hasta implementaciones de
Unix para PC como Linux ya incorporan esta posibilidad (Linux en
concreto puede controlar hasta cuatro <CODE>gateways</CODE> por defecto). 
<P>
<P>
<H2>5.4 Otros m&eacute;todos para que los hosts encuentren rutas</H2>

<P>En tanto en cuanto las implementaciones TCP/IP manejan ca&iacute;das de
las conexiones adecuadamente, estableciendo una o m&aacute;s rutas por
defecto en el fichero de configuraciones, se produce probablemente la
foma m&aacute;s simple de controlar el enrutamiento. No obstante, hay otras
dos t&eacute;cnicas de enrutamiento dignas de consideraci&oacute;n para algunos
casos especiales:
<P>
<UL>
<LI>espiar el protocolo de enrutamiento,</LI>
<LI>usar un <CODE>proxy</CODE> ARP. </LI>
</UL>
<P>
<P>
<H3>Espiar el enrutamiento.</H3>

<P>Los <CODE>gateways</CODE>, por regla general, tienen un protocolo especial que usan
entre ellos. Hay que aclarar que el redireccionamiento no puede ser
usado por los <CODE>gateways</CODE>, ya que &eacute;ste es simplemente el mecanismo por el
cu&aacute;l ellos informan a simples <CODE>hosts</CODE> que tienen que usar otro
<CODE>gateway</CODE>. Los <CODE>gateways</CODE> deben tener una visi&oacute;n completa de la red y un
m&eacute;todo para para calcular la ruta &oacute;ptima a cada subred. Generalmente,
los <CODE>gateways</CODE> mantienen esta visi&oacute;n mediante el intercambio de
informaci&oacute;n entre ellos. Hay varios protocolos distintos de enrutamiento
para este prop&oacute;sito. Una alternativa para que un ordenador siga la pista
a los <CODE>gateways</CODE> esescuchar los mensajes que se intercambian entre ellos.
Hay <CODE>software</CODE> capaz de hacer esto para la mayor&iacute;a de los protocolos.
Cuando ejecutamos este <CODE>software</CODE>, el ordenador mantendr&aacute; una visi&oacute;n
completa de la red, al igual que los <CODE>gateways</CODE>. Este <CODE>software</CODE>
normalmente est&aacute; dise&ntilde;ado para mantener din&aacute;micamente las tablas de
enrutamiento del ordenador, as&iacute; que los datagramas se enviar&aacute;n siempre
al <CODE>gateway</CODE> m&aacute;s adecuado. De hecho, el enrutamiento realizado es
equivalente a ejecutar los comandos Unix  "route add" y "route delete" a
medida que la topolog&iacute;a cambia. El resultado suele ser una completa
tabla de enrutamiento, en lugar de una con unas rutas por defecto. (Este
enfoque asume que los <CODE>gateways</CODE> mantienen entre ellos una tabla
completa.
Algunas veces los <CODE>gateways</CODE> tienen constancia de todas nuestras redes,
pero usan una ruta por defecto para las redes ajenas al campus, etc.).
<P>Ejecutando el <CODE>software</CODE> de enrutamiento en cada <CODE>host</CODE>
resolveremos de alguna manera el problema de enrutamiento, pero hay
algunas razones por las que normalmente no es recomendable,
reserv&aacute;ndola como &uacute;ltima alternativa. El problema m&aacute;s serio incorpora
numerosas opciones de configuraci&oacute;n, que deben mantenerse en cada
ordenador. Adem&aacute;s, los actuales <CODE>gateways</CODE> suelen a&ntilde;adir opciones cada
vez m&aacute;s complejas. Por tanto, no es deseable extender el uso de este
<CODE>software</CODE> en todos los <CODE>hosts</CODE>.
<P>Hay otro problema m&aacute;s espec&iacute;fico referido a los ordenadores sin
discos. Como es natural, un ordenador sin discos depende de la red y de
los servidores de ficheros para cargar los programas y hacer <CODE>swapping</CODE>.
No es recomendable que estos ordenadores escuchen las emisiones de la
red. Por ejemplo, cada <CODE>gateway</CODE> de la red debe emitir sus tablas de
enrutamiento cada 30 segundos. El problema es que el <CODE>software</CODE> que
escucha estas emisiones debe ser cargado a trav&eacute;s de la red. En un
ordenador ocupado, los programas que no son usados durante algunos
segundos deben guardarse haciendo swapping o paginaci&oacute;n. Cuando se
activan de nuevo, han de recuperarse. Cuando una emisi&oacute;n de un
<CODE>gateway</CODE> es enviada en la red, cada ordenador activa su <CODE>software</CODE> de red
para procesar dicha emisi&oacute;n, lo cual significa que todos ellos intentan
hacer una recuperaci&oacute;n al mismo tiempo y, por tanto, es probable que se
produzca una sobrecarga temporal de la red.
<P>
<P>
<H3>Proxy ARP.</H3>

<P>Los <CODE>proxy</CODE> ARP son otra t&eacute;cnica para permitir a los <CODE>gateways</CODE> tomar
todas las decisiones de enrutamiento. Son aplicables a aquellas redes
que usan ARP (Address Resolution Protocol), o una t&eacute;cnica similar para
corresponder las direcciones Internet con direcciones de redes
espec&iacute;ficas, como las direcciones Ethernet. Para facilitar la explicaci&oacute;n,
vamos a asumir redes Ethernet. Los cambios necesarios para otros tipos
de redes consistir&aacute;n en poner la correspondiente direcci&oacute;n de red, en
lugar de "direcci&oacute;n Ethernet", y protocolo an&aacute;logo a ARP para dicha
red.
<P>En muchos aspectos, los <CODE>proxy</CODE> ARP son semejantes al uso de una ruta
por defecto y redireccionamiento, y la mayor diferencia radica en que
tienen distintos mecanismos para comunicar rutas a los <CODE>hosts</CODE>.
Con el redireccionamiento se usa una tabla completa de enrutamiento,
de forma que en cualquier momento un <CODE>host</CODE> sabe a cual
<CODE>gateway</CODE> debe enviar los datagramas. En cambio, los <CODE>proxy</CODE> ARP
prescinden de las tablas de enrutamiento y hacen todo el trabajo a nivel
de direcciones Ethernet. Los <CODE>proxy</CODE> ARP pueden usarse para todos los
destinos, tanto para aquellos que est&aacute;n en nuestra red como para algunas
combinaciones de destinos. El caso m&aacute;s sencillo de explicar es el de
todas las direcciones; para ello ordenamos al ordenador que simule que
todos los ordenadores del mundo est&aacute;n conectados directamente a
nuestra Ethernet local. En Unix, esto se hace usando el comando
<P>
<BLOCKQUOTE><CODE>
<PRE>
     route add default 128.6.4.2 0
</PRE>
</CODE></BLOCKQUOTE>
<P>donde, 128.6.4.2 es la direcci&oacute;n IP de nuestro <CODE>host</CODE>. Como ya
hemos visto, la m&eacute;trica 0 provoca que todo aquello que se identifique
con esta ruta se enviar&aacute; directamente a la red local Ethernet.
Alternativamente, otros sistemas nos permiten conseguir el mismo
efecto fijando una m&aacute;scara de red de ceros, en cuyo caso
debemos asegurarnos de que no ser&aacute; alterada por un mensaje ICMP de
m&aacute;scara de subred debido a que un sistema conoce la verdadera m&aacute;scara
de red.
<P>Cuando un datagrama va a ser enviado a un destino dentro de la
Ethernet local, el ordenador necesita conocer la direcci&oacute;n Ethernet del
destino, y para ello, generalmente, se usa la llamada tabla ARP, que
contiene las correspondencias entre las direcciones Internet y las
direcciones Ethernet. Veamos un ejemplo t&iacute;pico de tabla ARP (en la
mayor&iacute;a de los sistemas se visualiza usando el comando "<I>arp -a</I>".):
<P>
<BLOCKQUOTE><CODE>
<PRE>
 FOKKER.RUTGERS.EDU (128.6.5.16) at 8:0:20:0:8:22 temporary
 CROSBY.RUTGERS.EDU (128.6.5.48) at 2:60:8c:49:50:63 temporary
 CAIP.RUTGERS.EDU (128.6.4.16) at 8:0:8b:0:1:6f temporary
 DUDE.RUTGERS.EDU (128.6.20.16) at 2:7:1:0:eb:cd temporary
 W2ONS.MIT.EDU (128.125.1.1) at 2:7:1:0:eb:cd temporary
 OBERON.USC.EDU (128.125.1.1) at 2:7:1:2:18:ee temporary
 gatech.edu (128.61.1.1) at 2:7:1:0:eb:cd temporary
 DARTAGNAN.RUTGERS.EDU (128.6.5.65) at 8:0:20:0:15:a9 temporary
</PRE>
</CODE></BLOCKQUOTE>
<P>Como dijimos anteriormente, simplemente es una lista de direcciones
IP y su correspondiente direcci&oacute;n Ethernet. El t&eacute;rmino "temporary"
indica que la entrada fue a&ntilde;adida din&aacute;micamente usando ARP, en lugar
de ser puesta manualmente.
<P>Si hay una entrada para una direcci&oacute;n determinada en la tabla ARP,
los datagramas ser&aacute;n puestos en la Ethernet con su correspondiente
direcci&oacute;n Ethernet. Si esto no ocurre, se enviar&aacute; una "petici&oacute;n ARP",
solicitando que el <CODE>host</CODE> destino se identifique. La petici&oacute;n es, en
efecto, una pregunta: "¿Puede decirme el <CODE>host</CODE> con
direcci&oacute;n Internet 128.6.4.194 cu&aacute;l es su direcci&oacute;n Ethernet?". Cuando
llega una respuesta, esta se a&ntilde;ade a la tabla ARP y los futuros
datagramas con ese destino ser&aacute;n enviados directamente.
<P>Este mecanismo fue dise&ntilde;ado inicialmente s&oacute;lo para <CODE>hosts</CODE>
que estuvieran directamente conectados a una simple Ethernet. Si
necesitamos comunicarnos con un <CODE>host</CODE> que se encuentra en
otra Ethernet, se supone que la tabla de enrutamiento lo dirigir&aacute; a un
<CODE>gateway</CODE>. Dicho <CODE>gateway</CODE>, como es obvio, deber&aacute; tener una interface
en nuestra Ethernet. El <CODE>host</CODE> deber&aacute; averiguar la direcci&oacute;n de
dicho <CODE>gateway</CODE> usando ARP. Este procedimiento es m&aacute;s &uacute;til que hacer
que el ARP trabaje directamente con un ordenador en una red lejana,
puesto que no est&aacute;n en la misma Ethernet, no disponemos de una
direcci&oacute;n Ethernet para poder enviar los datagramas y, al enviar
"peticiones ARP" por ellas, nadie nos responder&aacute;.
<P>Los <CODE>proxies</CODE> ARP se basan en la idea de que los gateways act&uacute;en como
proxies de <CODE>hosts</CODE> lejanos. Supongamos que tenemos un
<CODE>host</CODE> en la red 128.6.5, con direcciones (es el ordenador A en
diagrama siguiente), que va a enviar un datagrama al <CODE>host</CODE>
128.6.5.194 (el ordenador C) que se encuentra en una Ethernet distinta
(subred 128.6.4). Hay un <CODE>gateway</CODE> que conecta ambas subredes, de
direcciones 128.6.5.1 (<CODE>gateway</CODE> R)
<P>
<BLOCKQUOTE><CODE>
<PRE>
           red 1                      red 2
          128.6.5                    128.6.4
   ============================  ==================
     |              |        |    |      |    |
  ___|______   _____|____  __|____|__  __|____|____
  128.6.5.2    128.6.5.3   128.6.5.1   128.6.4.194
                           128.6.4.1
 ___________  ___________  __________  ____________
 ordenador A  ordenador B   gateway R   ordenador C
</PRE>
</CODE></BLOCKQUOTE>
<P>Ahora supongamos que el ordenador A env&iacute;a una petici&oacute;n ARP al
ordenador C, pero C no es capaz de responder por s&iacute; mismo. Al estar en
redes distintas, C nunca ver&aacute; la petici&oacute;n ARP; sin embargo, el <CODE>gateway</CODE>
actuar&aacute; en su lugar. En efecto, nuestro ordenador pregunta: "¿Puede
decirme el <CODE>host</CODE> con direcci&oacute;n de Internet 128.6.4.194 cu&aacute;l es
su direcci&oacute;n Ethernet?", y el <CODE>gateway</CODE> contesta: "Yo soy 128.6.4.194 es
2:7:1:0:eb:cd", donde 2:7:1:0:eb:cd es la direcci&oacute;n Ethernet del <CODE>gateway</CODE>.
Este peque&ntilde;o truco funciona correctamente y hace pensar a nuestro
<CODE>host</CODE> que 128.6.4.194 est&aacute; conectado a la Ethernet local con
direcci&oacute;n 2:7:1:0:eb:cd, pero, por supuesto, no es cierto. Cada vez que
enviamos un datagrama a 128.6.4.194, nuestro <CODE>host</CODE> lo env&iacute;a a
la direcci&oacute;n Ethernet especificada y, puesto que es la direcci&oacute;n del
<CODE>gateway</CODE> R, llega hasta dicho <CODE>gateway</CODE>. Y es entonces cuando se env&iacute;a a
su destino.
<P>Veamos que esto tiene el mismo efecto que tener una entrada en la
tabla de enrutamiento diciendo que la ruta de 128.6.4.194 al <CODE>gateway</CODE>
128.6.5.1 es:
<P>
<BLOCKQUOTE><CODE>
<PRE>
     128.6.4.194   128.6.5.1   UGH   pe0
</PRE>
</CODE></BLOCKQUOTE>
<P>Con la excepci&oacute;n de que, en lugar de tener el enrutamiento hecho a
nivel de tabla de enrutamiento, se hace a nivel de tabla ARP.
<P>Generalmente, es mejor usar tablas de enrutamiento, pero hay algunos
casos en los que tiene sentido los usar proxyes ARP:
<UL>
<LI>cuando tenemos un <CODE>host</CODE> que no trabaja con subredes;</LI>
<LI>cuando tenemos un <CODE>host</CODE> que no responde adecuadamente
al redireccionamiento;</LI>
<LI>cuando no queremos elegir un <CODE>gateway</CODE> determinado por defecto;</LI>
<LI>cuando el <CODE>software</CODE> no es capaz de recuperarse de un enrutamiento fallido.</LI>
</UL>
<P>La t&eacute;cnica fue dise&ntilde;ada originariamente para trabajar con
<CODE>hosts</CODE> que no soportan subredes. Supongamos que
tenemos una red dividida en subredes. Por ejemplo, hemos decidido
dividir la red 128.6 en subredes, obteniendo las subredes 128.6.4 y
128.6.5. Supongamos tambi&eacute;n que tenemos un <CODE>host</CODE> que no
trabaja con subredes y, por tanto, creer&aacute; que 128.6 es tan s&oacute;lo una red.
Esto &uacute;ltimo significa que ser&aacute; dif&iacute;cil establecer las
entradas para la tabla de enrutamiento para la configuraci&oacute;n vista. No
podemos decirle nada sobre la existencia del <CODE>gateway</CODE>, de forma
expl&iacute;cita, usando "route add 128.6.4.0  128.6.5.1  1", puesto que, al
considerar que toda la 128.6 es una simple red, no entender&aacute; que
intentamos enviarlo a una subred. En su lugar, interpretar&aacute; este
comando como un intento de configurar una ruta a un <CODE>host</CODE> de
direcci&oacute;n 128.6.4.0. La &uacute;nica manera que podr&iacute;a hacerlo funcionar ser&iacute;a
establecer rutas expl&iacute;citas a los <CODE>host</CODE>, para cada <CODE>host</CODE>
individual sobre cada subred. Tampoco podr&iacute;amos depender del
<CODE>gateway</CODE> por defecto y redireccionar. Supongamos que establecemos
"route add default 128.6.5.1  1", en el que fijamos el <CODE>gateway</CODE> 128.6.5.1
por defecto; esto no podr&iacute;a funcionar para enviar datagramas a otras
subredes. En el caso de que el <CODE>host</CODE> 128.6.5.2 quiera enviar
un datagrama al 128.6.4.194, puesto que el destino es parte de 128.6, el
ordenador lo considerar&aacute; en la misma red y no se preocupar&aacute; por
buscarle un <CODE>gateway</CODE> adecuado.
<P>Los <CODE>proxy</CODE> ARP resuelven el problema haciendo ver el mundo de un
modo simplista que espera encontrarse. Puesto que el <CODE>host</CODE>
piensa que todas las restantes subredes forman parte de su propia red,
simplemente usar&aacute; una petici&oacute;n ARP para comunicarse con ellas,
esperando recibir una direcci&oacute;n Ethernet que pueda usarse
para establecer comunicaciones directas. Si el <CODE>gateway</CODE> ejecuta un <CODE>proxy</CODE>
ARP, responder&aacute; con la direcci&oacute;n Ethernet del <CODE>gateway</CODE>. Por tanto, los
datagramas ser&aacute;n enviados al <CODE>gateway</CODE> y todo funcionar&aacute; correctamente.
<P>Como se puede observar, no se necesita una configuraci&ograve;n espec&iacute;fica
para usar una <CODE>proxy</CODE> ARP con <CODE>hosts</CODE> que no trabajan con
subredes. Lo que necesitamos es que todos nuestros <CODE>gateways</CODE> ARP
tengan implementado un <CODE>proxy</CODE> ARP. Para poder usarlos, deberemos
especificar la configuraci&oacute;n de la tabla de enrutamiento. Por
defecto, las implementaciones TCP/IP esperar&aacute;n encontrar un <CODE>gateway</CODE>
para cualquier destino que est&eacute; en otra red y, para hacerlo, deberemos
expl&iacute;citamente instalar una ruta de m&eacute;trica 0, como por ejemplo "route
add default 128.6.5.2  0", o poner la m&aacute;scara de subred a ceros.
<P>Es obvio que los <CODE>proxy</CODE> ARP son adecuados cuando los <CODE>hosts</CODE>
no son capaces de entender subredes. Generalmente, las
implementaciones TCP/IP son capaces de manejar mensajes de
redirecci&oacute;n ICMP correctamente, y, por tanto, normalmente lo que se
har&aacute; es configurar la ruta por defecto a alg&uacute;n <CODE>gateway</CODE>. Sin embargo, en
caso de contar con una implementaci&oacute;n que no reconoce los
redireccionamientos, o no puede configurarse un
<CODE>gateway</CODE> por defecto, podemos usar <CODE>proxy</CODE> ARP.
<P>A veces se usa <CODE>proxy</CODE> ARP por conveniencia. El problema de las tablas
de enrutamiento es que hay que configurarlas. La configuraci&oacute;n m&aacute;s
simple es fijar una ruta por defecto; pero, incluso en este caso, hay que
incluir un comando equivalente al de Unix "<I>route add default...</I>". En el
caso de que hubiese cambios en las direcciones de los <CODE>gateways</CODE>,
deber&iacute;amos modificar este comando en todos los <CODE>hosts</CODE>. Si
configuramos una ruta por defecto que depende de <CODE>proxy</CODE> ARP (con
m&eacute;trica 0), no deberemos cambiar los ficheros de configuraci&oacute;n cuando
los <CODE>gateways</CODE> cambian. Con los <CODE>proxy</CODE> ARP, no hace falta poner ninguna
direcci&oacute;n de un <CODE>gateway</CODE>. Cualquier <CODE>gateway</CODE> puede responder a una
petici&oacute;n ARP, no importa cu&aacute;l sea su direcci&oacute;n.
<P>Para evitarnos tener que configurar los sistemas, algunas
implementaciones TCP/IP usan ARP por defecto, cuando no tienen otra
ruta. Las implementaciones m&aacute;s flexibles nos permiten usar estrategias
mixtas. As&iacute;, si tenemos que especificar una ruta para cada red en
particular, o una ruta por defecto, se usar&aacute; esa ruta, pero si no hay rutas
para un destino lo tratar&aacute; como si fuese local y usar&aacute; una petici&oacute;n ARP.
En tanto en cuanto sus <CODE>gateways</CODE> soporten <CODE>proxy</CODE> ARP, esto permitir&aacute;
que los <CODE>hosts</CODE> alcancen cualquier destino sin necesitar
ninguna tabla de enrutamiento.
<P>Finalmente, podr&iacute;amos elegir usar una <CODE>proxy</CODE> ARP porque se
recuperan mejor de los fallos. La elecci&oacute;n depender&aacute; en gran medida de
la implementaci&oacute;n.
<P>En aquellas situaciones en las que hay varios <CODE>gateways</CODE> en una red,
veamos c&oacute;mo los <CODE>proxy</CODE> ARP permiten elegir el mejor. Como hemos
mencionado anteriormente, nuestro computador simplemente env&iacute;a un
mensaje preguntando por la direcci&oacute;n Ethernet del destino. Suponemos
que los <CODE>gateways</CODE> est&aacute;n configurados para responder a estos mensajes. Si
hay m&aacute;s de un <CODE>gateway</CODE>, ser&aacute; necesaria una coordinaci&oacute;n entre ellos.
Conceptualmente, los <CODE>gateways</CODE> tendr&aacute;n una visi&oacute;n completa de la
topolog&iacute;a de la red. Por consiguiente, ser&aacute;n capaces de determinar la
mejor ruta desde nuestro <CODE>host</CODE> a cualquier destino. Si hay una
coordinaci&oacute;n entre los <CODE>gateways</CODE>, ser&aacute; posible que el mejor <CODE>gateway</CODE>
pueda responder a la petici&oacute;n ARP. En la pr&aacute;ctica no es siempre posible,
por ello se dise&ntilde;an algoritmos para evitar rutas malas. Veamos por
ejemplo la siguiente situaci&oacute;n:
<P>
<BLOCKQUOTE><CODE>
<PRE>
         1              2              3
    ------------ A ------------ B -----------
</PRE>
</CODE></BLOCKQUOTE>
<P>donde, 1, 2 y 3 son redes; y A y B <CODE>gateways</CODE> conectando 2 con 1 &oacute; con 3.
Si un <CODE>host</CODE> de la red 2 quiere comunicarse con otro de la red 1
es bastante f&aacute;cil para el <CODE>gateway</CODE> A decidirse a contestar, y el <CODE>gateway</CODE> B
no lo har&aacute;. Veamos c&oacute;mo: si el <CODE>gateway</CODE> B acepta un datagrama para la
red 1, tendr&aacute; que remitirlo al <CODE>gateway</CODE> A para que lo entregue. Esto
significar&iacute;a que deber&iacute;a tomar un datagrama de la red 2 y enviarlo de
vuelta a la red 2. Es muy f&aacute;cil manejar las rutas que se dan en este tipo
de redes. Es mucho m&aacute;s dif&iacute;cil de controlar en una situaci&oacute;n como la
siguiente:
<P>
<BLOCKQUOTE><CODE>
<PRE>
               1
        ---------------
          A        B
          |        | 4
          |        |
        3 |        C
          |        |
          |        | 5
          D        E
        ---------------
               2
</PRE>
</CODE></BLOCKQUOTE>
<P>Supongamos que un ordenador en la red 1 quiere enviar un datagrama
a otro de la red 2. La ruta v&iacute;a A y D es probablemente la mejor, porque
s&oacute;lo hay una red (3) entre ambas. Tambi&eacute;n es posible la ruta v&iacute;a B, C y
E, pero este camino probablemente es algo m&aacute;s lento. Ahora
supongamos que el ordenador de la red 1 env&iacute;a peticiones ARP para
alcanzar 2. Seguramente A y B responder&aacute;n a dicha petici&oacute;n. B no es
tan buena como A, pero no hay tanta diferencia como en el caso
anterior. B no devolver&aacute; el datagrama a 1. Adem&aacute;s, no es
posible determinar qu&eacute; camino es mejor sin realizar un costoso an&aacute;lisis
global de la red. En la pr&aacute;ctica no disponemos de tanta cantidad de
tiempo para responder a una petici&oacute;n ARP.
<P>
<H3>Establecer nuevas rutas tras fallos.</H3>

<P>En principio, IP es capaz de controlar l&iacute;neas con fallos y ca&iacute;das de
<CODE>gateways</CODE>. Hay varios mecanismos para rectificar las tablas de
enrutamiento y las tablas de ARP y mantenerlas actualizadas. Pero, por
desgracia, muchas de las implementaciones TCP/IP no implementan
todos estos mecanismos, por lo que deberemos estudiar detalladamente
la documentaci&oacute;n de nuestra implementaci&oacute;n y, teniendo en cuenta los
fallos m&aacute;s frecuentes, deberemos definir una estrategia para asegurar la
seguridad de nuestra red. Las principales elecciones son las siguientes:
espiar el protocolo de enrutamiento de los <CODE>gateways</CODE>, establecer una ruta
por defecto y hacer uso del redireccionamiento y usar <CODE>proxy</CODE> ARP.
Todos estos m&eacute;todos tienen sus propias limitaciones dependiendo del
tipo de red.
<P>Espiar el protocolo de enrutamiento de los <CODE>gateways</CODE> es, en teor&iacute;a, la
soluci&oacute;n m&aacute;s directa y simple. Si suponemos que los <CODE>gateways</CODE> usan una
buena tecnolog&iacute;a de enrutamiento, las tablas que ellos env&iacute;an deber&iacute;an
contener la informaci&oacute;n necesaria para mantener unas rutas &oacute;ptimas para
todos los destinos. Si algo cambia en la red (una l&iacute;nea o un <CODE>gateway</CODE>
falla), esta informaci&oacute;n deber&aacute; reflejarse en las tablas y el <CODE>software</CODE> de
enrutamiento deber&aacute; ser capaz de actualizar adecuadamente las tablas de
enrutamiento de los <CODE>hosts</CODE>. Las desventajas de esta estrategia
son meramente pr&aacute;cticas, pero, en algunas situaciones, la robustez de
este enfoque puede pesar m&aacute;s que dichas desventajas. Veamos cu&aacute;les
son estas desventajas:                     
<P>
<UL>
<LI>Si los <CODE>gateways</CODE> usan un protocolo de enrutamiento sofisticado, la
configuraci&oacute;n puede ser bastante compleja, lo que se convierte en un
problema ya que debemos configurar y mantener los ficheros de
configuraci&oacute;n de cada <CODE>host</CODE>.</LI>
<LI>Algunos <CODE>gateways</CODE> usan protocolos espec&iacute;ficos de alguna marca
comercial. En este caso, es posible que no encontremos un <CODE>software</CODE>
adecuado para nuestros <CODE>hosts</CODE>.</LI>
<LI>Si los <CODE>hosts</CODE> carecen de disco, puede que haya serios
problemas a la hora de escuchar las emisiones. Algunos <CODE>gateways</CODE> son
capaces de traducir su protocolo interno de enrutamiento en otro m&aacute;s
simple que puede ser usado por los <CODE>hosts</CODE>. Esta podr&iacute;a ser una
forma de resolver las dos primeras desventajas. Actualmente no hay una
soluci&oacute;n definitiva para la tercera.</LI>
</UL>
<P>Los problemas de los m&eacute;todos de rutas por defecto/redireccionamiento
y de los <CODE>proxy</CODE> ARP son similares: ambos tienen problemas para trabajar
con situaciones donde las entradas a las tablas no se usan durante un
largo periodo de tiempo. La &uacute;nica diferencia real entre ellos son las
tablas que se ven involucradas. Supongamos que un <CODE>gateway</CODE> cae, si
alguna de las actuales rutas usan ese <CODE>gateway</CODE> no podr&aacute; ser usada. En el
caso de que estemos usando tablas de enrutamiento, el mecanismo para
ajustar las rutas es el redireccionamiento. Esto funciona perfectamente
en dos situaciones:
<P>
<UL>
<LI>cuando el <CODE>gateway</CODE> por defecto no est&aacute; en la mejor ruta. El <CODE>gateway</CODE> por
defecto puede dirigirlo a un <CODE>gateway</CODE> mejor;</LI>
<LI>cuando una l&iacute;nea distante o un <CODE>gateway</CODE> falla. Si esto cambia la mejor
ruta, el <CODE>gateway</CODE> actual nos dirigir&aacute; hacia el <CODE>gateway</CODE> que ahora es el
mejor.</LI>
</UL>
<P>El caso que no est&aacute; a salvo de problemas es cuando el <CODE>gateway</CODE> a que
se le env&iacute;a datagramas falla en ese momento. Puesto que est&aacute; fuera de
servicio, es imposible que redireccione a otro <CODE>gateway</CODE>. En muchos
casos, tampoco estamos a salvo si el <CODE>gateway</CODE> por defecto falla, justo
cuando el enrutamiento empieza a enviar al <CODE>gateway</CODE> por defecto. 
<P>La casu&iacute;stica de los <CODE>proxy</CODE> ARP es similar. Si los <CODE>gateways</CODE> se
coordinan adecuadamente, en principio el <CODE>gateway</CODE> indicado responder&aacute;
adecuadamente. Si algo en la red falla, el <CODE>gateway</CODE> que actualmente se
est&aacute; usando nos reconducir&aacute; a un nuevo y mejor <CODE>gateway</CODE>.
(Normalmente es posible usar redireccionamiento para
ignorar las rutas establecidas por el <CODE>proxy</CODE> ARP). Otra vez, el caso que no
podemos proteger de fallos es cuando el <CODE>gateway</CODE> actual falla. No hay
equivalencia al fallo de los <CODE>gateways</CODE> por defecto, puesto que cual
quier <CODE>gateway</CODE> puede responder a una petici&oacute;n ARP. 
<P>As&iacute; que el gran problema es el fallo debido a que el <CODE>gateway</CODE> en uso no
se puede recuperar, por el hecho de que el principal mecanismo para
alterar las rutas es el redireccionamiento, y un <CODE>gateway</CODE> en mal funciona
miento no puede redirigir. Te&oacute;ricamente, este problema podr&iacute;a
solucionarse a trav&eacute;s de la implementaci&oacute;n TCP/IP, usando "<CODE>timeout</CODE>".
Si un ordenador no recibe respuesta una vez terminado el <CODE>timeout</CODE>,
deber&iacute;a de cancelar la ruta actual y tratar de encontrar otra nueva.
Cuando usamos una ruta por defecto, esto significa que la
implementaci&oacute;n TCP/IP puede ser capaz de declarar una ruta como
fallida en base al <CODE>timeout</CODE>. En caso de que se haya redirigido a un
<CODE>gateway</CODE> distinto del de por defecto, y la ruta se declare fallida, el tr&aacute;fico
se devolver&aacute; al <CODE>gateway</CODE> por defecto. El <CODE>gateway</CODE> por defecto puede
entonces empezar a manejar el tr&aacute;fico, o redirigirlo a un <CODE>gateway</CODE>
diferente. Para manejar los fallos del <CODE>gateway</CODE> por defecto es posible
tener m&aacute;s de un <CODE>gateway</CODE> por defecto; si uno de ellos se declara fallido,
se usar&aacute; el otro. En conjunto, estos mecanismos nos salvaguardan de
cualquier fallo.
<P>M&eacute;todos similares pueden usarse en sistemas que dependen de <CODE>proxy</CODE>
ARP. Si una conexi&oacute;n sobrepasa el <CODE>timeout</CODE>, la entrada de la tabla ARP
usada se debe borrar. Esto causar&aacute; una petici&oacute;n ARP, que podr&aacute; ser
contestada por un <CODE>gateway</CODE> que funcione correctamente. El mecanismo
m&aacute;s simple para llevar esto a cabo podr&iacute;a ser usar los contadores de
<CODE>timeout</CODE> para todas las entradas ARP. Puesto que las peticiones ARP no
son muy costosas en tiempo, cada entrada cuyo <CODE>timeout</CODE> concluya ser&aacute;
borrada, incluso si estaba funcionando perfectamente. As&iacute;, su pr&oacute;ximo
datagrama ser&aacute; una nueva petici&oacute;n. Las respuestas, normalmente, son
suficientemente r&aacute;pidas para que el usuario no se de cuenta del retraso
introducido.
<P>Sin embargo, algunas implementaciones no usan estas estrategias. En
Berkeley 4.2 no hay manera de librarse de ning&uacute;n tipo de entrada, ni de
la tabla de enrutamiento ni de la tabla ARP. Estas implementaciones no
invalidan las entradas, &eacute;stas fallan. Luego si los problemas de fallos de
<CODE>gateways</CODE> son m&aacute;s o menos comunes, no habr&aacute; otra opci&oacute;n que ejecutar
un <CODE>software</CODE> que escuche el protocolo de enrutamiento. En Berkeley 4.3,
las entradas son eliminadas cuando las conexiones TCP fallan, pero no
las ARP. Esto hace que la estrategia de la ruta por defecto sea m&aacute;s
atractiva que la de <CODE>proxys</CODE> ARP, si usamos Berkeley 4.3. Si, adem&aacute;s,
inclu&iacute;mos m&aacute;s de una ruta por defecto se posibilitar&aacute; la recuperaci&oacute;n de
fallos cuando falle un <CODE>gateway</CODE> por defecto. Si una ruta est&aacute; siendo usada
s&oacute;lo por servicios basados en el protocolo UDP, no habr&aacute; una
recuperaci&oacute;n de fallos si el <CODE>gateway</CODE> implicado cae. Mientras que los
servicios "tradicionales" TCP/IP hacen uso del protocolo TCP, algunos
otros, como el sistema de ficheros de red, no lo hacen. Por tanto, la
versi&oacute;n 4.3 no nos garantiza una recuperaci&oacute;n de fallos absoluta.
<P>Por &uacute;ltimo, tambi&eacute;n podemos hablar de otras estrategias usadas por
algunas antiguas implementaciones. Aunque est&aacute;n casi en desuso,
vamos a describirlas de forma esquem&aacute;tica. Estas implementaciones
detectan un fallo de un <CODE>gateway</CODE> haciendo comprobaciones de qu&eacute;
<CODE>gateways</CODE> est&aacute;n en uso. Para ello, la mejor forma de hacer estas
comprobaciones es hacer una lista de <CODE>gateways</CODE> que actualmente se est&eacute;n
usando (para lo que se ayuda de la tabla de enrutamiento) y cada minuto
se env&iacute;a una petici&oacute;n de "echo" a cada <CODE>gateway</CODE> de la citada lista; si el
<CODE>gateway</CODE> no env&iacute;a una respuesta se declara como fallido, y todas las
rutas que hacen uso de &eacute;l se reconducir&aacute;n al <CODE>gateway</CODE> por defecto.
Generalmente, se deber&aacute; de proporcionar m&aacute;s de un <CODE>gateway</CODE> por
defecto, de manera que si el <CODE>gateway</CODE> por defecto falla se elige uno de los
alternativos. En otros casos no es necesario especificar un <CODE>gateway</CODE> por
defecto, ya que el <CODE>software</CODE>, aleatoriamente, eligir&aacute; un <CODE>gateway</CODE> que
responda. Estas implementaciones son muy flexibles y se recuperan bien
de los fallos, pero una gran red con esta implementaci&oacute;n malgastar&aacute; el
ancho de banda con datagramas "echo" para verificar qu&eacute; <CODE>gateways</CODE>
funcionan correctamente. Esta es la raz&oacute;n por la que esta estrategia est&aacute;
en desuso.
<P>
<P>
<H2><A NAME="s6">6. Puentes y gateways</A></H2>

<P>En esta secci&oacute;n vamos a tratar con m&aacute;s detalle la tecnolog&iacute;a usada
para construir grandes redes. Vamos a centrarnos especialmente en
c&oacute;mo conectar varias Ethernet, token rings, etc. Hoy d&iacute;a la mayor&iacute;a de
las redes son jer&aacute;rquicas. Los <CODE>hosts</CODE> est&aacute;n inclu&iacute;dos en una red
de &aacute;rea local, como una Ethernet o un token ring. Estas redes se
conectan entre s&iacute; mediante alguna combinaci&oacute;n de redes principales o
enlaces punto a punto. Una universidad puede tener una red como se
muestra, en parte, a continuaci&oacute;n:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 ________________________________
 |   red 1      red 2    red 3  |        red 4            red 5
 | ---------X---------X-------- |      --------         --------
 |                         |    |         |                 |
 |  Edificio A             |    |         |                 |
 |               ----------X--------------X-----------------X
 |                              | red principal del campus  :
 |______________________________|                           :
                                                      l&iacute;nea :
                                                      serie :
                                                     -------X-----
                                                         red  6
</PRE>
</CODE></BLOCKQUOTE>

Las redes 1, 2 y 3 est&aacute;n en un edificio. Las redes 4 y 5  est&aacute;n en
edificios distintos del campus. La red 6 puede estar en una localizaci&oacute;n
m&aacute;s distante. El diagrama anterior nos muestra que las redes 1, 2 y 3
est&aacute;n conectadas directamente, y los mecanismos que manejan las
conexiones se marcan con "X". El edificio A est&aacute; conectado a otros
edificios en el mismo campus por una red principal. El tr&aacute;fico desde la
red 1 a la red 5 tomar&aacute; el siguiente camino:
<P>
<UL>
<LI>de 1 a 2 a trav&eacute;s de la conexi&oacute;n entre estas redes;</LI>
<LI>de 2 a 3 a trav&eacute;s de su conexi&oacute;n directa;</LI>
<LI>de 3 a la red principal;</LI>
<LI>a trav&eacute;s de la red principal, desde el edificio A al edificio donde 
la red 5 est&aacute; emplazada;</LI>
<LI>de la red principal a la red 5.</LI>
</UL>
<P>El tr&aacute;fico hacia la red 6 deber&iacute;a pasar adicionalmente a trav&eacute;s de la
l&iacute;nea serie. Con la misma configuraci&oacute;n, se usar&iacute;a la misma conexi&oacute;n
para conectar la red 5 con la red principal y con la l&iacute;nea serie. As&iacute;, el
tr&aacute;fico de la red 5 a la red 6 no necesita pasar a trav&eacute;s de la red
principal, al existir esa conexi&oacute;n directa entre la red 5 y la l&iacute;nea serie.
<P>En esta secci&oacute;n vamos a ver qu&eacute; son realmente estas conexiones
marcadas con "x".
<P>
<P>
<H2>6.1 Dise&ntilde;os alternativos</H2>

<P>Hay que hacer constar que hay distintos dise&ntilde;os alternativos al
mostrado anteriormente. Uno de ellos es usar l&iacute;neas punto a punto entre
los <CODE>hosts</CODE>, y otro puede ser usar una tecnolog&iacute;a de red a un nivel
capaz de manejar tanto redes locales como redes de larga distancia.
<P>
<P>
<H3>Una red de l&iacute;neas punto a punto.</H3>

<P>En lugar de conectar los <CODE>hosts</CODE> a una red local como una
Ethernet, y luego conectar dichas Ethernets, es posible conectar
directamente los ordenadores a trav&eacute;s de l&iacute;neas serie de largo alcance.
Si nuestra red consiste primordialmente en un conjunto de ordenadores
situados en localizaciones distintas, esta opci&oacute;n tiene sentido. Veamos
un peque&ntilde;o dise&ntilde;o de este tipo:
<P>
<BLOCKQUOTE><CODE>
<PRE>
  ordenador 1              ordenador 2             ordenador 3
      |                        |                       |
      |                        |                       |
      |                        |                       |
  ordenador 4 ------------ ordenador 5 ----------- ordenador 6
</PRE>
</CODE></BLOCKQUOTE>
<P>En el primer dise&ntilde;o, la tarea de enrutamiento de los datagramas a
trav&eacute;s de red era realizada por unos mecanismos de prop&oacute;sito espec&iacute;fico
que marc&aacute;bamos con "x". Si hay l&iacute;neas que conectan directamente un
par de <CODE>hosts</CODE>, los propios <CODE>hosts</CODE> har&aacute;n esta labor de
enrutamiento, al mismo tiempo que realizan sus actividades 
normales. A no ser que haya l&iacute;neas que comuniquen directamente
todos los <CODE>hosts</CODE>, algunos sistemas tendr&aacute;n que manejar un
tr&aacute;fico destinado a otros. Por ejemplo, en nuestro dise&ntilde;o, el tr&aacute;fico de 1
a 3 deber&aacute; pasar a trav&eacute;s de 4, 5 y 6. Esto es perfectamente posible, ya
que la inmensa mayor&iacute;a de las implementaciones TCP/IP son capaces de
reenviar datagramas. En redes de este tipo podemos pensar que los
propios <CODE>hosts</CODE> act&uacute;an como <CODE>gateways</CODE>. Y, por tanto, deber&iacute;amos
configurar el <CODE>software</CODE> de enrutamiento de los <CODE>hosts</CODE> como si
se tratase de un <CODE>gateway</CODE>. Este tipo de configuraciones no es tan com&uacute;n
como podr&iacute;a pensarse en un principio debido, principalmente, a estas
dos razones:
<UL>
<LI>la mayor&iacute;a de las grandes redes tienen m&aacute;s de un ordenador por
localizaci&oacute;n. En estos casos es menos caro establecer una red local en
cada localizaci&oacute;n que establecer l&iacute;neas punto a punto entre todos los
ordenadores;</LI>
<LI>las unidades de prop&oacute;sito especial para conectar redes son m&aacute;s
baratas, lo que hace que sea m&aacute;s l&oacute;gico descargar las tareas de
enrutamiento y comunicaciones a estas unidades.</LI>
</UL>
<P>Por supuesto, es factible tener una red que mezcle los dos tipos de
tecnolog&iacute;as. As&iacute;, las localizaciones con m&aacute;s equipos podr&iacute;a manejarse
usando un esquema jer&aacute;rquico, con redes de &aacute;rea local conectadas por
este tipo de unidades, mientras que las localizaciones lejanas con un
s&oacute;lo ordenador podr&iacute;an conectarse mediante l&iacute;neas punto a punto. En
este caso, el <CODE>software</CODE> de enrutamiento usado en los ordenadores lejanos
deber&aacute; ser compatible con el usado por las unidades conmutadoras, o
bien tendr&aacute; que haber un <CODE>gateway</CODE> entre las dos partes de la red.
<P>Las decisiones de este tipo generalmente se toman tras estudiar el
nivel de tr&aacute;fico de la red, la complejidad de la red, la calidad del
<CODE>software</CODE> de enrutamiento de los <CODE>hosts</CODE> y la habilidad de los
<CODE>hosts</CODE> para hacer un trabajo extra con el tr&aacute;fico de la red.
<P>
<P>
<H3>Tecnolog&iacute;a de los circu&iacute;tos de conmutaci&oacute;n.</H3>

<P>Otro enfoque alternativo al esquema jer&aacute;rquico LAN/red principal es
usar circu&iacute;tos conmutadores en cada ordenador. Realmente, estamos
hablando de una variante de la t&eacute;cnica de las l&iacute;neas punto a punto,
donde ahora el circu&iacute;to conmutador permite tener a cada sistema
aparentar que tiene l&iacute;nea directa con los restantes. Esta tecnolog&iacute;a no es
usada por la mayor&iacute;a de la comunidad TCP/IP debido a que los
protocolos TCP/IP suponen que el nivel m&aacute;s bajo trabaja con
datagramas aislados. Cuando se requiere una conexi&oacute;n continuada,
el nivel superior de red la implementa usando datagramas. Esta
tecnolog&iacute;a orientada al datagrama no coincide con este sistema
orientado a los circu&iacute;tos de forma directa. Para poder usar esta
tecnolog&iacute;a de circu&iacute;tos conmutadores, el <CODE>software</CODE> IP debe modificarse
para ser posible construir circu&iacute;tos virtuales de forma adecuada. Cuando
hay un datagrama para un destino concreto se debe abrir un circu&iacute;to
virtual, que se cerrar&aacute; cuando no haya tr&aacute;fico para dicho destino por un
tiempo. Un ejemplo de este enfoque es la DDN (Defense Data
Network). El protocolo principal de esta red es el X.25. Esta red parece
desde fuera una red distribu&iacute;da X.25. El <CODE>software</CODE> TCP/IP trata de
manejar la DDN mediante el uso de canales virtuales. T&eacute;cnicas
similares podr&iacute;an usarse con otras tecnolog&iacute;as de circu&iacute;tos de
conmutaci&oacute;n, como, por ejemplo, ATT's DataKit, aunque
no hay demasiado <CODE>software</CODE> disponible para llevarlo a cabo.
<P>
<P>
<H3>Redes de un s&oacute;lo nivel.</H3>

<P>En algunos casos, los adelantos en el campo de las redes de larga
distancia pueden sustituir el uso de redes jer&aacute;rquicas. Muchas de las
redes jer&aacute;rquicas fueron configuradas as&iacute; para permitir el uso de
tecnolog&iacute;as tipo Ethernet y otras LAN, las cu&aacute;les no pueden extenderse
para cubrir m&aacute;s de un campus. As&iacute; que era mecesario el uso de l&iacute;neas
serie para conectar las distintas LANs de varios lugares. Sin embargo,
ahora hay tecnolog&iacute;as de caracter&iacute;sticas similares a Ethernet, pero que
pueden abarcar m&aacute;s de un campus y, por tanto, pensar en una sola red
de larga distancia que no hace uso de una estructura jer&aacute;rquica.
<P>Las principales limitaciones de este tipo de redes son cuestiones de
rendimiento y flexibilidad. Si una sola red es usada por todo el campus
es muy f&aacute;cil que se sobrecargue. Las redes jer&aacute;rquicas pueden manejar
un volumen de trabajo mucho mayor que las redes de un solo nivel.
Adem&aacute;s, el tr&aacute;fico dentro de los departamentos tiende a ser mayor que
el tr&aacute;fico entre departamentos.
<P>Veamos un ejemplo concreto. Sumpongamos que hay diez
departamentos, cada uno de los cuales genera 1 Mbit/seg de tr&aacute;fico.
Supongamos que el 90% del tr&aacute;fico se realiza entre sistemas del mismo
departamento y el 10% restante hacia los dem&aacute;s departamentos. Si cada
departamento tiene su prop&igrave;a red, &eacute;stas deber&iacute;an ser capaces de manejar
1 Mbit/seg, al igual que la red principal que las maneja, para poder
posibilitar el 10% que cada departamento destina a otros departamentos.
Para resolver la misma situaci&oacute;n con una red de un solo nivel, puesto
que debe manejar simult&aacute;neamente los diez departamentos, se resuelve
con una red que soporte 10 Mbit/seg.
<P>Est&aacute; claro que el ejemplo anterior est&aacute; pensado para que el sistema
jer&aacute;rquico sea ventajoso o, al menos, que sea m&aacute;s f&aacute;cil de llevar a cabo.
Si el tr&aacute;fico destinado a los otros departamentos fuese mayor, el ancho
de banda de la red principal deber&aacute; ser mayor. Por ejemplo, si en un
campus hay algunos recursos centraliza dos, como mainframes u otros
grandes sistemas en un centro de c&aacute;lculo. Si la mayor&iacute;a del tr&aacute;fico
procede de peque&ntilde;os sistemas que intentan comunicarse con el sistema
central, entonces el argumento anterior no es v&aacute;lido. Aunque un enfoque
jer&aacute;rquico puede que todav&iacute;a sea &uacute;til, sin embargo no reduce el ancho
de banda requerido. Siguiendo con el ejemplo dado, si los diez
departamentos se comunicasen primordialmente con los sistemas del
ordenador central, la red principal deber&aacute; ser capaz de manejar 10
Mbit/seg. El ordenador central deber&iacute;a de conectarse directamente a la
red principal, o tener una red "departamental" con una capacidad de 10
Mbist/seg, en lugar de los 1 Mbit/seg de los otros departamentos.
<P>La segunda limitaci&oacute;n se refieren a consideraciones respecto a la
fiabilidad, mantenibilidad y seguridad. Las redes de &aacute;rea amplia son
m&aacute;s dif&iacute;ciles de diagnosticar y mantener que las redes de &aacute;rea local,
porque los problemas pueden localizarse en el edificio donde la red se
ubica. Adem&aacute;s, hacen que el tr&aacute;fico sea m&aacute;s f&aacute;cil de controlar. Por estas
razones es m&aacute;s l&oacute;gico manejar un tr&aacute;fico local dentro del edificio y usar
las redes de &aacute;rea amplia s&oacute;lo para el tr&aacute;fico entre edificios. No obstante,
si se da el caso de que en cada localizaci&oacute;n hay s&oacute;lo uno o dos
ordenadores, no tiene sentido montar una red local en cada lugar y s&iacute;
usar una red de un solo nivel.
<P>
<P>
<H3>Dise&ntilde;os mixtos.</H3>

<P>En la pr&aacute;ctica, pocas redes se permiten el lujo de adoptar un dise&ntilde;o
te&oacute;ricamente puro.
<P>Es poco probable que una red grande sea capaz de evitar el uso de un
dise&ntilde;o jer&aacute;rquico. Supongamos que la configuramos como una red de un
solo nivel. Incluso si la mayor&iacute;a de los edificios tienen s&oacute;lo uno o dos
ordenadores, habr&aacute; alguna localizaci&oacute;n donde haya bastantes
ordenadores para justificar el uso de una red local. El resultado es una
mezcla entre una red de un solo nivel y una red jer&aacute;rquica. En la
mayor&iacute;a de los edificios sus ordenadores est&aacute;n conectados directamente
a una red de &aacute;rea amplia, como una red de un solo nivel, pero en un
edificio hay una red de &aacute;rea local usando su red de &aacute;rea amplia como
red principal, a la cu&aacute;l se conecta a trav&eacute;s de unidades conmutadoras.
<P>Por otro lado, incluso los dise&ntilde;adores de redes que defienden el uso de
una enfoque jer&aacute;rquico, en muchas ocasiones encuentran partes de redes
donde simplemente no resulta econ&oacute;mico instalar una red de &aacute;rea local,
as&iacute; que algunos <CODE>hosts</CODE> se enganchan directamente a la red
principal, o bien se usa una l&iacute;nea serie.
<P>Adem&aacute;s de las razones econ&oacute;micas de la instalaci&oacute;n en s&iacute;, hay que
tener en cuenta que a la larga hay que valorar aspectos de
mantenimiento, de manera que a veces es mejor hacer un desembolso
econ&oacute;mico en el dise&ntilde;o para ahorrarnos dinero en el mantenimiento
futuro. Por tanto, el dise&ntilde;o m&aacute;s consistente ser&aacute; aqu&eacute;l que podamos ser
capaces de mantener m&aacute;s f&aacute;cilmente.
<P>
<P>
<H2>6.2 Introducci&oacute;n a las distintas tecnolog&iacute;as de conmutaci&oacute;n </H2>

<P>En esta secci&oacute;n discutiremos las caracter&iacute;sticas de varias tecnolog&iacute;as
usadas para intercambiar datagramas entre redes. En efecto, trataremos
de dar m&aacute;s detalles sobre esas "cajas negras" que hemos visto en las
anteriores secciones. Hay tres tipos b&aacute;sicos de conmutadores, como
repetidores, bridges (o puentes) y <CODE>gateways</CODE> (o pasarelas), o,
alternativamente, <CODE>switches</CODE> de nivel 1, 2 y 3 (bas&aacute;ndonos en el nivel del
modelo OSI en el que operan). Tambi&eacute;n hay que aclarar que hay
sistemas que combinan caracter&iacute;sticas de m&aacute;s de uno de estos
dispositivos, especialmente <CODE>bridges</CODE> y <CODE>gateways</CODE>.
<P>Las diferencias m&aacute;s importantes entre estos tipos de dispositivos
residen en el grado de aislamiento a fallos, prestaciones, enrutamiento y
las facilidades que ofrecen para la administraci&oacute;n de la red. M&aacute;s
adelante examinaremos esto con m&aacute;s detalle.
<P>La diferencia mayor se encuentra entre los repetidores y los otros dos
tipos de <CODE>switches</CODE>. Hasta hace relativamente poco tiempo, los <CODE>gateways</CODE>
proporcionaban unos servicios muy distintos a los ofrecidos por los
bridges, pero ahora hay una tendencia a unificar estas dos tecnolog&iacute;as.
Los <CODE>gateways</CODE> est&aacute;n empezando a adoptar un hardware de prop&oacute;sito
espec&iacute;fico que antes era caracter&iacute;stico de los <CODE>bridges</CODE>. Los <CODE>bridges</CODE> est&aacute;n
empezando a adoptar un enrutamiento m&aacute;s sofisticado, caracter&iacute;sticas
de aislamiento y de administraci&oacute;n de redes que antes s&oacute;lo se pod&iacute;an
encontrar en los <CODE>gateways</CODE>. Incluso hay sistemas que pueden funcionar
como <CODE>bridges</CODE> y <CODE>gateway</CODE>. Esto significa que la decisi&oacute;n crucial no es
decidir si tenemos que usar un <CODE>bridge</CODE> o un <CODE>gateway</CODE>, sino qu&eacute;
caracter&iacute;sticas necesitamos en un <CODE>switch</CODE> y c&oacute;mo &eacute;ste afecta el dise&ntilde;o
global de la red.
<P>
<P>
<H3>Repetidores.</H3>

<P>Un repetidor es un equipo que conecta dos redes que usan la misma
tecnolog&iacute;a. Recibe los paquetes de datos de cada red y los retransmite a
la otra red. La red resultante se caracteriza por tener la uni&oacute;n de los
paquetes de ambas redes. Para las redes Ethernet, o que cumplen el
protocolo IEEE 802.3, hay dos tipos de repetidores (otras tecnolog&iacute;as de
red no hacen estas distinciones).
<P>Un repetidor trabaja a muy bajo nivel. Su objetivo principal es
subsanar las limitaciones de la longitud del cable que provocan p&eacute;rdidas
de se&ntilde;al, dispersi&oacute;n temporal, etc. Nos permiten construir redes m&aacute;s
grandes y liberarnos de las limitaciones de la longitud del cable.
Podr&iacute;amos pensar que un repetidor se comporta como un amplificador a
ambos lados de la red, pasando toda la informaci&oacute;n contenida en la
se&ntilde;al (incluso las colisiones) sin hacer ning&uacute;n procesamiento a nivel de
paquetes. No obstante, hay un n&uacute;mero m&aacute;ximo de repetidores que
pueden introducirse en una red. Las especificaciones b&aacute;sicas de Ethernet
requieren que las se&ntilde;ales lleguen a su destino dentro de un l&iacute;mite de
tiempo, lo que determina que haya una longitud m&aacute;xima de la red.
Poniendo varios repetidores en el camino se introducen dificultades para
estar dentro del l&iacute;mite (de hecho, cada repetidor introduce un retraso, as&iacute;
que de alguna manera se introducen nuevas dificultades).
<P>Un "repetidor con buffer" trabaja a nivel de paquetes de datos. En
lugar de pasar la informaci&oacute;n contenida en la se&ntilde;al, almacena paquetes
enteros de una red en un buffer interno y, luego, lo retranstime a la otra
red, por lo que no deja pasar las colisiones. Debido a que los fen&oacute;menos
de bajo nivel, como las colisiones, no son repetidos, se puede considerar
como si las dos redes continuasen separadas en lo que se refiere a las
especificaciones Ethernet. Por tanto, no hay restricciones respecto al
n&uacute;mero de repetidores con buffer que se pueden usar. De hecho, no es
necesario que ambas redes sean del mismo tipo, pero han de ser
suficientemente similares, de manera que tengan el mismo formato de
paquete. Generalmente, esto significa que se emplean repetidores con
buffer entre redes de la familia IEEE 802.x (asumiendo que elegimos la
misma longitud para las direcciones y el mismo tama&ntilde;o m&aacute;ximo para
los paquetes), o entre dos redes de otra familia. Adem&aacute;s, un par de
repetidores con buffer pueden usarse para conectar dos redes mediante
una l&iacute;nea serie.
<P>Los repetidores con buffer y los repetidores b&aacute;sicos tienen una
caracter&iacute;stica en com&uacute;n: repiten cada paquete de datos que reciben de
una red en la otra. Y as&iacute; ambas redes, al final, tienen exactamente el
mismo conjunto de paquetes de datos.
<P>
<H3>Bridges y gateways.</H3>

<P>Un <CODE>bridge</CODE> se diferencia principalmente de un repetidor en que realiza
alg&uacute;n tipo de selecci&oacute;n de qu&eacute; datagramas se pasan a las otras redes.
Persiguen alcanzar el objetivo de aumentar la capacidad de los sistemas,
al mantener el tr&aacute;fico local confinado a la red donde se originan.
Solamente el tr&aacute;fico destinado a otras redes ser&aacute; reenviado a trav&eacute;s del
<CODE>bridge</CODE>. Esta descripci&oacute;n tambi&eacute;n podr&iacute;a aplicarse a los <CODE>gateways</CODE>.
Bridges y <CODE>gateways</CODE> se distinguen por la manera de determinar qu&eacute;
datagramas deben reenviarse. Un <CODE>bridge</CODE> usa s&oacute;lo las direcciones del
nivel 2 de OSI; en el caso de las redes Ethernet, o IEEE 802.x, nos
referimos a las direcciones de 6 bytes de Ethernet o direcciones del
nivel-MAC (el t&eacute;rmino "direcciones del nivel MAC" es m&aacute;s general.
Sin embargo, con la intenci&oacute;n de aclarar ideas, los ejemplos de esta
secci&oacute;n se referir&aacute;n a redes Ethernet y as&iacute; s&oacute;lo deberemos reemplazar el
t&eacute;rmino "direcci&oacute;n Ethernet" por el equivalente de direcci&oacute;n de
nivel MAC en cualquier otra tecnolog&iacute;a). Un <CODE>bridge</CODE> no examina el
datagrama en s&iacute;, as&iacute; que no usa las direcciones IP, o su equivalente para
tomar las decisiones de enrutamiento. Como contraste, un <CODE>gateway</CODE> basa
sus decisiones en las direcciones IP, o su equivalente en otros protocolos.
<P>Hay varias razones por las que importa el tipo de direcci&oacute;n usada para
tomar una decisi&oacute;n. La primera de ellas afecta a c&oacute;mo interact&uacute;an
dichos dispositivos conmutadores con los niveles superiores del
protocolo. Si el reenv&iacute;o se hace a nivel de las direcciones de nivel-
MAC (<CODE>bridge</CODE>), dicho dispositivo ser&aacute; invisible a los protocolos. Si se
hace a nivel IP, ser&aacute; visible. Veamos un ejemplo en el que hay dos redes
conectadas por un <CODE>bridge</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
       Red 1                    Red 2
      128.6.5                  128.6.4
 ===================  ==============================
    |             |    |           |            |
 ___|_______    __|____|__  _______|___   ______|____
  128.6.5.2       bridge     128.6.4.3     128.6.4.4
 ___________    __________  ___________   ___________
 ordenador A                ordenador B   ordenador C
</PRE>
</CODE></BLOCKQUOTE>
<P>Hay que decir que un <CODE>bridge</CODE> no tiene una direcci&oacute;n IP. En lo que se
refiere a los ordenadores A, B y C, hay una sola Ethernet a la que est&aacute;n
conectados. Esto se traduce en que las tablas de enrutamiento deben
configurarse de manera que los ordenadores de ambas redes se traten
como si fuesen locales. Cuando el ordenador A abre una conexi&oacute;n con
el ordenador B, primero se env&iacute;a una petici&oacute;n ARP preguntando por la
direcci&oacute;n Ethernet del ordenador B. El <CODE>bridge</CODE> debe dejar pasar esta
petici&oacute;n de la red 1 a la red 2. (En general, los bridges deben atender
todas las peticiones). Una vez que ambos ordenadores conocen las
direcciones Ethernet del otro, las comunicaciones usar&aacute;n las direcciones
Ethernet en el destino. Llegados a este punto, el <CODE>bridge</CODE> puede empezar a
ejecutar alguna selecci&oacute;n, y dejar&aacute; pasar aquellos datagramas cuya
direcci&oacute;n Ethernet de destino se encuentren en una m&aacute;quina de la otra
red. De esta manera un datagrama desde A hasta Bpasar&aacute; de la red 2 a la
red 1, pero un datagrama desde B hasta C se ignorar&aacute;.
<P>Con objeto de hacer esta selecci&oacute;n, el <CODE>bridge</CODE> necesita saber en qu&eacute; red
est&aacute; cada m&aacute;quina. La mayor&iacute;a de los bridges modernos construyen una
tabla para cada red a la que se conecta, listando las direcciones Ethernet
de las m&aacute;quinas de las que se sabe en qu&eacute; red se encuentran, y para ello
vigilan todos los datagramas de cada red. Cuando un datagrama aparece
primero en la red 1 es razonable pensar que la direcci&oacute;n del remitente
corresponde a una m&aacute;quina de la red 1.
<P>Un <CODE>bridge</CODE> debe examinar cada datagrama por dos razones: la primera,
para usar la direcci&oacute;n de procedencia y aprender qu&eacute; m&aacute;quinas est&aacute;n en
cada red, y, la segunda, para decidir si el datagrama ha de ser reenviado
o no en base a la direcci&oacute;n de destino.
<P>Como mencionamos anteriormente, por regla general los bridges
dejan pasar las peticiones de una red a la otra. Frecuentemente se usan las
peticiones para localizar alg&uacute;n recurso. Una petici&oacute;n ARP es un t&iacute;pico
ejemplo de lo anterior. Debido a que un <CODE>bridge</CODE> no tiene manera de saber
si un <CODE>host</CODE> va a responder a dicha petici&oacute;n, deber&aacute; dejarla pasar
a la otra red. Algunos bridges tienen filtros definidos por el usuario, que
les posibilita dejar pasar algunos y bloquear a otros. Podemos permitir
peticiones ARP (que son esenciales para que el protocolo IP funcione) y
restringir otras peticiones menos importantes a su propia red de origen.
Por ejemplo, podemos elegir no dejar pasar las peticiones rwhod, que
usan algunos sistemas para conocer los usuarios conectados en cualquier otro
sistema, o podemos decidir que rwhod s&oacute;lo pueda tener acceso a una parte de
la red.
<P>Ahora veamos un ejemplo de dos redes conectadas por un <CODE>gateway</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
         Red 1                           Red 2
        128.6.5                         128.6.4
 ======================       ==============================
     |              |           |      |    |            |
 ____|______   _____|___________|__  __|____|___   ______|____
  128.6.5.2    128.6.5.1  128.6.4.1   128.6.4.3     128.6.4.4
 ___________   ____________________  ___________   ___________
 ordenador A          gateway        ordenador B   ordenador C
</PRE>
</CODE></BLOCKQUOTE>
<P>Los <CODE>gateways</CODE> tienen asignada una direcci&oacute;n IP por cada interface. Las
tablas de enrutamiento de los ordenadores deber&aacute;n configurarse para
hacer los env&iacute;os a las direcciones adecuadas. As&iacute;, por ejemplo, el
ordenador A tiene una entrada especificando que debe usarse el
<CODE>gateway</CODE> 128.6.5.1 para alcanzar la red 128.6.4.
<P>Debido a que los ordenadores tienen conocimiento de la existencia del
<CODE>gateway</CODE>, el <CODE>gateway</CODE> no necesita inspeccionar todos los paquetes de la
Ethernet. Los ordenadores le enviar&aacute;n datagramas cuando sea
apropiado. Por ejemplo, supongamos que el ordenador A necesita enviar
un mensaje al ordenador B. En la tabla de enrutamiento de A se indica
que deberemos usar el <CODE>gateway</CODE> 128.6.5.1, y entonces se enviar&aacute; una
petici&oacute;n ARP para esa direcci&oacute;n, respondi&eacute;ndonos el <CODE>gateway</CODE> a la
petici&oacute;n como si se tratase de un <CODE>host</CODE> cualquiera. A partir de 
entonces, los datagramas destinados a B ser&aacute;n enviados a la direcci&oacute;n Ethernet 
del <CODE>gateway</CODE>.
<P>
<P>
<H3>M&aacute;s sobre bridges.</H3>

<P>Hay varias ventajas para usar direcciones del nivel MAC, como lo
hace un <CODE>bridge</CODE>. La primera es que cada paquete en una Ethernet, o en
una red IEEE, usa dichas direcciones, y la direcci&oacute;n se localiza en el
mismo lugar en cada paquete, incluso si es IP, DECnet, o de cualquier
otro protocolo. De tal manera que es relativamente r&aacute;pido obtener la
direcci&oacute;n de cada paquete. Por otro lado, un <CODE>gateway</CODE> debe decodificar
toda la cabecera IP y, si soporta otros protocolos distintos a IP, debe
tener un <CODE>software</CODE> distinto para cada protocolo. Esto significa que un
<CODE>bridge</CODE> soporta autom&aacute;ticamente cualquier protocolo posible, mientras
que un <CODE>gateway</CODE> debe preveer qu&eacute; protocolo debe soportar. 
<P>Sin embargo, tambi&eacute;n hay desventajas. La principal se refiere al
dise&ntilde;o de un puente 
<UL>
<LI>Un puente debe mirar cada paquete de la red, no solo aqu&eacute;llos
a los que se le destinan. Esto hace posible que haya sobrecargas en el
<CODE>bridge</CODE> si se coloca en una red muy concurrida, incluso si el tr&aacute;fico 
que atraviesa el <CODE>bridge</CODE> es peque&ntilde;o.
     
No obstante, existe otra desventaja basada en la manera como los
bridges est&aacute;n dise&ntilde;ados. Ser&iacute;a posible, en principio, dise&ntilde;ar bridges sin
estas desventajas, pero no hay indicios de que se cambie. La desventaja
se debe al hecho de que los bridges no tienen una tabla de enrutamiento
completa con todos los sistemas de las redes, ya que s&oacute;lo tienen una
simple lista con las direcciones Ethernet que se encuentran en sus redes.
Lo que significa que</LI>
<LI>Las redes que usan bridges no pueden tener bucles en su
dise&ntilde;o. Si hubiera un bucle, algunos bridges ver&iacute;an el tr&aacute;fico procedente
de una misma direcci&oacute;n Ethernet venir de ambas direcciones,
por lo que le ser&iacute;a imposible decidir en qu&eacute; tabla debe poner dicha
direcci&oacute;n. Hay que aclarar que un camino paralelo en la misma
direcci&oacute;n constituye un bucle y, por tanto, no se podr&aacute;n usar m&uacute;ltiples
caminos con el fin de descargar el tr&aacute;fico de la red.
     
Hay algunos m&eacute;todos para afrontar el problema de los bucles. Muchos
puentes permiten configuraciones con conexiones redundantes, pero
desactivando enlaces de manera que no haya bucles. Si un enlace falla,
uno de los desactivados entra en servicio. As&iacute;, los enlaces redundantes
nos proporcionan una fiabilidad extra, pero nos proporcionan nuevas
capacidades. Tambi&eacute;n es posible construir un <CODE>bridge</CODE> capaz de manejar
l&iacute;neas punto a punto paralelas, en un caso especial donde dichas l&iacute;neas
tienen en sus extremos un <CODE>bridge</CODE>. Los bridges tratar&iacute;an las dos l&iacute;neas
como una &uacute;nica l&iacute;nea virtual y usarlas alternativamente, siguiendo alg&uacute;n
algoritmo aleatorio.

El proceso de desactivar conexiones redundantes hasta que no queden
bucles es conocido como un "algoritmo de expansi&oacute;n de &aacute;rboles". Este
nombre se debe a que un &aacute;rbol se define como un patr&oacute;n de conexiones
sin bucles. Lo que se hace es ir desactivando conexiones, ya que las
conexiones restantes en el &aacute;rbol incluyen a todas las redes del sistema.
Para llevarlo a cabo, todos los bridges del sistema de redes deben
comunicarse entre ellos.

Hay una tendencia a que los &aacute;rboles de expansi&oacute;n resultantes cargan
demasiado a la red en alguna parte del sistema. Las redes cercanas a la
"raiz del &aacute;rbol" manejan todo el tr&aacute;fico entre las distintas partes de la
red.
En una red que usa <CODE>gateways</CODE>, ser&iacute;a posible poner enlaces extras entre
partes de la red que tengan un gran tr&aacute;fico, pero dichos enlaces extras no
pueden ser usados por un conjunto de bridges.</LI>
</UL>
<P>
<H3>M&aacute;s sobre gateways.</H3>

<P>Los <CODE>gateways</CODE> tienen sus propias ventajas y desventajas. En general, un
<CODE>gateway</CODE> es m&aacute;s complejo de dise&ntilde;ar y administrar que un <CODE>bridge</CODE>. Un
<CODE>gateway</CODE> debe participar en todos los protocolos para los que est&aacute;
dise&ntilde;ado para reenviar. Por ejemplo, un <CODE>gateway</CODE> IP debe responder a
peticiones ARP. El est&aacute;ndar IP tambi&eacute;n necesita estudiar por completo
las cabeceras IP, decrementando el tiempo para activar campos y
obedecer cualquier opci&oacute;n IP.
<P>Los <CODE>gateways</CODE> son dise&ntilde;ados para manejar topolog&iacute;as de redes m&aacute;s
complejas que las que son capaces de manejar los bridges. Y, como ya
hemos mencionado, tienen diferentes (y m&aacute;s complejas) decisiones que
estudiar. En general, un <CODE>bridge</CODE> tiene decisiones m&aacute;s f&aacute;ciles que tomar: si
se debe reenviar un datagrama y, en caso de que deba hacerse, qu&eacute;
interface hemos de elegir. Cuando un <CODE>gateway</CODE> reenv&iacute;a un datagrama,
debe decidirse a qu&eacute; <CODE>host</CODE> o <CODE>gateway</CODE> hay que enviarlo a
continuaci&oacute;n. Si un <CODE>gateway</CODE> env&iacute;a un datagrama de vuelta a la red de
donde procede, tambi&eacute;n debe enviar una redirecci&oacute;n al emisor del
datagrama indicando que use una mejor ruta. Muchos <CODE>gateways</CODE> pueden
tambi&eacute;n manejar caminos paralelos. Si hay varios caminos igual
mente buenos para un destino, el <CODE>gateway</CODE> usar&aacute; uno de ellos
determinado por alg&uacute;n tipo de algoritmo aleatorio. (Esto se hace
tambi&eacute;n en algunos bridges, pero no suele ser lo usual. En ambos casos,
se elige uno de ellos mediante alg&uacute;n tipo de algoritmo aleatorio. Esto
tiende a hacer que la llegada de los datagramas tenga un orden distinto
al que fueron enviados. Lo que puede complicar la labor de
procesamiento de los datagramas de los <CODE>hosts</CODE> de destino, e,
incluso, hay viejas implementaciones TCP/IP que tienen errores a la
hora de ordenar los datagramas).
<P>Para poder analizar todas estas decisiones, un <CODE>gateway</CODE> tendr&aacute; una
tabla de enrutamiento muy similar a la de los <CODE>hosts</CODE>. Al igual
que las tablas de enrutamiento, las tablas de los <CODE>gateways</CODE> contienen una
entrada por cada posible n&uacute;mero de red. Para cada red hay, o bien una
entrada indicando que la red est&aacute; conectada directamente al <CODE>gateway</CODE>, o
hay una entrada indicando que el tr&aacute;fico para esa red debe reenviarse
hacia alg&uacute;n otro <CODE>gateway</CODE> o <CODE>gateways</CODE>. Describiremos posteriormente los
"protocolos de enrutamiento" usados para elaborar esta informaci&oacute;n, en
la discusi&oacute;n sobre c&oacute;mo configurar un <CODE>gateway</CODE>.
<P>
<P>
<H2>6.3 Comparando las tecnolog&iacute;as de conmutaci&oacute;n</H2>

<P>Los repetidores, repetidores con buffer, bridges y <CODE>gateways</CODE> forman un
espectro. Los dispositivos del principio de la lista son mejores para
redes peque&ntilde;as, adem&aacute;s son m&aacute;s baratos y f&aacute;ciles de configurar aunque
tienen menos servicios. Los del final de la lista son apropiados para
construir redes m&aacute;s complejas. Muchas redes usan mezclas de
dispositivos, con repetidores para conectar peque&ntilde;os segmentos de red,
bridges para algunas &aacute;reas grandes y <CODE>gateways</CODE> para enlaces de larga
distancia.
<P>Hasta ahora hemos asumido que s&oacute;lo usan <CODE>gateways</CODE>. La secci&oacute;n de
c&oacute;mo configurar un <CODE>host</CODE> describe c&oacute;mo configurar una tabla de
enrutamiento, listando los <CODE>gateways</CODE> que se deb&iacute;an usar para alcanzar a
distintas redes. Los repetidores y bridges son invisibles a IP, y, en lo que
a las anteriores secciones se refiere, las redes conectadas mediante ellos
se deben considerar como una &uacute;nica red. En la secci&oacute;n 3.4. se describe
c&oacute;mo configurar un <CODE>host</CODE> en el caso en que varias subredes se
traten como una &uacute;nica red f&iacute;sica; la misma configuraci&oacute;n deber&iacute;a usarse
cuando varias subredes se conectan mediante repetidores o bridges.  
<P>Como ya mencionamos, las caracter&iacute;sticas a tener en cuenta en un
dispositivo conmutador son: aislamiento, rendimiento, enrutamiento y
las facilidades de mantenimiento de la red.
<P>
<P>
<H3>Aislamiento.</H3>

<P>Generalmente, los dispositivos conmutadores se usan para conectar
redes. As&iacute; que, normalmente, pensamos en ganar conectividad, no en el
aislamiento. Sin embargo, el aislamiento es algo digno de tener en
cuenta. Si conectamos dos redes y no tenemos en cuenta el aislamiento
para nada, entonces cualquier problema en otras redes aparecer&aacute; en la
nuestra tambi&eacute;n. Asimismo, dos redes juntas pueden tener suficiente
tr&aacute;fico como para saturar la nuestra. Es por lo tanto conveniente elegir
un nivel apropiado de protecci&oacute;n.
<P>El aislamiento puede llegar de dos maneras: aislamiento frente al mal
funcionamiento y frente al tr&aacute;fico. Con el objeto de discutir el
aislamiento debido a errores de funcionamiento, vamos a se&ntilde;alar una
clasificaci&oacute;n de malfunciones:
<P>
<UL>
<LI>Fallos el&eacute;ctricos, como por ejemplo una bajada de tensi&oacute;n o
alg&uacute;n tipo de fallo que distorsiona la se&ntilde;al. Todos los tipos de
dispositivos deber&aacute;n confinarlo a un lado del dispositivo (repetidor,
repetidor con buffer, <CODE>bridge</CODE>, <CODE>gateway</CODE>).</LI>
<LI>Problemas con los transceiver y controladores que, en general,
generan se&ntilde;ales el&eacute;ctricamente correctas, pero de contenido err&oacute;neo
(por ejemplo, paquetes de tama&ntilde;o infinito o demasiado grandes, falsas
colisiones, portadora continua). Todos, excepto el repetidor, nos
protegen de estos problemas, que no son muy comunes.</LI>
<LI>Errores en el <CODE>software</CODE> que provocan un excesivo tr&aacute;fico entre
algunos <CODE>hosts</CODE> (no nos referimos a mensajes de tipo
broadcoast). Los bridges y <CODE>gateways</CODE> pueden aislarnos de estos errores.
(Este tipo de fallos son bastante raros. La mayor parte de los problemas
del <CODE>software</CODE> y de protocolos generan broadcoasts).</LI>
<LI>Errores en el <CODE>software</CODE> que provocan un excesivo tr&aacute;fico de
broadcast. Los <CODE>gateways</CODE> se aislan de estos problemas. Generalmente, los
bridges no lo hacen, porque deben dejar las peticiones ARP y otros
broadcasts. Los bridges con filtros definidos por el usuario podr&iacute;an
protegernos contra algunos de estos errores de sobrecarga de broadcast.
Sin embargo, en general, los bridges deben dejar pasar ARP y la
mayor&iacute;a de estos errores se deben a ARP. Este problema no es tan grave
en redes donde el <CODE>software</CODE> tiene un cuidadoso control, pero tendremos
regularmente problemas de este tipo en redes complejas o con <CODE>software</CODE>
experimental.</LI>
</UL>
<P>El aislamiento al tr&aacute;fico es proporcionado por bridges y <CODE>gateways</CODE>. La
decisi&oacute;n m&aacute;s importante al respecto es conocer el n&uacute;mero de
ordenadores que podemos poner en una red sin sobrecargarla. Esto
requiere el conocimiento de la capacidad de la red, y el uso al que se
destinar&aacute;n los <CODE>hosts</CODE>. Por ejemplo, una Ethernet puede
soportar cientos de sistemas si se van a destinar para logins remotos y,
ocasionalmente, para transferencia de ficheros. Sin embargo, si los
ordenadores carecen de disco, y usamos la red para swapping, una
Ethernet podr&iacute;a soportar entre 10 y 40, dependiendo de su velocidad y
sus caracter&iacute;sticas de E/S.
<P>Cuando ponemos m&aacute;s ordenadores en una red de los que es capaz de
manejar, deberemos dividirla en varias redes y poner alg&uacute;n dispositivo
conmutador entre ellos. Si esto se hace correctamente, la mayor&iacute;a del
tr&aacute;fico deber&aacute; realizarse entre m&aacute;quinas de la misma parte de la
divisi&oacute;n, lo que significa poner los clientes en la misma red que su
servidor, poner los servidores de terminales en la misma red que los
<CODE>hosts</CODE> a los que se  accede m&aacute;s frecuentemente.
<P>Bridges y <CODE>gateways</CODE>, generalmente, suministran el mismo grado de
aislamiento al tr&aacute;fico. En ambos casos, s&oacute;lo el tr&aacute;fico destinado a los
<CODE>hosts</CODE> del lado de la unidad conmutadora se pasar&aacute;. Veremos
esto m&aacute;s detalladamente en la secci&oacute;n del enrutamiento.
<P>
<P>
<H3>Prestaciones.</H3>

<P>Los l&iacute;mites de las prestaciones empiezan a ser menos claros, puesto
que las tecnolog&iacute;as de conmutaci&oacute;n est&aacute;n mejorando continuamente.
Generalmente, los repetidores pueden manejar todo el ancho de banda
de la red (por su propia naturaleza, un repetidor b&aacute;sico ha de ser capaz
de hacer esto). Los bridges y <CODE>gateways</CODE> frecuentemente tienen
limitaciones en sus prestaciones de varios tipos. Los bridges tienen dos
estad&iacute;sticos de inter&eacute;s: la tasa de paquetes analizados y el rendimiento.
Como explicamos anteriormente, los bridges deben analizar cada
paquete que se encuentra en la red, incluso aquellos que no van a ser
reenviados. El n&uacute;mero de paquetes analizados por segundo es la unidad
usada para medir la tasa de paquetes analizados. El rendimiento se
puede aplicar tanto a bridges como a <CODE>gateways</CODE>, y refleja la parte del
tr&aacute;fico que ha sido reenviada; generalmente, depende del tama&ntilde;o del
datagrama. As&iacute;, el n&uacute;mero de datagramas por segundo que una unidad
puede manejar ser&aacute; mayor cuanto haya m&aacute;s datagramas peque&ntilde;os que
grandes. Normalmente, un <CODE>bridge</CODE> puede manejar desde algunos cientos
de datagramas hasta unos 7.000. Se puede obtener mayor capacidad de
procesamiento con equipos que usan una hardware de prop&oacute;sito
espec&iacute;fico para acelerar la labor de an&aacute;lisis de paquetes. La primera
generaci&oacute;n de <CODE>gateways</CODE> pod&iacute;an procesar entre algunos cientos de
datagramas por segundo hasta unos 1.000 &oacute; m&aacute;s; sin embargo, los
<CODE>gateways</CODE> de segunda generaci&oacute;n, ampliamente extendidos,
usan un hardware de prop&oacute;sito espec&iacute;fico igual de sofisticado que el
usado en los bridges y con ellos se pueden manejar alrededor de 10.000
datagramas por segundo. Debido a que en este momento los bridges y
<CODE>gateways</CODE> de altas prestaciones pueden manejar casi todo el ancho de
banda de una Ethernet, las prestaciones no son una raz&oacute;n para elegir
entre un tipo u otro de dispositivo. Sin embargo, para un tipo dado de
dispositivo, hay todav&iacute;a grandes diferencias entre los distintos modelos,
sobre todo en la relaci&oacute;n precio/prestaciones. Esto es especialmente cierto 
en los modelos de la gama baja. Los bridges m&aacute;s baratos cuestan
menos de la mitad que los <CODE>gateways</CODE> m&aacute;s baratos.
<P>Desgraciadamente, no hay un &uacute;nico estad&iacute;stico para poder estimar las
prestaciones de un dispositivo. No obstante, el que m&aacute;s se usa es el de
paquetes por segundo. Hay que tener en cuenta que la mayor&iacute;a de las
empresas cuentan los datagramas una sola vez, cuando pase por el
<CODE>gateway</CODE>; hay una compa&ntilde;&iacute;a importante que cuenta los datagramas 2
veces, y, por tanto, deben dividirse por 2 para poder comparar. Tambi&eacute;n
hay que asegurarse, para hacer una comparaci&oacute;n correcta, que los
datagramas son del mismo tama&ntilde;o. Un modelo para poder comparar
prestaciones es
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
tiempo_de_procesamiento =   tiempo_conmutaci&oacute;n + tama&ntilde;o_datagrama * tiempo_por_byte
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Aqu&iacute;, el tiempo de conmutaci&oacute;n suele ser una constante; representa la
interrupci&oacute;n latente, el procesamiento de las cabeceras, buscar en la
tabla de enrutamiento, etc., m&aacute;s un componente proporcional al tama&ntilde;o
del datagrama, representando el tiempo necesario para hacer cualquier
copia de datagrama. Un enfoque razonable para estudiar las prestaciones
es dar los datagramas por segundo por los tama&ntilde;os m&iacute;nimos y m&aacute;ximos
de los datagramas. Otra forma de conocer los l&iacute;mites de un dispositivo
es conociendo la velocidad de los datagramas por segundo y el
rendimiento en bytes por segundo, y aplicando la f&oacute;rmula anterior.
<P>
<P>
<H3>Enrutamiento.</H3>

<P>Vamos a estudiar las tecnolog&iacute;as usadas para decidir hacia d&oacute;nde debe
enviarse un datagrama. Por supuesto, no haremos esto para los
repetidores, ya que &eacute;stos reenv&iacute;an todos los paquetes.
<P>La estrategia de enrutamiento de un <CODE>bridge</CODE> conlleva tomar dos
decisiones: 
<UL>
<LI>activar o desactivar los enlaces de manera que se mantenga el &aacute;rbol
de expansi&oacute;n; y, </LI>
<LI>decidir si debemos reenviar un paquete en particular y a trav&eacute;s de
cu&aacute;l interface (si el puente es capaz de manejar m&aacute;s de dos interfaces).</LI>
</UL>
<P>La segunda decisi&oacute;n se toma en base a una tabla de direcciones del
nivel-MAC. Como ya hemos descrito anteriormente, esta tabla se construye 
analizando el tr&aacute;fico que pasa por cada interface. El objetivo
es reenviar aquellos paquetes cuyo destino se encuentre a otro lado del
<CODE>bridge</CODE>. Este algoritmo requiere tener una configuraci&oacute;n de red que no
contenga bucles o l&iacute;neas redundantes. Los bridges menos sofisticados
dejan esta tarea al dise&ntilde;ador de la red, y debemos dise&ntilde;ar y configurar
una red sin bucles. Los bridges m&aacute;s sofisticados permiten una topolog&iacute;a
cualquiera, pero ir&aacute; desactivando enlaces hasta que no haya bucles;
adem&aacute;s, nos proporciona una fiabilidad extra, ya que, en caso de fallo
de un enlace, se activar&aacute; autom&aacute;ticamente un enlace alternativo. Los
bridges que funcionan de este modo tienen un protocolo que les permite
detectar cu&aacute;ndo una unidad debe desactivarse o activarse, de manera
que el conjunto activo de enlaces abarquen el &aacute;rbol de expansi&oacute;n. Si
necesitamos la fiabilidad proporcionada por los enlaces redundantes,
debemos asegurarnos que nuestros bridges sean capaces de trabajar de
esta manera. Actualmente no hay un protocolo est&aacute;ndar para este tipo de
bridges, pero est&aacute; en camino. En caso de comprar bridges de m&aacute;s de una
marca, debemos asegurarnos que sus protocolos para trabajar con los
&aacute;rboles de expansi&oacute;n pueden entenderse.
<P>Por otro lado, los <CODE>gateways</CODE> permiten cualquier tipo de topolog&iacute;a,
incluyendo bucles y enlaces redundantes. Debido a que tienen
algoritmos m&aacute;s generales de enrutamiento, los <CODE>gateways</CODE> deben
mantener un modelo de toda la red. Diferentes t&eacute;cnicas de enrutamiento
mantienen modelos de redes con m&aacute;s o menos complejidad, y usan esta
informaci&oacute;n con distinto tipo de sofisticaci&oacute;n. Los <CODE>gateways</CODE> que pueden
manejar IP, normalmente soportan los dos protocolos est&aacute;ndares de
Internet: RIP (Routing Information Protocol) y EGP (External Gateway
Protocol). El EGP es un protocolo de prop&oacute;sito espec&iacute;fico usado en
redes donde hay una red principal, y permite intercambiar informaci&oacute;n
de "c&oacute;mo llegar" con la red principal. Por regla general, es bastante
recomendable que nuestros <CODE>gateways</CODE> soporten EGP.
<P>RIP es un protocolo dise&ntilde;ado para manejar rutas en redes peque&ntilde;as o
medianas, donde la velocidad de las l&iacute;neas no difieren demasiado. Sus
principales limitaciones son:
<P>
<UL>
<LI>No puede usarse con redes donde los caminos pasan por m&aacute;s de
15 <CODE>gateways</CODE>. Se puede, incluso, reducir este n&uacute;mero en el caso de que
usemos una opci&oacute;n de dar un paso mayor de uno a una l&iacute;nea lenta.</LI>
<LI>No puede compartir el tr&aacute;fico entre l&iacute;neas paralelas (algunas
implementaciones permiten hacer esto si dichas l&iacute;neas se encuentran entre 
el mismo par de <CODE>gateways</CODE>).</LI>
<LI>No puede adaptarse a la sobrecarga de redes.</LI>
<LI>No es adecuada para situaciones en las que hay rutas
alternativas a trav&eacute;s de l&iacute;neas con muy distinta velocidad.</LI>
<LI>No es estable en redes donde las l&iacute;neas o los <CODE>gateways</CODE> cambian
con frecuencia.</LI>
</UL>
<P>Algunas compa&ntilde;&iacute;as venden modificaciones de RIP que mejoran su
funcionamiento con EGP, o que incrementan la longitud del camino
m&aacute;ximo m&aacute;s all&aacute; de 15, pero no incluyen otro tipo de modificaciones.
En caso de que nuestra red disponga de <CODE>gateways</CODE> de m&aacute;s de una marca,
en general necesitaremos que soporten RIP, puesto que suele ser el
&uacute;nico protocolo de enrutamiento disponible. Si vamos a trabajar,
adem&aacute;s, con otro tipo de protocolo, pueden sernos &uacute;tiles <CODE>gateways</CODE> que
traduzcan su propio protocolo y RIP. Sin embargo, para redes muy
grandes o complejas no nos queda otro remedio que usar otros
protocolos.
<P>Tambi&eacute;n existen otros protocolos m&aacute;s sofisticados. Los principales
son IGRP y los basados en los algoritmos SPF (el camino m&aacute;s corto
primero - short path fist). Usualmente, estos protocolos han sido
dise&ntilde;ados para redes m&aacute;s grandes o complejas y, en general, son
estables bajo una gran variedad de condiciones, pudiendo manejar l&iacute;neas
de cualquier velocidad. Algunos de ellos permiten tener en cuenta la
sobrecarga de algunos caminos, pero hasta el moemento no conozco un
<CODE>gateway</CODE> que sea capaz de hacer esto. (Hay serios problemas para
mantener un enrutamiento estable para realizarlo). Hay numerosas
variantes de tecnolog&iacute;as de enrutamiento, y &eacute;stas se est&aacute;n modificando
r&aacute;pidamente, as&iacute; que deberemos tener en cuenta la topolog&iacute;a de
nuestra red para elegir un producto en concreto; tenemos que
asegurarnos que puede manejar nuestra topolog&iacute;a y que puede soportar
otros requerimientos especiales, como compartir el tr&aacute;fico entre l&iacute;neas
paralelas, o ajustar la topolog&iacute;a ante fallos. A largo plazo, se espera que
aparezcan nuevos protocolos que estandaricen estos trabajos. Pero, por
el momento, no se usa otra tecnolog&iacute;a de enrutamiento que la RIP.
<P>Otro asunto concerniente al enrutamiento es la politica en la que se
basa el enrutamiento. En general, los protocolos de enrutamiento
pretenden encontrar el camino m&aacute;s corto o m&aacute;s r&aacute;pido posible para cada
datagrama. En algunos casos, esto no es lo deseable; a veces, por
razones de seguridad, razones econ&oacute;micas, etc, puede que deseemos
reservar algunos caminos para alg&uacute;n uso espec&iacute;fico. La mayor&iacute;a de los
<CODE>gateways</CODE> tienen la capacidad de controlar la propagaci&oacute;n de la
informaci&oacute;n de enrutamiento, lo que nos da algunas facilidades de
administraci&oacute;n sobre la forma en que estas rutas se usan, y el grado de
control que soportan var&iacute;a de un <CODE>gateway</CODE> a otro.
<P>
<P>
<H3>Administraci&oacute;n de Redes.</H3>

<P>La administraci&oacute;n de redes abarca un amplio n&uacute;mero de asuntos. En
general, se suelen tratar con muchos datos estad&iacute;sticos e informaci&oacute;n
sobre el estado de distintas partes de la red, y se realizan las acciones
necesarias para ocuparse de fallos y otros cambios. La t&eacute;cnica m&aacute;s
primitiva para la monitorizaci&oacute;n de una red es hacer "pinging" a los
<CODE>hosts</CODE> cr&iacute;ticos; el "pinging" se basa en un datagrama de "echo"
(eco), que es un tipo de datagrama que produce una r&eacute;plica inmediata
cuando llega al destino. La mayor&iacute;a de las implementaciones TCP/IP
incluyen un programa (generalmente, llamado "ping") que env&iacute;a un
echo a un <CODE>host</CODE> en concreto. Si recibimos r&eacute;plica, sabremos que
<CODE>host</CODE> se encuentra activo, y que la red que los conecta funciona;
en caso contrario, sabremos que hay alg&uacute;n error. Mediante "pinging" a
un razonable n&uacute;mero de ciertos <CODE>hosts</CODE>, podremos normalmente
conocer qu&eacute; ocurre en la red. Si los ping a todos los <CODE>hosts</CODE> de
una red no dan respuesta, es l&oacute;gico concluir que la conexi&oacute;n a dicha red,
o la propia red, no funciona.  Si s&oacute;lo uno de los <CODE>hosts</CODE> no da
respuesta, pero los dem&aacute;s de la misma red responden, es razonable
concluir que dicho <CODE>host</CODE> no funciona.
<P>T&eacute;cnicas m&aacute;s sofisticadas de monitorizaci&oacute;n necesitan conocer
informaci&oacute;n estad&iacute;stica y el estado de varios dispositivos de la red. Para
ello necesitar&aacute; llevar la cuenta de varias clases de datagramas, as&iacute; como
de errores de varios tipos. Este tipo de informaci&oacute;n ser&aacute; m&aacute;s detallada
en los <CODE>gateways</CODE>, puesto que el <CODE>gateway</CODE> clasifica los datagramas seg&uacute;n
protocolos e, incluso, &eacute;l mismo responde a ciertos tipos de datagramas.
Sin embargo, los bridges e incluso los repetidores con buffer
contabilizan los datagramas reenviados, errores de interface. Es posible
recopilar toda esta informaci&oacute;n en un punto de monitorizaci&oacute;n central.
<P>Tambi&eacute;n hay un enfoque oficial TCP/IP para llevar a cabo la
monitorizaci&ograve;n. En la primera fase, usamos un conjunto de protocolos
SGMP y SNMP, ambos dise&ntilde;ados para permitirnos recoger informaci&oacute;n
y cambiar los par&aacute;metros de la configuraci&oacute;n y otras entidades de la red.
Podemos ejecutar los correpondientes programas en cualquier
<CODE>host</CODE> de nuestra red. SGMP est&aacute; disponible para varios
<CODE>gateways</CODE> comerciales, as&iacute; como para sistemas Unix que act&uacute;an como
<CODE>gateway</CODE>. Cualquier implementaci&oacute;n SGMP necesita que se
proporciones un conjunto de datos para que pueda empezar a funcionar,
y tienen mecanismos para ir a&ntilde;adiendo informaciones que var&iacute;an de un
dispositivo a otro. A finales de 1988 apareci&oacute; una segunda generaci&oacute;n
de este protocolo, SNMP, que es ligeramente m&aacute;s sofisticado y necesita
m&aacute;s informaci&oacute;n para trabajar y, para ello, usa el llamado MIB
(Management Information Base). En lugar de usar una colecci&oacute;n de
variable SNMP, el MIB es el resultado de numerosas reuniones de
Comit&eacute;s formados por vendedores y usuarios. Tambi&eacute;n se espera la
elaboraci&oacute;n de un equivalente de TCP/IP de CMIS, el servicio ISO de
monitorizaci&oacute;n de redes. Sin embargo, CMIS y sus protocolos, CMIP,
todav&iacute;a no son est&aacute;ndares oficiales ISO, pero est&aacute;n en fase
experimental.
<P>En t&eacute;rminos generales, todos estos protocolos persiguen el mismo
objetivo: permitirnos recoger informaci&oacute;n cr&iacute;tica de una forma
estandarizada. Se ordena la emisi&oacute;n de datagramas UDP desde un
programa de administraci&oacute;n de redes que se encuentra ejecutando en
alguno de los <CODE>hosts</CODE> de red. Generalmente, la interacci&oacute;n
es bastante simple, con el intercambio de un par de datagramas: una
orden y una respuesta.  El mecanismo de seguridad tambi&eacute;n es bastante
simple, siendo posible que se incluyan passwords en las &oacute;rdenes. (En
SGMP nos referiremos a &eacute;stos como una "session name", en lugar de
password). Tambi&eacute;n existen mecanismos de seguridad m&aacute;s elaborados,
basados en la criptograf&iacute;a. 
<P>Probablemente querremos configurar la administraci&oacute;n de la red con
las herramientas que tenemos a nuestra disposici&oacute;n para controlar
diversas actividades. Para redes con pocas terminales, queremos
controlar cu&aacute;ndo nuestros dispositivos de conmutaci&oacute;n fallan, est&aacute;n
fuera de servicio por mantenimiento, y cuando haya fallos
en las l&iacute;neas de comunicaci&oacute;n u otro hardware. Es posible configurar
SGMP y SNMP para que usen "traps" (mensajes no solicitados) para un
<CODE>host</CODE> en particular o para una lista de <CODE>hosts</CODE> cuando
ocurre un evento cr&iacute;tico (por ejemplo, l&iacute;neas activas o desactivas). No
obstante, no es realista esperar que un dispositivo de conmutaci&oacute;n nos
notifique cuando falla. Tambi&eacute;n es posible que los mensajes "traps" se
pierdan por un fallo en la red, o por sobrecarga, as&iacute; que no podemos
depender completamente de los traps. No obstante, es conveniente
que nuestros dispositivos de conmutaci&oacute;n re&uacute;nan regularmente este tipo
de informaci&oacute;n. Hay varias herramientas que visualizan un mapa de la
red, donde los objetos cambian de color cuando cambian de estado, y
hay cuadros que muestran estad&iacute;sticas sobre los datagramas y otros
objetos.
<P>Otro tipo de  monitorizaci&oacute;n deseable es recolectar informaci&oacute;n para
hacer informes peri&oacute;dicos del porcentaje de uso de la red y prestaciones.
Para ello, necesitamos analizar cada dispositivo de conmutaci&oacute;n y
quedarnos con los datos de inter&eacute;s. En la Universidad de Rutgers
esto se hace cada hora, y se obtienen datos del n&uacute;mero de datagramas
reenviados a Internet u otra red, errores, varios, etc.; y se almacenan
informes detallados de cada d&iacute;a.  Hay informes mensuales en los que se
refleja el tr&aacute;fico que soporta cada <CODE>gateway</CODE> y algunas estad&iacute;sticas de
errores, elegidas para ver si hay un <CODE>gateway</CODE> que est&aacute; sobrecargado
(datagramasperdidos).
<P>Ser&iacute;a posible que cualquier tipo de conmutador pudiese usar cualquier
tipo de t&eacute;cnica de monitorizaci&oacute;n. Sin embargo, generalmente los
repetidores no proporcionan ning&uacute;n tipo de estad&iacute;stica, debido a que
normalmente no tienen ning&uacute;n procesador para abaratar su precio. Por
otro lado, es posible usar un <CODE>software</CODE> de administraci&oacute;n de redes con
repetidores con buffer, bridges y <CODE>gateways</CODE>. Los <CODE>gateways</CODE>, en la mayor&iacute;a
de los casos, incluyen un avanzado <CODE>software</CODE> de administraci&oacute;n de redes.
La mayor&iacute;a de los <CODE>gateways</CODE> pueden manejar IP y los protocolos de
monitorizaci&oacute;n anteriormente mencionados. Y la mayor&iacute;a de los bridges
tienen medios para poder recoger algunos datos de prestaciones. Puesto
que los bridges no est&aacute;n dirigidos a ning&uacute;n protocolo en particular, la
mayor&iacute;a de ellos no tienen el <CODE>software</CODE> necesario para implementar los
protocolos TCP/IP de administraci&oacute;n de redes. En algunas ocasiones, la
monitorizaci&oacute;n puede hacerse tecleando algunos comandos a una
consola a la que est&eacute; directamente conectada. (Hemos visto un caso
donde era necesario dejar el puente fuera de servicio para recoger estos
datos). En los restantes casos, es posible recoger datos a trav&eacute;s de la red,
pero el protocolo requerido no suele ser ning&uacute;n est&aacute;ndar.
<P>Excepto para algunas peque&ntilde;as redes, debemos insistir en que
cualquier dispositivo conmutador m&aacute;s complejo que un simple repetidor
es capaz de recolectar estad&iacute;sticas y alg&uacute;n mecanismo para hacernos con
ellas de forma remota. Aquellas partes de la red que no soporten dichas
operaciones pueden monitorizarse mediante pinging (aunque el ping
s&oacute;lo detecta errores graves, y no nos permite examinar el nivel de ruido
de una l&iacute;nea serie y otros datos necesarios para llevar a cabo un
mantenimiento de alta calidad). Se espera que la mayor&iacute;a del <CODE>software</CODE>
disponible cumpla los protocolos SGMP/SNMP y CMIS. Tambi&eacute;n un
<CODE>software</CODE> de monitorizaci&oacute;n no est&aacute;ndar, siempre y cuando sea soportado
por los equipos que tenemos.
<P>
<P>
<H3>Una evaluaci&oacute;n final.</H3>

<P>Vamos a reunir todo lo anterior indicando d&oacute;nde se usa cada tipo de
conmutador, normalmente:
<UL>
<LI>Los repetidores, normalmente, se restringen a un solo edificio.
Puesto que no nos proveen de un aislamiento al tr&aacute;fico, debemos
asegurarnos en todas las redes concectadas por los repetidores que
pueden hacer llegar todos sus ordenadores. Puesto que no suelen tener
herramientas de monitorizaci&oacute;n, no ser&aacute; deseable su uso para aquellos
enlaces que fallan a menudo.</LI>
<LI>Los bridges y <CODE>gateways</CODE> deben situarse de manera que se divida
la red en partes cuyo volumen de tr&aacute;fico sea manejable. Incluso se
podr&iacute;an emplazar bridges o <CODE>gateways</CODE> incluso en el caso de que no sean
necesarios por razones de monitorizaci&oacute;n.</LI>
<LI>Debido a que los bridges deben dejar pasar datagramas de
broadcast, hay un l&iacute;mite en el tama&ntilde;o de las redes que pueden conectar.
Por lo general, basta limitar estas redes con un ciento de m&aacute;quinas,
aproximadamente. Este n&uacute;mero puede ser mayor, si el <CODE>bridge</CODE> incluye
algunas facilidades de filtrado de datagramas.</LI>
<LI>Debido a que algunos tipos de redes son proclives al mal
funcionamiento, deberemos usar los bridges s&oacute;lo entre partes de la red
donde un solo grupo es responsable de diagnosticar los problemas.
Debemos estar locos para usar un <CODE>bridge</CODE> para conectar redes que
pertenecen a distintas organizaciones. Las partes de la red "de tipo
experimental" deber&aacute;n aislarse del resto de la red por <CODE>gateways</CODE>.</LI>
<LI>En muchas aplicaciones es m&aacute;s importante elegir un producto
con la adecuada combinaci&oacute;n de prestaciones, herramientas de
administraci&oacute;n de la red y otras caracter&iacute;sticas, para tomar la decisi&oacute;n
de elegir entre bridges y <CODE>gateways</CODE>.</LI>
</UL>
     
<P>
<P>
<H2><A NAME="s7">7. Configurando gateways</A></H2>

<P>Vamos a ver algunos aspectos espec&iacute;ficos de la configuraci&oacute;n de
<CODE>gateways</CODE>. Aquellos <CODE>gateways</CODE> que entienden el protocolo IP son, al
mismo tiempo, <CODE>hosts</CODE> de Internet y, por tanto, podemos poner
en pr&aacute;ctica lo visto para configurar las direcciones y el enrutamiento en
los <CODE>hosts</CODE>. No obstante, la forma exacta de c&oacute;mo debemos
configurar un <CODE>gateway</CODE> depende del modelo en concreto. En algunos
casos, deberemos editar algunos ficheros inclu&iacute;dos en un disco del
propio <CODE>gateway</CODE>. Sin embargo, por razones de fiabilidad, la mayor&iacute;a de
los <CODE>gateways</CODE> no tienen discos propios; en su lugar, esta informaci&oacute;n se
almacena en una memoria no vol&aacute;til o en ficheros que se cargan desde
uno o varios <CODE>hosts</CODE> de la red.
<P>Como m&iacute;nimo, para configurar el <CODE>gateway</CODE> hay que especificar la
direcci&oacute;n IP y la m&aacute;scara de cada interface, y activar un protocolo de
enrutamiento adecuado. Normalmente ser&aacute; deseable configurar otros
par&aacute;metros.
<P>Un par&aacute;metro importante a tener en cuenta es la direcci&oacute;n de
broadcast. Como explicamos con anterioridad, hay cierto <CODE>software</CODE>
antiguo que no funciona bien cuando se env&iacute;an broadcasts usando los
nuevos protocolos de direcciones de broadcast. Por esta raz&oacute;n, algunos
modelos nos permiten elegir una direcci&oacute;n broadcast para cada
interface. Por tanto, en ese caso, se deber&aacute;n configurar teniendo en cuenta
los ordenadores que hay en la red. En general, si los ordenadores soportan
los actuales est&aacute;ndares, podr&aacute; usarse una direcci&oacute;n del tipo
255.255.255.255. No obstante, antiguas implementaciones deben
comportarse mejor con otro tipo de direcciones, especialmente con
aquellas direcciones que usan ceros para los n&uacute;meros del <CODE>host</CODE>
(para la red 128.6 &eacute;sta tendr&iacute;a que ser 128.6.0.0. Para mantener la
compatibilidad con redes que no soportan sub-redes deber&iacute;amos usar
128.6.0.0 como direcci&oacute;n de broadcast, incluso para una subred del tipo
128.6.4). Podemos observar nuestra red con un monitor de red y ver los
resultados de las distintas elecciones de direciones de broadcast; en caso
de que hagamos una mala elecci&oacute;n, cada vez que hagamos un broadcast
para  actualizar el enrutamiento, muchas m&aacute;quinas de nuestra red
nos responder&iacute;an con errores ARP o ICMP. Hay que hacer notar que
cuando cambiamos las direcciones de broadcast en el <CODE>gateway</CODE>,
necesitaremos cambiarla tambi&eacute;n en cada uno de los ordenadores. Lo
que se suele hacer es cambiar la direcci&oacute;n de aquellos sistemas que
podemos configurar, para hacerlos compatibles con los otros sistemas
que no podemos configurar.
<P>Hay otros par&aacute;metros de la interface que pueden que sea necesario
configurar para trabajar con las peculiaridades de la red a la que se
conectan. Por ejemplo, muchos <CODE>gateways</CODE> comprueban sus interfaces a
Ethernet para asegurarse de que el cable al que se conectan y el
transceiver funcionan correctamente. Algunos de estos tests no
funcionan correctamente con la antigua versi&oacute;n 1 de transceiver
Ethernet. En caso de que usemos un transceiver de este tipo, deberemos
desactivar este tipo de test. De forma similar, los <CODE>gateways</CODE> conectados a
l&iacute;neas en serie normalmente hacen este tipo de test para verificar su
buen funcionamiento, y tambi&eacute;n hay situaciones en las que
necesitaremos deactivar el test.
<P>Es bastante usual que tengamos que activar las opciones necesarias
para el <CODE>software</CODE> que tengamos que usar. Por ejemplo, muchas veces es
necesario activar expl&iacute;citamente el protocolo de administraci&oacute;n de red,
y dar el nombre o la direcci&oacute;n del <CODE>host</CODE> donde se ejecuta el
<CODE>software</CODE> que acepta traps (mensajes de error).
<P>La mayor&iacute;a de los <CODE>gateways</CODE> tienen opciones relacionadas con la
seguridad. Como m&iacute;nimo, hay que indicar un password para poder hacer
cambios de forma remota (y una "session name" para SGMP). Si
queremos controlar el acceso a ciertas partes de la red, tambi&eacute;n
deberemos definir una lista de control de accesos, o cualquier otro
mecanismo que use el <CODE>gateway</CODE> en cuesti&oacute;n.
<P>Los <CODE>gateways</CODE> cargan la informaci&oacute;n de la configuraci&oacute;n a trav&eacute;s de la
red. Cuando un <CODE>gateway</CODE> arranca, env&iacute;a una petici&oacute;n broadcast de varias
clases, intentando conocer su direcci&oacute;n Internet para luego cargar su
configuraci&oacute;n. As&iacute;, hay que asegurarse que haya algunos ordenadores
capaces de responder a dichas peticiones. En algunos casos, hay alg&uacute;n
micro dedicado ejecutando un <CODE>software</CODE> especial. Otras veces, hay un
<CODE>software</CODE> gen&eacute;rico que podemos ejecutar en varias m&aacute;quinas. Por razones
de fiabilidad, debemos comprobar que hay m&aacute;s de un <CODE>host</CODE> con
la informaci&oacute;n y los programas que necesita. En algunos casos
tendremos que mantener varios archivos distintos. Por ejemplo, los
<CODE>gateways</CODE> usados en Groucho usan un programa llamado "bootp" para
que le proporcione su direcci&oacute;n Internet, y luego cargan el c&oacute;digo y la
informaci&oacute;n de la configuraci&oacute;n usando TFTP. Esto significa que
tenemos que mantener un archivo para "bootp" que  contiene las
direcciones Ethernet e Internet para cada <CODE>gateway</CODE>, y un conjunto de
archivos para la restante informaci&oacute;n de cada uno de ellos. Si una red es
muy grande, podemos tener problemas para asegurarnos de que esta
informaci&oacute;n permanece consistente. Podemos mantener copias nuestras
de todas las configuraciones en un &uacute;nico ordenador y que se distribuya a
otros sistemas cuando haya alg&uacute;n cambio, usando las facilidades make
y rdist de Unix. Si nuestro <CODE>gateway</CODE> tiene la opci&oacute;n de almacenar la
informaci&oacute;n de la configuraci&oacute;n en una memoria no vol&aacute;til, podremos
eliminar todos estos problemas log&iacute;sticos, pero presenta sus propios
problemas. El contenido de esta memoria deber&iacute;a almacenarse en
alguna localizaci&oacute;n central, porque de todas maneras es dif&iacute;cil para el
personal de administraci&oacute;n de la red revisar la configuraci&oacute;n si se
encuentra distribu&iacute;da entre los distintos <CODE>gateways</CODE>.
<P>Arrancar un <CODE>gateway</CODE> que carga la informaci&oacute;n de su configuraci&oacute;n
desde una localizaci&oacute;n distante es especialmente arriesgado. Los
<CODE>gateways</CODE> que necesitan cargar su informaci&oacute;n de configuraci&ograve;n a trav&eacute;s
de la red, generalmente emiten una petici&oacute;n broadcast a todas las redes
que conectan. Si alg&uacute;n ordenador de una de esas redes es capaz de
responder, no habr&aacute; ning&uacute;n problema. Sin embargo, algunos <CODE>gateways</CODE>
que se encuentren a gran distancia donde los ordenadores de su
alrededor no soportan los protocolos necesarios, en cuyo caso es
necesario que las respuestas le lleguen a trav&eacute;s de una red donde haya
unos ordenadores apropiados. Desde un punto de vista estricto, esto va
en contra de la filosof&iacute;a de trabajo de los <CODE>gateways</CODE>, ya que normal
mente un <CODE>gateway</CODE> no permite que un broadcast procedente de una red
pase a trav&eacute;s de una red adyacente.
Para permitir que un <CODE>gateway</CODE> obtenga informaci&oacute;n de un ordenador en
una red distinta, al menos uno de los <CODE>gateways</CODE> que est&aacute; entre ellos
tendr&aacute; que configurarse para que pase una clase especial de broadcast
usado para recuperar este tipo de informaci&oacute;n. Si tenemos este tipo de
configuraci&oacute;n, tendremos que comprobar este proceso peri&oacute;dicamente,
ya que no es raro que nos encontremos con que no podamos arrancar un
<CODE>gateway</CODE> tras un fallo de energ&iacute;a, debido a un cambio en la configuraci&oacute;n
en otro <CODE>gateway</CODE> que hace imposible cargar esta informaci&oacute;n.
<P>
<P>
<H2>7.1 Configurando el enrutamiento de los gateways</H2>

<P>Por &uacute;ltimo, vamos a tratar c&oacute;mo configurar el enrutamiento. Este tipo
de configuraci&oacute;n es m&aacute;s dif&iacute;cil para un <CODE>gateway</CODE> que para un
<CODE>host</CODE>. La mayor&iacute;a de los expertos TCP/IP recomiendan dejar las
cuestiones de enrutamiento a los <CODE>gateways</CODE>. As&iacute;, los <CODE>hosts</CODE>
simplemente tienen una ruta por defecto que apunta al <CODE>gateway</CODE> m&aacute;s
cercano (por supuesto, los <CODE>gateways</CODE> no pueden configurarse de esta
manera. Ellos necesitan tablas completas de enrutamiento).
<P>Para entender c&oacute;mo configurar un <CODE>gateway</CODE>, vamos a examinar con un
poco m&aacute;s de detalle c&oacute;mo los <CODE>gateways</CODE> se comunican las rutas.
<P>Cuando encendemos un <CODE>gateway</CODE>, la &uacute;nica red de la que tiene
informaci&oacute;n es aqu&eacute;lla a la que est&eacute; directamente conectado (lo que se
especifica en la configuraci&oacute;n). Para llegar a saber c&oacute;mo se llega a
partes m&aacute;s distantes de la red, marca alg&uacute;n tipo de "protocolo de
enrutamiento", que simplemente es un protocolo que permite a cada
<CODE>gateway</CODE> anunciar a qu&eacute; redes tiene acceso, y extender esa informaci&oacute;n
de un <CODE>gateway</CODE> a otro. Eventualmente, cada <CODE>gateway</CODE> deber&iacute;a saber c&oacute;mo
llegar a cada red. Hay distintos tipos de protocolos de enrutamiento; en
el m&aacute;s com&uacute;n, los <CODE>gateways</CODE> se comunican  exclusivamente con los m&aacute;s
cercanos; en otra clase de protocolos, cada <CODE>gateway</CODE> construye una base
de datos describiendo cada <CODE>gateway</CODE> del sistema. No obstante, todos
estos protocolos encuentran c&oacute;mo llegar a cualquier destino.
<P>Una m&eacute;trica es un n&uacute;mero, o conjunto de n&uacute;meros, usado para
comparar rutas. La tabla de enrutamiento se construye recogiendo
informaci&oacute;n de otros <CODE>gateways</CODE>. Si dos <CODE>gateways</CODE> son capaces de llegar a
un mismo destino, debe de haber alg&uacute;n m&eacute;todo para decidir cu&aacute;l usar.
La m&eacute;trica se usa para tomar esta decisi&oacute;n. Todas las m&eacute;tricas indican de 
alguna forma lo "costoso" de una ruta. Podr&iacute;a ser cu&aacute;ntos d&oacute;lares
costar&iacute;a enviar un datagrama por una ruta, el retraso en milisegundos, o
cualquier otra medida. La m&eacute;trica m&aacute;s simple es el n&uacute;mero de <CODE>gateways</CODE>
que hay hasta el destino ("cuenta de saltos"), y es la que generalmente
se encuentra en los ficheros de configuraci&oacute;n.
<P>Como m&iacute;nimo, una configuraci&oacute;n de enrutamiento consistir&iacute;a en un
comando para activar el protocolo de enrutamiento que vayamos a usar.
La mayor&iacute;a de los <CODE>gateways</CODE> est&aacute;n orientados para usar un protocolo; a
no ser que tengamos razones para usar otro, es recomendable usar dicho
protocolo. Una raz&oacute;n habitual para elegir otro protocolo es para hacerlo
compatible con otros <CODE>gateways</CODE>. Por ejemplo, si nuestra red est&aacute; conecta
da a una red nacional que nos exige usar EGP ("exterior <CODE>gateway</CODE>
protocol") para que se pueda intercambiar rutas con ella, EGP s&oacute;lo es
apropiado para este caso espec&iacute;fico. No deberemos usar EGP dentro de
nuestra propia red, sino s&oacute;lo para comunicarnos con la red nacional. Si
tenemos varias clases de <CODE>gateways</CODE>, necesitaremos usar un protocolo
entendible por todos ellos. En muchas ocasiones este protocolo ser&aacute; RIP
(Routing Information Protocol). A veces podremos usar protocolos m&aacute;s
complejos entre los <CODE>gateways</CODE> que los soporten, y usar RIP s&oacute;lo cuando
nos comuniquemos con <CODE>gateways</CODE> que no entiendan estos protocolos.
<P>Si ya hemos elegido un protocolo de enrutamiento y lo hemos puesto
en marcha, todav&iacute;a nos quedan por tomar algunas decisiones. Una de las
tareas mas b&aacute;sicas de configuraci&oacute;n que tenemos que completar es
uministrar la informaci&oacute;n de la m&eacute;trica. Los protocolos m&aacute;s simples,
como RIP, normalmente usan "cuenta de saltos", de manera que una
ruta que pasa a trav&eacute;s de dos <CODE>gateways</CODE> es mejor que una que pasa por
tres. Por supuesto, si la &uacute;ltima ruta usa l&iacute;neas de 1'5 Mbps y la primera
l&iacute;neas de 9.600 bps, ser&iacute;a una mala elecci&oacute;n. La mayor&iacute;a de los
protocolos de enrutamiento tienen medios para tomar esto en cuenta.
Con RIP, podr&iacute;amos tratar las l&iacute;neas de 9.600 bps como si fueran
"saltos" adicionales, de manera que la mejor l&iacute;nea (la m&aacute;s r&aacute;pida) tenga
una m&eacute;trica menor. Otros protocolos m&aacute;s sofisticados tendr&aacute;n en cuenta
la velocidad de la l&iacute;nea de forma autom&aacute;tica. Generalmente, estos
par&aacute;metros deber&aacute;n asociarse a una interface en particular. Por ejemplo,
con RIP deberemos establecer expl&iacute;citamente el valor de la m&eacute;trica, si
se est&aacute; conectado con una l&iacute;nea de 9.600 bps. Con aquellos protocolos
que tienen en cuenta la velocidad de las l&iacute;neas, deberemos de
especificar la velocidad de las l&iacute;neas (si el <CODE>gateway</CODE> no los puede
configurar autom&aacute;ticamente).
<P>La mayor parte de los protocolos de enrutamiento han sido dise&ntilde;ados
para que cada <CODE>gateway</CODE> se aprenda la topolog&iacute;a de toda la red, y elegir 
la mejor ruta posible para cada datagrama. En algunos casos no estaremos
interesados en la mejor ruta; por ejemplo, puede que estemos interesados
en que el datagrama se desplace por una parte de la red por razones de
seguridad o econ&oacute;micas. Una manera de tener este control es
especificando opciones de enrutamiento. Dichas opciones var&iacute;an mucho
de un <CODE>gateway</CODE> a otro, pero la estrategia b&aacute;sica es que si el resto 
de la red no conoce dicha ruta, no ser&aacute; utilizada. Estos controles limitan 
la forma en la que se van a usar las rutas.
<P>Hay m&eacute;todos para que el usuario ignore las decisiones de
enrutamiento hechas por los <CODE>gateways</CODE>. Si realmente necesitamos
controlar el acceso a ciertas redes, podemos hacer dos cosas:
<UL>
<LI>los controles de enrutamiento nos aseguran que los <CODE>gateways</CODE> usan s&oacute;lo
las rutas que queremos;</LI>
<LI>usar listas de control de acceso en los <CODE>gateways</CODE> adyacentes a 
las redes controladas.</LI>
</UL>
<P>Estas dos opciones trabajan a distinto nivel. Los controles de
enrutamiento afectan a lo que ocurre a la mayor&iacute;a de los datagramas:
aqu&eacute;llos en los que el usuario no ha especificado manualmente una ruta.
Nuestro mecanismo de enrutamiento ha de ser capaz de elegir una ruta
aceptable para ellos. Una lista de control de acceso a&ntilde;ade una limitaci&oacute;n
adicional, preserv&aacute;ndonos de usuarios que incluyesen su propio
enrutamiento y pasasen nuestros controles.
<P>Por razones de fiabilidad y seguridad, puede que tambi&eacute;n haya
controles con listas de <CODE>gateways</CODE> de las que podemos aceptar
informaci&oacute;n. Tambi&eacute;n es posible hacer una clasificaci&oacute;n de prioridad.
Por ejemplo, podemos decidir hacer antes los enrutamientos de nuestra
propia organizaci&oacute;n antes que los de otras organizaciones, u otras partes
de la organizaci&oacute;n.  Esto tendr&aacute; el efecto de dar preferencia al tr&aacute;fico
interno frente al externo, incluso si el externo parece ser mejor.
<P>Si usamos varios protocolos distintos de enrutamiento, probablemente
tendremos que afrontar algunas decisiones respecto a la informaci&oacute;n que
se pasan entre ellos. Puesto que el uso de varios protocolos de
enrutamiento est&aacute; frecuentemente asociado a la existencia de varias
organizaciones, deberemos de tomar la precauci&oacute;n de hacer estas
decisiones consultando con los administradores de las redes de dichas
organizaciones.
Este tipo de decisiones puede tener consecuencias en las otras redes
bastante dif&iacute;ciles de detectar. Podr&iacute;amos pensar que la mejor forma de
configurar un <CODE>gateway</CODE> es que fuese capaz de entender todos los
protocolos, pero hay algunas razones por las que esto no es
recomendable:
<UL>
<LI>Las m&eacute;tricas usadas por los distintos protocolos no son
compatibles en muchas ocasiones. Si estamos conectados a dos redes
externas distintas, podemos especificar que una siempre debe usarse
preferentemente a la otra, o que la m&aacute;s cercana es la que debe usarse, en
lugar de comparar la m&eacute;trica recibida de las dos redes para ver cu&aacute;l
tiene la mejor ruta.</LI>
<LI>EGP es especialmente delicado, ya que no admite bucles. Por
esto hay unas reglas estrictas para regular la informaci&oacute;n que hay que
intercambiar para comunicarse con una red principal usando EGP. En
aquellos casos en que se use EGP, el administrador de la red principal
deber&iacute;a ayudarnos a  configurar el enrutamiento.</LI>
<LI>Si tenemos l&iacute;neas lentas en nuestra red (9.600 bps o menos),
puede que no queramos enviar la tabla de enrutamiento completa a
trav&eacute;s de la red. Si nos conectamos a una red exterior, tenemos la
posibilidad de tratarla como una ruta por defecto, en lugar de introducir
toda su informaci&oacute;n en nuestro protocolo de enrutamiento.</LI>
</UL>
<P>
<H2><A NAME="s8">8. Anexo: Copyright</A></H2>

<P><BR> Computer Science Facilities Group. 
<P><BR> RUTGERS.  <BR>
 The State University of New Jersey<BR>
 Center for Computers and  Information Services.<BR>
 Laboratory for Computer Science Research. 
<P><BR> Copyright © 1988 Charles L. Hedrick. Cualquiera puede reproducir este 
documento en su totalidad o en parte, comprometi&eacute;ndose a: (1) que en 
cualquier copia o publicaci&oacute;n debe aparecer Rutgers University como fuente, 
y debe incluir este mensaje; y (2) cualquier otro uso de este material debe 
hacer referencia a este manual y a Rutgers University, y al hecho de que este 
material es copyright de Charles Hedrick y es usado bajo su permiso. 
<P><BR> Unix es  una marca registrada de AT&amp;T Technologies.
<P><BR> 23 de Septiembre de 1988 
<P>
<P>
</BODY>
</HTML>
