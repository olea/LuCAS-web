<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.34">
 <META NAME="LFCATEGORY" CONTENT="SoftwareDevelopment">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf233, SoftwareDevelopment: Introducci&oacute;n a Ncurses</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 p.cl { color:#EE9500 }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 .mark  { background-color:#e6e6ff }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://www.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Reha K. Ger&ccedil;eker
 =LF=CAT___: SoftwareDevelopment
 =LF=TITLE_: Introducci&oacute;n a Ncurses
 =LF=NUMBER: 233
 =LF=ANAME_: article233.html
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top"><A class="nodec" href="../"><FONT color=
                 "#DDDDDD" size="2">Hogar</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Mapa</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Indice</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../Search/"><FONT color=
                 "#DDDDDD" size="2">Busqueda</FONT></A> </TD>
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/"><FONT color=
           "#FFFFFF">Noticias</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/"><FONT color=
           "#FFFFFF">Arca</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/"><FONT color=
           "#FFFFFF">Enlaces</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">Sobre LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!--#include virtual="../../dynahead.shtml" -->

<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT BIO ABOUT THE AUTHOR -->
<TABLE ALIGN=LEFT BORDER=0  WIDTH="190" summary="about the author">
<TR>
<TD>

<!-- 2pdaIgnoreStart -->
<!-- PALM DOC -->
<TABLE BORDER=0 hspace=4 vspace=4 summary="pda download"> <TR> <TD>
<font size=1> <img src="../../common/images/2doc.gif" width=34 align=left border=0 height=22 alt="convert to palm"><a href="http://cgi.linuxfocus.org/cgi-bin/2ztxt">Convert to GutenPalm</a><br>or <a href="http://cgi.linuxfocus.org/cgi-bin/2pda">to PalmDoc</a></font>
</TD> </TR> </TABLE>
<!-- END PALM DOC -->
<!-- 2pdaIgnoreStop -->
<br>
<img src="../../common/images/RehaGerceker.jpg" width="178" height="243" alt="[RehaGerceker]">
<BR>por  Reha K. Ger&ccedil;eker <br> <small>&lt;gerceker(at)itu.edu.tr&gt;</small>
<BR><BR>
<I>Sobre el autor:</I><BR>
<!-- aboutauthor_start -->
<p>
Reha es un estudiante de ingenieria de computadoras en Estambul, Turqu&iacute;a.
Le encanta la libertad que le proporciona Linux como plataforma
de   desarrollo   de software. Gasta gran parte de su tiempo enfrente de
su ordenador,   escribiendo   programas. Desea llegar a ser un programador
elegante   alg&uacute;n  d&iacute;a.
</p>
<!-- aboutauthor_stop -->
<!-- TRANSLATED TO es -->
<BR><BR><I>Taducido al espa&ntilde;ol por:</I><BR>
V&iacute;ctor J. Gonz&aacute;lez <small>&lt;rution(at)hotmail.com&gt;</small>
<br>
<!--
 =LF=TRANSTO=es: V&iacute;ctor J. Gonz&aacute;lez
-->
<!-- TRANSLATED TO STOP -->
<BR><i>Contenidos</i>:
<UL>
  <LI><A HREF="#233lfindex0">&iquest;Qu&eacute; es Ncurses?</A></LI>
  <LI><A HREF="#233lfindex1">&iquest;Donde descargarlo?</A></LI>
  <LI><A HREF="#233lfindex2">Lo b&aacute;sico</A></LI>
  <LI><A HREF="#233lfindex3">Actualizando la pantalla: refresh</A></LI>
  <LI><A HREF="#233lfindex4">Creando nuevas ventanas</A></LI>
  <LI><A HREF="#233lfindex5">Escribir a Ventanas, Leer de Ventanas</A></LI>
  <LI><A HREF="#233lfindex6">Cursores F&iacute;sicos y L&oacute;gicos</A></LI>
  <LI><A HREF="#233lfindex7">Borrando en Ventanas</A></LI>
  <LI><A HREF="#233lfindex8">Usando Colores</A></LI>
  <LI><A HREF="#233lfindex9">Recuadros Alrededor de Ventanas</A></LI>
  <LI><A HREF="#233lfindex10">Teclas de Funci&oacute;n</A></LI>
  <LI><A HREF="#233lfindex11">Un Ejemplo</A></LI>
  <LI><A HREF="#233lfindex12">Conclusi&oacute;n</A></LI>
  <LI><A HREF="#233lfindex13">Referencias</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=233">Formulario de "talkback" para este art&iacute;culo</A></LI>
</UL>

</TD></TR></TABLE>
<!-- HEAD OF THE ARTICLE -->
<br>&nbsp;
<table border="0"><tr><td>
<H2>Introducci&oacute;n a Ncurses</H2>
 <img src="../../common/images/article233/ncurses.gif" width="153" height="160" alt="[ncurses]">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Resumen</i>:
<P>
<!-- articleabstract_start -->
<p>
Ncurses es una librer&iacute;a que proporciona mapeado
de  las   teclas   de funci&oacute;n, funciones de dibujado en pantalla
y  la habilidad   de usar   m&uacute;ltiples ventanas no solapadas en terminales
de texto.
</P>
<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- BODY OF THE ARTICLE -->


<A NAME="233lfindex0">&nbsp;</A>
<H2>&iquest;Qu&eacute; es Ncurses?</H2>


<p>&iquest;Quiere que sus programas tengan una colorida interfaz basada en
el terminal? Ncurses es una librer&iacute;a que proporciona funcionalidad
de ventanas para terminales de texto. Algunas cosas que ncurses es
capaz      de hacer son:</p>

<ul>
<li>Usar la pantalla completa como quieras.</li>
<li>Crear y controlar ventanas.</li>
<li>Usar 8 colores diferentes.</li>
<li>Darle a su programa soporte para el rat&oacute;n.</li>
<li>Usar las teclas de funci&oacute;n del teclado.</li>
</ul>

<p>Es posible usar ncurses en cualquier sistema Unix que sigua la norma ANSI/POSIX.
Aparte de esto la librer&iacute;a es capaz de detectar las propiedades
del   terminal de la base de datos del sistema y actuar en consecuencia,
proporcionando   una interfaz independiente del terminal. Por lo tanto,
ncurses  puede ser usado   con garant&iacute;as para dise&ntilde;os que
vayan  a trabajar en  diferentes plataformas   y terminales..</p>

<p>Midnight Commander es un ejemplo de un programa que utiliza ncurses.
Tambi&eacute;n la interfaz utilizada para la configuraci&oacute;n del
kernel    est&aacute; escrita con ncurses. M&aacute;s abajo se pueden ver
unas capturas    de pantalla de estos ejemplos.</p>
<br clear="all">
<img src="../../common/images/article233/mc.jpg"
width="526" height="423" alt="    [Midnight Commander]">
<br>
<img src="../../common/images/article233/menuconfig.jpg" width="526"
height="423" alt="    [kernel config]">

<A NAME="233lfindex1">&nbsp;</A>
<H2>&iquest;Donde descargarlo?</H2>


<p>Ncurses est&aacute; desarrollado bajo GNU/Linux. Para descargar la &uacute;ltima
versi&oacute;n, ver informaci&oacute;n detallada y encontrar otros
enlaces,       visite&nbsp; <a
href="http://www.gnu.org/software/ncurses/">www.gnu.org/software/ncurses/</a>.</p>

<A NAME="233lfindex2">&nbsp;</A>
<H2>Lo b&aacute;sico</H2>


<p>Para utilizar la librer&iacute;a, debe incluir curses.h en su c&oacute;digo
y asegurarse de enlazar su c&oacute;digo con la librer&iacute;a curses.
Eso  se hace pasando el par&aacute;metro -lcurses a gcc.</p>

<p>Es necesario tener alg&uacute;n conocimiento acerca de la estructura b&aacute;sica
de datos cuando se trabaja con ncurses. Esta es la estructura WINDOW
y,   como  indica su nombre, es usada para representar las ventanas que
se creen. Casi   todas  las funciones de la librer&iacute;a tienen un puntero
a WINDOW como   par&aacute;metro.</p>

<p>Los componentes m&aacute;s usados de ncurses son las ventanas. Incluso
si no crea sus propias ventanas, la pantalla es considerada como una
ventana.     As&iacute; como el descriptor FILE stdout de la librer&iacute;a
est&aacute;ndar     de E/S representa la pantalla (cuando no hay redirecciones),
ncurses tiene el puntero de tipo WINDOW stdscr, otro puntero de tipo
WINDOW     llamado curscr tambi&eacute;n es definido en la librer&iacute;a.
Mientras stdscr representa     la pantalla, curscr representa la pantalla
actual conocida por la librer&iacute;a.     Aqu&iacute; se preguntar&aacute;:
"&iquest;Cu&aacute;l es la diferencia?".    Siga leyendo.</p>

<p>Para poder usar las funciones y variables de ncurses, primero tiene que
llamar a la funci&oacute;n initscr. Esta funci&oacute;n asigna memoria
para   variables tales como stdscr o curscr y prepara la librer&iacute;a
para   ser usada. En otras palabras, todas las funciones de ncurses tienen
que ir  despu&eacute;s de la llamada a initscr. As&iacute;mismo, debe llamar
a endwin  una vez que haya acabado con ncurses. Esto libera la memoria
usada    por ncurses.  Despu&eacute;s de llamar a endwin no podr&aacute; usar
ninguna    funci&oacute;n  de ncurses a menos que vuelva a llamar a initscr.</p>

<p>Entre las llamadas a initscr y endwin, aseg&uacute;rese de no enviar la
salida a pantalla usando las funciones de la librer&iacute;a est&aacute;ndar
de E/S. Si no, es probable que la salida en pantalla se corrompa
y no se parezca en nada a lo que quer&iacute;a. Cuando    ncurses est&aacute;
activo, use &uacute;nicamente sus funciones para enviar la salida a pantalla.
Antes de llamar a initscr o despu&eacute;s de llamar a endwin puede hacer
lo que desee.&nbsp;</p>

<A NAME="233lfindex3">&nbsp;</A>
<H2>Actualizando la pantalla: refresh</H2>


<p>La estructura WINDOW no solamente guarda la altura, anchura y posici&oacute;n
de la ventana, sino que tambi&eacute;n almacena su contenido. Cuando
usted     escribe en una ventana, los contenidos de la ventana son cambiados,
pero   eso  no significa que esos cambios aparezcan en la pantalla inmediatamente.
Para  que los cambios se muestren en pantalla hay que llamar a las funciones
refresh  o wrefresh.</p>

<p>Aqu&iacute; est&aacute; la diferencia entre stdscr y curscr. Mientras
que curscr almacena el contenido de la pantalla actual, stdscr puede tener
una informaci&oacute;n diferente despu&eacute;s de las llamadas a las funciones
de salida de ncurses. Si desea que los &uacute;ltimos cambios sobre
stdscr      sean volcados en curscr, entonces tendr&aacute; que llamar a
la funci&oacute;n      refresh. En otras palabras, refresh es la &uacute;nica
funci&oacute;n  que   trata con con curscr. Es recomendable que no se l&iacute;e
con curscr y deje que sea la funci&oacute;n refresh quien se encargue de
actualizarlo.</p>

<p>refresh tiene un mecanismo para actualizar la pantalla lo m&aacute;s r&aacute;pidamente
posible. Cuando la funci&oacute;n es llamada, solamente actualiza las
l&iacute;neas    de la ventana que hayan sido cambiadas. Esto ahorra tiempo de
CPU  y evita    al programa tener que volver a escribir la misma informaci&oacute;n
en pantalla..   Este mecanismo es la raz&oacute;n por la que las funciones
de ncurses y las  funciones de E/S est&aacute;ndar pueden producir resultados
err&oacute;neos   cuando son usadas conjuntamente. Cuando las funciones
de  ncurses son llamadas   &eacute;stas fijan un indicador que indica a refresh
cu&aacute;les son las   l&iacute;neas que han cambiado, nada de &eacute;sto
ocurre cuando se llama   a las funciones de la librer&iacute;as de E/S
est&aacute;ndar.</p>

<p>refresh y wrefresh b&aacute;sicamente hacen lo mismo. wrefresh toma un
puntero a WINDOW como par&aacute;metro y &uacute;nicamente actualiza
el   contenido  de &eacute;sta ventana. refresh() es equivalente a wrefresh(stdscr).
Como  se ver&aacute; m&aacute;s tarde, al igual que wrefresh, la mayor&iacute;a
de las funciones de ncurses tienen macros que aplican estas funciones
a  stdscr.</p>

<A NAME="233lfindex4">&nbsp;</A>
<H2>Creando nuevas ventanas</H2>


<p>Hablemos ahora un poco de subwin y newwin, las funciones para crear nuevas
ventanas. Estas funciones toman la altura, el ancho y las coordenadas
de   la esquina superior izquierda de la nueva ventana como par&aacute;metros
y devuelven un puntero de tipo WINDOW que apunta a su nueva ventana.
Este    puntero puede ser usado por wrefresh y otras funciones que se ver&aacute;n
m&aacute;s adelante.</p>

<p>"&iquest;Si hacen lo mismo, por qu&eacute; duplicar las funciones?" se
puede preguntar usted. Est&aacute; en lo cierto, hay peque&ntilde;as diferencias,
subwin crea una nueva ventana que es subventana de otra. Una ventana
creada   de esta forma hereda las propiedades de la ventana padre. Estas
propiedades   pueden ser cambiadas m&aacute;s adelante sin afectar a la ventana
padre.</p>

<p>Aparte de esto, hay una cosa que las mantiene unidas. La matriz de caracteres
que almacena los contenidos de la ventana son compartidos entre las
ventanas      padre e hijo. En otras palabras, los caracteres que est&eacute;n
en la   intersecci&oacute;n   de las dos ventanas pueden ser cambiados por
cualquiera   de ellas. Si la ventana  padre escribe en dicho &aacute;rea, el contenido
de la ventana hija tambi&eacute;n cambia, y a tambi&eacute;n la inversa.
</p>

<p>Al contrario que subwin, newwin crea una ventana totalmente nueva. Esa ventana,
a menos que tenga sus propias subventanas, no compartir&aacute; su matriz
de caracteres con ninguna otra ventana. La ventaja de usar subwin es
que    al usar una matriz de caracteres compartida el gasto de memoria es
menor.    Por otro lado, cuando las ventanas empiezan a escribirse unas sobre
otras,   el uso de newwin tiene sus propias ventajas.</p>

<p>Puede crear sus propias subventanas hasta cualquier profundidad. Cada subventana
puede tener a su vez sus propias subventanas, pero entoces tiene que tener
en cuenta que la matriz de caracteres ser&aacute; compartida por m&aacute;s
de dos ventanas.</p>

<p>Cuando haya acabado con la ventana que ha creado, puede borrarla con la
funci&oacute;n delwin. Le aconsejo que consulte las p&aacute;ginas del
man   para ver la lista de par&aacute;metros de est&aacute;s funciones.</p>

<A NAME="233lfindex5">&nbsp;</A>
<H2>Escribir a Ventanas, Leer de Ventanas</H2>


<p>Hemos hablado acerca de stdscr, curscr, refrescar la pantalla y crear nuevas
ventanas. &iquest;Pero que pasa cuando escribimos en una ventana? &iquest;O
cuando leemos datos de una ventana?</p>

<p>Las funciones usadas para ello son similares a sus contrapartidas de la librer&iacute;a
de E/S est&aacute;ndar. Entre estas funciones est&aacute; printw en
lugar      de printf, scanw en lugar de scanf, addch en lugar de putc o putchar,
getch    en lugar de getc o getchar. Estas funciones se usan de la forma
usual, s&oacute;lo   sus nombres son diferentes. De forma similar, addstr
puede ser utilizada  para escribir una cadena en una ventana y getstr para
leer una cadena de una ventana. Todas esta funciones, con la letra 'w' al
principio de su nombre  y un puntero a WINDOW como primer par&aacute;metro
hacen su trabajo en una  ventana diferente a stdscr. Por ejemplo, printw
(...) y wprintw(stdscr, ...)  son equivalentes, as&iacute; como refresh()
y wrefresh(stdscr).</p>

<p>Entrar en detalles con estas funciones llevar&iacute;a mucho tiempo. Las
p&aacute;ginas del man son la mejor fuente de informaci&oacute;n para
aprender acerca de sus descripciones,     prototipos, valores de retorno
y otras notas. Le aconsejo que las mire  para   cada funci&oacute;n que use.
Ofrecen detallada y valiosa informaci&oacute;n.     La &uacute;ltima secci&oacute;n
de este art&iacute;culo en la que expongo     un programa de ejemplo tambi&eacute;n
puede servir de tutorial sobre como     usar estas funciones.</p>

<A NAME="233lfindex6">&nbsp;</A>
<H2>Cursores F&iacute;sicos y L&oacute;gicos</H2>


<p>Es necesario explicar como funcionan los cursores f&iacute;sicos y l&oacute;gicos
despu&eacute;s de hablar acerca de c&oacute;mo escribir y leer en ventanas.
Lo que se entiende por cursor f&iacute;sico es el t&iacute;pico cursor
parpadeante   que se ve en pantalla, &uacute;nicamente puede haber un
cursor    f&iacute;sico.   Por otro lado, los cursores l&oacute;gicos pertenecen
a  las ventanas de  ncurses y cada ventana tiene el suyo propio. As&iacute;
pues puede haber  muchos cursores l&oacute;gicos.</p>

<p>El cursor l&oacute;gico est&aacute; en la posici&oacute;n de la ventana donde
el proceso de lectura o escritura va a comenzar. Por lo tanto, moviendo
el  cursor l&oacute;gico podremos escribir en cualquier punto de la pantalla
o ventana cuando queramos. Esta es una de las ventajas de ncurses sobre
las   librer&iacute;a de E/S est&aacute;ndar.</p>

<p>La funci&oacute;n que se encarga de mover el cursor l&oacute;gico es move
o, como podr&aacute; deducir f&aacute;cilmente, wmove. move es una
macro      de wmove, hecha para stdscr.</p>

<p>Otros asunto es la coordinaci&oacute;n entre los cursores f&iacute;sicos
y l&oacute;gicos. La posici&oacute;n del cursor f&iacute;sico despu&eacute;s
de un proceso de escritura depende del flag _leave, presente en la estructura
WINDOW.
Si _leave est&aacute; activo, el cursor l&oacute;gico se mover&aacute;
hasta la posici&oacute;n del cursor f&iacute;sico despu&eacute;s de realizar la escritura (donde se escribi&oacute;
el &uacute;ltimo caracter). Si _leave no est&aacute; activo, el
cursor    f&iacute;sico vuelve a la posici&oacute;n del cursor l&oacute;gico
despu&eacute;s de realizar la escritura (donde    se escribi&oacute; el primer caracter). El flag _leave es controlado
por   la funci&oacute;n leaveok.
</p>

<p>La funci&oacute;n que mueve el cursor f&iacute;sico es mvcur. Al contrario
que otras, mvcur tiene efecto inmediatamente, antes incluso de la siguiente
llamada a refresh. Si desea que el cursor f&iacute;sico sea invisible
use    la funci&oacute;n curs_set. En las p&aacute;ginas del man encontrar&aacute;
m&aacute;s detalles.</p>

<p>Tambi&eacute;n hay macros que combinan las funciones de movimiento y escritura
descritas anteriormente en una simple llamada. Esto est&aacute; bien
explicado     en las mismas p&aacute;ginas del man que las funciones addch,
addstr, printw,    getch, getstr, scanw, etc...</p>

<A NAME="233lfindex7">&nbsp;</A>
<H2>Borrando en Ventanas</H2>


<p>Ya sabemos como se puede escribir en ventanas. &iquest;Pero ahora c&oacute;mo
borramos ventanas, l&iacute;neas o caracteres?</p>

<p>Borrar, en ncurses, significa rellenar el car&aacute;cter, la l&iacute;nea o el contenido
de la ventana con espacios en blanco. Las funciones que voy a explicar
m&aacute;s   abajo rellenan los caracteres (posiciones en la pantalla
en realidad) necesarios con espacios en blanco
y as&iacute;   borran la pantalla.</p>

<p>Primero hablemos de las funciones que se refieren al borrado de un caracter
o una l&iacute;nea. Las funciones delch y wdelch borran el caracter que est&aacute;
bajo el cursor l&oacute;gico de la ventana y desplaza los caracteres
que  le siguen en la misma l&iacute;nea hacia la derecha. deleteln y wdeleteln
borran    la l&iacute;nea en la que est&aacute; el cursor l&oacute;gico y desplazan
hacia   arriba todas las l&iacute;neas que est&eacute;n m&aacute;s abajo.</p>

<p>Las funciones clroeol y wclroeol borrar&aacute;n todos los caracteres de
la misma l&iacute;nea que est&eacute;n a la derecha del cursor l&oacute;gico. clrobot
y wclrobot primero llaman a wclrtoeol para borrar todos los caracteres a
la derecha del cursor l&oacute;gico y despu&eacute;s borra todas las l&iacute;neas
que haya a continuaci&oacute;n.</p>

<p>Aparte de estas, hay funciones que borran la pantalla entera o solamente
una ventana.     Hay dos m&eacute;todos para borrar la pantalla entera. El
primero es rellenar    todas las posiciones con caracteres en blanco y despu&eacute;s
llamar a la   funci&oacute;n refresh y la otra es usar el codigo de control
integrado en el terminal.   El primer m&eacute;todo es m&aacute;s lento
porque  requiere que todas las posiciones de la pantalla sean reescritas
una a una  mientras que el segundo   borra toda la pantalla inmediatamente.</p>

<p>erase y werase rellenan la matriz de caracteres de una ventana con espacios
en blanco. En la pr&oacute;xima llamada a refresh la ventana se borrar&aacute;.
Sin embargo, si la ventana que hay que borrar ocupa toda la pantalla, usar
estas funciones es una soluci&oacute;n poco elegante. Estas funciones
usan el m&eacute;todo descrito m&aacute;s arriba. Cuando la ventana que
hay  que borrar ocupa toda la pantalla, es mucho mejor utilizar las siguientes
funciones.</p>

<p>Antes de entrar en estas funciones, habr&iacute;a que hablar del indicador
_clear. Est&aacute; en la estructura WINDOW y si est&aacute; activado, pregunta
a refresh para enviar el c&oacute;digo de control al terminal cuando es
llamado. Al ser llamado, refresh comprueba si la ventana ocupa toda la pantalla
(usando el indicador _FULLWIN) y si es as&iacute;, borra la pantalla con
el m&eacute;todo integrado en el terminal. Luego s&oacute;lo tiene que escribir
los caracteres y no los espacios en blanco en la pantalla. Esto hace que
borrar la pantalla completa sea m&aacute;s r&aacute;pido. La raz&oacute;n
por la que este sistema s&oacute;lo se usa para ventanas que ocupan toda
la pantalla es que el c&oacute;digo  de control del terminal borra toda la
pantalla y no s&oacute;lo una ventana.  El indicado _clear es controlado
por la funci&oacute;n clearok.</p>

<p>Las funciones clear y wclear son usadas para borrar ventanas que ocupan
toda la pantalla. De hecho, estas funciones son equivalentes a hacer
una    llamada a werase y a clearok. Primero, rellenan la matriz de caracteres
de  la ventana con espacios en blanco. Y luego, activando el indicador
_clear borra la pantalla usando el metodo integrado en el terminal si la
ventana ocupa toda la pantalla y en caso contrario lo hace rellenando todas
las posiciones con espacios en blanco.&nbsp;</p>

<p>En resumen, si sabe que la ventana a ser borrada ocupa toda la pantalla
entonces use clear o wclear. Ser&aacute; m&aacute;s r&aacute;pido. Si
no,    no hay ninguna diferencia entre el uso de wclear o werase.</p>

<A NAME="233lfindex8">&nbsp;</A>
<H2>Usando Colores</H2>


<p>Los colores que ve en la pantalla se muestran a traves de pares de colores.
Esto es as&iacute; porque cada posici&oacute;n tiene un color de primer plano
y  otro de segundo plano. Para escribir en color con ncurses tienen que
crear    sus propios pares de colores y &nbsp;usarlos para escribir en pantalla.</p>

<p>Al igual que initscr necesita ser llamado para poder utilizar ncurses,
start_color tiene que ser llamado para poder usar colores. La funci&oacute;n
necesaria para crear sus propios pares de colores es init_pair. Cuando
crea   un par de colores con init_pair, &eacute;ste es asociado con el n&uacute;mero
que   se le pasa como primer par&aacute;metro a la funci&oacute;n. As&iacute;,
siempre que quiera usar un par, tiene que referirse a &eacute;l con el
n&uacute;mero asignado a COLOR_PAIR.</p>

<p>Aparte de crear pares de colores, necesita algunas funciones para escribir
con diferentes pares de colores. Esto se hace con las funciones attron
y  wattron. Estas funciones hacen que, desde el momento en que son llamadas,
todo lo que se escriba en la ventana
correspondiente se haga en el par de colores que ha elegido.</p>

<p>Tambi&eacute;n tiene las funciones bkgd y wbkgd que cambia el par de colores
asociado con una ventana completa. Cuando alguna de ellas es llamada
cambia     el color &nbsp;tanto del primer como del segundo plano de todas
las posiciones    de la ventana. Esto significa que en la pr&oacute;ximo
refresco de pantalla,     cada posici&oacute;n de la ventana se reescribir&aacute;
con el nuevo par de  colores.</p>

<p>Mire en las p&aacute;ginas del man para saber cuales son los colores disponibles
y m&aacute;s detalles de las funciones que hemos mencionado.</p>

<A NAME="233lfindex9">&nbsp;</A>
<H2>Recuadros Alrededor de Ventanas</H2>


<p>Puede crear recuadros alrededor de las ventanas para darle un aspecto
m&aacute;s agradable a su programa. Hay una macro en la librer&iacute;a
llamado  box que lo hace por usted. Al contrario que otras funciones wbox
no existe,  box toma como argumento un puntero de tipo WINDOW.</p>

<p>Puede encontrar f&aacute;cilmente m&aacute;s detalles de box en las p&aacute;ginas
del man. Aunque hay algo m&aacute;s que deber&iacute;a ser mencionado.
Ponerle   un recuadro&nbsp; a una ventana simplemente consiste en escribir
los caracteres   necesarios en la matriz de caracteres de la ventana que
corresponden con  las posiciones de los bordes. Si mas adelante por alg&uacute;n
motivo escribe en  estas posiciones, el recuadro puede corromperse. Para
evitar  esto, puede crear  una ventana dentro de la ventana original con
subwin, poner el [recuadro]  en la ventana original y utilizar la ventana
interior para escribir.</p>

<A NAME="233lfindex10">&nbsp;</A>
<H2>Teclas de Funci&oacute;n</H2>


<p>Para poder usar las teclas de funci&oacute;n, el indicador _use_keypad
tiene que ser activado en la ventana desde la que se va a leer la entrada
de teclado. keypad es la funci&oacute;n que establece el valor de _use_keypad.
Una vez activado _use_keypad, puede tomar la entrada de teclado de la forma
habitual con las funciones de entrada.</p>

<p>En este caso, si por ejemplo utiliza getch para obtener datos, debe tener
cuidado en almacenar los datos en una variable de tipo entero en lugar de
una de tipo char. Esto es porque los valores num&eacute;ricos de las teclas
de funci&oacute;n son mayores que los valores que puede contener una variable
de tipo char. No necesita conocer el valor num&eacute;rico de las teclas de
funci&oacute;n ya que la librer&iacute;a proporciona nombres ya definidos
para ellas. Estos nombres est&aacute;n listados en la p&aacute;gina man de
getch.</p>

<A NAME="233lfindex11">&nbsp;</A>
<H2>Un Ejemplo</H2>


<p>Vamos a analizar ahora un sencillo y bonito programa. En &eacute;l los
men&uacute;s van a ser creados usando ncurses y se indicar&aacute; cuando se
selecciones una opci&oacute;n del men&uacute;. Un aspecto interesante de este
programa    es el uso de ventanas ncurses para simular los men&uacute;s cuando
se abren. Lo puede  ver  en la captura de pantalla de m&aacute;s abajo.</p>
<img
src="../../common/images/article233/example.jpg" width="588"
height="399" alt="    [example program]">

<p>El programa comienza con las cabeceras como es habitual. Luego definimos
las constantes para los valores ASCII de las teclas de enter y escape.</p>

<pre>
#include &lt;curses.h&gt;

#include &lt;stdlib.h&gt;

#define ENTER 10
#define ESCAPE 27
</pre>

<p>La siguiente funci&oacute;n es las primera que se llama al ejecutar el
programa. Primero llama a initscr para inicializar curses y luego a start_color
para poder utilizar colores. Los pares de colores que se van a utilizar
en  el programa se definen a continuaci&oacute;n. La llamada a curs_set(0)
hace  que el cursor f&iacute;sico sea invisible. noecho hace que entrada
del teclado  no aparezca en pantalla. Tambi&eacute;n se puede usar la funci&oacute;n
noecho  para controlar la entrada del teclado y mostrar &uacute;nicamente
las partes  que quiera que se muestren. Para quitar los efectos de la funci&oacute;n
noecho hay que llamar a la funci&oacute;n echo. Finalmente se llama a la
funci&oacute;n keypad para habilitar las teclas de funci&oacute;n cuando
se lea la entrada de stdscr. Esto es necesario porque en nuestro programa
vamos a utilizar las teclas F1, F2 y los cursores.</p>

<pre>void init_curses()
{
    initscr();
    start_color();
    init_pair(1,COLOR_WHITE,COLOR_BLUE);
    init_pair(2,COLOR_BLUE,COLOR_WHITE);
    init_pair(3,COLOR_RED,COLOR_WHITE);
    curs_set(0);
    noecho();
    keypad(stdscr,TRUE);
}
</pre>

<p>La siguiente funci&oacute;n crea una barra de men&uacute; que aparece en la parte
de arriba de la pantalla. Si se fija en dicha funci&oacute;n se dar&aacute;
cuenta de que la barra de men&uacute; que se ve como una l&iacute;nea sencilla
en la parte   superior en realidad est&aacute; definida como una subventana
de stdscr con una &uacute;nica l&iacute;nea de alto. &Eacute;sta funci&oacute;n
toma un puntero a esta ventana   como par&aacute;metro, primero cambia el
color de fondo y luego escribe los  nombres de los men&uacute;s. Usamos waddstr para
escribir los nombres de los men&uacute;s. Preste atenci&oacute;n a las llamadas
a wattron, se usan para escribir con un par de colores diferente (n&uacute;mero
3) en lugar de usar el par de colores por defecto (n&uacute;mero 2). Recuerde
que el par n&uacute;mero 2 fue puesto como par por defecto en la primera
l&iacute;nea por wbkgd. wattroff es llamado cuando se quiere cambiar al par de color
por defecto.</p>

<pre>void draw_menubar(WINDOW *menubar)
{
    wbkgd(menubar,COLOR_PAIR(2));
    waddstr(menubar,"Menu1");
    wattron(menubar,COLOR_PAIR(3));
    waddstr(menubar,"(F1)");
    wattroff(menubar,COLOR_PAIR(3));
    wmove(menubar,0,20);
    waddstr(menubar,"Menu2");
    wattron(menubar,COLOR_PAIR(3));
    waddstr(menubar,"(F2)");
    wattroff(menubar,COLOR_PAIR(3));
}
</pre>

<p>La siguiente funci&oacute;n dibuja los men&uacute;s cuando las teclas F1 o F2
son presionadas. Para crear el efecto de men&uacute; una ventana nueva con el
mismo   color blanco que la barra de men&uacute; es creada sobre la ventana azul
que compone el fondo.No queremos que esta nueva ventana sobrescriba los caracteres
que hubiera anteriormente en el fondo. Estos deben continuar ah&iacute;
una  vez que el men&uacute; sea cerrado. Esto es&nbsp; por lo que la ventana men&uacute;
no puede ser creada como una subventana de stdscr. Como ver&aacute; m&aacute;s
abajo, la ventana items[0] es creada con la funci&oacute;n newwin mientras
que las otras ocho ventanas <it>items</it> son creadas como subventanas de items[0].
Aqu&iacute; items[0] es usada para dibujar una caja alrededor del men&uacute; y
las otras ventanas <it>items</it> lo son para mostrar los items seleccionados en el
men&uacute; y tambi&eacute;n para no sobreescribir los caracteres de la caja alrededor
del men&uacute;. Para hacer que un item del men&uacute; parezca que est&aacute; seleccionado
es  suficiente con hacer que el color de fondo sea diferente al del resto
de los items. Esto es lo que hace la antepen&uacute;ltima l&iacute;nea; el color
de fondo del primer item es puesto de un color diferente al de los otros
y as&iacute; cuando el men&uacute; aparece, el primer item est&aacute; seleccionado.</p>

<pre>WINDOW **draw_menu(int start_col)
{
    int i;
    WINDOW **items;
    items=(WINDOW **)malloc(9*sizeof(WINDOW *));

    items[0]=newwin(10,19,1,start_col);
    wbkgd(items[0],COLOR_PAIR(2));
    box(items[0],ACS_VLINE,ACS_HLINE);
    items[1]=subwin(items[0],1,17,2,start_col+1);
    items[2]=subwin(items[0],1,17,3,start_col+1);
    items[3]=subwin(items[0],1,17,4,start_col+1);
    items[4]=subwin(items[0],1,17,5,start_col+1);
    items[5]=subwin(items[0],1,17,6,start_col+1);
    items[6]=subwin(items[0],1,17,7,start_col+1);
    items[7]=subwin(items[0],1,17,8,start_col+1);
    items[8]=subwin(items[0],1,17,9,start_col+1);
    for (i=1;i&lt;9;i++)
        wprintw(items[i],"Item%d",i);
    wbkgd(items[1],COLOR_PAIR(1));
    wrefresh(items[0]);
    return items;
}</pre>

<p>La funci&oacute;n que tenemos a continuaci&oacute;n simplemente borra
la ventana men&uacute; creada por la funci&oacute;n anterior. Primero borra las
ventanas de los items con delwin y luego libera la memoria asignada para
el puntero items.</p>

<pre>void delete_menu(WINDOW **items,int count)
{
    int i;
    for (i=0;i&lt;count;i++)
        delwin(items[i]);
    free(items);
}
</pre>

<p>La funci&oacute;n scroll_menu nos permite movernos entre men&uacute;s y
dentro de ellos. Primero lee con getch las teclas que son pulsadas en el
teclado. Si se presionan los cursores de arriba o abajo, entonces se selecciona
el   item superior o inferior. Esto se hace, como recordar&aacute;, haciendo
que  el color de fondo sea diferente que el del resto de los items. Si
se presionan  los cursores de izquierda o derecha, el men&uacute; abierto se cierra
y luego se  abre el siguiente. Si se presiona la tecla enter, la funci&oacute;n
devuelve el item seleccionado. Si la tecla presionada es ESC, se cierran
todos los  men&uacute;s sin seleccionar ning&uacute;n item, La funci&oacute;n
ignora cualquier otra tecla que sea pulsada. En esta funci&oacute;n, getch
es capaz de leer las teclas de cursor del teclado. Perm&iacute;tame recordarle
que esto es posible porque anteriormente, en la funci&oacute;n init_curses,
se hizo una llamada a keypad (stdscr, TRUE) y el valor devuelto por getch
es de tipo int en lugar de ser de tipo cha ya que los valores de las teclas
de funci&oacute;n son mayores de lo que una variable de tipo char puede contener.</p>

<pre>int scroll_menu(WINDOW **items,int count,int menu_start_col)
{
    int key;
    int selected=0;
    while (1) {
        key=getch();
        if (key==KEY_DOWN || key==KEY_UP) {
            wbkgd(items[selected+1],COLOR_PAIR(2));
            wnoutrefresh(items[selected+1]);
            if (key==KEY_DOWN) {
                selected=(selected+1) % count;
            } else {
                selected=(selected+count-1) % count;
            }
            wbkgd(items[selected+1],COLOR_PAIR(1));
            wnoutrefresh(items[selected+1]);
            doupdate();
        } else if (key==KEY_LEFT || key==KEY_RIGHT) {
            delete_menu(items,count+1);
            touchwin(stdscr);
            refresh();
            items=draw_menu(20-menu_start_col);
            return scroll_menu(items,8,20-menu_start_col);
        } else if (key==ESCAPE) {
            return -1;
        } else if (key==ENTER) {
            return selected;
        }
    }
}
</pre>

<p>Finalmente tenemos la funci&oacute;n principal. En ella se usan todas las
funciones que hemos escrito anteriormente para hacer que el programa funcione
adecuadamente. Tambi&eacute;n lee las teclas pulsadas con getch y si F1 o
F2 son pulsadas, dibuja la ventana de men&uacute; correspondiente con draw_menu.
Despu&eacute;s llama a scroll_menu y deja que el usuario haga su selecci&oacute;n
desde los men&uacute;s. Una vez tenga el valor devuelto por scroll_menu, borra las
ventanas de men&uacute; e imprime el item seleccionado en la barra de mensajes.
</p>

<p>Habr&iacute;a que mencionar ahora la funci&oacute;n touchwin. Si se llama
directamente a refresh sin llamar antes a touchwin despu&eacute;s de cerrar
los men&uacute;s, el &uacute;ltimo men&uacute; abierto puede permanecer en pantalla. Esto
es poque las funciones de men&uacute; no afectan para nada a stdscr y as&iacute;,
cuando se llama a refresh, &eacute;ste no reescribe ning&uacute;n caracter
de stdscr ya que asume que dicha ventana no ha sido cambiada. touchwin pone
todos los indicadores en la estructura WINDOW para decirle a refresh que
todas   las l&iacute;neas de la ventana han cambiado y as&iacute; en el pr&oacute;ximo
refresco  de pantalla se reescribe la ventana completa incluso aunque sus
contenidos  no hayan cambiado. La informaci&oacute;n escrita en stdscr permanece
&nbsp;ah&iacute;  una vez que los men&uacute;s se han cerrado porque los men&uacute;s no
escriben sobre stdscr,  sino que lo hacen en las ventanas nuevas que han creado.</p>

<pre>int main()
{
    int key;
    WINDOW *menubar,*messagebar;

    init_curses();

    bkgd(COLOR_PAIR(1));
    menubar=subwin(stdscr,1,80,0,0);
    messagebar=subwin(stdscr,1,79,23,1);
    draw_menubar(menubar);
    move(2,1);
    printw("Press F1 or F2 to open the menus. ");
    printw("ESC quits.");
    refresh();

   do {
        int selected_item;
        WINDOW **menu_items;
        key=getch();
        werase(messagebar);
        wrefresh(messagebar);
        if (key==KEY_F(1)) {
            menu_items=draw_menu(0);
            selected_item=scroll_menu(menu_items,8,0);
            delete_menu(menu_items,9);
            if (selected_item&lt;0)
                wprintw(messagebar,"You haven't selected any item.");
            else
                wprintw(messagebar,
                  "You have selected menu item %d.",selected_item+1);
            touchwin(stdscr);
            refresh();
        } else if (key==KEY_F(2)) {
            menu_items=draw_menu(20);
            selected_item=scroll_menu(menu_items,8,20);
            delete_menu(menu_items,9);
            if (selected_item&lt;0)
                wprintw(messagebar,"You haven't selected any item.");
            else
                wprintw(messagebar,
                  "You have selected menu item %d.",selected_item+1);
            touchwin(stdscr);
            refresh();
        }
    } while (key!=ESCAPE);

    delwin(menubar);
    delwin(messagebar);
    endwin();
    return 0;
}
</pre>

<p>Si copia el c&oacute;digo en un fichero llamada example.c y elimina mis
explicaciones puede compilarlo con</p>

<pre>gcc -Wall example.c -o example -lcurses</pre>

<p>y probar el programa. Tambi&eacute;n puede descargar el c&oacute;digo en
el enlace que viene m&aacute;s abajo en la secci&oacute;n de referencias.</p>

<A NAME="233lfindex12">&nbsp;</A>
<H2>Conclusi&oacute;n</H2>


<p>He explicado un poco el funcionamiento b&aacute;sico de las ncurses, lo
suficiente para crear una buena interfaz para su programa. Aun as&iacute;,
las capacides de la librer&iacute;a &nbsp;no se limitan s&oacute;lo a lo
que he explicado aqu&iacute;. Prodr&aacute; descubrir muchas m&aacute;s cosas
en las p&aacute;ginas man a las que ya le he remitido con anterioridad,
cuando  las mire se dar&aacute; cuenta de que la informaci&oacute;n presentada
aqu&iacute;  es solamente una introducci&oacute;n.</p>

<A NAME="233lfindex13">&nbsp;</A>
<H2>Referencias</H2>


<ul>
<li>El programa de ejemplo: <a href="../../common/src/article233/example_c.txt">example.c</a> </li>
<li>P&aacute;gina web de ncurses:<a href="http://www.gnu.org/software/ncurses/">www.gnu.org/software/ncurses/</a>
</li>

</ul>



<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Formulario de "talkback" para este art&iacute;culo</h2>
Cada art&iacute;culo tiene su propia p&aacute;gina de "talkback". A trav&eacute;s de esa p&aacute;gina puedes enviar un comentario o consultar los comentarios de otros lectores
<center>
<table border="0"  CELLSPACING="2" CELLPADDING="1" summary="tb-button-outerpart">
 <tr BGCOLOR="#C2C2C2"><td align=center>
  <table border="3"  CELLSPACING="2" CELLPADDING="1" summary="tb-button">
   <tr BGCOLOR="#C2C2C2"><td align=center>
    <A href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=233"><b>&nbsp;Ir a la p&aacute;gina de "talkback"&nbsp;</b></a>
   </td></tr></table>
</td></tr></table>
</center>

<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#9999AA" WIDTH="50%">
<A HREF="../../common/lfteam.html">Contactar con el equipo de LinuFocus</A>
<BR><FONT COLOR="#FFFFFF">&copy; Reha K. Ger&ccedil;eker, <a href="../../common/copy.html">FDL</a> <BR><a href="http://www.linuxfocus.org">LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#9999AA">
<!-- TRANSLATION INFO -->
<font size=2>Informaci&oacute;n sobre la traducci&oacute;n:</font>
<TABLE summary="translators">
  <tr><td><font size="2">tr --&gt; -- : Reha K. Ger&ccedil;eker <small>&lt;gerceker(at)itu.edu.tr&gt;</small></font></td></tr>
  <tr><td><font size="2">tr --&gt; en: Reha K.Ger&ccedil;eker &lt;gerceker(at)itu.edu.tr&gt;</font></td></tr>
  <tr><td><font size="2">en --&gt; es: V&iacute;ctor J. Gonz&aacute;lez &lt;rution(at)hotmail.com&gt;</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2002-12-29, generated by lfparser version 2.34</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
