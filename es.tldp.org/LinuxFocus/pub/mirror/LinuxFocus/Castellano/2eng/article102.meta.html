<HTML>
<BODY>

<H1>
Java. Parte III</H1>

<H4>
ArticleCategory: [Artikel Kategorie]</H4>
Software Development
<H4>
AuthorImage:[Bild des Autors]</H4>
<IMG SRC="../../common/images/Who.gif" ALT="[Photo of the Author]" HEIGHT=147 WIDTH=122>
<H4>
AuthorName:[Name des Autors]</H4>
<A HREF="mailto:fgcia@correoweb.com">Jose M Fern&aacute;ndez</A>
<H4>
AboutTheAuthor:[&Uuml;ber den Autor]</H4>
Diplomado en inform&aacute;tica, en la especialidad de planificaci&oacute;n
y control de sistemas inform&aacute;ticos por la universidad de M&aacute;laga
a finales de los a&ntilde;os 80. Desde entonces trabaj&oacute; primero
como programador y despu&eacute;s como analista de aplicaciones en empresas
siempre relacionadas con la Administraci&oacute;n. Siempre he trabajado
con grandes sistemas (y profesionalmente sigo haci&eacute;ndolo) pero hace
a&ntilde;o y medio por casualidad tropec&eacute; con Linux y descubr&iacute;
que en este mundo la libertad se escribe con letras MAY&Uacute;SCULAS.
<H4>
Abstract:[Zusammenfassung]</H4>
Con esta &uacute;ltima entrega dar&eacute; por terminada la primera serie
de art&iacute;culos dedicados a Java (<A HREF="../July1998/article8.html">I</A>
y <A HREF="../articles/article8.html">II</A> ), en el que he intentado
dar una visi&oacute;n global y definir los conceptos b&aacute;sicos del
lenguaje. Despu&eacute;s de este art&iacute;culo podremos comenzar el estudio
de los aspectos m&aacute;s novedosos de Java, siempre (y que nadie se despiste)
desde el prisma de GNU-Linux. Pero todav&iacute;a nos queda un buen trecho
para cerrar esta primera fase.
<H4>
ArticleIllustration:[Titelbild des Artikels]</H4>
<IMG SRC="../../common/images/illustration102.gif" ALT="[Ilustration]" HEIGHT=100 WIDTH=100>
<H4>
ArticleBody:[Der eigentliche Artikel]</H4>

<H3>
Introducci&oacute;n</H3>
El art&iacute;culo anterior finaliz&oacute; con el tema de las clases,
m&aacute;s concretamente con la Herencia y desde este mismo punto arrancaremos
este tercer art&iacute;culo para concluir el tema. Continuaremos con otros
temas no menos importantes en Java como el control de excepciones y la
programaci&oacute;n concurrente adem&aacute;s de la entrada/salida b&aacute;sica.
Finalizaremos con un repaso general a los paquetes b&aacute;sicos de Java
entre los que podemos destacar <TT>Java.net</TT> para todos los trabajos
en red, <TT>Java.awt</TT> y <TT>Java.Applet</TT> para los entornos gr&aacute;ficos
y applets tal vez el aspecto de Java m&aacute;s conocido.
<H3>
CLASES. PAQUETES. INTERFACES. CLASES ABSTRACTAS. SUPER. THIS. STATIC. MATRICES.
STRING</H3>
Las clases abstractas se utilizan para crear superclases que s&oacute;lo
definen formas generalizadas. Formas que ser&aacute;n compartidas por todas
las subclases, dejando a cada una de estas la tarea de crear los detalles.
La superclase determina la naturaleza de los m&eacute;todos que la subclase
deben implementar.
<BR>&nbsp;
<TABLE ALIGN=RIGHT BORDER=2 CELLPADDING=5 >
<TR>
<TD VALIGN=TOP><TT>abstract tipo nombre (lista_de_parametros);</TT></TD>
</TR>
</TABLE>

<P>Se puede hacer que ciertos m&eacute;todos sean sobrescritos por las
subclases utilizando el identificador de tipo abstracto. Es responsabilidad
de la subclase implementarlo ya que no posee ninguna implementaci&oacute;n
de la superclase. La forma general:
<P>Cualquier clase que contenga uno o m&aacute;s m&eacute;todos abstractos
se tiene que declarar como <B><TT>abstract</TT></B>, para declararla simplemente,
se utiliza la palabra <TT>abstract</TT> al principio de la declaraci&oacute;n
de la clase. No se puede crear instancias de estos tipos de clases. Aunque
s&iacute; pueden ser utilizadas para crear referencias a objetos. Es posible
crear una referencia de una clase abstracta para que pueda ser utilizada
como referencia a un objeto de una subclase. Gracias a este mecanismo se
puede decidir en tiempo de ejecuci&oacute;n cu&aacute;l de las versiones
de un m&eacute;todo sobrescrito se debe ejecutar.
<P>Para que un m&eacute;todo haga referencia al objeto que lo invoc&oacute;,
Java define una palabra clave <B><TT>this</TT></B>, es siempre una referencia
al objeto sobre el que ha sido llamado el m&eacute;todo. Se utiliza siempre
que se quiera hacer una referencia a un objeto del tipo de la clase actual.
<P>Para definir m&eacute;todos de una clase que puedan ser utilizados por
s&iacute; mismo sin referirse a una instancia espec&iacute;fica se precede
en la declaraci&oacute;n del m&eacute;todo con la palabra clave <B><TT>static</TT></B>.
El m&eacute;todo puede ser referenciado sin haber creado ning&uacute;n
objeto de esa clase. El ejemplo m&aacute;s com&uacute;n es en la declaraci&oacute;n
de <TT>main()</TT> ya que es llamado sin que exista ning&uacute;n objeto.
<P><U>Super</U> se puede utilizar para dos cosas: para llamar al constructor
de la superclase y para acceder a un miembro de la superclase que ha sido
ocultado por un miembro de la subclase.
<P><U>Paquetes</U>: son contenedores de clases que se utilizan para dividir
en compartimentos el espacio de nombres de clases, los paquetes son un
componente b&aacute;sico de los programas, para definirlos hay que utilizar
el comando <B><TT>package</TT></B> como primera sentencia del archivo fuente.
Cualquier clase que se defina dentro de este archivo pertenece a ese paquete,
estos definen un conjunto de espacios de nombres particionados en los que
se almacenan las clases.
<BR>&nbsp;
<TABLE ALIGN=LEFT BORDER CELLPADDING=5 BORDERCOLOR="red" >
<TR>
<TD VALIGN=CENTER><TT>Import paquete1. [paquete2].(nombre_clase | *) ;&nbsp;</TT></TD>
</TR>
</TABLE>

<P>Todas las clases est&aacute;ndar est&aacute;n almacenadas en alg&uacute;n
paquete con nombre <TT>Java</TT>, con la sentencia <B><TT>import</TT></B>
importamos paquetes enteros en nuestros programas y as&iacute; una clase
incluida en el paquete importado puede ser referenciada directamente. El
formato general se la sentencia import es:
<BR>&nbsp;
<TABLE ALIGN=RIGHT BORDER CELLPADDING=5 >
<TR>
<TD VALIGN=CENTER>
<PRE>[public ] nombre_interface{&nbsp;
tipo metodo1 (par&aacute;metros);
tipo variable_final1=valor;&nbsp;
tipo metodo2 (par&aacute;metros);
tipo variable_final2=valor; ...&nbsp;
tipo metodo (par&aacute;metros);
tipo variable_finaln=valor;&nbsp;
}</PRE>
</TD>
</TR>
</TABLE>

<P><U>Interfaces</U>: En las clases que definimos como interfaces especificamos
qu&eacute; es lo que hace, pero no c&oacute;mo lo hace. Tienen el mismo
aspecto que una clase pero sin variables de instancias y con m&eacute;todos
declarados sin cuerpos. Definiendo una interfaz cualquier clase puede implementarla.
Este mecanismo permite implementar totalmente el polimorfismo "una interfaz
m&uacute;ltiples m&eacute;todos". Las interfaces est&aacute;n es jerarqu&iacute;as
distintas de las de las clases, por lo que es posible que varias clases
sin relaci&oacute;n implementen la misma interfaz. El formato general de
una interfaz ser&iacute;a:
<P>Observa que los m&eacute;todos declarados no tienen cuerpo, son m&eacute;todos
abstractos ya que no se pueden implementar en la declaraci&oacute;n de
una interfaz, cada clase que incluye una interfaz debe implementar todos
los m&eacute;todos. El acceso a la interfaz es <TT>public</TT> o no se
utiliza, en este &uacute;ltimo caso se utiliza el modificador de acceso
por defecto y la interfaz estar&aacute; solo disponible para los otros
miembros de paquete en la que ha sido declarada. Si se declara <TT>public</TT>
la interfaz puede ser utilizada por cualquier c&oacute;digo.
<P>Las variables se pueden declarar dentro de las declaraciones de la interfaz
y son impl&iacute;citamente "<B><TT>final</TT></B>" y <B><TT>static</TT></B>
lo que indica que s&oacute;lo se puede modificar la clase que las implementa
y adem&aacute;s pueden ser inicializadas con un valor constante.
<BR>&nbsp;
<TABLE ALIGN=RIGHT BORDER CELLPADDING=5 BORDERCOLOR="#000000" >
<TR>
<TD VALIGN=TOP><TT>[public] class nombre_clase [extends superclase]</TT>
<BR><TT>[implements interfaz1, [interfaz2]....] {</TT>
<BR><TT><FONT COLOR="#FF3030">//cuerpo&nbsp;</FONT></TT>
<BR><TT>}</TT></TD>
</TR>
</TABLE>

<P>Una vez definida la interfaz una o varias clases pueden implementarla,
para ello hay que incluir la sentencia <B><TT>implements</TT></B> en la
definici&oacute;n de la clase y crear los m&eacute;todos definidos por
la interfaz. El formato general ser&aacute;:
<P>El formato del m&eacute;todo implementado debe coincidir exactamente
con el formato del tipo especificado en la definici&oacute;n de la interfaz.
<P>Las interfaces a igual que las clases pueden utilizar la herencia, incluyendo
la palabra clave extends.
<P>Para poder realizar ejemplos de todo los que llevamos hasta ahora ,
estudiaremos dos clases que nos ser&aacute;n muy &uacute;tiles la clase
String y las matrices.
<P><U>Matrices</U>: Las matrices, como casi todo el mundo sabe, son un
grupo de variables del mismo tipo, a las que se hace referencia con el
mismo nombre. Se pueden crear matrices de cualquier tipo y pueden tener
una o m&aacute;s dimensiones. Adem&aacute;s las matrices no son un tipo
simple de datos por lo que, por definici&oacute;n, todo lo que no es un
tipo simple de datos es un objeto en Java, y las matrices habr&aacute;
que tratarlas como tal.
<P>La forma general de la definici&oacute;n de una matriz es:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 >
<TR>
<TD VALIGN=TOP><TT>tipo nombre_matriz [] ;</TT>
<BR><TT>unidimensional tipo nombre_matriz[][]...[] ;</TT>
<BR><TT>multidimensionales</TT></TD>
</TR>
</TABLE></CENTER>

<TABLE ALIGN=RIGHT BORDER CELLPADDING=5 >
<TR>
<TD VALIGN=TOP><TT>Nombre_matriz = new tipo [tama&ntilde;o]&nbsp;</TT></TD>
</TR>
</TABLE>

<P>Esta declaraci&oacute;n establece una variable tipo matriz pero realmente
no existe ninguna matriz hasta que no resolvemos memoria con el operador
new.
<P>Donde <TT>tipo</TT> espec&iacute;fica el tipo de los datos que van a
ser asignados, <TT>tama&ntilde;o</TT> el n&uacute;mero de elementos de
la matriz. La memoria necesaria para cada matriz la reserva din&aacute;micamente,
una vez reservada se puede acceder a un elemento espec&iacute;fico de la
misma indicando su &iacute;ndice entre corchetes.
<P>La definici&oacute;n de una matriz se puede hacer en una sola l&iacute;nea:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=TOP><TT>tipo nombre_matriz = new tipo [tama&ntilde;o];&nbsp;</TT></TD>
</TR>
</TABLE></CENTER>

<P><U>String</U>: a igual que las tablas los <B><TT>string</TT></B> son
otra estructura b&aacute;sica para cualquier lenguaje de programaci&oacute;n
y a igual que los array los String en Java no son un tipo b&aacute;sico
por lo que se implementa como un objeto. Dispone de un conjunto completo
de operaciones que facilita su utilizaci&oacute;n.
<P>Hay algo importante en la clase <TT>String</TT>, cuando se crea un objeto
de este tipo no puede ser modificado (no se pueden modificar los car&aacute;cteres
que forman la cadena). Java nos permite hacerlo aunque lo que ocurre es
que creamos un nuevo objeto con las modificaciones ya realizadas, esta
implementaci&oacute;n la realiza Java por eficiencia del lenguaje. Existe
una clase paralela a la <TT>String</TT> llamada <B><TT>StringBuffer</TT></B>
que permite ser modificada.
<P>Como toda clase que se precie la clase String y StringBuffer tiene varios
constructores:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="70%" >
<TR>
<TD VALIGN=TOP><TT>String cadena = new String();&nbsp;</TT></TD>

<TD VALIGN=TOP>Crea una instancia vac&iacute;a&nbsp;</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>Char car[] = {'a' ,'A','b','B'} String cadena = new
String(car);&nbsp;</TT></TD>

<TD VALIGN=TOP>Crea una instancia de String, inicializandola con los caracteres
de "car"(que es una array de tipo char)&nbsp;</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>String cadena = new String(car,i,n);&nbsp;</TT></TD>

<TD VALIGN=TOP>Idem anterior pero indicando la posici&oacute;n de inicio(i)
y numero de caracteres(n) que se utiliza.&nbsp;</TD>
</TR>
</TABLE></CENTER>

<TABLE ALIGN=RIGHT BORDER CELLPADDING=5 >
<TR>
<TD VALIGN=TOP><TT>String c1 = new String(cadena);</TT></TD>
</TR>
</TABLE>

<P>Si tenemos creado el string del ejemplo anterior, podemos hacer:
<P>Con lo que las dos instancias creadas tendr&aacute;n el mismo contenido.
<BR>&nbsp;
<TABLE ALIGN=RIGHT BORDER CELLPADDING=5 >
<TR>
<TD VALIGN=TOP><TT>String cadena = "aAbB";</TT></TD>
</TR>
</TABLE>

<P>Una forma muy com&uacute;n de crear un <TT>String</TT> es utilizar literales:
<P>Ya que Java crea autom&aacute;ticamente un objeto <TT>String</TT> por
cada literal de tipo cadena que haya en el programa.
<P>Una vez creada nuestra instancia podemos realizar multitud de operaciones
que corresponde con los m&eacute;todos definidos en esta clase, repasaremos
los m&aacute;s interesantes: donde <TT>c = "aAbB"</TT>
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="90%" >
<TR>
<TD VALIGN=TOP><TT>int length(); l = c.length();</TT></TD>

<TD VALIGN=TOP>Longitud de una cadena, n&uacute;mero de caracteres que
tiene.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>int l=34; String c="tengo" + l + "a&ntilde;os";</TT></TD>

<TD VALIGN=TOP>Concatenaci&oacute;n de caracteres incluso con tipos que
no son <TT>String</TT>.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>char charAt(int pos) char ch; ch=c.charAt(1);</TT></TD>

<TD VALIGN=TOP>Extrae un car&aacute;cter de una cadena. En nuestro ejemplo
vale "<TT>a</TT>".</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>Void getChars(int posin, int posfin,chardestino[],int
desin);</TT></TD>

<TD VALIGN=TOP>Extrae m&aacute;s de un car&aacute;cter a la vez, posin
indica la posici&oacute;n inicial de la subcadena, posfin la posici&oacute;n
siguiente donde termina la subcadena, en<TT> destino[]</TT> se obtendr&aacute;
los resultados copiando la subcadena en la posici&oacute;n dentro de <TT>destino[]</TT>
que indique desin.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>Char[] toCharArray();</TT></TD>

<TD VALIGN=TOP>Convierte los caracteres de un objeto <TT>String</TT> en
una cadena de caracteres.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>String toLowercase(); String toUpperCase();</TT></TD>

<TD VALIGN=TOP>Convierte todos los caracteres de una cadena a may&uacute;sculas
o min&uacute;sculas respectivamente.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>String trim();</TT></TD>

<TD VALIGN=TOP>Devuelve el string eliminado los espacios en blanco del
principio y del final.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>ValueOf();</TT></TD>

<TD VALIGN=TOP>Convierte tipos de datos a <TT>String</TT>.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>String substring(int posinicial);</TT></TD>

<TD VALIGN=TOP>Permite extraer un trozo de una cadena de un string, posinicial
indica el inicio de la subcadena.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>String concat();</TT></TD>

<TD VALIGN=TOP>Concatena cadenas.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>String replace(char original, char sustituto);</TT></TD>

<TD VALIGN=TOP>Sustituye en la cadena que llama al m&eacute;todo todos
los caracteres que coinciden con original por sustituto.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>boolean equals(object str);&nbsp;</TT>
<BR><TT>boolean equalsIgnoreCase(object str);</TT></TD>

<TD VALIGN=TOP>Copara cadenas para ver si son iguales.
<BR>Idem ignorando los caracteres may&uacute;sculas y min&uacute;sculas.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>int indexOf(int ch); int lastIndexOf(int ch);</TT></TD>

<TD VALIGN=TOP>Devuelve la primera y &uacute;ltima aparici&oacute;n de
un car&aacute;cter en una subcadena.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>StringBuffer insert (int indice, String str);</TT></TD>

<TD VALIGN=TOP>Inserta una cadena en otra.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>StringBuffer reverse();</TT></TD>

<TD VALIGN=TOP>Invierte el orden de los caracteres de una cadena.</TD>
</TR>
</TABLE></CENTER>

<P><U>Ejemplo</U>: repasaremos en este ejemplo algunos de los temas que
hemos visto, en este ejemplo desarrollaremos una clase que nos sirva para
contar los distintos caracteres que le enviamos en un String. La clase
la instanciaremos desde otra clase principal que recibe la cadena a analizar
desde la l&iacute;nea de comandos:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="90%" >
<TR BGCOLOR="#5898C0">
<TH ALIGN=CENTER>C&Oacute;DIGO</TH>

<TH ALIGN=CENTER>COMENTARIOS&nbsp;</TH>
</TR>

<TR>
<TD BGCOLOR="#F8FCC0">
<PRE>Class Contar{
char La_Matriz[] = new char[128];

void Caracteres(String La_Cadena){
int Indice;
char car;&nbsp;
for(Indice=0 ; Indice&lt;La_Cadena.length() ; Indice++){
car = La_Cadena.charAt(Indice);&nbsp;&nbsp;
++La_Matriz[car];&nbsp;
}&nbsp;
}

void Resultado (){
int Indice, Resultado;
char car;
for (Indice=0;Indice &lt; 128;Indice++){
car=(char)Indice;
Resultado =(int)La_Matriz[Indice];
If (Resultado > 0){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("del caracter "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + car + " hay :"&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + Resultado
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " Caracteres" );
}&nbsp;
}&nbsp;
}&nbsp;</PRE>
</TD>

<TD VALIGN=CENTER>La clase contar define una matriz de caracteres de 128
ocurrencias, adem&aacute;s se definen dos m&eacute;todos:
<P>Caracteres y resultado, los dos no devuelven ning&uacute;n valor (<TT>void</TT>).
El primero de ellos recibe como par&aacute;metro un string el cual vamos
a analizar. Utilizamos dos m&eacute;todos de la clase String vistos anteriormente:
<P>La_cadena.length() que nos devuelve la longitud de la cadena. Y La_cadena.charAt(Indice)
que extrae un car&aacute;cter del String de la posici&oacute;n indicada
por Indice.
<P>Se&ntilde;alar que utilizamos car de tipo char como &iacute;ndice de
la matriz.
<P>El m&eacute;todo resultado simplemente devuelve el resultado de la operaci&oacute;n
de calcular las veces que se repite en una frase cada car&aacute;cter.</TD>
</TR>

<TR>
<TD VALIGN=CENTER BGCOLOR="#F8FCC0">
<PRE>class Pcontar {

public static void main(String arg[]) {
String cadena = "";
int i;
for(i=0; i&lt;arg.length ;i++){
cadena = cadena + arg[i]; }&nbsp;
Contar Frases = new Contar();&nbsp;&nbsp;
System.out.println(cadena);&nbsp;
Frases.Caracteres(cadena);&nbsp;
Frases.Resultado(); }
}</PRE>
</TD>

<TD VALIGN=CENTER>La clase Pcontar la utilizamos para instanciar la clase
Contar y recibir la frase a analizar para envi&aacute;rsela v&iacute;a
par&aacute;metro al objeto creado. Como observamos es un programa que se
ejecuta en la l&iacute;nea de comando y recibe par&aacute;metros por medio
de un array de String arg[].&nbsp;
<P>Concatenamos cada uno de las ocurrencias del par&aacute;metro de entrada(cada
palabra de la frase esta en una ocurrencia de la matriz).
<P>Creamos el objeto Frases del tipo Contar y llamamos a los m&eacute;todos
de este: Caracteres, enviando como par&aacute;metro la frase a analizar
y al m&eacute;todo Resultado para que represente en pantalla el resultado
el an&aacute;lisis.</TD>
</TR>
</TABLE></CENTER>

<H3>
PROGRAMACION CONCURRENTE</H3>
La programaci&oacute;n concurrente dentro del mismo lenguaje de programaci&oacute;n
es un concepto relativamente nuevo. Un lenguaje pionero en este tema fue
Ada (1983). La arquitectura de Java admite ejecuci&oacute;n en subprocesos
m&uacute;ltiples.
<P>El paradigma de la orientaci&oacute;n a objetos y la ejecuci&oacute;n
en subprocesos permite a usuario interactuar con varios objetos simult&aacute;neamente.
De qu&iacute; en adelante supondr&eacute; que el lector conoce los conceptos
b&aacute;sicos de programaci&oacute;n concurrente: hilo de ejecuci&oacute;n,
secci&oacute;n cr&iacute;tica, sem&aacute;foro, recurso etc. Estos conceptos
est&aacute;n perfectamente explicados en cualquier buen libro sobre sistemas
operativos.
<P>Existen dos formas de crear una clase que admita ejecutarse en subprocesos
m&uacute;ltiples:
<UL>
<LI>
crear una clase <B><TT>Thread</TT></B></LI>

<LI>
utilizando la interfaz <B><TT>Runnable</TT></B></LI>
</UL>
En Java todo proceso concurrente tiene un hilo principal, desde el cual
se crearan el resto de los procesos del programa. Cuando el hilo principal
finaliza todos los subprocesos terminan y as&iacute; la ejecuci&oacute;n
del programa.
<P>Para crear subprocesos hijos extendiendo la clase <TT>Thread</TT>:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=TOP>
<PRE>&nbsp;
Class nombre_clase extends Thread {&nbsp;
Public void run() {&nbsp;
<FONT COLOR="#FF3030">// cuerpo de ejecucion del subproceso.&nbsp;
</FONT>}&nbsp;
}</PRE>
</TD>
</TR>
</TABLE></CENTER>

<P>Para instanciar la clase y crear el subproceso concurrente con el hilo
principal haremos:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=TOP><TT>nombre_clase nombre_instancia = new nombre_clase();</TT></TD>
</TR>
</TABLE></CENTER>

<P>Y llamaremos al m&eacute;todo <TT>start()</TT> que invoca al m&eacute;todo
<TT>run()</TT>,
iniciando el subproceso y volviendo al hilo principal.
<P>Si lo hacemos con la interfaz <TT>Runnable</TT>:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=TOP>
<PRE>Class nombre_clase implements Runnable {&nbsp;
Public void run() {&nbsp;
<FONT COLOR="#FF3030">// cuerpo subproceso&nbsp;
</FONT>}&nbsp;
}</PRE>
En el proceso principal haremos:
<PRE>Nombre_clase nombre_instancia = new nombre_clase;&nbsp;
New Thread(nombre_instancia).Start();</PRE>
</TD>
</TR>
</TABLE></CENTER>

<P>Normalmente se utilizar&aacute; este &uacute;ltimo m&eacute;todo ya
que por una norma no escrita se extiende una clase si &eacute;sta va a
ser mejorada o sobrescrita y &eacute;ste no es el caso de la clase <TT>Thread</TT>.
<P>Otros m&eacute;todos &uacute;tiles para controlar el estado y ejecuci&oacute;n
de un subproceso ser&aacute;n:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="70%" rule="cols" >
<TR>
<TD VALIGN=TOP><TT>getName()</TT></TD>

<TD VALIGN=TOP>Devuelve una cadena con el nombre del subproceso.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>setName(String)</TT></TD>

<TD VALIGN=TOP>Da un nombre a un subproceso.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>currentThread()</TT></TD>

<TD VALIGN=TOP>Devuelve el subproceso en ejecuci&oacute;n.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>isActive()</TT></TD>

<TD VALIGN=TOP>Comprueba si el subproceso esta activo.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>suspend()</TT></TD>

<TD VALIGN=TOP>Suspende la ejecuci&oacute;n de un subproceso.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>resume()</TT></TD>

<TD VALIGN=TOP>Reanuda la ejecuci&oacute;n de un subproceso.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>sleep(int</TT>)</TD>

<TD VALIGN=TOP>Suspende el ssubproceso durante int milisegundos.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>yield()</TT></TD>

<TD VALIGN=TOP>El subproceso cede la ejecuci&oacute;n a otro en espera.</TD>
</TR>
</TABLE></CENTER>

<P>Cuando uno o varios subprocesos comparten un recurso, ya sea un dispositivo
f&iacute;sico o simplemente variables y se pueden producir "condiciones
de carrera" (esto es, errores de ejecuci&oacute;n debido a una ejecuci&oacute;n
no secuencial) se debe implementar la sincronizaci&oacute;n entre los hilos
para asegurar que solo uno est&aacute; accediendo al recurso en un instante
dado. Java proporciona un soporte &uacute;nico a nivel de lenguaje, utilizando
el concepto de sem&aacute;foro, este no es mas que un objeto que puede
ser utilizado por un solo subproceso en un instante determinado. Esto se
pude hacer por dos v&iacute;as:
<BLOCKQUOTE>Restringiendo el acceso a un m&eacute;todo, utilizando la palabra
clave synchronized en la definici&oacute;n del m&eacute;todo.
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=CENTER><TT>Class nombre_clase {</TT>
<BR><TT>Syschronized void metodo () {&nbsp;</TT></TD>
</TR>
</TABLE></CENTER>

<P>la segunda v&iacute;a ser&iacute;a con la sentencia <TT>syschronized</TT>,
la llamada a los m&eacute;todos se realiza dentro de un bloque de c&oacute;digo
sincronizado.
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=CENTER><TT>Sysnchronized (objeto){</TT>
<BR><TT>&nbsp;&nbsp; <FONT COLOR="#FF3030">// sentencias que deben ser
sincronizadas</FONT></TT>
<BR><TT>}</TT></TD>
</TR>
</TABLE></CENTER>
</BLOCKQUOTE>
Este segundo caso es &uacute;til ya que podemos utilizar clases de car&aacute;cter
general que en su definici&oacute;n sean sincronizadas o simplemente no
dispongamos de su c&oacute;digo fuente.
<P>Java implementa m&eacute;todos para facilitar la comunicaci&oacute;n
eficiente entre subprocesos:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="70%" rule="cols" >
<TR>
<TD VALIGN=TOP><TT>wait()</TT></TD>

<TD VALIGN=TOP>Indica al hilo en curso que abandone el sem&aacute;foro
(recurso sincronizado) y espere hasta que otro hilo entre en el mismo sem&aacute;foro
y llame a <TT>notify()</TT>.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>notify()</TT></TD>

<TD VALIGN=TOP>Activa el primer hilo que realiza la llamada a <TT>wait()</TT></TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>notifyAll()</TT></TD>

<TD VALIGN=TOP>Despierta a todos los subprocesos que realizan llamadas
a <TT>wait()</TT>.</TD>
</TR>
</TABLE></CENTER>

<P>Ejemplo:
<P>En el siguiente programa veremos como utilizamos la concurrencia e Java,
para ello creamos una clase que escribe en la salida est&aacute;ndar si
un n&uacute;mero es divisible por otro. El programa principal recibe como
par&aacute;metro el limite de la serie y llama concurrentemente a la primera
clase de tres formas para obtener los m&uacute;ltiplos de 2, 3 y 5 de forma
concurrente.
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="90%" >
<TR ALIGN=CENTER BGCOLOR="#5898C0">
<TH>C&Oacute;DIGO&nbsp;</TH>

<TH>COMENTARIOS&nbsp;</TH>
</TR>

<TR>
<TD VALIGN=CENTER BGCOLOR="#F8FCC0">
<PRE>Class Cmultiplos implements Runnable {
int limite, multiplo;
Thread t;
Cmultiplos (int h , int m){
limite = h;
multiplo = m;
t = new Thread(this, "hijo");
t.start();
}

public void run() {
for (int i = 1;i &lt; limite + 1; i++) {
int mod = i % multiplo;
if (mod == 0){
System.out.println( i + " es multiplo de "&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + multiplo);
}&nbsp;
}
}
}
&nbsp;&nbsp;</PRE>
</TD>

<TD>Creamos la clase <TT>Cmultiplos</TT> para que pueda ser utilizada de
forma concurrente utilizado en interfaz <TT>Runnable</TT>.</TD>
</TR>

<TR VALIGN=CENTER>
<TD BGCOLOR="#F8FCC0">
<PRE>class Multiplos {

public static void main (String arg[]) {
int parametro=Integer.valueOf(arg[0]).intValue();
new Cmultiplos(parametro,2);
new Cmultiplos(parametro,3);
new Cmultiplos(parametro,5);
}
}</PRE>
</TD>

<TD VALIGN=CENTER>El programa principal llama a la clase en tres ocasiones
envi&aacute;ndole par&aacute;metros distintos, con lo que se ejecutara
esta clase de forma concurrente.</TD>
</TR>
</TABLE></CENTER>

<P><A NAME="excepciones"></A>
<H3>
EXCEPCIONES EN JAVA</H3>
Java puede detectar e indicar qu&eacute; errores se han producido en tiempo
de ejecuci&oacute;n. Cuando se produce un error se crea un objeto y es
enviado al m&eacute;todo que lo ha provocado, este puede elegir gestionar
la excepci&oacute;n o no.
<BR>&nbsp;
<TABLE ALIGN=RIGHT BORDER CELLPADDING=5 >
<TR>
<TD VALIGN=TOP>
<PRE>try {
<FONT COLOR="#FF3030">// c&oacute;digo que puede generar una excepci&oacute;n
</FONT>} catch (excepci&oacute;n 1 nombre){
<FONT COLOR="#FF3030">&nbsp;// gesti&oacute;n excepcion1 }
</FONT>} catch (excepci&oacute;n2 nombre){
<FONT COLOR="#FF3030">// gesti&oacute;n de excepcion2 }
</FONT>} finally {
<FONT COLOR="#FF3030">//c&oacute;digo
</FONT>}&nbsp;</PRE>
</TD>
</TR>
</TABLE>

<P>Para manejar excepciones lo realizaremos con la ayuda de:
<DL>
<DT>
<TT>Try</TT>:</DT>

<DD>
crea un bloque de c&oacute;digo donde puede producirse una excepci&oacute;n.</DD>

<DT>
<TT>Catch</TT>:</DT>

<DD>
recoge las instrucciones generadas y las trata.</DD>

<DT>
<TT>Finally</TT>:</DT>

<DD>
recoge el c&oacute;digo que necesitamos que se ejecute incluso aunque se
genere una excepci&oacute;n.</DD>
</DL>
De una forma esquem&aacute;tica:
<H3>
E/S EN JAVA</H3>
Java realiza la entrada-salida a trav&eacute;s de flujos. Cada flujo est&aacute;
relacionado con un dispositivo f&iacute;sico. Todos los flujos se comportan
de la misma forma.
<P>La entrada-salida m&aacute;s habitual ser&aacute; la realizada con los
dispositivos por defecto: la consola como salida y el teclado como entrada
(ya lo hemos utilizado en algunos ejemplos anteriores).
<P>En la cima de la jerarqu&iacute;a de clases de E/S se encuentra las
clases <TT>InputStream</TT> y <TT>OutputStrean</TT> de las cuales se derivan
el resto de las clases, la entrada y salida est&aacute;ndar est&aacute;n
encapsuladas en la variables de objeto int y out de la clase <TT>System</TT>,
dichas variables de objeto son de los tipos <TT>InputStrean</TT> y <TT>OutputStream</TT>
respectivamente. Por lo que:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=TOP>System.out
<P>System.int
<P>System.err&nbsp;</TD>
</TR>

<TR>
<TD VALIGN=TOP>Flujo de salida est&aacute;ndar.
<P>Flujo de entrada est&aacute;ndar.
<P>Flujo de error est&aacute;ndar.</TD>
</TR>
</TABLE></CENTER>

<P>La salida est&aacute;ndar la conocemos de ejemplos anteriores por lo
que veremos la utilizaci&oacute;n de <TT>System.int</TT> con el m&eacute;todo
principal que es <TT>Read()</TT>, el formato general ser&aacute;:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=TOP>In Read() throws IOException</TD>
</TR>
</TABLE></CENTER>

<P>Con este m&eacute;todo, por cada llamada lee un &uacute;nico car&aacute;cter
y lo devuelve como un valor entero. Devuelve <TT>-1</TT> cuando encuentra
el final del flujo. Como podemos observar hay que controlar la excepci&oacute;n
<TT>IOException</TT>.
<P>Adem&aacute;s de la E/S b&aacute;sico, el dispositivo m&aacute;s importante
para comunicarse con el mundo exterior es el sistema de archivos. La clase
<B><TT>File</TT></B>
proporciona un m&eacute;todo independiente para guardar informaci&oacute;n
referente a un archivo, se utiliza para obtener modificar la informaci&oacute;n
asociada a un archivo.
<P>Los objetos File se pueden crear utilizando uno de los tres constructores
siguiente (los ejemplos utilizan un archivo en <TT>/usr/local/texto/articulo.txt</TT>):
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="70%" rule="cols" >
<TR>
<TD VALIGN=TOP><TT>File (string directorio);</TT>
<BR>Ejemplo:
<BR><TT>File dir = new File("/usr/local/texto");</TT></TD>
</TR>

<TR>
<TD VALIGN=TOP>Crea un objeto file basado en el directorio final.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>File(String directorio, String archivo);</TT>
<BR>Ejemplo:
<BR><TT>File Arch=new File("texto","articulo.txt");</TT></TD>

<TD VALIGN=TOP>Crea una instancia de la clase file para un archivo especifico
y no para el directorio completo.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>File(File obj, String archivo);</TT>
<BR>Ejemplo:
<BR><TT>File Arch= new File(dir,"articulo.txt");</TT></TD>

<TD VALIGN=TOP>Idem anterior, pero en lugar de definir el directorio como
un string se define como un objeto.</TD>
</TR>
</TABLE></CENTER>

<P>La clase file define muchos m&eacute;todos, donde los m&aacute;s destacados
pueden ser:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="90%" >
<TR ALIGN=CENTER BGCOLOR="#5898C0">
<TH>M&Eacute;TODO&nbsp;</TH>

<TH>DESCRIPCI&Oacute;N&nbsp;</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>public String getName()</TT></TD>

<TD VALIGN=TOP>El nombre del archivo como <TT>String</TT>, no devuelve
la estructura de directorios donde se encuentra.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public String getPath()</TT></TD>

<TD VALIGN=TOP>El nombre del archivo en la clase <TT>File</TT>.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public String getAbsolutePath()&nbsp;</TT></TD>

<TD VALIGN=TOP>El nombre del archivo, precedido de la ruta de acceso.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public String getParent()</TT></TD>

<TD VALIGN=TOP>El nombre del directorio padre si existe si no <TT>null</TT>.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public boolean exists()</TT></TD>

<TD VALIGN=TOP>Devuelve verdadero si el archivo existe el sistema.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public boolean isFile()</TT></TD>

<TD VALIGN=TOP>Devuelve verdadero si la instancia de <TT>File</TT> es un
archivo valido y normal.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public boolean canWrite()</TT></TD>

<TD VALIGN=TOP>Devuelve verdadero si existe el archivo y este puede modificarse.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public boolean canRead()</TT></TD>

<TD VALIGN=TOP>Devuelve verdadero si existe el fichero y este puede leerse.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public int lastModified()</TT></TD>

<TD VALIGN=TOP>La &uacute;ltima vez que se modifico el fichero.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public boolean renameto(File dest)</TT></TD>

<TD VALIGN=TOP>Renombra el archivo actual con el nombre del archivo de
la clase File. Devuelve true si ha tenido existo y false en caso contrario.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public boolean mkdir()</TT></TD>

<TD VALIGN=TOP>Crea en la clase <TT>File</TT> el directorio relativo al
directorio actual. Devuelve verdadero si el directorio se creo con existo
y falso en caso contrario.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public boolean mkdirs()</TT></TD>

<TD VALIGN=TOP>Idem caso anterior pero crea la estructura de directorio
completa.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>public String list[]</TT></TD>

<TD VALIGN=TOP>Lista el contenido del directorio que se encuentra en la
clase file. Devuelve una matriz con nombre de archivos menos "." y "..".</TD>
</TR>
</TABLE></CENTER>

<P><TT><U>FileInputStream</U></TT> : crea un <TT>InputStream</TT> que se
puede utilizar para leer el contenido de un archivo. Los constructores
m&aacute;s habituales son:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=TOP><TT>FileInputStream(String ruta) throws FileNotFoundExcption;</TT></TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>FileInputStream(File obj) throws FileNotFoundException;</TT></TD>
</TR>
</TABLE></CENTER>

<P>Donde ruta es el nombre completo del directorio de un archivo y obj
es un objeto de tipo File. Si el archivo no existe genera una excepci&oacute;n.
<P>M&eacute;todos definidos por <TT>fileinputstream</TT>:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="90%" rule="cols" >
<TR ALIGN=CENTER BGCOLOR="#5898C0">
<TH>M&Eacute;TODO&nbsp;</TH>

<TH>DESCRIPCI&Oacute;N&nbsp;</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>int read()</TT></TD>

<TD VALIGN=TOP>Devuelve como entero el siguiente byte de la entrada.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>int read(byte bufer[])</TT></TD>

<TD VALIGN=TOP>Intenta leer hasta <TT>bufer.length</TT> bytes situ&aacute;ndolos
en bufer y devuelve el n&uacute;mero de bytes le&iacute;dos con exito.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>int read (byte bufer[], int off, int len)</TT></TD>

<TD VALIGN=TOP>Intenta leer <TT>len</TT> bytes situ&aacute;ndolos en
<TT>bufer</TT>
comenzando en <TT>bufer[off]</TT>, devuelve el n&uacute;mero de bytes que
se leyeron con exito.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>int skip(long n)</TT></TD>

<TD VALIGN=TOP>Omite <TT>n</TT> bytes de la entrada y devuelve el numero
de bytes que se han omitido.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>int available()</TT></TD>

<TD VALIGN=TOP>Devuelve el n&uacute;mero de bytes disponibles para la lectura.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>void close()</TT></TD>

<TD VALIGN=TOP>Cierra el origen de la entrada.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>void mark(int n)</TT></TD>

<TD VALIGN=TOP>Coloca una marca en el punto actual del flujo de entrada
que seguir&aacute; siendo valido hasta que se lean <TT>n</TT> bytes.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>void rest()</TT></TD>

<TD VALIGN=TOP>Devuelve el puntero de entrada a la marca establecida con
el m&eacute;todo anterior.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>boolean markSupported()</TT></TD>

<TD VALIGN=TOP>Devuelve true si se admite los m&eacute;todos <TT>mark()</TT>
o <TT>reset()</TT>.</TD>
</TR>
</TABLE></CENTER>

<P>La clase <TT>FileOutputStream</TT> crea un <TT>OutputStream</TT> que
se utiliza para escribir en un archivo. Sus dos constructores m&aacute;s
habituales son:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=TOP><TT>FileOutputStream (String ruta) throws IOException;</TT>
<P><TT>FileOutputStream(File obj) throws IOException;</TT></TD>
</TR>
</TABLE></CENTER>

<P>Donde <TT>ruta</TT> es nuevamente el directorio completo de un archivo
y <TT>obj</TT> un objeto de tipo <TT>File</TT>, puede lanzar una excepci&oacute;n
<TT>IOException</TT>.
Los m&eacute;todos m&aacute;s interesantes que define esta clase son:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="90%" rule="cols" >
<TR ALIGN=CENTER BGCOLOR="#5898C0">
<TH>M&Eacute;TODO&nbsp;</TH>

<TH>DESCRIPCI&Oacute;N&nbsp;</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>void write(int b)</TT></TD>

<TD VALIGN=TOP>Escribe un &uacute;nico byte en un fichero de salida.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>void write(byte buffer[])</TT></TD>

<TD VALIGN=TOP>Escribe una matriz completa de bytes en un flujo de salida</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>void write(byte bufer[], int n, int lon)</TT></TD>

<TD VALIGN=TOP>Escribe <TT>lon</TT> bytes de la matriz <TT>bufer</TT>,
comenzando a partir de <TT>bufer[n]</TT>.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>void flush()</TT></TD>

<TD VALIGN=TOP>Inicializa la salida.</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>void close()</TT></TD>

<TD VALIGN=TOP>Cierra el flujo de salida.</TD>
</TR>
</TABLE></CENTER>

<P>Java permite los flujos con bufer, esto permite realizar las operaciones
de E/S con varios bytes a la vez increment&aacute;ndose el rendimiento.
Se define las clases:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="60%" >
<TR>
<TD VALIGN=TOP><TT>BufferdInputStream</TT>
<P><TT>BufferdOutputStream</TT></TD>
</TR>
</TABLE></CENTER>

<P><U>RandomAccessFile</U>
<BR>&nbsp;
<TABLE ALIGN=RIGHT BORDER CELLPADDING=5 >
<TR>
<TD VALIGN=TOP><TT>RandomAccesFile(File obj, string modo)</TT>
<BR><TT>RandomAccesFile(String archivo, String modo)</TT></TD>
</TR>
</TABLE>

<P>Ofrece m&uacute;ltiples m&eacute;todos para interacciones con un archivo,
en esta clase se a&uacute;nan todas las funciones de las clases anteriores
m&aacute;s la posibilidad de acceder a un archivo que se encuentre en cualquier
lugar y adem&aacute;s es posible determinar con exactitud la posici&oacute;n
del archivo desde el cual se desea recuperar los datos. Se definen los
siguientes constructores:
<P>Donde obj especifica el nombre del archivo que se desea abrir a igual
que archivo pero este como un String. En ambos casos modo determina el
tipo de acceso al archivo:
<DIR><U>r</U>: s&oacute;lo lectura
<P><U>w</U>: lectura, escritura</DIR>
El m&eacute;todo <TT>seek(long posinicial)</TT> se utiliza para establecer
la posici&oacute;n actual del puntero dentro del archivo.
<P>Ejemplo :
<BR>En el siguiente ejemplo veremos como accedemos a un fichero secuencial,
leeremos car&aacute;cter a car&aacute;cter y como en un ejemplo anterior
calcularemos el numero de caracteres que hay distintos en el fichero:
<BR>&nbsp;
<CENTER><TABLE BORDER CELLPADDING=5 WIDTH="90%" rule="cols" >
<TR ALIGN=CENTER BGCOLOR="#5898C0">
<TH>C&Oacute;DIGO&nbsp;</TH>

<TH>COMENTARIOS&nbsp;</TH>
</TR>

<TR>
<TD VALIGN=TOP BGCOLOR="#F8FCC0">
<PRE>import java.io.*;
class Fichero {

public static void main(String args[]){&nbsp;
int i, j ;
char c;
char linea[] = new char [256];
String archivo= args[0];&nbsp;
FileInputStream fichero;
try {&nbsp;
fichero = new FileInputStream(archivo);
}catch (FileNotFoundException e) {
System.out.println("archivo no encontrado");
Return;
}&nbsp;
try {
do {
i = fichero.read();
if (i != -1)
++linea[i];
} while (i != -1);
}catch(IOException e){
System.out.println("error e/s");
return;
}
try {
fichero.close();
}catch(IOException e){
System.out.println("error e/s");
return;
}
for (j=0;j&lt;256;j++) {
if (linea[j] > 0)
System.out.println("del caracter: "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + (char)j
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " hay :"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + (int)linea[j]);
}
}
}</PRE>
</TD>

<TD VALIGN=CENTER>Importamos el paquete java.io, para poder realizar operaciones
con archivos. El nombre del archivo a analizar los recibimos por la l&iacute;nea
de par&aacute;metros <TT>args[]</TT>.
<P>Crearemos un objeto "<TT>fichero</TT>" de tipo <TT>FileInputStream</TT>,
que posteriormente instanciaremos utilizando el constructor:
<P><TT>FileInputStream(String archivo ) throws FileNotFoundExcption</TT>
<P>Ya que utilizamos la variable "<TT>archivo</TT>" que es de tipo <TT>String</TT>.
Controlaremos la existencia del fichero con la excepci&oacute;n adecuada
dando un mensaje de error por la salida est&aacute;ndar si no existe.
<P>A continuaci&oacute;n leeremos el fichero car&aacute;cter a car&aacute;cter
hasta que se encuentre el final del archivo, asimismo controlaremos que
no se produce ning&uacute;n tipo de error. Finalmente cerraremos el fichero
y visualizaremos los resultados.
<P>La lectura de los archivos car&aacute;cter a car&aacute;cter tiene una
sola ventaja a mi entender, que es la posibilidad de leer cualquier car&aacute;cter
Unicode y no quedarnos en los 256 caracteres del ASCII.</TD>
</TR>
</TABLE></CENTER>

<H3>
PAQUETES</H3>
A continuaci&oacute;n haremos un recorrido por la biblioteca est&aacute;ndar
de Java. Veremos los paquetes b&aacute;sicos del lenguaje donde se encuentra
la mayor parte de su potencia. No pretendo hacer una presentaci&oacute;n
completa del API del JDK, ya que solo esto de forma esquem&aacute;tica
ocupar&iacute;a m&aacute;s de 300 p&aacute;ginas, s&oacute;lo describiremos
cada paquete y se&ntilde;alaremos las clases y m&eacute;todos m&aacute;s
importantes. Para una mayor informaci&oacute;n podemos recurrir a la propia
documentaci&oacute;n del JDK o alg&uacute;n otro manual que la incorpora.
Es necesario indicar que este API crece y evoluciona r&aacute;pidamente
por lo que nos podemos quedar obsoletos en poco tiempo.
<DL>
<DT>
<B>Paquete java.lang:</B></DT>

<DD>
Es el m&aacute;s &iacute;ntimamente relacionado con el lenguaje. Contiene
:</DD>

<UL>
<LI>
La clase Object madre de todas las clases.</LI>

<LI>
Clases correspondientes a los tipo base: <TT>Boolean, Character, Byte,
Short, Integer, Long, Float, Void</TT> , a estas clases se les llaman envolventes
y se utilizan cuando se quieren utilizar los tipos b&aacute;sicos como
objetos.</LI>

<LI>
<TT>Math</TT>, proporciona funciones matem&aacute;ticas avanzadas.</LI>

<LI>
<TT>String</TT> y <TT>StringBuffer</TT> para gestionar las cadenas de caracteres.</LI>

<LI>
<TT>Throwable</TT>, <TT>Exception</TT> y <TT>Error</TT> para la gesti&oacute;n
de errores.</LI>

<LI>
<TT>Tread</TT> y <TT>ThrreadGroup</TT> para la gesti&oacute;n de los procesos
concurrentes.</LI>

<LI>
<TT>Runtime</TT> y <TT>System</TT> para acceder a funciones de bajo nivel
la JVM y del sistema anfitri&oacute;n.</LI>
</UL>
Dentro de las clases se&ntilde;alaremos:
<DL>
<DT>
Clase <TT>Math</TT>:</DT>

<DD>
Esta Pseudoclase define las principales cosntantes matem&aacute;ticas y
las funciones m&aacute;s habituales. La funci&oacute;n <TT>Log</TT> se
refiere a los logaritmos neperianos.</DD>

<BLOCKQUOTE>public static final Double E=2.718281828459045
<BR>public static final Double PI=3.14592653589793
<BR>public static Double abs(Double a)
<BR>public static float abs(float a)
<BR>public static int abs(int a)
<BR>public static native Double acos(Double a)
<BR>public static native Double asin(Double a)
<BR>public static native Double atan(Double a)</BLOCKQUOTE>
idem para las funciones:<TT> cos, exp, floor, log, max, min, round, sin,
sqrt, tan</TT>.
<DT>
Clase <TT>Object</TT>:</DT>

<DD>
Esta clase es la antecesora de todas las dem&aacute;s. Define comportamientos
predeterminados para los m&eacute;todos comunes a todos los objetos.</DD>

<DT>
Clase <TT>OutOfMemoryError</TT>:</DT>

<DD>
Error que se&ntilde;ala la falta de memoria. T&iacute;pico error que en
los ejemplos y manuales no se utiliza pero que en la vida real se debe
de usar para controlar la falta de memoria en la ejecuci&oacute;n de programas.</DD>

<DT>
Clase <TT>String, StringBuffer, Thread</TT> :</DT>

<DD>
Estas clases ya las hemos repasamos en cap&iacute;tulos anteriores, indicar
que pertenecen a este paquete.</DD>

<DT>
Clase <TT>System</TT>:</DT>

<DD>
Se utiliza para manipular algunas funciones relacionadas con el sistema
operativo. En particular define los principales flujos de entrada, salida
y error.</DD>
</DL>

<DT>
<B>Paquete java.util:</B></DT>

<DD>
Este paquete define clases de utilidad. Se agrupan en las familias siguientes:</DD>

<UL>
<LI>
clases estructuras de datos: <TT>Hashtable</TT>, <TT>Vector</TT>, <TT>Enumeration</TT>.</LI>

<LI>
clases de gesti&oacute;n de fechas.</LI>

<LI>
gesti&oacute;n de internacionalizaci&oacute;n.</LI>

<LI>
gesti&oacute;n de eventos, etc.</LI>
</UL>

<DL>
<DT>
Clase <TT>Calendar</TT>:</DT>

<DD>
Clase abstracta que permite la conversi&oacute;n entre un objeto <TT>Date</TT>
y valores enteros de tipo D&iacute;a, Mes, A&ntilde;o, etc. Permite tambi&eacute;n
efectuar operaciones aritm&eacute;ticas sobre las fechas. Esta clase define
constantes que representan los meses, los d&iacute;as, y ciertos m&eacute;todos
de c&aacute;lculo.</DD>

<PRE>public static final int ERA=0
public static final int YEAR=1
public static final int MONTH=2
public static final int SUNDAY=1
public static final int MONDAY=2
.......
public static final int JUNARY=0
public static final int FEBRUARY=1
.......
public static sysnchronized Calendar getinstance()
public static sysnchronized Calendar getinstance(TimeZone, zone)
......
public int getFirstDaysinFirstWeek()
public final Date getTime()
protected void setTimeinMillis(long)
public final void set(int year, int month, int date)</PRE>

<DT>
Clase <TT>Hashtable</TT>:</DT>

<DD>
define una estructura de datos tipo matriz con claves hashing. Asocia un
valor con una clave permitiendo recuperar el valor muy r&aacute;pidamente.
Se utiliza cuando se quiera almacenar valores con un &iacute;ndice no num&eacute;rico.</DD>

<DT>
Clase <TT>Properties</TT>:</DT>

<DD>
extensi&oacute;n de la clase anterior que permite leer y escribir en un
flujo una lista de pares clave-valor:</DD>

<PRE><FONT COLOR="#FF3030">// constructores
</FONT>public Properties()
public Properties(Properties defecto)
<FONT COLOR="#FF3030">// m&eacute;todos
</FONT>public String getProperty(String key)
public void list(PrintSttream out)
public Enumeration propertyNames()</PRE>

<DT>
Clase <TT>Random</TT>:</DT>

<DD>
devuelve n&uacute;meros pseudoaleatorios.</DD>

<DT>
Clase <TT>Timezone</TT>:</DT>

<DD>
Representa un uso horario, se utiliza con Calendar y devuelve el uso dado
por el sistema.</DD>

<DT>
Clase <TT>Vector</TT>:</DT>

<DD>
Define una estructura de datos tipo vector(matriz din&aacute;mica).</DD>
</DL>

<DT>
<B>Paquete Java.io:</B></DT>

<DD>
Contiene todas las clases relativas a las entradas y salidas. Contine:</DD>

<UL>
<LI>
Un conjunto de clases para gestionar los flujos de bytes.</LI>

<LI>
Un conjunto de clases para gestionar los flujos de caracteres.</LI>

<LI>
Un conjunto de clases para los accesos a los archivos.</LI>
</UL>
Muchas de las clases aqu&iacute; mencionadas las hemos visto en los &uacute;ltimos
cap&iacute;tulos de este articulo:
<DL>
<DT>
Clase <TT>File</TT>:</DT>

<DD>
define un conjunto de atributos est&aacute;ticos dependientes del sistema.</DD>

<DT>
Clase <TT>InputStream</TT>:</DT>

<DD>
clase abtracta que es el prototipo de todos los objetos que manipulan un
flujo de entrada.</DD>

<DT>
Clase <TT>FileInputStream</TT>:</DT>

<DD>
esta clase es un InputStream asociada a un archivo.</DD>

<DT>
Clase <TT>FileNotFoundException</TT>:</DT>

<DD>
esta excepcion se activa autom&aacute;ticamente cuando se intenta crear
un objeto que referencia a un archivo que no existe.</DD>

<DT>
Clase <TT>OutputStream</TT>:</DT>

<DD>
clase abstracta que es el prototipo de todos los objetos que manipulan
un flujo de salida.</DD>

<DT>
Clase <TT>FileOutputStream</TT>:</DT>

<DD>
flujo de salida asociado a un archivo.</DD>

<DT>
Clase <TT>PipedInputStream</TT>:</DT>

<DD>
esta clase permite conectar un flujo de entrada a un flujo de salida.</DD>

<DT>
Clase <TT>RandomAccesFile</TT>:</DT>

<DD>
propone un interfaz de lectura y escritura a un archivo.</DD>
</DL>

<DT>
<B>Paquete Java.net:</B></DT>

<DD>
Este paquete proporciona los mecanismos de trabajo en red. Java admite
los protocolos TCP y UDP. Las clases que se utilizan mas frecuentemente
son:</DD>

<UL>
<LI>
La clase <TT>URL</TT>, que representa un URL de Internet.</LI>

<LI>
La clase <TT>Socket</TT> y <TT>ServerSocket</TT> que permiten establecer
conexiones TCP/IP seg&uacute;n la interfaz Socket.</LI>

<LI>
<TT>DatagramaPacket</TT> y <TT>DatagramaServer</TT>, para establecer conexiones
UDP.</LI>

<LI>
<TT>InetAdress</TT> que representa un direcci&oacute;n ICP/IP.</LI>
</UL>

<DL>
<DT>
Clase <TT>ContenHandler</TT>:</DT>

<DD>
clase abstracta que es el prototipo de clases especializadas en la interpretaci&oacute;n
del contenido de un flujo, un caso tipo es el del protocolo HTTP.</DD>

<DT>
Clase <TT>HttpUrlConnection</TT>:</DT>

<DD>
esta clase est&aacute; especializada en la gesti&oacute;n de protocolos
HTTP. Es utilizada autom&aacute;ticamente por un objeto URL cuando se habr&eacute;
una conexi&oacute;n.</DD>

<DT>
Clase <TT>InetAddress</TT>:</DT>

<DD>
encapsula las diferentes formas de vincular direcciones Internet a un nombre
de anfitri&oacute;n, por lo tanto encpsula tanto los direcciones IP num&eacute;ricas
como el nombre de domino de esas direcciones.</DD>

<PRE>public String getHostName()
public byte[] getAddress()</PRE>

<DT>
Clase <TT>ServerSocket</TT>:</DT>

<DD>
posee la capacidad de escucha de un puerto TCP. Se trata de un elemento
fundamental en el dise&ntilde;o de un servidor.</DD>

<PRE><FONT COLOR="#FF3030">//constructores
</FONT>public ServerSocket(int puerto)
public ServerSocket(in puerto, int ba)
<FONT COLOR="#FF3030">//m&eacute;todos
</FONT>public Socket accept()
public void close()
public InetAdress getInetAdress()</PRE>

<DT>
Clase <TT>URL</TT>:</DT>

<DD>
permite definir un modo de representaci&oacute;n uniforme para el nombrado
de objetos.</DD>
</DL>

<DT>
<B>Paquete Java.applet:</B></DT>

<DD>
Es paquete aporta las funcionalidades para crear y gestionar los applets.</DD>

<DL>
<DT>
Clase <TT>Applet</TT>:</DT>

<DD>
para crear su propia applet tendr&aacute; que derivar esta clase y especificar
los m&eacute;todos siguientes:</DD>

<DL>
<DT>
<TT>getAppletInfo</TT>:</DT>

<DD>
devuelve informaci&oacute;n sobre el applet.</DD>

<DT>
<TT>getParameterInfo</TT>:</DT>

<DD>
idem pero de los par&aacute;metros del applet.</DD>

<DT>
<TT>Init</TT>:</DT>

<DD>
llamada al inicio del applet.</DD>

<DT>
<TT>Start</TT>:</DT>

<DD>
llamada para lanzar el applet.</DD>

<DT>
<TT>Stop</TT>:</DT>

<DD>
llamada para parar al applet.</DD>

<DT>
<TT>Destroy</TT>:</DT>

<DD>
llamada para liberar los recursos ocupados por el applet.</DD>
</DL>
No se preocupe, los dos siguientes art&iacute;culos los dedicaremos por
completo a este paquete.</DL>

<DT>
<B>Paquete Java.awt:</B></DT>

<DD>
Este paquete engloba toda la interfaz gr&aacute;fica. Es el que m&aacute;s
a crecido y m&aacute;s r&aacute;pidamente evoluciona y cambia. Tiene innumerables
clases y m&eacute;todos, intentaremos ver los m&aacute;s representativos:</DD>

<DL>
<DT>
Clase <TT>BorderLayout</TT>:</DT>

<DD>
Es el gestor de organizaci&oacute;n con limites.</DD>

<DT>
Clase <TT>Button</TT>:</DT>

<DD>
crea un bot&oacute;n de control.</DD>

<DT>
Clase <TT>Canvas</TT>:</DT>

<DD>
crea una ventana sin una sem&aacute;ntica asociada.</DD>

<DT>
Clase <TT>CardLayout</TT>:</DT>

<DD>
gestor de organizaci&oacute;n con tarjetas.</DD>

<DT>
Clase <TT>Chekbox</TT>:</DT>

<DD>
cuadro de comprobaci&oacute;n.</DD>

<DT>
Clase <TT>Choise</TT>:</DT>

<DD>
crea una lista emergente.</DD>

<DT>
Clase <TT>Color</TT>:</DT>

<DD>
gestiona los colores.</DD>

<DT>
Clase <TT>Dialog</TT>:</DT>

<DD>
crea una ventana de di&aacute;logo.</DD>

<DT>
Clase <TT>Event</TT>:</DT>

<DD>
encapsula eventos.</DD>

<DT>
Clase <TT>FileDialog</TT>:</DT>

<DD>
crea ventanas para seleccionar archivos.</DD>

<DT>
Clase <TT>FlowLayout</TT>:</DT>

<DD>
gestor de organizaci&oacute;n lineal.</DD>

<DT>
Clase <TT>Font</TT>:</DT>

<DD>
encapsula un tipo de letra.</DD>

<DT>
Clase <TT>Frame</TT>:</DT>

<DD>
crea una ventana est&aacute;ndar.</DD>

<DT>
Clase <TT>Graphics</TT>:</DT>

<DD>
encapsula el entorno gr&aacute;fico.</DD>

<DT>
Clase <TT>Image</TT>:</DT>

<DD>
encapsula im&aacute;genes gr&aacute;ficas.</DD>

<DT>
Clase <TT>Label</TT>:</DT>

<DD>
crea una etiqueta.</DD>

<DT>
Clase <TT>List</TT>:</DT>

<DD>
crea una lista donde el usuario puede elegir un elemento.</DD>

<DT>
Clase <TT>Menu</TT>:</DT>

<DD>
crea un men&uacute; desplegable.</DD>

<DT>
Clase <TT>MenuBar</TT>:</DT>

<DD>
crea una barra de men&uacute;.</DD>

<DT>
Clase <TT>MenuItem</TT>:</DT>

<DD>
crea un elemento de un men&uacute;.</DD>

<DT>
Clase <TT>Polygon</TT>y:</DT>

<DD>
encapsula un pol&iacute;gono.</DD>

<DT>
Clase <TT>Rectangle</TT>:</DT>

<DD>
&iacute;dem rect&aacute;ngulo.</DD>

<DT>
Clase <TT>Scrollbar</TT>:</DT>

<DD>
crea una barra de desplazamiento.</DD>

<DT>
Clase <TT>Textarea</TT>:</DT>

<DD>
crea un control para un &aacute;rea de texto.</DD>

<DT>
Clase <TT>Window</TT>:</DT>

<DD>
crea una ventana sin marco, si men&uacute;, ni t&iacute;tulo.</DD>
</DL>
</DL>
La lista de este paquete, como de los anteriores y de otros que aun faltan,
ser&iacute;a interminable y no ser&iacute;a nada did&aacute;ctico aunque
hay que entender que toda la potencia del lenguaje Java est&aacute; encerrada
en todas estas clases, y de aqu&iacute; deriva tambi&eacute;n su complejidad;
ya que conocer todo los paquetes y sus clases es una tarea bastante larga
y compleja, y mucho m&aacute;s aun dominarla.
<P>Habr&aacute; observado que en estos cap&iacute;tulos y en estas paginas
HTML no se ha encontrado nada en movimiento, es decir ning&uacute;n Applet
que distrajese nuestra vista. No soy muy partidario de ello pero como aperitivo
a los cap&iacute;tulos siguientes que estar&aacute;n dedicados a los paquetes
gr&aacute;ficos y los applets incluir&eacute; aqu&iacute; &eacute;ste que
me pareci&oacute; muy interesante y est&aacute; basado en el juego incluido
en las librer&iacute;as gr&aacute;ficas de Linux (y UNIX) y la idea viene
del manual: <B><I>Tutorial de Java</I></B>. Manual en castellano en formato
HTML obtenido de la direcci&oacute;n <A HREF="http://www.fie.us.es/info/internet/JAVA">www.fie.us.es/info/internet/JAVA</A>.
Agust&iacute;n Froufe.
<P>He cambiado algunas cosas en el fuente para adaptarlo a mi forma de
ser (Los Ojos m&aacute;s redondos y con un poco de estrabismo). El <A HREF="/common/src/article102/">fuente</A>
va incluido con el art&iacute;culo. (para activarlo hay que pasar el puntero
del rat&oacute;n por la imagen).
<BR>&nbsp;
<P><BR>
<CENTER>
<P><APPLET code="../../common/src/article102/Ojos.class" width=320 height=180></APPLET></CENTER>

<BR>&nbsp;
<H3>
Conclusiones:</H3>
Con este art&iacute;culo concluyo la introducci&oacute;n al lenguaje de
programaci&oacute;n Java para poder con posterioridad dedicarnos ha estudiar
aspectos que me parecen m&aacute;s interesantes del lenguaje como su capacidad
gr&aacute;fica (en cuanto a Applet), acceso a bases de datos SQL, trabajos
en red, Bean, etc. En le art&iacute;culo siguiente estudiaremos las Applets,
y con ellas detallaremos el paquete gr&aacute;fico de Java AWT, adem&aacute;s
veremos algunas interesantes Applets que incluso est&aacute;n muy extendidas
en innumerables p&aacute;ginas web de la red.
<H3>
Referencias:</H3>

<UL>
<LI>
<B><I>JAVA manual de referencia</I></B>. Patrick Naughton Herbert Schildt.
Mcgraw-Hill.</LI>

<LI>
<B><I>Programando con JAVA</I></B>. Tim Ritchey. Prentice Hall.</LI>

<LI>
<B><I>Tutorial de Java</I></B>. Manual en castellano en formato HTML obtenido
de la direcci&oacute;n <A HREF="http://www.fie.us.es/info/internet/JAVA">www.fie.us.es/info/internet/JAVA</A>.
Agust&iacute;n Froufe.</LI>

<LI>
<B><I>The Java Tutorial</I></B>. Manual en ingles en formato HTML obtenido
en la direcci&oacute;n <A HREF="http://www.javasoft.com/">www.javasoft.com</A>.
Sun.</LI>

<LI>
<B><I>Tutoriales de la propia instalaci&oacute;n del JDK</I></B>.</LI>

<LI>
<B><I>Java cliente-servidor</I></B>.C&eacute;dric Nicolas, Chistophe Avare
y Frederic Najman. Gesti&oacute;n 2000.</LI>

<LI>
<B><I>De esta misma serie: <A HREF="../July1998/article8.html">Java. Parte
I</A> y <A HREF="../articles/article8.html">Java. Parte II</A></I></B></LI>
</UL>

<DIV ALIGN=right><I>Texto original en Castellano</I></DIV>

</BODY>
</HTML>
