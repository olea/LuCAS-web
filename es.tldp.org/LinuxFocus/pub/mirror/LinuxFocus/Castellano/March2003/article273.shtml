<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.34">
 <META NAME="LFCATEGORY" CONTENT="SystemAdministration">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf273, SystemAdministration: Asegurando tus conexiones con SSH</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 p.cl { color:#EE9500 }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 .mark  { background-color:#e6e6ff }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://www.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Bernard Perrot
 =LF=CAT___: SystemAdministration
 =LF=TITLE_: Asegurando tus conexiones con SSH
 =LF=NUMBER: 273
 =LF=ANAME_: article273.html
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top"><A class="nodec" href="../"><FONT color=
                 "#DDDDDD" size="2">Hogar</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Mapa</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Indice</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../Search/"><FONT color=
                 "#DDDDDD" size="2">Busqueda</FONT></A> </TD>
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/"><FONT color=
           "#FFFFFF">Noticias</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/"><FONT color=
           "#FFFFFF">Arca</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/"><FONT color=
           "#FFFFFF">Enlaces</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">Sobre LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!--#include virtual="../../dynahead.shtml" -->

<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT BIO ABOUT THE AUTHOR -->
<TABLE ALIGN=LEFT BORDER=0  WIDTH="190" summary="about the author">
<TR>
<TD>

<!-- 2pdaIgnoreStart -->
<!-- PALM DOC -->
<TABLE BORDER=0 hspace=4 vspace=4 summary="pda download"> <TR> <TD>
<font size=1> <img src="../../common/images/2doc.gif" width=34 align=left border=0 height=22 alt="convert to palm"><a href="http://cgi.linuxfocus.org/cgi-bin/2ztxt">Convert to GutenPalm</a><br>or <a href="http://cgi.linuxfocus.org/cgi-bin/2pda">to PalmDoc</a></font>
</TD> </TR> </TABLE>
<!-- END PALM DOC -->
<!-- 2pdaIgnoreStop -->
<br>
<img src="../../common/images/bernard.perrot.jpg" width="100"
    height="138" alt="Bernard Perrot">
<BR>por  Bernard Perrot <br> <small>&lt;bernard.perrot(at)univ-rennes1.fr&gt;</small>
<BR><BR>
<I>Sobre el autor:</I><BR>
<!-- aboutauthor_start -->

    Bernard ha sido el Ingeniero de red y sistemas del CNRS
    (Centro Nacional de Investigaciones Cient&iacute;ficas de Francia) desde 1982.
    Ha estado a cargo de los proyectos relativos a la seguridad del
    sistema inform&aacute;tico en el "Instituto nacional de f&iacute;sica nuclear y
    f&iacute;sica de las part&iacute;culas" (In2p3). Ahora, trabaja para el Instituto de
    investigaci&oacute;n matem&aacute;tica (IRMAR) en el Departamento de ciencias f&iacute;sicas y
    matem&aacute;ticas (SPM).<br><br>
<!-- aboutauthor_stop -->
<!-- TRANSLATED TO es -->
<BR><BR><I>Taducido al espa&ntilde;ol por:</I><BR>
Javier G&oacute;mez Sierras <small>&lt;jgomsi(at)obelix.umh.es&gt;</small>
<br>
<!--
 =LF=TRANSTO=es: Javier G&oacute;mez Sierras
-->
<!-- TRANSLATED TO STOP -->
<BR><i>Contenidos</i>:
<UL>
  <LI><A HREF="#273lfindex0">&iquest;Para qu&eacute; se usa SSH?</A></LI>
  <LI><A HREF="#273lfindex1">&iquest;Qu&eacute; se necesita?</A></LI>
  <LI><A HREF="#273lfindex2">Manejando un mont&oacute;n de claves</A></LI>
  <LI><A HREF="#273lfindex3">Los algoritmos de cifrado</A></LI>
  <LI><A HREF="#273lfindex4">Redirecci&oacute;n de puertos, t&uacute;neles</A></LI>
  <LI><A HREF="#273lfindex5">Principales distribuciones: disponibles gratuitamente</A></LI>
  <LI><A HREF="#273lfindex6">OpenSSH </A></LI>
  <LI><A HREF="#273lfindex7">Malas noticias...</A></LI>
  <LI><A HREF="#273lfindex8">Explotando el canal cubierto (inducido por el relleno aleatorio
    en SSHv1)</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=273">Formulario de "talkback" para este art&iacute;culo</A></LI>
</UL>

</TD></TR></TABLE>
<!-- HEAD OF THE ARTICLE -->
<br>&nbsp;
<table border="0"><tr><td>
<H2>Asegurando tus conexiones con SSH</H2>
 <img src="../../common/images/illustration273.gif" alt="ssh"
    hspace="10" width="320" height="95">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Resumen</i>:
<P>
<!-- articleabstract_start -->
<p>Este art&iacute;culo se public&oacute; por primera vez en un n&uacute;mero especial de Linux
    Magazine France enfocado a la seguridad. El editor, los autores y los
    traductores permitieron amablemente a LinuxFocus publicar todos los
    art&iacute;culos de este n&uacute;mero especial. En consecuencia, LinuxFocus los
    publicar&aacute; tan pronto como est&eacute;n traducidos al ingl&eacute;s. Gracias a todas las
    personas implicadas en este trabajo. Este resumen se mostrar&aacute; en todos los
    art&iacute;culos que procedan de la misma fuente.<p><p>El prop&oacute;sito de este art&iacute;culo es realizar un buen repaso de SSH, y por
    qu&eacute; se usa.
    Esto no es un manual o gu&iacute;a de instalaci&oacute;n, sino una introducci&oacute;n al
    vocabulario y las caracter&iacute;sticas de SSH. Los enlaces y la documentaci&oacute;n
    que aparecen durante todo el art&iacute;culo, te dar&aacute;n todos los detalles de la
    implementaci&oacute;n.
    </p>
<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- BODY OF THE ARTICLE -->


    <A NAME="273lfindex0">&nbsp;</A>
<H2>&iquest;Para qu&eacute; se usa SSH?</H2>


    <p>Primero de todo (e hist&oacute;ricamente), SSH (el comando <i>ssh</i>)
    es una versi&oacute;n segura de los comandos <i>rsh</i> (y <i>rlogin</i>).
    SSH significa "<i>Secure SHell -- shell segura</i>" y <i>rsh</i> significa
    "<i>Remote SHell -- shell remota</i>". Por lo tanto, mientras que <i>rsh</i>
    te da un acceso a una shell remota f&aacute;cilmente, pero sin un mecanismo de
    autentificaci&oacute;n de usuario, <i>ssh</i> proporciona el mismo servicio pero
    con una seguridad multinivel muy alta.</p>

    <p>Si quisi&eacute;ramos dar una explicaci&oacute;n muy breve a un usuario que no quiere
    saber nada m&aacute;s (o hacer nada m&aacute;s), uno se podr&iacute;a para aqu&iacute; y decir el
    administrador ha hecho su trabajo y ha instalado el software (esto es
    bastante f&aacute;cil hoy en d&iacute;a), todo lo que tienes que hacer es reemplazar los
    comandos <i>telnet, rsh</i> o <i>rlogin</i> por el comando <i>ssh</i>, y
    todo funcionar&aacute; igual pero con m&aacute;s seguridad.
    </p>

    <p>Por lo tanto, donde hac&iacute;as:</p>

    <p>	<tt>% rlogin servidor.org</tt>	(o <tt>telnet
    servidor.org</tt>)</p>

    <p>ahora tienes que hacer:</p>

    <p>	<tt>% ssh servidor.org</tt></p>

    <p>&iexcl;y es mucho mejor!</p>

    <p>Para terminar este breve resumen, sugerir&eacute; que hoy en d&iacute;a, todos los
    incidentes de seguridad que podr&iacute;an haber sido evitados simplemente usando
    SSH en vez de <i>rsh</i> (<i>rlogin</i>,<i>telnet</i>) son principalmente
    consecuencia de la negligencia de las v&iacute;ctimas.</p>

    <A NAME="273lfindex1">&nbsp;</A>
<H2>&iquest;Qu&eacute; se necesita?</H2>


    <p>Para ver los detalles, aqu&iacute; tienes algunos de los aspectos m&aacute;s
    importantes y fr&aacute;giles de las conexiones interactivas que uno quiere ver
    resueltos:</p>

    <ul>
      <li>El primero de todos, evitar que las contrase&ntilde;as se transmitan a
      trav&eacute;s de la red</li>

      <li>uso de autentificaci&oacute;n fuerte en los sistemas a conectar, pero no
      s&oacute;lo basado en el nombre o direcci&oacute;n IP que est&aacute;n sujetos a spoofing;</li>

      <li>ejecuci&oacute;n de comandos remotos con total seguridad.</li>

      <li>protecci&oacute;n de las transferencias de ficheros;</li>

      <li>securizaci&oacute;n de las sesiones X11 que son muy vulnerables</li>
    </ul>

    <p>Para responder a estas necesidades, existen algunas soluciones que no
    son del todo satisfactorias:</p>

    <ul>
      <li>Los "<i>R-commands</i>": estos comandos no transmiten
      las contrase&ntilde;as en texto plano pero el mecanismo "rhosts" usando
      est&aacute; sujeto a numerosos problemas de seguridad,</li>

      <li>Los "<i>Contrase&ntilde;as de un solo uso -- One Time Password</i>,
      (OTP)": protegen s&oacute;lo
      la autentificaci&oacute;n y no el flujo de datos que le sigue. Aunque
      este sistema es muy atractivo desde el punto de vista de la
      seguridad, tiene unas limitaciones que lo hacen un sistema dif&iacute;cil de
      aceptar por parte de los usuarios. Consecuentemente se aplica
      mayoritariamente en entornos que no est&aacute;n sujetos a consideraciones
      de ergonom&iacute;a;</li>

      <li>telnet con cifrado: esta soluci&oacute;n s&oacute;lo es aplicable
      ... a telnet. A parte, no incluye al protocolo X11,
      un complemento a menudo necesario.</li>
    </ul>

    <p>Y tenemos SSH, una buena soluci&oacute;n para:</p>

    <ul>
      <li>reemplazo de los <i>R-commands</i>: <i>ssh</i> en vez de
      <i>rsh</i> y <i>rlogin</i>, <i>scp</i> con <i>rcp</i>,
      <i>sftp</i> con <i>ftp</i>;</li>

      <li>uso de autentificaci&oacute;n fuerte, basada en algoritmos de cifrado
      usando claves p&uacute;blicas (tanto para sistemas como usuarios);</li>

      <li>capacidad de redirigir el flujo de datos TCP en un "tunel"
      por sesi&oacute;n y en particular en sesiones X11 donde se puede hacer
      autom&aacute;ticamente;</li>

      <li>Cifrado del tunel, y cuando sea necesario y especificado,
      comprimirlo.</li>
    </ul>

    <h4>SSH versi&oacute;n 1 y SSH versi&oacute;n 2</h4>

    <p>Como nada en este mundo es perfecto, existen dos versiones
    incompatibles del protocolo SSH: la versi&oacute;n 1.x (1.3 y 1.5) y la
    versi&oacute;n 2.0. Pasar de una versi&oacute;n a la otra no es doloroso para el
    usuario, teniendo a mano el cliente correcto y el servidor correcto
    compatible con la versi&oacute;n.</p>

    <p>La versi&oacute;n 1 del protocolo SSH est&aacute; integrada, mientras que la
    versi&oacute;n 2 ha definido el protocolo anterior en tres "capas":</p>

    <ol>
      <li>Capa de transporte del protocolo SSH (SSH-TRANS)</li>

      <li>Autentificaci&oacute;n del protocolo SSH (SSH-AUTH)</li>

      <li>Conexi&oacute;n del protocolo SSH (SSH-CONN)</li>
    </ol>

    <p>Cada capa del protocolo est&aacute; definida espec&iacute;ficamente en un
    documento (borrador) normalizado por la IETF, seguido de un cuarto
    borrador que describe la arquitectura (Arquitectura del protocolo SSH,
    SSH-ARCH). Se pueden encontrar todos los detalles en: <a href=
    "http://www.ietf.org/html.charters/secsh-charter.html">http://www.ietf.org/html.charters/secsh-charter.html</a></p>

    <p>Sin meternos en muchos detalles, aqu&iacute; tienes lo que encontrar&aacute;s en
    SSHv2:</p>

    <ul>
      <li>la capa de transporte proporciona integridad, cifrado, y
      compresi&oacute;n, la autentificaci&oacute;n de sistemas</li>

      <li>la capa de autentificaci&oacute;n proporciona ... autentificaci&oacute;n
      (contrase&ntilde;a, basada en m&aacute;quina, clave p&uacute;blica)</li>

      <li>la capa de conexi&oacute;n que gestiona el t&uacute;nel (shell,
      agente SSH, redirecci&oacute;n de puertos, control del flujo).</li>
    </ul>

    <p>Las principales diferencias t&eacute;cnicas entre la versi&oacute;n 1 de SSH
    y la versi&oacute;n 2 son:</p>

    <table border="1" width="582" cellpadding="1" bgcolor="#aedbe8">
      <tr valign="TOP">
        <th>
          <p>SSH versi&oacute;n 1</p>
        </th>

        <th>
          <p>SSH versi&oacute;n 2</p>
        </th>
      </tr>

      <tr>
        <td>
          <p>dise&ntilde;o monol&iacute;tico (integrado)</p>
        </td>

        <td>
          <p>separaci&oacute;n de las funciones de autentificaci&oacute;n, conexi&oacute;n y
	  transporte en capas</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>integridad via CRC32 (no seguro)</p>
        </td>

        <td>
          <p>integridad via HMAC (cifrado hash)</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>un &uacute;nico canal por sesi&oacute;n</p>
        </td>

        <td>
          <p>un n&uacute;mero ilimitado de canales por sesi&oacute;n</p>
        </td>
      </tr>

      <tr>
        <td>
	  <p>negociaci&oacute;n usando &uacute;nicamente cifrado sim&eacute;trico en el canal,
	  identificaci&oacute;n de sesi&oacute;n con una &uacute;nica clave en ambos lados</p>
        </td>

        <td>
          <p>negociaci&oacute;n m&aacute;s detallada (cifrado sim&eacute;trico, llave p&uacute;blica,
	  compresi&oacute;n, ...), y una clave de sesi&oacute;n independiente, compresi&oacute;n
	  e integridad en ambos lados</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>s&oacute;lo RSA para el algoritmo de clave p&uacute;blica</p>
        </td>

        <td>
          <p>RSA y DSA para el algoritmo de clave p&uacute;blica</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>clave de sesi&oacute;n transmitida por el cliente</p>
        </td>

        <td>
	  <p>clave de sesi&oacute;n negociada por el protocolo Diffie-Hellman</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>clave de sesi&oacute;n v&aacute;lida para toda la sesi&oacute;n</p>
        </td>

        <td>
          <p>clave de sesi&oacute;n renovable</p>
        </td>
      </tr>
    </table>

    <A NAME="273lfindex2">&nbsp;</A>
<H2>Manejando un mont&oacute;n de claves</H2>


    <p>Tipos de claves SSH, las definir&eacute; r&aacute;pidamente:</p>

    <ul>
      <li>Clave de usuario: un par de claves compuestas de una clave
      p&uacute;blica y otra privada (ambas asim&eacute;tricas), definidas por el usuario
      y permanentes (se guardan en el disco). Estas claves permiten la
      autentificaci&oacute;n de usuario si se utiliza el m&eacute;todo de autentificaci&oacute;n
      de clave p&uacute;blica (descrito m&aacute;s adelante).</li>

      <li>Clave de m&aacute;quina: tambi&eacute;n un par de claves compuestas de una
      llave p&uacute;blica y otra privada (ambas asim&eacute;tricas), pero definidas al
      instalar/configurar SSH por el administrador del servidor y
      permanentes (guardadas en el disco). Esta clave permite la
      autentificaci&oacute;n entre sistemas.</li>

      <li>Clave de servidor: de nuevo un par de claves compuestas de una
      clave p&uacute;blica y otra privada (ambas asim&eacute;tricas), pero generadas por
      un demonio al iniciarse y renovadas regularmente. Esta clave
      permanece en memoria para asegurar el intercambio de la clave de
      sesi&oacute;n en SSHv1 (con SSHv2, no hay clave de servidor ya que el
      intercambio se asegura con el protocolo Diffie-Hellman).</li>

      <li>Clave de sesi&oacute;n: esta es una clave secreta usada por el algoritmo
      de cifrado sim&eacute;trico para cifrar el canal de comunicaci&oacute;n. Como es
      en todos los productos modernos de criptograf&iacute;a, la clave es
      aleatoria y perecedera. SSHv1 tiene una clave por sesi&oacute;n, en ambos
      lados. SSHv2 tiene dos claves de sesi&oacute;n regeneradas, una en cada
      lado.</li>
    </ul>

    <p>El usuario a&ntilde;ade una frase de paso (pass phrase) que protege
    la parte privada de las anteriores claves. Esta protecci&oacute;n se asegura
    cifrando el fichero que contiene la clave privada con un algoritmo
    sim&eacute;trico. La clave secreta usada para cifrar el fichero se deriva de
    esta frase de paso.</p>

    <h4>M&eacute;todos de autentificaci&oacute;n</h4>

    <p>Hay varios m&eacute;todos de autentificaci&oacute;n de usuario, la elecci&oacute;n
    depende de la necesidades definidas en las pol&iacute;ticas de seguridad. Los
    m&eacute;todos autorizados se activan o no en el fichero de configuraci&oacute;n del
    servidor. Aqu&iacute; est&aacute;n las principales categor&iacute;as:</p>

    <ul>
      <li>
        <b>"similar a telnet":</b>

	<p>Este es el "tradicional" m&eacute;todo de la contrase&ntilde;a: al conectar,
	despu&eacute;s de haber introducido nuestro identificador, se le pide al
	usuario que introduzca una contrase&ntilde;a que se env&iacute;a al servidor que
	la compara con la que tiene asociada a dicho usuario. El problema
	residual (el que causa una cifra astron&oacute;mica actos delictivos en
	Internet) es que la contrase&ntilde;a se env&iacute;a a la red <i>en claro</i>, y
	por lo tanto puede ser interceptada por cualquiera que que tenga un
	simple "<i>sniffer</i>" (capturador de paquetes). En este caso SSH
	tiene la misma apariencia (es un modo f&aacute;cil usuarios inexpertos que
	migran de telnet a SSH, ya que no hay nada nuevo que aprender ...),
	no obstante el protocolo SSH cifra el canal y la contrase&ntilde;a en
	claro se encapsula.
        </p>

	<p>Una variante incluso m&aacute;s segura, configurable si uno tiene lo
	necesario en el servidor es el uso de una "<i>Contrase&ntilde;a de un solo
	uso -- One time password</i>" (S/Key por ejemplo):
	seguramente es mejor, obviamente m&aacute;s seguro, pero las limitaciones
	de ergonom&iacute;a lo hacen aplicable &uacute;nicamente a situaciones
	particulares. Este sistema opera como sigue: despu&eacute;s de introducir
	nuestro identificador, en vez de preguntar al usuario una
	contrase&ntilde;a (est&aacute;tica), el servidor envia un "<i>desaf&iacute;o</i>" al que
	el usuario debe responder. Dado que el desaf&iacute;o debe ser diferente,
	la respuesta debe tambi&eacute;n cambiar. En consecuencia, la interceptaci&oacute;n
	de la respuesta no es importante ya que no puede ser reusada. La
	limitaci&oacute;n, como se mencion&oacute;, viene esencialmente de la
	codificaci&oacute;n de la respuesta que debe ser calculada (por un
	token, software en el lado cliente, etc.), y la entrada es
	bastante "cabal&iacute;stica" (seis monos&iacute;labos ingleses, en el mejor de
	los casos).<br>
        </p>
      </li>

      <li>
      <b>"similar a rhosts"</b> (<i>basados en la m&aacute;quina</i>):

        <p>En este caso la identificaci&oacute;n es similar a la de los R-commands
	con ficheros como /etc/rhosts o ~/.rhosts, que "certifican" los
	sitios clientes. SSH s&oacute;lo contribuye a una mejor identificaci&oacute;n del
	sitio, y al uso de de ficheros "<i>shosts</i>" privados. Esto no es
	suficientemente recomendable desde el punto de vista de la
	seguridad y no recomiendo usar este m&eacute;todo si se utiliza sin m&aacute;s.</p>
      </li>

      <li>
        <b>Por claves p&uacute;blicas</b>

	<p>En este caso, el sistema de autentificaci&oacute;n se basa en el
	cifrado asim&eacute;trico (para m&aacute;s detalles ver el <a
		href="../May2002/article243.shtml">art&iacute;culo sobre
		criptograf&iacute;a</a>; b&aacute;sicamente, SSHv1 usa RSA, y SSHv2 ha
	introducido DSA). La clave p&uacute;blica del usuario se registra de
	antemano en el servidor y la clave privada se guarda en el cliente.
	Con este sistema de autentificaci&oacute;n, ning&uacute;n secreto viaja a trav&eacute;s de
	la red ni es enviado al servidor.</p>

	<p>Este sistema es excelente, y sin embargo, su seguridad est&aacute;
	limitada (desde mi punto de vista) por ser casi exclusivamente
	dependiente de la "seriedad" del usuario (este problema no es
	particular de SSH, sino que creo es el EL principal problema de los
	sistemas de clave p&uacute;blica, como los actualmente populares sistemas
	PKI): por lo tanto, para evitar un compromiso de la clave p&uacute;blica
	del ordenador cliente, la clave se protege con una contrase&ntilde;a (a
	menudo llamada <i>palabra de paso -- pass phrase</i> para enfatizar
	la necesidad de usar m&aacute;s de una <i>palabra</i>). Si el usuario no
	protege cuidadosamente (o simplemente NO protege) su clave privada,
	alguien puede usarla f&aacute;cilmente para conseguir acceder a todos sus
	recursos. Es por esto por lo que digo que la seguridad recae en la
	seriedad del usuario y su nivel de confianza, ya que en este
	sistema el administrador del servidor <i>no</i> tiene ninguna
	manera de saber si la clave privada est&aacute; protegida o no. Hoy en
	d&iacute;a, SSH no administra listas de revocaci&oacute;n (no lo hacen muchos, ni
	siquiera PKI...). Por ejemplo, si una clave privada se guarda sin
	una frase de paso en el ordenador de casa (no hay ning&uacute;n chico malo
	en casa, as&iacute; que para qu&eacute; preocuparse por una frase de paso...) y
	un d&iacute;a se lleva al servicio de reparaci&oacute;n de un distribuidor
	importante ( no os ri&aacute;is, esto es lo que va a pasar cuando las
	firmas electr&oacute;nicas sean comunes...), el encargado de la reparaci&oacute;n
	( su hijo, sus amigos ) podr&aacute;n conseguir las claves privadas de
	cualquier ordenador que pase por sus mesas.</p>

	<p>Configurar el mecanismo de autentificaci&oacute;n para el usuario es
	ligeramente diferente si uno usa SSHv1, SSHv2, o OpenSSH, tambi&eacute;n
	en el caso de un cliente MacOS<sup>tm</sup> o Windows<sup>tm</sup>.
	Los principios b&aacute;sicos y los pasos a recordar son:</p>

        <ul>
	  <li>Generar un "par de claves asim&eacute;tricas" (esto es un par
	  de claves p&uacute;blica/privada RSA o DSA), la mayor&iacute;a de veces en el
	  sistema cliente, (si varios sistemas clientes se conectan
	  entonces generamos el par de claves en uno de los clientes y
	  despu&eacute;s replicamos las claves en los otros clientes). Algunos de
	  los clientes de Windows<sup>tm</sup> y MacOS<sup>tm</sup> no
	  tienen ninguna utilidad para generar el par de claves, se tiene
	  que hacer la generaci&oacute;n en una m&aacute;quina Unix antes de duplicar las
	  claves. El par de claves se registra en el directorio de usuario
	  <tt>~/.ssh</tt>.</li>

	  <li>Copiar una clave p&uacute;blica a los servidores que se usar&aacute;n para
	  la autentificaci&oacute;n. Esto se hace a&ntilde;adiendo una l&iacute;nea,
	  que corresponde al par de claves generado del directorio de
	  usuario ~/.ssh, a un fichero en el mismo directorio del servidor.
	  (El nombre depende de la versi&oacute;n SSH, tanto
	  <tt>authorized_keys</tt> o <tt>authorization</tt>).</li>

	  <li>Y eso es todo... si la configuraci&oacute;n requiere una
	  autentificaci&oacute;n mayor a nivel de servidor, entonces el cliente
	  preguntar&aacute; una "<i>frase de paso</i>" al conectar.<br>
	  </li>
        </ul>
      </li>
    </ul>

    <p>Tambi&eacute;n, es &uacute;til saber al menos dos elementos m&aacute;s referentes a la
    autentificaci&oacute;n:</p>

    <ul>
      <li>
        <b>ssh-agent</b>

	<p>Una de las razones por las que uno no protege su clave privada
	es lo molesto que resulta tener que introducir la clave en cada
	conexi&oacute;n interactiva y la imposibilidad de usar conexiones ssh en
	scripts que corran en segundo plano. Existe un remedio, el
	<i>Agente SSH -- SSH agent</i>. Es un programa (<i>ssh-agent</i>),
	que una vez activado por el usuario, te ayuda a almacenar el
	identificador de tres par&aacute;metros (nombre de usuario, nombre del
	servidor, frase de paso), y envia por ti el identificador cuando se
	realiza una conexi&oacute;n. En el lado cliente, la contrase&ntilde;a se pregunta
	una sola vez, as&iacute; que lo podr&iacute;amos llamar SSO (<i>Single Sign
	On -- Registro &uacute;nico</i>).</p>

	<p>Ahora que estas informado, nada te obliga a proteger tus claves
	privadas, pero si no lo haces, ser&aacute; una negligencia por tu parte, y
	t&uacute; ser&aacute;s el responsable de las consecuencias.</p>
      </li>
<!-- guido -->
      <li>
        <b>modo <i>"prolijo"</i> -- "<i>verbose</i>" mode</b>

	<p>Puede pasar que la conexi&oacute;n falle por motivos que el usuario
	desconoce: simplemente a&ntilde;ade la opci&oacute;n "<tt>-v</tt>" (viene de
	"<i>verbose</i>", "prolijo, verboso") al comando <i>ssh</i>. Con
	esta opci&oacute;n, aparecer&aacute;n numerosos mensajes detallados en la
	pantalla durante la conexi&oacute;n, lo que a menudo te dar&aacute; suficiente
	informaci&oacute;n para determinar la causa del fallo.</p>
      </li>
    </ul>

    <A NAME="273lfindex3">&nbsp;</A>
<H2>Los algoritmos de cifrado</H2>


    <p>Se debe distinguir entre los que cifran los canales de comunicaci&oacute;n
    (cifrando con claves secretas) y los que se usan para la
    autentificaci&oacute;n (cifrando con claves p&uacute;blicas).</p>

    <p>Para la autenticaci&oacute;n, podemos elegir entre RSA y DSA con la
    versi&oacute;n 2 del protocolo, y &uacute;nicamente RSA con la versi&oacute;n 1 (no hay
    elecci&oacute;n posible...). Hist&oacute;ricamente se eligi&oacute; DSA porque RSA
    estaba <i>patentado</i> en algunos pa&iacute;ses. Desde finales del
    verano del a&ntilde;o 2000, RSA est&aacute; libre de derechos, y por lo tanto
    esta restricci&oacute;n ha desaparecido. No tengo preferencia sobre si la
    elecci&oacute;n buena y la mala (y m&aacute;s cuando DSA es un producto "puro"
    de la NSA, aunque halla sido esta quien lo ha puesto directa o
    indirectamente a disposici&oacute;n de la criptograf&iacute;a p&uacute;blica y
    comercial...&iquest;?)
    </p>

    <p>Para el cifrado sim&eacute;trico existen casi demasiados donde
    elegir... El protocolo impone un algoritmo com&uacute;n que tiene que
    estar presente en todas las implementaciones : el <i>triple-DES
    con tres claves</i>. En consecuencia, siempre se usar&aacute; si la
    negociaci&oacute;n entre el cliente y el servidor falla con los otros
    algoritmos. Si puedes, prueba a negociar con otro algoritmo, que
    ser&aacute; mejor, ya que que 3DES es hoy en d&iacute;a uno de los algoritmos de
    menor rendimiento. No obstante dejaremos de lado, a menos que sea
    necesario, los ex&oacute;ticos o antiguos (arc4, DES, RC4, ...) y nos
    limitaremos a:</p>

    <ul>
      <li>IDEA: tiene un mejor rendimiento que 3DES, pero no es
      completamente libre de licencias bajo ciertas condiciones (era a
      menudo el algoritmo por defecto en las versiones Unix);</li>

      <li>Blowfish: muy r&aacute;pido, posiblemente seguro, pero el algoritmo
      tiene que ser probado m&aacute;s tiempo;</li>

      <li>AES: el nuevo est&aacute;ndar (reemplaza a DES), si est&aacute; disponible
      en ambos lados, entonces &uacute;salo, est&aacute; hecho para esto.</li>
    </ul>

    <p>Personalmente, me pregunto a mi mismo sobre el inter&eacute;s que
    tiene proponer tanto algoritmos: incluso aunque el protocolo
    permite la posibilidad de negociar "uno privado" ( para un grupo
    particular de usuarios, por ejemplo), algo que me parece esencial,
    pero para el uso normal, creo que con el tiempo, AES est&aacute; llamado
    a convertirse en el est&aacute;ndar. Si AES fuera comprometido, entonces
    los problemas de seguridad ser&iacute;an mucho mayores que los que
    pudiese inducir SSH...</p>

    <A NAME="273lfindex4">&nbsp;</A>
<H2>Redirecci&oacute;n de puertos, t&uacute;neles</H2>


    <p>SSH permite la redirecci&oacute;n (<i>forwarding</i>) de cualquier
    flujo de datos TCP a trav&eacute;s de un "t&uacute;nel" en una sesi&oacute;n SSH. Esto
    significa que el flujo de datos de la aplicaci&oacute;n, en vez de ser
    gestionada directamente por los puertos del servidor y el cliente,
    es "encapsulada" en un "t&uacute;nel" creado al conectar (inicio de
    sesi&oacute;n) (<i>ver el siguiente diagrama</i>).</p>

    <p>Esto mismo se hace con el protocolo X11 sin ning&uacute;n esfuerzo
    especial (por parte del usuario), con un manejo transparente de los
    <i>displays</i> y la capacidad de propagarse continuamente cuando
    se realizan varias conexiones.</p>

    <p>Para otros flujos, existe una opci&oacute;n de l&iacute;nea de comandos, para
    cada lado:<br>
    </p>

    <ul>
      <li>
        Conexi&oacute;n directa entre el cliente y servidor<br>

        <p><img src="../../common/images/article273/SSH.gif" alt=
        "SSH.gif" width="356" height="121"></p>

        <p>(ejemplo: <tt>usuario@alice% telnet bob.org)<br>
        </tt></p>
      </li>

      <li>
        Redirecci&oacute;n de un puerto local (cliente) a un puerto remoto
	(servidor)

        <p><img src="../../common/images/article273/SSH4.gif" alt=
        "SSH4.gif" width="356" height="211"></p>

        <p>ejemplo: <tt>usuario@alice% ssh -L 1234:bob.org:143
        bob.org</tt></p>

        <p>este sistema permite el acceso desde "<i>alice.org</i>" a
        el servidor imap de "<i>bob.org</i>",<br>
	las conexiones externas a la red local ser&aacute;n rechazadas.
	&Uacute;nicamente estar&aacute;n disponibles a trav&eacute;s del la direcci&oacute;n
	<i>localhost</i>, puerto 1234, desde el cliente imap ejecutado
	en "<i>alice.org</i>".</p>

        <ul>
          <li>(1) el usuario en "<i>alice.org</i>" abre (realiza una
	  conexi&oacute;n) el t&uacute;nel SSH</li>

	  <li>(2) el usuario de <i>"alice.org"</i> configura el
	  cliente local de imap para acceder al<br>
	  servidor imap que se encuentra en <i>localhost</i> puerto
	  1234<br>
          </li>
        </ul>
<br>
<br>
      </li>

      <li>
      Redirecci&oacute;n de un puerto remoto (cliente) a un puerto local
      (servidor)<br>

        <p><img src="../../common/images/article273/SSH5.gif" alt=
        "SSH5.gif" width="356" height="215"></p>

        <p>ejemplo: <tt>root@alice% ssh -R 1234:bob.org:143
        bob.org</tt></p>

<p>Esto es lo mismo que antes pero el puerto en la m&aacute;quina remota se
redirecciona. &Uacute;nicamente root tiene los privilegios necesarios para
ejecutar este comando SSH pero cualquier usuario puede usar este
puerto redirigido/t&uacute;nel.

      </li>
        </ul>
      </li>
    </ul>

    <p>Esta potente caracter&iacute;stica ha llevado algunas veces a
    calificar a SSH como "un t&uacute;nel para pobres". Se debe comprender
    que la pobreza aqu&iacute; significa: aquellos que no tienen privilegios de
    administrador en el lado cliente. S&oacute;lo en casos particulares se
    puede redirigir un puerto local con menos privilegios ( puertos
    &gt; 1024) y sin privilegios de superusuario ("<i>root</i>"). Por
    otro lado, cuando se necesita redirigir un puerto local con
    privilegios, se tiene que hacer con la cuenta de <i>root</i>, o el
    cliente debe tener privilegios de superusuarios ("<i>suid</i>")
    (De hecho, un puerto local privilegiado permite la redefinici&oacute;n de
    un servicio est&aacute;ndar).</p>

    <p>Como con IP, es bastante f&aacute;cil meter cualquier cosa en
    cualquier cosa (y lo contrario), no solo es posible redirigir un
    flujo TCP, sino tambi&eacute;n las conexiones PPP, lo que nos permite
    hacer un t&uacute;nel IP "real" en IP (que est&aacute; cifrado, por lo tanto
    seguro). El m&eacute;todo excede el objetivo de este art&iacute;culo, pero
    puedes leer el "<a
	    href="http://www.linuxdoc.org/HOWTO/VPN-HOWTO.html">Linux
	    VPN-HOWTO</a>" para conocer los detalles y obtener scripts
    de instalaci&oacute;n (tambi&eacute;n podr&aacute;s encontrar soluciones nativas VPN
    para Linux, como "<i>stunnel</i>" que deber&iacute;as considerar antes de
    realizar la elecci&oacute;n final).</p>

    <p>Ten presente que la primera posibilidad es redirigir los flujos
    de <i>telnet</i>: Esto podr&iacute;a parecer totalmente in&uacute;til, ya que
    SSH implementa una conexi&oacute;n interactiva por defecto. Sin embargo,
    al redirigir las conexiones <i>telnet</i>, podr&iacute;as usar tu cliente
    favorito en vez del modo SSH interactivo. Esto es realmente
    valioso en entornos Windows<sup>tm</sup> o MacOS<sup>tm</sup>
    donde los clientes SSH puede que no se adecuen a la ergonom&iacute;a
    preferida por el usuario. Por ejemplo, la "emulaci&oacute;n de terminal"
    parte del cliente "<i>Mindterm</i>" (cliente SSH en Java, presente
    en todos los sistemas modernos) sufre la escasez de rendimiento
    del lenguaje Java: puede ser ventajoso usar este cliente
    &uacute;nicamente para abrir un t&uacute;nel SSH.

    <p>De la misma manera, tambi&eacute;n puedes iniciar un cliente remoto
    como "<i>xterm</i>" (por ejemplo, usando redirecci&oacute;n X11
    autom&aacute;tica -- <i>automatic X11 forwarding</i> -- en SSH), lo que
    nos permite usar SSH en terminales X.
    </p>

    <p>Ten en cuenta que el t&uacute;nel permanece abierto mientras halla un
    flujo de datos, incluso aunque no venga del que lo inici&oacute;. Por lo
    tanto, el comando "<i>sleep</i>" es muy &uacute;til para abrir un t&uacute;nel
    SSH para redirigir una nueva conexi&oacute;n TCP.</p>

    <p><tt>	% ssh -n -f -L 2323:serveur.org:23 serveur.org sleep
    60</tt></p>

    <p><tt>	% telnet localhost 2323</tt></p>

    <p><tt>	... bienvenido a serveur.org ...</tt></p>

    <p>La primera l&iacute;nea abre el t&uacute;nel, lanza el comando "<i>sleep
    60</i>" en el servidor, y redirige el puerto local n&uacute;mero 2323 al
    puerto remoto (<i>telnet</i>) n&uacute;mero 23. El segundo inicia un
    cliente <i>telnet</i> en el puerto local n&uacute;mero 2323, y entonces
    usar&aacute; el t&uacute;nel (cifrado) para conectarse al demonio <i>telnetd</i>
    del servidor. El comando "<i>sleep</i>" terminar&aacute; despu&eacute;s de
    un minuto (tienes s&oacute;lo un minuto para iniciar telnet) , pero SSH
    s&oacute;lo cerrar&aacute; el t&uacute;nel cuando el &uacute;ltimo cliente halla terminado.</p>

    <A NAME="273lfindex5">&nbsp;</A>
<H2>Principales distribuciones: disponibles gratuitamente</H2>


    <p>Tenemos que distinguir entre los clientes y/o servidores en las
    diferentes plataformas y deber&iacute;as saber que la SSH versi&oacute;n 1 y SSH
    versi&oacute;n 2 son incompatibles.
    Las referencias al final del art&iacute;culo te ayudar&aacute;n a encontrar
    otras implementaciones, que no se incluyen en la siguiente tabla
    que se limita a los productos gratuitos con caracter&iacute;sticas
    suficientemente estables.</p>

    <table border="1" width="553" cellpadding="1" bgcolor="#aedbe8">
      <tr>
        <th>
            <p>producto</p>
        </th>

        <th>
            <p>plataforma</p>
        </th>

        <th>
            <p>protocolo</p>
        </th>

        <th>
            <p>enlace</p>
        </th>

        <th>
            <p>notas</p>
        </th>
      </tr>

      <tr>
        <td>
          <p>OpenSSH</p>
        </td>

        <td>
          <p>Unix</p>
        </td>

        <td>
          <p>versiones 1 y 2</p>
        </td>

        <td>
          <p><a href=
          "http://www.openssh.com/">www.openssh.com</a></p>
        </td>

        <td>
          <p>detalles debajo</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>TTSSH</p>
        </td>

        <td>
          <p>Windows<sup>tm</sup></p>
        </td>

        <td>
          <p>versi&oacute;n 1</p>
        </td>

        <td>
          <p><a href=
          "http://www.zip.com.au/~roca/ttssh.html">www.zip.com.au/~roca/ttssh.html</a></p>
        </td>

        <td>
&nbsp;
        </td>
      </tr>

      <tr>
        <td>
          <p>Putty</p>
        </td>

        <td>
          <p>Windows<sup>tm</sup></p>
        </td>

        <td>
          <p>versiones 1 y 2</p>
        </td>

        <td>
          <p><a href=
          "http://www.chiark.greenend.org.uk/~sgtatham/putty/">www.chiark.greenend.org.uk/~sgtatham/putty</a></p>
        </td>

        <td>
          <p>s&oacute;lo beta</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>Tealnet</p>
        </td>

        <td>
          <p>Windows<sup>tm</sup></p>
        </td>

        <td>
          <p>versiones 1 y 2</p>
        </td>

        <td>
          <p><a href=
          "http://telneat.lipetsk.ru/">telneat.lipetsk.ru</a></p>
        </td>

        <td>
&nbsp;
        </td>
      </tr>

      <tr>
        <td>
          <p>SSH secure shell</p>
        </td>

        <td>
          <p>Windows<sup>tm</sup></p>
        </td>

        <td>
          <p>versiones 1 y 2</p>
        </td>

        <td>
          <p><a href="http://www.ssh.com/">www.ssh.com</a></p>
        </td>

        <td>
          <p>gratuito para uso no comercial</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>NiftytelnetSSH</p>
        </td>

        <td>
          <p>MacOS<sup>tm</sup></p>
        </td>

        <td>
          <p>versi&oacute;n 1</p>
        </td>

        <td>
          <p><a href=
          "http://www.lysator.liu.se/~jonasw/freeware/niftyssh/">www.lysator.liu.se/~jonasw/freeware/niftyssh/</a></p>
        </td>

        <td>
&nbsp;
        </td>
      </tr>

      <tr>
        <td>
          <p>MacSSH</p>
        </td>

        <td>
          <p>MacOS<sup>tm</sup></p>
        </td>

        <td>
          <p>versi&oacute;n 2</p>
        </td>

        <td>
          <p><a href=
          "http://www.macssh.com/">www.macssh.com</a></p>
        </td>

        <td>
&nbsp;
        </td>
      </tr>

      <tr>
        <td>
          <p>MindTerm</p>
        </td>

        <td>
          <p>Java</p>
        </td>

        <td>
          <p>versi&oacute;n 1</p>
        </td>

        <td>
          <p><a href=
          "http://www.mindbright.se/">www.mindbright.se</a></p>
        </td>

        <td>
          <p>v2 ahora comercial</p>
        </td>
      </tr>
    </table>

    <p>Ten en cuenta que MindTerm es tanto una implementaci&oacute;n
    independiente en Java (s&oacute;lo necesitas el <i>runtime</i> de Java )
    como un <i>servlet</i> que se puede ejecutar dentro de un un
    navegador web compatible y bien dise&ntilde;ado. Desafortunadamente, las
    &uacute;ltimas versiones de esta excelente distribuci&oacute;n han pasado a ser
    productos comerciales.</p>

    <A NAME="273lfindex6">&nbsp;</A>
<H2>OpenSSH </H2>


    <p>Hoy en d&iacute;a esta distribuci&oacute;n es probablemente la que se debe
    usar en entornos Unix/Linux (soporte continuo, buen tiempo de
    respuesta, c&oacute;digo abierto y gratuito).</p>

    <p>El desarrollo de OpenSSH comenz&oacute; con la versi&oacute;n original (SHH
    1.2.12) de Tatu Ylonen (la &uacute;ltima realmente libre) en el proyecto
    OpenBSD 2.6 (via OSSH). Ahora, OpenSSH es desarrollado por dos
    grupos, uno desarrollando &uacute;nicamente para el proyecto OpenBSD, y
    otro adaptando continuamente el c&oacute;digo para hacer una versi&oacute;n
    portable.</p>

    <p>Todo esto tiene algunas consecuencias, particularmente, el
    c&oacute;digo es cada vez m&aacute;s y m&aacute;s una monstruosa adaptaci&oacute;n constante
    (noto el s&iacute;ndrome "<i>sendmail</i>" apareciendo en el horizonte) y
    esto no es saludable para una aplicaci&oacute;n dedicada al cifrado que
    deber&iacute;a ser extremadamente rigurosa y clara.</p>

    <p>Adem&aacute;s de una programaci&oacute;n limpia y legible, otros dos puntos
    me molestan:</p>

    <ul>
      <li>OpenSSH usa la librer&iacute;a OpenSSL para sus servicios de
      cifrado, y generalmente esta librer&iacute;a se enlaza din&aacute;micamente.
      En nuestro caso, la implementaci&oacute;n de una utilidad de cifrado
      que tiene caracter&iacute;sticas tales como un buen nivel de seguridad
      y unas opciones totalmente confiables, hace que la anterior
      aproximaci&oacute;n me parezca totalmente err&oacute;nea. Por supuesto, una
      ataque a la librer&iacute;a significa un ataque al producto. M&aacute;s que
      un ataque perverso, las caracter&iacute;sticas de cifrado
      (calidad) en OpenSSH son/ser&aacute;n las de la librer&iacute;a, que tiene un
      desarrollo independiente de OpenSSH.</li>

      <li>OpenSSH usa el sistema OpenBSD para algunos de sus servicios
      m&aacute;s sensibles (por ejemplo, un generador de n&uacute;meros aleatorios).
      S&oacute;lo en este contexto, quiero resaltar la dependencia de un
      servicio externo como con OpenSSL. M&aacute;s molesto todav&iacute;a, la
      versi&oacute;n portable de OpenSSH, que deber&iacute;a funcionar en otras
      plataformas, delega los servicios requeridos por OpenBSD a
      diversos mecanismos en otras plataformas. Por ejemplo,
      dependiendo de si hay disponible o no un generador de n&uacute;meros
      aleatoreos, se usar&aacute; este o uno interno.
      En consecuencia, la entrop&iacute;a efectiva de OpenSSH depende de la
      plataforma de ejecuci&oacute;n, lo que digamos es moderadamente
      determin&iacute;stico.</li>
    </ul>

    <p>En mi opini&oacute;n (y no soy el &uacute;nico), un producto de cifrado
    multiplataforma deber&iacute;a tener un comportamiento demostrado,
    determinado y constante independientemente de la plataforma, as&iacute;
    como tomar en cuenta (eliminando) las caracter&iacute;sticas particulares
    de la plataforma y su evoluci&oacute;n.
    </p>

    <p>Dicho esto, tenemos que admitir que, las implementaciones de la
    competencia no son ni numerosas ni atractivas. Creo que es m&aacute;s
    pragm&aacute;tico considerar que hoy en d&iacute;a OpenSSH es la peor
    implementaci&oacute;n &iexcl;si excluimos al resto...! Un proyecto muy &uacute;til
    para la comunidad ser&iacute;a el redise&ntilde;o y reescritura del c&oacute;digo.</p>

    <A NAME="273lfindex7">&nbsp;</A>
<H2>Malas noticias...</H2>


    <p>&iexcl;SSH no es milagroso! Cumple bien la tarea para la que fue
    dise&ntilde;ado, pero no le puedes pedir m&aacute;s. Particularmente no evitar&aacute;
    conexiones "autorizadas": si una cuenta es comprometida, el
    intruso podr&aacute; conectarse via SSH a tu m&aacute;quina, aunque este sea el
    &uacute;nico m&eacute;todo, ya que controla la autentificaci&oacute;n. S&oacute;lo se puede
    confiar totalmente en SSH si va acompa&ntilde;ado de una pol&iacute;tica de
    seguridad pr&aacute;ctica y coherente: si alguien usa la misma contrase&ntilde;a
    para todo, y no usa SHH en todos lados, el riesgo potencial s&oacute;lo
    disminuye ligeramente.
    Podemos admitir que en esta situaci&oacute;n SSH se puede "volver contra
    t&iacute;" ya que el intruso puede usar una conexi&oacute;n segura cifrada
    con un t&uacute;nel, y podr&aacute; hacer casi todo lo que quiera sin que
    puedas rastrearlo de forma eficiente.</p>

    <p>De la misma manera, uno debe tener en cuenta tambi&eacute;n los
    "rootkits" bien hechos que normalmente contienen un demonio SSH
    para hacer volver discretamente a tu sistema, pero con unas pocas
    modificaciones: por supuesto no escucha en el puerto 22, tiene la
    delicadeza de no loguear, se llama como un demonio ordinario ( por
    ejemplo <i>httpd</i>), e invisible para el comando "ps" (que
    tambi&eacute;n ha sido modificado de alguna manera por el rootkit).
    </p>

    <p>Al contrario, uno no debe estar demasiado preocupado por el
    peligro que puede representar un demonio SSH que puede permitir a
    los intrusos estar m&aacute;s cubiertos todav&iacute;a: deber&iacute;as saber (espero)
    que es posible meter casi cualquier cosa en casi cualquier cosa en
    IP, incluyendo la "apropiaci&oacute;n indebida" de protocolos esenciales
    a trav&eacute;s de un cortafuegos: tunelizaci&oacute;n de HTML, tunelizaci&oacute;n de
    ICMP, tunelizaci&oacute;n de DNS, .... As&iacute; que no enciendas el ordenador
    si quieres un sistema 100% seguro ;-).
    </p>


    <p>SSH no est&aacute; exento de "agujeros" de seguridad derivados de la
    implementaci&oacute;n (muchos han sido corregidos en el pasado, no hay
    programa perfecto), pero tambi&eacute;n a nivel de protocolo. Estos
    "agujeros", aunque se anuncien como muy alarmantes, normalmente
    afectan a debilidades que son dif&iacute;ciles de utilizar lo que hace
    que su manipulaci&oacute;n sea t&eacute;cnicamente compleja: uno debe tener en
    mente que los incidentes de seguridad que podr&iacute;an haber sido
    evitados por el uso de SSH son diarios, mientras que aquellos que
    estar&iacute;an causados por puntos d&eacute;biles de SSH son de alguna manera
    te&oacute;ricos. Ser&iacute;a interesante leer el estudio relativo a ataques
    "<i>man in the middle</i>": <a href=
    "http://www.hsc.fr/ressources/presentations/mitm/index.html">
    http://www.hsc.fr/ressources/presentations/mitm/index.html</a>.
    No obstante ser&aacute; necesario tener en cuenta este tipo de
    vulnerabilidades potenciales para las aplicaciones de "alta
    seguridad" (banca, militares, ....), donde los medios usados por
    el cracker, altamente motivado por el premio y el
    beneficio, pueden ser considerables.</p>

    <ul>
      <li>
        Ataque "Man in the middle":<br>

        <p><img src="../../common/images/article273/SSH3.gif" alt=
        "SSH3.gif" width="503" height="257"></p>

	<p>El agresor intercepta los paquetes de ambos lados, y genera
	sus paquetes para enga&ntilde;ar a ambas partes<br>
	(diferentes escenarios son posibles, hasta el extremo de
	terminar la conexi&oacute;n en un lado,<br>
	y continuar con el otro lado haci&eacute;ndole creer que es la otra
	parte habitual)</p>
      </li>
    </ul>

    <p>Me gusta se&ntilde;alar a menudo una debilidad incomprensible del
    protocolo respecto al "relleno -- padding" (conocido como canal
    cubierto): tanto en la versi&oacute;n 1 y 2 los paquetes, tienen una
    longitud que el m&uacute;ltiplo de 64 bits, si son rellenados con un
    n&uacute;mero aleatorio. Esto es bastante inusual y por lo tanto da lugar
    a un fallo cl&aacute;sico que es bien conocido en las implementaciones de
    los productos de cifrado: un canal "oculto" (o "subliminal").
    Normalmente, "rellenamos" con una secuencia verificada como por
    ejemplo, dar el valor <i>n</i> para el rango de bytes <i>n</i>
    (<i>relleno autodescriptivo</i>). En SSH, la secuencia siendo (por
    definici&oacute;n) aleatoria, no se puede verificar. Consecuentemente
    es posible que una de las partes en comunicaci&oacute;n comprometiese
    la comunicaci&oacute;n, por ejemplo como en el caso de una tercera parte
    que est&aacute; a la escucha. Una tambi&eacute;n puede imaginar una
    implementaci&oacute;n corrupta desconocida por las dos partes (f&aacute;cil de
    realizar en un producto donde se proporcionen &uacute;nicamente los
    binarios como en general es el caso de los productos comerciales).
    Esto se puede hacer f&aacute;cilmente y en este caso uno s&oacute;lo necesita
    "infectar" el cliente o el servidor. Dejar dicho incre&iacute;ble fallo
    en el protocolo, siendo universalmente conocido que la instalaci&oacute;n
    de un canal cubierto en un producto de cifrado es EL m&eacute;todo
    cl&aacute;sico y b&aacute;sico para corromper la comunicaci&oacute;n, me parece
    increible. Puede ser interesante leer los comentarios de Bruce
    Schneier sobre la implementaci&oacute;n de dichos elementos en productos
    influenciados por agencias gubernamentales. (<a href=
    "http://www.counterpane.com/crypto-gram-9902.html#backdoors">http://www.counterpane.com/crypto-gram-9902.html#backdoors</a>).</p>

    <p>Para terminar quiero resaltar el error que encontr&eacute; en el c&oacute;digo de
    las versiones Unix anteriores a la 1.2.25, al realizar SSF, la
    adaptaci&oacute;n francesa de SSH, y cuya consecuencia era que el generador
    de n&uacute;meros aleatoreos produc&iacute;a... resultado... predecibles (esta
    situaci&oacute;n es lamentable en un producto criptogr&aacute;fico, no entrar&eacute; en
    detalles pero se pod&iacute;a comprometer una comunicaci&oacute;n con simplemente
    capturar los datos). Por aquel entonces el equipo de desarrollo de SSH
    ya hab&iacute;a corregido el problema (s&oacute;lo hab&iacute;a que modificar una l&iacute;nea),
    pero curiosamente sin enviar ninguna alerta, ni siquiera una menci&oacute;n
    en el "changelog" del producto... si no hubiesen querido que no se
    supiera, no habr&iacute;an actuado de esa manera. Por supuesto esto no tiene
    ninguna relaci&oacute;n con el enlace al art&iacute;culo anterior.</p>


    <h4>Conclusi&oacute;n</h4>

    <p>Voy a repetir lo que escrib&iacute; en la introducci&oacute;n: SSH, ni hace
    milagros, ni resuelve &eacute;l solo todos los problemas de seguridad, pero
    hace posible el manejo eficiente de los aspectos m&aacute;s fr&aacute;giles de los
    programas hist&oacute;ricamente utilizados para las conexiones interactivas
    (telnet, rsh...).
    </p>

    <h4>Bibliograf&iacute;a, enlaces esenciales</h4>

    <p>Los dos siguientes libros cubren la versi&oacute;n 1 y 2 de SSH:
    </p>

    <ul>
      <li><i>SSH: the Secure Shell</i><br>
      Daniel J. Barret &amp; Richard E. Silverman<br>
      O'Reilly - ISBN 0-596-00011-1<br>
      </li>

      <li><i>Unix Secure Shell</i><br>
      Anne Carasik<br>
      McGraw-Hill - ISBN 0-07-134933-2</li>

      <li><a href=
      "http://www.openssh.com/">openssh: http://www.openssh.com</a></li>
    </ul>

    <p>Y si te quieres gastar un poco de dinero, aqu&iacute; tienes un sitio
    donde comenzar...:</p>

    <ul>
      <li><a href="http://www.ssh.com/">http://www.ssh.com</a></li>
    </ul>

    <A NAME="273lfindex8">&nbsp;</A>
<H2>Explotando el canal cubierto (inducido por el relleno aleatorio
    en SSHv1)</H2>


    <p>
    Aqu&iacute; tienes un m&eacute;todo para explotar el canal cubierto (subliminal)
    consecuencia del uso el relleno aleatorio en SSHv1 (y v2). Rechazo
    cualquier responsabilidad sobre los ataques de coraz&oacute;n que les puedan
    dar a los m&aacute;s paranoicos.</p>

    <p>Los paquetes de SSHv1 tienen la siguiente estructura:</p>

    <table border="1" width="565" cellpadding="1" bgcolor="#aedbe8">

      <tr>
        <td>
          <p><b>offset</b></p>

          <p><b>(bytes)</b></p>
        </td>

        <td>
          <p><b>nombre</b></p>
        </td>

        <td>
          <p><b>longitud</b></p>

          <p><b>(bytes)</b></p>
        </td>

        <td>
          <p><b>descripci&oacute;n</b></p>
        </td>
      </tr>

      <tr>
        <td>
          <p>0</p>
        </td>

        <td>
          <p>tama&ntilde;o</p>
        </td>

        <td>
          <p>4</p>
        </td>

        <td>
          <p>tama&ntilde;o del paquete, tama&ntilde;o del campo sin relleno, entonces:</p>

          <p>tama&ntilde;o = longitud(tipo)+longitud(data)+longitud(CRC)</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>4</p>
        </td>

        <td>
          <p>relleno</p>
        </td>

        <td>
          <p>p =1 a 8</p>
        </td>

        <td>
          <p>relleno <b>aleatorio</b> : tama&ntilde;o ajustado para que la parte
          cifrada sea m&uacute;ltiplo de ocho</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>4+p</p>
        </td>

        <td>
          <p>tipo</p>
        </td>

        <td>
          <p>1</p>
        </td>

        <td>
          <p>tipo de paquete</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>5+p</p>
        </td>

        <td>
          <p>datos</p>
        </td>

        <td>
          <p>n (variable &gt;= 0)</p>
        </td>

        <td>
&nbsp;
        </td>
      </tr>

      <tr>
        <td>
          <p>5+p+n</p>
        </td>

        <td>
          <p>suma de control (checksum)</p>
        </td>

        <td>
          <p>4</p>
        </td>

        <td>
          <p>CRC32</p>
        </td>
      </tr>
    </table>

    <p>&Uacute;nicamente un campo no est&aacute; cifrado: el "tama&ntilde;o". La longitud de la
    parte cifrada es siempre un m&uacute;ltiplo de ocho, ajustada por el
    "relleno". El relleno siempre se realiza, si la longitud de los
    &uacute;ltimos tres campos es ya m&uacute;ltiplo de 8 entonces el relleno tendr&aacute; una
    longitud de ocho bytes (<i>5+p+n</i> resto 0 modulo 8). Sea
    la funci&oacute;n de cifrado <i>C</i>, sim&eacute;trica, usada en modo CBC, y la
    funci&oacute;n de descifrado <i>C<sup>-1</sup></i>. Para simplificar la
    demostraci&oacute;n, cogeremos solo los paquetes con un relleno de ocho
    bytes. Cuando llega un paquete, en vez de rellenarlo con un n&uacute;mero
    aleatorio, pondremos un valor <i>C<sup>-1</sup>(M)</i>, de ocho bytes
    en este caso. Esto significa descifrar el mensaje <i>M</i> con la
    funci&oacute;n <i>C</i> usada para cifrar el canal (el hecho de que <i>M</i>
    sea "descifrada" sin haber sido cifrada de antemano no tiene ninguna
    importancia desde un punto de vista estrictamente matem&aacute;tico, no voy a
    entrar en detalles aqu&iacute; sobre la implementaci&oacute;n). Lo siguiente es
    llevar a cabo el procesado normal del paquete, esto es, el cifrado en
    bloques de ocho bytes.</p>

    <p>El resultado ser&aacute; el siguiente :</p>

    <table border="1" width="478" cellpadding="1" bgcolor="#aedbe8">

      <tr>
        <td>
          <p><b>offset</b></p>
        </td>

        <td>
          <p><b>contenidos</b></p>
        </td>

        <td>
          <p><b>notas</b></p>
        </td>
      </tr>

      <tr>
        <td>
          <p>0</p>
        </td>

        <td>
          <p>tama&ntilde;o</p>
        </td>

        <td>
          <p>4 bytes no cifrado</p>
        </td>
      </tr>

      <tr>
        <td>
          <p>4</p>
        </td>

        <td>
          <p>relleno de 8 bytes (cifrado)</p>
        </td>

        <td>
          <p>entonces <i>C(C<sup>-1</sup>(M))</i></p>
        </td>
      </tr>

      <tr>
        <td>
          <p>12... fin</p>
        </td>

        <td>
          <p>tipo, datos, CRC</p>
        </td>

        <td>
&nbsp;
        </td>
      </tr>
    </table>

    <p>&iquest;Qu&eacute; es lo asombroso? El primer bloque cifrado
    contiene <i>C(C<sup>-1</sup>(M))</i>. Como <i>C</i> es una funci&oacute;n
    de cifrado sim&eacute;trica, entonces <i>C(C<sup>-1</sup>(M))</i> =
    <i>M</i>. &iexcl;Este primer bloque se envia sin cifrar en un flujo de
    datos cifrado! Eso simplemente significa que cualquier persona
    espiando la comunicaci&oacute;n que conozca la estratagema sabr&aacute; como
    explotar la informaci&oacute;n. Por supuesto, uno puede asumir que el
    propio mensaje <i>M</i> est&aacute; cifrado (mediante una clave p&uacute;blica,
    por ejemplo, lo que evita poner la clave dentro del c&oacute;digo
    pervertido), lo que permite que alguien que no est&eacute; informado no
    la pueda descifrar.</p>

    <p>Por ejemplo, son suficientes tres paquetes de este tipo para
    pasar la clave de sesi&oacute;n triple-DES (168 bit), tras los cuales el
    sniffer escuchando este flujo podr&aacute; descifrar toda la
    comunicaci&oacute;n. A partir del momento en que la clave es transmitida,
    ya no es necesario "pre-descifrar" el relleno pervertido antes de
    inyectarlo al paquete, es posible usar rellenos de cualquier
    tama&ntilde;o si uno quiere a&ntilde;adir incluso m&aacute;s informaci&oacute;n.
    </p>

    <p>El uso de este canal cubierto es <i>&iexcl;absolutamente
    indetectable!</i> (se debe tener cuidado al cifrar cada elemento
    del mensaje como se explic&oacute; previamente, para que la entrop&iacute;a del
    bloque no revele la estratagema). Indetectable porque el relleno
    es aleatorio, lo que elimina cualquier posibilidad de pruebas de
    validaci&oacute;n. El Relleno Aleatorio <i>nunca</i> deber&iacute;a utilizarse
    en los productos de criptograf&iacute;a, nunca.</p>

    <p>Lo que hace a este canal incluso m&aacute;s peligroso que otros en el
    protocolo es lo inducido por mensajes como SSH_MSG_IGNORE que es
    utilizable <i>sin</i> tener conocimiento de la clave cifrada.</p>

    <p>Para evitar los perversos efectos del relleno aleatorio, uno
    simplemente debe definir en el protocolo el uso del relleno
    determin&iacute;stico: normalmente llamado "<i>self describing padding --
    relleno autodescriptivo</i>", lo que significa que el bit de
    offset <i>n</i> contiene <i>n</i>. El relleno aleatorio existe en
    SSH v2, es una elecci&oacute;n, as&iacute; que tenlo presente...
    </p>

    <p>Para terminar, simplemente dir&eacute; que si critico el canal
    cubierto, es porque me gustar&iacute;a que un producto como SSH, que dice
    ser altamente seguro, realmente ofreciera un m&aacute;ximo de seguridad.
    Ahora eres capaz de imaginar que existen m&uacute;ltiples oportunidades
    potenciales de manipulaci&oacute;n en los productos comerciales: solo los
    productos de c&oacute;digo abierto pueden ofrecer una soluci&oacute;n a un
    requisito indispensable, la posibilidad de revisar el c&oacute;digo
    (incluso aunque dichas revisiones sean necesarias).</p>
  


<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Formulario de "talkback" para este art&iacute;culo</h2>
Cada art&iacute;culo tiene su propia p&aacute;gina de "talkback". A trav&eacute;s de esa p&aacute;gina puedes enviar un comentario o consultar los comentarios de otros lectores
<center>
<table border="0"  CELLSPACING="2" CELLPADDING="1" summary="tb-button-outerpart">
 <tr BGCOLOR="#C2C2C2"><td align=center>
  <table border="3"  CELLSPACING="2" CELLPADDING="1" summary="tb-button">
   <tr BGCOLOR="#C2C2C2"><td align=center>
    <A href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=273"><b>&nbsp;Ir a la p&aacute;gina de "talkback"&nbsp;</b></a>
   </td></tr></table>
</td></tr></table>
</center>

<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#9999AA" WIDTH="50%">
<A HREF="../../common/lfteam.html">Contactar con el equipo de LinuFocus</A>
<BR><FONT COLOR="#FFFFFF">&copy; Bernard Perrot, <a href="../../common/copy.html">FDL</a> <BR><a href="http://www.linuxfocus.org">LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#9999AA">
<!-- TRANSLATION INFO -->
<font size=2>Informaci&oacute;n sobre la traducci&oacute;n:</font>
<TABLE summary="translators">
  <tr><td><font size="2">fr --&gt; -- : Bernard Perrot <small>&lt;bernard.perrot(at)univ-rennes1.fr&gt;</small></font></td></tr>
  <tr><td><font size="2">fr --&gt; en: Guy Passemard &lt;g.passemard(at)free.fr&gt;</font></td></tr>
  <tr><td><font size="2">en --&gt; es: Javier G&oacute;mez Sierras &lt;jgomsi(at)obelix.umh.es&gt;</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2003-04-07, generated by lfparser version 2.34</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
