<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML lang="es">

  <HEAD>

    <STYLE>
      <!--
      P { text-indent: 1em } 
      -->
    </Style>
    <META http-equiv="Content-Type" content="text/html; charset=uso-8859-1">
    <TITLE>LinuxFocus Octubre 1998: GNU/Linux en un Fujitsu 635T</TITLE>
    

  </HEAD>
  


  <BODY bgcolor="#ffffff"  text="#000000" alink="#336633" link="#336633" vlink="#336633">
    
    
    
    <!-- MAP for top navegation bar -->
    <MAP name="top">
      <AREA shape="rect" coords="367, 9, 418, 30" alt="Home" href="../">
      <AREA shape="rect" coords="423, 9, 457, 30" alt="Map" href="../map.html">
      <AREA shape="rect" coords="463, 9, 508, 30" alt="Index" href="../indice.html">
      <AREA shape="rect" coords="514, 9, 558, 30" alt="Search" href="../search.html">
    </MAP>
    
    

    <!-- MAP for bottom navegation bar -->
    <MAP name="bottom">
      <AREA shape="rect" coords="78, 0, 163, 15"   alt="News" href="../News/">
      <AREA shape="rect" coords="189, 0, 284, 15"  alt="Archives" href="../Archives/">
      <AREA shape="rect" coords="319, 0,  395, 15" alt="Links" href="../Links">
      <AREA shape="rect" coords="436, 0,  523, 15" alt="About LF" href="../aboutus.html">
    </MAP>
    
    
    
    <center>
      <IMG src="../../common/images/Topbar-es.gif" width="600" height="40" border="0" alt="[Top Bar]" ismap usemap="#top" ><BR>
      <IMG src="../../common/images/Bottombar-es.gif" width="600" height="21" border="0" alt="[Bottom Bar]" ismap usemap="#bottom">
    </CENTER>
    
    
    <!-- SHORT BIO ABOUT THE AUTHOR -->
    <TABLE  align="left" width="30%" border="0" cellspacing="0" cellpadding="5">
      
      <TR>
	<TD>
	  <IMG src="../../common/images/Who.gif" width="180" height="169" alt="[Photo of the Author]"><BR>
	      <FONT color="#336633" size="+2">Serge Winitzki</FONT><BR>
		
	  
		<!--   INDEX      -->
		
		<font color="#336633">Contenidos</FONT>: <BR>
		  <a href="#IN">Introducci&oacute;n</a><BR>
		  <a href="#FS">Primeros pasos hacia la instalaci&oacute;n</a><BR>
		  <a href="#LA">¡A instalar Linux!</a><BR>
		  <a href="#TV">La saga del vídeo</a><BR>
		  <a href="#VI">La varidead es la gracia de Linux</a><BR>
		  <a href="#TC">Compilando un nuevo kernel</a><BR>
		  <a href="#BA">&Uacute;ltimos detalles</a><BR>
		  <a href="#DU">Conexión vía módem a la GNU</a><BR>
		  <a href="#AT">Apéndice: el Hardware</a><BR>
		  <a href="#REFS">Referencias</a><BR>
	  
	  <SPACER TYPE=VERTICAL SIZE=100>
	    
	</TD>
      </TR>
      
    </TABLE>
    
    
    
    
    <!--   BODY OF THE ARTICLE    -->
    <H2> GNU/Linux en un Fujitsu 635T</H2>
    <IMG src="../../common/images/illustration16.gif" alt="[Ilustration]" width="100" height="100" hspace="10" >
  </img>
    
    <p align="top">
      <FONT color="#336633" size="2">Resumen</FONT>: 
      <FONT size="+1" face="Helvetica,Arial,Roman">

	<p>Aqu&iacute;    explico    c&oacute;mo   instal&eacute;  una
	versi&oacute;n  reciente del sistema operativo GNU/Linux desde
	cero en un  ordenador  port&aacute;til. La  idea es que  sirva
	como fuente  de  informaci&oacute;n para la  gente  que quiera
	instalar   Linux  en un  ordenador  port&aacute;til  similar o
	incluso en un ordenador   de sobremesa, y quiz&aacute;s  tiene
	tambi&eacute;n   alg&uacute;n          inter&eacute;s     para
	desarrolladores    de     distribuciones     de  Linux.     La
	exposici&oacute;n es totalmente t&eacute;cnica, por lo que los
	lectores   deber&aacute;n  tener    amplios  conocimientos del
	sistema operativo Linux  (o  al  menos estar interesados    en
	aprenderlo).</p>
      </FONT>
      
    </P>
    
    

    <HR size="0" noshadow></hr>
    
    

    <a name="IN"></a><h3>Introducci&oacute;n</h3>



    <p>Ésta es  la  segunda   vez  que instalo  un sistema   operativo
    GNU/Linux en un port&aacute;til. La primera vez fue con un LapNote
    P150 y est&aacute; documentado <a href="#ref1">aqu&iacute;</a>. He
    usado   informaci&oacute;n    del CDROM  de   Slackware,  como los
    diferentes <tt>HOWTO</tt>s,  la  Gu&iacute;a de Instalaci&oacute;n
    de Linux  (<a href="#ref2"><i>Linux Installation Guide</i> versión
    3.2</a>) y, naturalmente,  la <a href="#ref3">Linux on Laptops web
    page</a>.  Toda  la    informaci&oacute;n que sigue  se    refiere
    espec&iacute;ficamente a la instalaci&oacute;n de Slackware 3.5 en
    un   Fujitsu  635T.  No  he  proporcionado  enlaces  de Internet a
    programas   espec&iacute;ficos  ya   que asumo    que  el   lector
    ser&aacute;  capaz de   encontrarlos   mediante  los sitios    de
    referencia indicados.</p>


    <a name="FS"></a><h3>Primeros pasos hacia la instalaci&oacute;n</h3>

    <p>Compr&eacute; un port&aacute;til de segunda mano, un Fujitsu
    635T, por correo. Como ya me esperaba, el ordenador vino cargado
    con el llamado sistema operativo con "ventanas", versi&oacute;n
    "95 OSR 2". La instalaci&oacute;n de "windows" hab&iacute;a sido
    probablemente una "reinstalaci&oacute;n limpia", hecha por el
    antiguo propietario antes de vend&eacute;rmelo. La tarjeta de
    sonido no era reconocida, y todo el sistema PCMCIA parec&iacute;a
    tambi&eacute;n ausente. No recuerdo ahora si el modo true-color
    funcionaba. Tampoco prob&eacute; la opci&oacute;n "suspender a
    disco", ya que no hab&iacute;a una partici&oacute;n para ello en
    el disco duro y pens&eacute; que no funcionar&iacute;a y
    podr&iacute;a cargarme la partici&oacute;n existente. (Mis temores
    estaban infundados: la BIOS reconoc&iacute;a que no exist&iacute;a
    una partici&oacute;n para suspender a disco y mostr&oacute; un
    aviso cuando intent&eacute; activar la opci&oacute;n).</p>

    <p>Sab&iacute;a que no era prudente sucumbir a la tentaci&oacute;n
    de  borrar "windows" directamente; necesitaba a&uacute;n extraerle
    un par de cosas.   Primero, instal&eacute; el driver  de impresora
    "Generic Text" y us&eacute;  el  Panel  de Control para   imprimir
    todos los ajustes de sistema  a un fichero, para posibles  futuras
    referencias.  Este fichero  es quiz&aacute;s  la &uacute;nica cosa
    &uacute;til   que   uno  puede  obtener  de   este llamado sistema
    operativo, ya que el  ordenador ven&iacute;a sin manuales ("muchas
    gracias" al compra-venta de ordenadores, el sabe qui&eacute;n es).
    En principio, toda  esta  informaci&oacute;n deber&iacute;a  estar
    contenida en los manuales de hardware; pero es una pr&aacute;ctica
    de m&aacute;rqueting habitual considerar una instalaci&oacute;n de
    "windows" equivalente a   dar toda la informaci&oacute;n sobre  el
    hardware.    Esencialmente,  obtienes    una copia  de   "windows"
    presumiblemente bien  instalada de la  que puedes intentar extraer
    informaci&oacute;n.</p>

    <p>Despu&eacute;s de copiar el fichero con el resumen de hardware
    a un disquete, rebot&eacute; y entr&eacute; en el setup de la
    BIOS. La BIOS tiene un agradable interface y te deja controlar

      <table width="200" align="right" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2"  color="#004080">  Decidí
		no enredarme con este llamado sistema operativo nunca más
		
	      </font>
	    </center>
	  </td>
	</tr>
      </table>  
      varios ajustes interesantes, como el n&uacute;mero del puerto y de
    la IRQ de los puertos series y de la tarjeta de sonido, as&iacute;
    como el modo del puerto paralelo, el control de energ&iacute;a,
    etc... Tambi&eacute;n hay dos modos de funcionamiento del PCMCIA;
    el llamado "CardBus" y el modo "PCIC compatible". "Windows" puede
    reconocer el sistema PCMCIA en el modo "PCIC" pero no en el modo
    "CardBus" (como descubr&iacute; luego, los dos modos est&aacute;n
    plenamente soportados en Linux). El control de energ&iacute;a
    tampoco est&aacute; soportado en "windows", y el bot&oacute;n de
    "Undock" prometido por el manual de usuario de la "docking
    station" tampoco estaba. Decid&iacute; no enredarme con este
    llamado sistema operativo nunca m&aacute;s. Pero a&uacute;n no era
    la hora de borrarlo, ya que necesitaba crear un disco de arranque
    de Linux para cargar el SO Linux.</p>
 

    <p>
      El primer paso era descubrir c&oacute;mo crear los discos de
      arranque de Linux. Ya me hab&iacute;a bajado la
      distribuci&oacute;n de Slackware Linux 3.5 y hojeado los
      ficheros llamados <tt>README</tt>, <tt>INSTALL</tt>
      etc. Seg&uacute;n el procedimiento recomendado, us&eacute; un
      programa de DOS llamado

    

      "rawrite.exe" que viene con Slackware para escribir las
      im&aacute;genes de los discos de arranque en los disquetes. El
      comando era algo as&iacute; como: <tt>rawrite.exe bare.i a:</tt>
      ejecutado en el directorio <tt>bootdsks.144</tt> del CDROM de
      Slackware, para hacer un disco de arranque con el kernel
      m&aacute;s simple ("bare"), y <tt>rawrite.exe color.gz a:</tt>
      en el directorio <tt>rootdisk</tt> para hacer el "rootdisk", que
      tambi&eacute;n es necesario para iniciar la instalaci&oacute;n
      de Slackware. M&aacute;s tarde me imagin&eacute; que
      podr&iacute;a haber usado el disco de inicio "bareapm.i", porque
      el port&aacute;til tiene funciones de "control de energ&iacute;a
      avanzado" (APM) y as&iacute; podr&iacute;a haberlas usado
      durante la instalaci&oacute;n inicial, esto es, podr&iacute;a
      haver suspendido el port&aacute;til en mitad de la
      instalaci&oacute;n y continuarla m&aacute;s tarde. Pero al
      principio no quer&iacute;a usar nada m&aacute;s que el kernel
      m&aacute;s b&aacute;sico. Como resultado de usar un kernel que
      no soportaba APM, obtuve unas petadas extrañas cuando
      dej&eacute;r el port&aacute;til durante una hora y entr&oacute;
      en auto-suspend. La t&iacute;pica reacci&oacute;n era que
      programas aleatorios no se ejecutaban y daban un error de CPU
      "divisi&oacute;n por cero" con vuelco de los registros. Cosas
      como estas desaparecieron cuando empez&eacute; a usar el kernel
      con APM.</p>

    <a name="LA"></a><h3>¡A instalar Linux!</h3>

    <p>
      Con los dos disquetes preparados, rebot&eacute; el ordenador y
      obtuve un sistema Linux al que pod&iacute;a entrar como "root"
      sin contraseña.  El mensaje de entrada me dec&iacute;a que ahora
      ten&iacute;a que crear algunas particiones de disco para Linux y
      ejecutar el programa "setup" cuando las tuviera listas. El mismo
      mensaje me dec&iacute;a que pod&iacute;a usar tanto
      <tt>fdisk</tt> como <tt>cfdisk</tt> para hacer las
      particiones. Como yo sab&iacute;a que <tt>fdisk</tt> no era muy
      f&aacute;cil de usar, decid&iacute; probar con <tt>cfdisk</tt> y
      fui sorprendido por su simple e intuitivo interface en modo
      texto.  Borr&eacute; la partici&oacute;n FAT de 1.35 GB (adios,
      "windows") y cre&eacute; una partici&oacute;n de 64MB para swap
      y dos (300 MB y 1 GB) particiones nativas de Linux
      (ext2). Pens&eacute; usar la partici&oacute;n m&aacute;s pequeña
      para ficheros de sistema y la m&aacute;s grande para ficheros de
      usuario y aplicaciones, por si luego decid&iacute;a reinstalar
      Linux no tener que borrarlo todo.
    </p>

    <p>
      Cuando acab&eacute; con <tt>cfdisk</tt>, inici&eacute; el
      programa <tt>setup</tt>. Los primeros pasos del setup fueron
      suficientemente claros: cambiar el teclado (no lo
      cambi&eacute;), preparar el espacio de swap, elegir los
      directorios de origen y destino de la instalaci&oacute;n..
      Eleg&iacute; la partici&oacute;n pequeña como partici&oacute;n
      root (<tt>/</tt>) y la partici&oacute;n grande que se montara en
      <tt>/usr</tt>.  El primer problema vino con el directorio
      origen de la instalaci&oacute;n: yo no ten&iacute;a el CDROM
      original de Slackware, sin&oacute; que me hab&iacute;a bajado
      todos los ficheros y los hab&iacute;a grabado en un CDROM usando
      "windows". Prob&eacute; varias veces, pero el setup no me
      reconoc&iacute;a los directorios que yo le daba como directorios

      <table width="200" align="left" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2"  color="#004080"> 
		Para solucionar el problema, pulsé Ctrl-Alt-F2
	      </font>
	    </center>
	  </td>
	</tr>
      </table>  


      con la distribuci&oacute;n de Slackware. El problema era que yo
      hab&iacute;a creado esos ficheros desde un sistema de ficheros
      de DOS y se hab&iacute;an añadido puntos a los nombres de
      ficheros, e.g. "README." en lugar de "readme", por lo que el
      setup ten&iacute;a problemas con esto (no tube ning&uacute;n
      problema similar con el CDROM de Slackware que recib&iacute; en
      el correo pocos d&iacute;as m&aacute;s tarde). Para solucionar
      el problema, puls&eacute; <tt>Ctrl-Alt-F2</tt>; como ya
      sab&iacute;a de mi experiencia previa con Linux, se usan las
      teclas desde <tt>Ctrl-Alt-F1</tt> hasta <tt>F6</tt> en modo
      texto para cambiar entre consolar virtuales.  Obtuve otro
      mensaje de log&iacute;n y entr&eacute; de nuevo como root sin
      contraseña. Tener una segunda c&oacute;nsola fue una
      bendici&oacute;n: estaban disponibles programas tan
      &uacute;tiles como <tt>mount</tt>, <tt>ls</tt>, y <tt>cat</tt>,
      y fue posible montar el CD (sab&iacute;a por la
      informaci&oacute;n de arranque de Slackware que la unidad de
      CDROM era /dev/hdc, por lo que los comandos para montarla eran
      <tt>mkdir /cdrom; mount /dev/hdc /cdrom</tt>), copiar los
      ficheros de Slackware desde el CD a una de las particiones y
      renombrar los ficheros que tenian el punto añadido. (Otra
      opci&oacute;n hubiera sido usar la unidad ZIP para acceder a los
      ficheros de instalaci&oacute;n, pero el kernel "bare" no la
      soporta, y m&aacute;s tarde descubr&iacute; que los ficheros del
      driver ZIP para puerto paralelo que vienen con Slackware no
      funcionan en mi m&aacute;quina, ver m&aacute;s abajo.)
      Despu&eacute;s de esto, le dije al programa setup que "usara
      ficheros de un directorio ya montado" y Slackware pudo reconocer
      sus ficheros de instalaci&oacute;n. Como pod&iacute;a cambiar a
      otra c&oacute;nsola, pude tambi&eacute;n montar el CD con los
      ficheros de documentaci&oacute;n de Slackware y leer los
      diversos <tt>README</tt>'s, <tt>HOWTO</tt>'s y obviamente la <a
      href="#ref2"><i>Installation Guide</i></a> mientras se
      hac&iacute;a la instalaci&oacute;n. Poder solucionar los
      problemas del sistema mientras se configura me pareci&oacute;
      muy &uacute;til. Pude ver qu&eacute; sistemas de ficheros
      estaban montados en cada momento (<tt>cat /etc/mtab</tt>),
      montarlos o desmontarlos cuando era necesario (e. g. <tt>mount
      -t ext2 /dev/hda3 /mnt/usr</tt>), o hacer cualquier cambio a la
      situaci&oacute;n de los ficheros. Pude entrar en una ventana
      paralela y ver lo que le ocurria al sistema. En fin, eso hizo la
      instalaci&oacute;n m&aacute;s agradable, ya que no estaba
      sometido completamente a la merced del script de
      instalaci&oacute;n.
    </p>

    <p>
      El siguiente paso era elegir los paquetes de software que
      quer&iacute;a instalar. Eleg&iacute; todos los paquetes excepto
      los juegos, el kit de desarrollo del servidor X y la
      documentaci&oacute;n, que de todos modos ya estaba en el
      CDROM. Entonces el setup ofreci&oacute; hacer el disco duro de
      arranque con el boot manager <tt>lilo</tt>. Eleg&iacute; la
      "instalaci&oacute;n de <tt>lilo</tt> autom&aacute;tica" usando
      el kernel <tt>bareapm.i</tt>. Me salt&eacute; la
      configuraci&oacute;n de la red, no eleg&iacute; ninguna fuente
      especial, le dije que mi modem estaba en COM2, mi rat&oacute;n
      era PS/2, y que mi zona horaria era Amsterdam.  (¿Por qu&eacute;
      no han hecho que funcione PageDown para moverse
      r&aacute;pidamente por esa enorme lista de zonas
      horarias?). Finalmente, reinici&eacute; y el sistema se puso en
      marcha correctamente. Entr&eacute; de nuevo como root sin
      contraseña y ya estaba listo, con una potencia computacional de
      53 "BogoMips". M&aacute;s o menos era correcto para un Pentium
      133 Mhz (como se indica en el "BogoMips mini-HowTo").
    </p>
    
    <p>
      La &uacute;nica mancha era que no pod&iacute;a reconoce la
      unidad ZIP en el puerto paralelo. El driver (<tt>ppa</tt>,
      adaptador de puerto paralelo) dec&iacute;a esencialmente que no


      <table width="300" align="right" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080"> El
	      nuevo driver, "Curtin" version 1.42, autodetecta todo
	      sobre los puertos paralelos correctamente y usa un modo
	      de acceso más rápido con mi puerto paralelo ECP.
	      </font>
	    </center>
	  </td>
	</tr>
      </table>  
      hab&iacute;a un adaptador de puerto paralelo en el puerto
      <tt>0x278</tt> (el mensaje era dif&iacute;cil de entender,
      <tt>modprobe ppa</tt> dec&iacute;a algo como "init_module:
      device or resource busy" como l&iacute;nea inicial del mensaje
      de error). Reinici&eacute; y me fui al setup de la BIOS: el
      puerto paralelo estaba puesto en <tt>0x378</tt>. Bien,
      ¿quiz&aacute;s necesita <tt>0x278</tt>? Lo puse en
      <tt>0x278</tt>, cambi&eacute; al modo de puerto paralelo
      bidireccional simple, por si acaso, y reinici&eacute; de
      nuevo. Esta vez el driver del puerto paralelo me dijo que no
      pod&iacute;a encontrar la unidad ZIP en el puerto
      <tt>0x378</tt>.  Esto empezaba a parecerse al juego del perro y
      el gato: ¿por qu&eacute; el adaptador se negaba a mirar en el
      puerto correcto? El problema desapareci&oacute; cuando
      compil&eacute; una versi&oacute;n m&aacute;s reciente del driver
      del ZIP en puerto paralelo (mira la informaci&oacute;n
      importante en la p&aacute;gina <a href="#ref3">Linux Laptop web
      page</a>).  El nuevo driver, "Curtin" version 1.42, autodetecta
      todo sobre los puertos paralelos correctamente y usa un modo de
      acceso m&aacute;s r&aacute;pido con mi puerto paralelo ECP.
      </p>


    <p>
      Tambi&eacute;n trat&eacute; de modificar a mano el fichero de
      configuraci&oacute;n de <tt>lilo</tt>, pero encontr&eacute; que
      usar el programa <tt>liloconfig</tt> es m&aacute;s seguro, sobre
      todo porque olvid&eacute; ejecutar <tt>lilo</tt> despu&eacute;s
      de cambiar la configuraci&oacute;n.</p>

    <p>
      Comentarios finales: a veces hay mensajes de error
      despu&eacute;s de hacer algunas de las funciones del setup, pero
      estos mensajes se pierden inmediatamente cuando se muestra la
      siguiente panatalla. Me gustar&iacute;a que los mensajes de
      error estuvieran disponibles para poder ver si los
      procedimientos del setup han sido correctos. Quiz&aacute;s esto
      requiera m&aacute;s trabajo en los scripts, pero no mucho
      m&aacute;s: por lo menos la salida de los comandos se puede
      redireccionar para mostrarse cuando se pida. (Hola,
      Mr. Volkerding, quiz&aacute;s me oigas.)</p>

<a name="TV"></a><h3>La Saga del Video</h3>

    <p>
      Anticipo que el mayor problema fue configurar el sistema X
      window para funcionar con mi adaptador gr&aacute;fico y la
      pantalla LCD de 800x600.  Pero el proceso completo no fue tan
      costoso; básicamente funcion&oacute; solo, sólo me dio problemas
      el modo de color verdadero.</p>

    <p>
      La distribuci&oacute;n de Slackware de Linux viene con XFree86,
      un servidor de X gratu&iacute;to y de gran calidad que
      promet&iacute;a suportar plenamente mi chip gr&aacute;fico. Yo
      pensaba utilizar Accelerated X pero me decid&iacute; en contra
      porque XFree86 es m&aacute;s configurable y hab&iacute;a tenido
      una mejor experiencia con mi antiguo port&aacute;til, menos
      soportado. Existen dos alternativas para configurar XFree86: el
      programa de configuraci&oacute;n basado en X y el basado en modo
      texto. El &uacute;nico rat&oacute;n que ten&iacute;a era el
      touchpad algo gastado y voluminoso, por lo que opt&eacute; por
      la configuraci&oacute;n en modo texto (el interface era un poco
      cutrecillo pero funcionaba bien). M&aacute;s tarde
      descubr&iacute; que el interface gr&aacute;fico no hubiera
      funcionado en este punto porque es incompatible con
      <tt>gpm</tt>, el driver del rat&oacute;n en modo texto que
      hab&iacute;a seleccionado que se instalase y
      activase. Mat&aacute;ndolo con <tt>gpm -k</tt> ayud&oacute;,
      pero la configuraci&oacute;n gr&aacute;fica no es realmente tan
      &uacute;til y requiere rat&oacute;n.
    </p>

    <p>
      El adaptador gr&aacute;fico, C&amp;T 65550 con 2MB de memoria,
      estaba en la lista y seleccion&eacute; los modos de 800x600 en
      todas las profundidades de color. El &uacute;nico problema fue
      cuando a mitad de la configuraci&oacute;n se me ofreci&oacute;
      ejecutar <tt>X -probeonly</tt> para detectar los modos de
      v&iacute;deo viables, pero fall&oacute; porque en este punto la
      instalaci&oacute;n todav&iacute;a no hab&iacute;a escrito
      suficiente informaci&oacute;n en los ficheros de
      inicializaci&oacute;n. Por lo que me salt&eacute; este paso y
      segu&iacute; adelante a por m&aacute;s preguntas.
      Tambi&eacute;n ignor&eacute; las preguntas sobre las
      caracter&iacute;sticas del monitor (como rangos admisibles de
      frecuencias de refresco horixontales y verticales); de mi
      experiencia previa, esta informaci&oacute;n nunca es necesaria
 <table width="300" align="left" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080">Este
	      fichero (XF86Config) normalmente está lleno de líneas
	      inútiles insertadas automáticamente por el programa de
	      configuración.
	      </font>
	    </center>
	  </td>
	</tr>
      </table>  
      ni suficiente para configuraciones exitosas. Simplemente


      seleccion&eacute; el "generic multisync SVGA monitor" (¿por
      qu&eacute; no aparece ninguna pantalla de port&aacute;til en la
      lista?).
    </p>

    <p>
      Despu&eacute;s de acabar todo el proceso de
      configuraci&oacute;n, mir&eacute; el fichero principal de
      configuraci&oacute;n del hardware de v&iacute;deo
      <tt>/etc/X11/XF86Config</tt>. Este fichero normalmente
      est&aacute; lleno de l&iacute;neas in&uacute;tiles insertadas
      automáticamente por el programa de
      configuraci&oacute;n. La parte m&aacute;s importante en cuanto a
      hardware se refiere es la llamada secci&oacute;n
      "Modelines". Cada l&iacute;nea describe un modo de v&iacute;deo
      concreto, correspondiente a una resoluci&oacute;n de pantalla,
      frecuencias de refresco, etc. Cada modo tiene un nombre, y el
      fichero de configuraci&oacute;n se refiere m&aacute;s tarde a
      los modos por dicho nombre, cuando se le indica al servidor
      qu&eacute; modos usar en cada una de las profundidades de color
      (en la secci&oacute;n <tt>Screen</tt> del fichero). Si se les da
      el mismo nombre a varios modos, el servidor solo usar&aacute;
      uno de ellos, el que tenga "mejor" frecuencia de refresco y, por
      lo tanto, calidad de imagen. Por mi experiencia previa
      configurando el servidor XFree86, conoc&iacute;a el problema con
      la configuraci&oacute;n autom&aacute;tica: inserta demasiadas
      l&iacute;neas con la misma resoluci&oacute;n y las nombra con el
      mismo nombre, como <tt>640x480</tt> o <tt>800x600</tt>, dejando
      que el servidor elija el "mejor" modo para el monitor dado. Pero
      puede que uno solo de los modos llamados, por ejemplo
      <tt>800x600</tt>, funcione. Lo que ocurre en la pr&aacute;ctica
      es que el servidor elije el mejor modo, pero por lo que sea no
      funciona y deja al usuario sin salida. Es mejor renombrar estos
      modos con nombres difrentes, como <tt>800x600a</tt>,
      <tt>800x600b</tt> etc, y dejar que el servidor los use todos. El
      usuario puede entonces pulsar <tt>Ctrl Alt +</tt> y <tt>Ctrl Alt
      -</tt> para cambiar entre todos los modos disponibles y
      seleccionar el que mejor se vea.
    </p>


    <p>Por lo cual borr&eacute; todos los modos excepto los de
    <tt>800x600</tt>, los renombr&eacute;, los inclu&iacute; en la
    secci&oacute;n <tt>Screen</tt>, y tecle&eacute; <tt>startx</tt>
    para iniciar el sistema X window. Mi mejor l&iacute;nea fue:
    </p>
<pre>
# 800x600 @ 60 Hz, 37.8 kHz hsync
Modeline "800x600a" 40 800 840 968 1056 600 601 605 628 +hsync +vsync
</pre>

    <p>Otra era similar a 56 Hz con casi la misma calidad de
    imagen. Obtuve una bonita imagen a resoluci&oacute;n completa. Sin
    embargo, no hab&iacute;a ning&uacute;n controlador de ventanas
    visible. Adem&aacute;s el modo de color verdadero no
    funcionaba. (El modo de color verdadero se inicia con <tt>startx
    -- -bpp 24</tt> ya que en mi chip el modo de color verdadero
    correcto no es de 32 bits, sin&oacute; de 24 bits por
    p&iacute;xel, esto es, 24 bpp; el X configurator omite
    correctamente los ajustes de 32 bits en la secci&oacute;n
    <tt>Screen</tt> y tambi&eacute;n usa por defecto la profundidad de
    8bpp.) Ejecut&eacute; X con la salida redirigida (<tt>startx
    >&amp; /tmp/startx-output</tt>) y mir&eacute; en el fichero
    resultante. Esta t&eacute;cnica es muy &uacute;til para
    diagnosticar los problemas de configuraci&oacute;n de X, ya que de
    otro modo los mensajes se desplazan r&aacute;pidamente fuera de la
    pantalla.
    </p>

    <table width="300" align="right" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080">El
	      problema con el manejador de ventanas que no
	      aparec&iacute;a era debido a que la variable
	      <tt>DISPLAY</tt>, por alguna raz&oacute;n, no estaba
	      definida.
	      </font>
	    </center>
	  </td>
	</tr>
      </table>  

    <p>El problema con el manejador de ventanas que no aparec&iacute;a
    era debido a que la variable <tt>DISPLAY</tt>, por alguna
    raz&oacute;n, no estaba definida. Esa variable de entorno es
    necesaria para que todos los programas sepan d&oacute;nde mostrar
    sus ventanas. Lo arregl&eacute; editando el script <tt>startx</tt>
    script (ver m&aacute;s abajo).
    </p>

    <p>
      El problema del modo de color verdader era que X se quejaba de
      que el "pixel clock" era demasiado alto en dichos
      modos. Aparentemente es una limitaci&oacute;n real del hardware
      en el pixel clock. Durante alg&uacute;n tiempo pens&eacute; que
      nunca obtendr&iacute;a el modo de color verdadero, pero un
      d&iacute;a mir&eacute; las l&iacute;neas de modo de otra gente
      con adaptadores C&amp;T (de un mont&oacute;n de
      informaci&oacute;n que encontr&eacute; en <a href="#ref3">Linux on
      Laptops web page</a>) y descubr&iacute; la siguiente
      l&iacute;nea con frecuencia de reloj inferior:
    </p>

<pre>
#800x600 @ 49.5 Hz vsync, 30 kHz hsync, yucky and flickery even on LCD
ModeLine "800x600b" 28.3 800 816 856 920 600 603 605 618
</pre>

    <p>
      Este modo tiene una frecuencia de refresco muy baja y una pobre
      calidad de imagen; cuando la activ&eacute;, el monitor zumbaba
      notablemente mientras me lloraban los ojos. Las pantallas LCD
      dan mejor calidad de imagen que las CRT y normalmente la imagen
      es aceptable a unos 56 Hz de frecuencia vertical (que sólo
      ser&iacute;a una terrible pesadilla para los ojos en un tubo
      t&iacute;pico de 14 pulgadas) pero esto no era nada bueno. No
      supe lo que hac&iacute;a pero increment&eacute; la frecuencia a
      <tt>35.1</tt> en lugar de <tt>28.3</tt> sin cambiar los otros
      n&uacute;meros. El modo funcion&oacute; entonces mucho
      mejor. Prob&eacute; entonces a cambiar la frecuencia de reloj
      por <tt>35.4</tt> en la antigua l&iacute;nea y funcion&oacute;
      tambi&eacute;n.  Ahora la estoy usando (en color verdadero) para
      escribir esto. Tambi&eacute;n he añadido la l&iacute;nea
      <tt>DefaultColorDepth 24</tt> a la secci&oacute;n
      <tt>Screen</tt> del fichero <tt>XF86Config</tt>, para que el
      modo de color verdadero sea el modo por defecto. Recordaba que
      hab&iacute;a una manera de usar una profundidad de color
      concreta por defecto, pero tube que mirar los manuales de X para
      encontrar la palabra exacta: "DefaultColorDepth", ya que el
      script de configuraci&oacute;n de X no puso ningun ejemplo en el
      fichero.
    </p>

    <p>Para hacer que X aceptara el modo de prueba de 28.3, tube que
    cambiar el rango de frecuencias permitidas por el monitor. El
    configurator puso estos rangos:


    <pre>
HorizSync 31.5 - 37.9
VertRefresh 50 - 90
    </pre>


      pero entonces el nuevo modo de <tt>28.3</tt> no se iniciaba
      porque la frecuencia era demasiado baja: examin&eacute; el
      fichero <tt>/tmp/startx-output</tt> y vi que X se quejaba de
      rangos de frecuencia no permitidos. As&iacute; pues,
      disminu&iacute; el valor de <tt>HorizSync</tt> a 30 en lugar de
      31.5 y el de <tt>VertRefresh</tt> a 48 en lugar de 50. Sin
      embargo, estos dos ajustes, especialmente el valor inferior, no
      son esenciales, ya que las frecuencias reales de reloj quedan
      determinadas por las l&iacute;neas de modo. En principio, estos
      valores est&aacute;n aqu&iacute; para impedir que el monitor se
      queme al poner una frecuencia demasiado alta: el servidor X
      calcular&aacute; las frecuencias resultantes de todas las
      l&iacute;neas de modo y rechazar&aacute; las que queden fuera de
      los rangos dados. Pero en la pr&aacute;ctica he encontrado que
      nunca puedo dar datos precisos sobre las capacidades del
      monitor, y que usualmente tengo que cambiar estos rangos un poco
      para que el servidor de X acepte los modos buenos.</p>

    <p>
      Tube que hacer dos toques finales: añad&iacute; la l&iacute;nea
      <tt>TextClockFreq 40</tt> al fichero <tt>XF86Config</tt> para
      restaurar la frecuencia de texto correcta cuando cambio de una
      sesi&oacute;n X a una c&oacute;nsola de texto; y
      modifiqu&eacute; el script <tt>startx</tt>
      (<tt>/usr/X11R6/bin/startx</tt>) para mantener la c&oacute;nsola
      virtual accesible y poner valor a la variable de entorno
      <tt>DISPLAY</tt> (se supone que de esta variable se encarga el
      controlador de ventanas, <tt>fvwm2</tt>, pero no parec&iacute;a
      funcionar). La parte final del script qued&oacute; como:
    </p>

    <pre>
export DISPLAY=":0.0"
exec xinit $clientargs -- $serverargs >& /tmp/xinit.out &
    </pre>

    <p>
      La seguna l&iacute;nea redirecciona toda la salida de la consola
      de X a un fichero en el directorio temporal, para poder ser
      examinado si es necesario, y pone todo el proceso de X window en
      un segundo plano.</p>

<a name="VI"></a><h3>La variedad es la gracia de Linux</h3>

    <p>
      El sistema estaba listo, pero ten&iacute;a la impresi&oacute;n
      que me estaba perdiendo la diversi&oacute;n: ten&iacute;a dos de
      las &uacute;ltimas distribuciones semicomerciales, RedHat 5.1 y
      SuSE 5.2, las dos me promet&iacute;an facilidad de
      instalaci&oacute;n y configuraci&oacute;n, y en su lugar estaba
      usando la distribuci&oacute;n pelada para los hackers,
      Slackware. Por lo cual decid&iacute; probar las alternativas.
    </p>
    <table width="300" align="left" border="0" cellspacing="5" cellpadding="5" >
      <tr>
	<td>  
	  <center>
	    <font face="helvetica" size="+2" color="#004080">
	      El sistema estaba listo, pero tenía la impresión que me estaba perdiendo la diversión.
	    </font>
	  </center>
	</td>
      </tr>
    </table>  
    <p>
      SuSE 5.2, con todas sus proclamadas virtudes, nunca
      arranc&oacute; en mi port&aacute;til. Prepar&eacute; los discos
      de arranque usando mi instalaci&oacute;n de Slackware, con el
      comando <tt>dd if=/cdrom/disks/eide01 of=/dev/fd0</tt>. Ninguno
      de los discos de arranque IDE (<tt>eide01</tt> a
      <tt>eide03</tt>) fue m&aacute;s lejos que mostrar el mensaje
      "Loading Linux..." (con tres puntos), quiz&aacute;s por un
      conflicto de memoria, o algo as&iacute;. He o&iacute;do de gente
      que dice que a veces los discos de arranque petan y entonces se
      necesita jugar con el cach&eacute; de memoria, o seleccionar
      diferentes kernels, pero 1) ninguno de los kernels

      <table width="200" align="right" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080">
		SuSE 5.2, con todas sus proclamadas virtudes, nunca
		arranc&oacute; en mi port&aacute;til.
	      </font>
	    </center>
	  </td>
	</tr>
      </table>  
      
      funcion&oacute;, mientras que el setup de la BIOS no me deja
      cambiar el cach&eacute; de memoria y 2) ¿por qu&eacute; me tengo
      que preocupar si los discos de arranque de Slackware funcionan
      perfectamente?. Por ello abandon&eacute; SuSE. Debo decir
      tambi&eacute;n (a pesar de que el ingl&eacute;s no es mi idioma
      nativo) que sigo pensando que los mensajes de SuSE (en
      ingl&eacute;s) parecen una mala traducci&oacute;n del
      alem&aacute;n.
    </p>

    <p>
      En cuanto a RedHat 5.1, sent&iacute;a curiosidad, ya que mi
      experiencia previa con RedHat fue con la versi&oacute;n 4.2 y
      hab&iacute;a o&iacute;do que se hab&iacute;an mejorado muchas
      cosas. El script de instalaci&oacute;n era estupendo, sólo tuve
      que hacer un disco de arranque que funcion&oacute; perfectamente
    y me llev&oacute; a la instalaci&oacute;n en un momento.  El zip
      de puerto paralelo se detect&oacute; bien como "/dev/sda", pero
      como no lo ten&iacute;a que usar para la instalaci&oacute;n, fue
      m&aacute;s una molestia; en concreto, no se podi&iacute;a
      iniciar <tt>fdisk</tt> porque dec&iacute;a que "no pod&iacute;a
      acceder al dispositivo por defecto /dev/sda".  Durante el setup
      tuve una c&oacute;nsola libre paralela que ya estaba ejecutando
      bash, y dos consolas para el log de errores (Ctrl-Alt-F3 y F4)
      para monitorizar el progreso del script. Cuando lleg&oacute; el
      momento de seleccionar los paquetes concretos de software a
      instalar, pude ver cu&aacute;nto espacio era necesario para cada
      uno de los componentes, a diferencia que en el script de
      Slackware. Pero no fue tampoco algo crucial, ya que el espacio
      total requerido estaba por debajo de los 400MB y yo ten&iacute;a
      m&aacute;s del doble de espacio libre en la partici&oacute;n de
      <tt>/usr</tt>.
    </p>

    <p>
      Lleg&eacute; entonces a la configuraci&oacute;n de X, que
      transcurri&oacute; m&aacute;s o menos sin problemas. El fichero
      <tt>/etc/X11/XF86Config</tt> resultante de la
      configuraci&oacute;n era algo menos adecuado para mi hardware,
      ya que no dispon&iacute;a del modo de color verdadero de 24bpp;
      en su lugar deber&iacute;a haber tirado el modo de 32bpp. Pero
      yo ya sab&iacute;a qu&eacute; modos funcionaban y no fue tan
      malo despu&eacute;s de todo. Mi adaptador gr&aacute;fico
      (C&amp;T) fue identificado correctamente. Inici&eacute; X sin
      problemas (excepto que la terminal X usaba texto blanco sobre
      fondo negro, cosa que a m&iacute; no me gusta) y, sólo por
      probar, intent&eacute; iniciar el glorioso <tt>rpm</tt> ("RedHat
      package manager", la herramienta que usan para controlar la
      instalaci&oacute;n y desinstalaci&oacute;n de software) para
      instalar el nuevo Ghostscript 5.10 desde el directorio
      <tt>redhat/contrib</tt>.  Deb&iacute;a ser una cosa deliciosa,
      pens&eacute;, uno sólo debe escribir un comando intuitivo:
      <tt>rpm -i packagename.rpm</tt> en lugar del tedioso y
      cr&iacute;ptico <tt>tar zxf packagename.tgz</tt>, ¿no?
      Oops... obtuve un mensaje del <tt>rpm</tt> diciendo que era
      necesario otro paquete para instalar Ghostscript, algo
      as&iacute; como "ghostscript-fonts-standard", y no
      encontr&eacute; por ning&uacute;n lado ese
      paquete. Encontr&eacute; otros paquetes de fuentes de
      Ghostscript, pero no ese. Hab&iacute;a visto algo parecido otra
      vez: recuerdo el <tt>rpm</tt> dici&eacute;ndome una vez (bajo
      RedHat 4.2) que "no ten&iacute;a el paquete <tt>/bin/sh</tt> en
      mi sistema"; <tt>/bin/sh</tt> es la shell, ¿c&oacute;mo estaba
      picando esos comandos sin ella?. Me gustar&iacute;a oirle decir
      que falta la placa madre.  T&iacute;pica "locura del rpm",
      pens&eacute;, y lo dej&eacute; estar. En general, el sistema
      parec&iacute;a funcionar m&aacute;s lento que con la
      instalaci&oacute;n de Slackware de, esencialmente, los mismos
      componentes.
    </p>
      
   <table width="400" align="left" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080">
	      .. la herramienta de configuración del sistema
	      linuxconf, llamada "el mejor amigo de los
	      administradores de sistemas".
	      </font>
	    </center>
	  </td>
	</tr>
      </table> 


    <p>
      Entonces prob&eacute; la herramienta de configuraci&oacute;n del
      sistema <tt>linuxconf</tt>, llamada "el mejor amigo de los
      administradores de sistemas". Desgraciadamente, no fui capaz de
      entender qu&eacute; es lo que iban a cambiar cada uno de sus
      desconectados widgets en mi sistema; algunas veces era obvio
      pero otras era totalmente cr&iacute;ptico. La principal tarea
      para mi es entender la configuraci&oacute;n de sistemas y ser
      capaz de resolver problemas bas&aacute;ndome en este
      conocimiento; sospecho que RedHat y quiz&aacute;s otros
      seguidores de la doctrina "hazlo-f&aacute;cil" est&aacute;n
      tratando de hacer la administraci&oacute;n de sistemas
      "f&aacute;cil" no ocultando los detalles triviales, sin&oacute;
      haciendo que el administrador ejecute programas que ellos
      proporcionan y que nunca configure nada a mano.
      </p>

    <p>
      Otra cosa: aunque detect&oacute; la unidad de ZIP, el acceso are
      terr&iacute;blemente lento porque el driver que usaban era una
      versi&oacute;n beta muy antigua que sólo soportaba el modo de
      acceso m&aacute;s lento, por lo que necesitaba recompilar el
      driver (y posiblemente el kernel) de cualquier
      modo. Encontr&eacute; algunos otros problemas tratando de
      instalar los fuentes del kernel, no recuerdo lo que fue. Por
      estas consideraciones y por el miedo a la "locura del rpm",
      decid&iacute; abandonar RedHat y volver al viejo Slackware.
      Rebot&eacute; con los discos de Slackware que todav&iacute;a
      ten&iacute;a, repet&iacute; la instalaci&oacute;n con las cosas
      que ya sab&iacute;a y pronto el sistema estaba listo y
      funcionando de nuevo.
    </p>
    <a name="TC"></a><h3>Compilando un nuevo kernel</h3>

    <p>
      En el centro de un sistema Linux est&aacute; el kernel, y yo
      sab&iacute;a que debe contener soporte para todos los diversos
      dispositivos perif&eacute;ricos conectados al sistema, desde el
      rat&oacute;n hasta la tarjeta de sonido, pasando por la unidad
      ZIP de puerto paralelo y la unidad CDROM SCSI
      externa. Tambi&eacute;n sab&iacute;a que el kernel puede
      soportar estos dispositivos de una manera modular, esto es,
      cargando los drivers bajo demanda y descarg&aacute;ndolos
      m&aacute;s tarde. Esto hace que el kernel sea m&aacute;s pequeño
      y m&aacute;s flexible, ya que en principio puedes entonces
      cargar y descargar drivers para dispositivos incompatibles
      cuando sea necesario. Por ejemplo, el driver de la impresora
      puede no ser compatible con la unidad de ZIP de puerto paralelo,
      en cuyo caso sólo podr&eacute; tener cargado uno de los dos
      drivers.
    </p>
<table width="200" align="right" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080">
Es mejor compilar un kernel a medida que soporte justo el ordenador en el que va a
correr. 


	      </font>
	    </center>
	  </td>
	</tr>
      </table>  


    <p>
      El kernel que viene con una distribuci&oacute;n de Linux
      est&aacute;ndar incluye soporte para algunos dispositivos
      b&aacute;sicos, incluyendo algunos que no ten&iacute;a
      intenci&oacute;n de tener nunca; los drivers para estos
      dispositivos simplemente est&aacute;n en memoria y no hacen
      nada. Es mejor compilar un kernel a medida que soporte justo el
      ordenador en el que va a correr.
    </p>
    
    <p>
      Con esto en mente empez&eacute; a configurar y compilar el
      kernel a medida para mi ordenador. Como eleg&iacute; instalar
      los fuentes completos del kernel (versi&oacute;n 2.0.34) cuando
      instal&eacute; Slackware, recompilar el kernel fue muy
      f&aacute;cil. Cambi&eacute; al directorio
      <tt>/usr/src/linux</tt> y tecle&eacute; <tt>make menuconfig</tt>
      para iniciar el script de configuraci&oacute;n del kernel en
      modo texto. Despu&eacute;s de breves instantes, me
      apareci&oacute; una caja de di&aacute;logo muy agradable con las
      diferentes opciones del kernel. Cada opci&oacute;n est&aacute;
      muy bien comentada y fui capaz de mirarlas todas en muy poco
      tiempo. Entr&eacute; todo lo que pude, hasta llegar a la tarjeta
      de sonido (una "ESS AudioDrive") que no aparec&iacute;a en la
      lista, pero descubr&iacute; mirando en los <tt>README</tt>s que
      es una cl&oacute;nica SoundBlaster (aunque no est&aacute;
      listada expl&iacute;citamente como SoundBlaster, deber&iacute;a
      estarlo). Eleg&iacute; que todos los drivers de dispositivos
      perif&eacute;ricos se compilaran como m&oacute;dulos; los
      dispositivos inclu&iacute;an el control de energ&iacute;a
      ("APM"), la tarjeta compatible SoundBlaster, un rat&oacute;n
      PS/2, los puertos serie, la unidad de disquetes, el cdrom, y
      soporte para disco SCSI (para mi disco ZIP). Hize tambi&eacute;n
      m&oacute;dulos para varias cosas de redes, como SLIP y PPP, y
      para los formatos de ejecutables a.out, ELF y java (por si los
      necesitaba).  Compil&eacute; por separado los m&oacute;dulos de
      sistema de ficheros Macintosh (hfs), que necesito para trabajar
      con discos ZIP compatibles SGI, y el soporte actualizado para la
      unidad ZIP de puerto paralelo (esto no viene con el kernel
      est&aacute;ndar, pero yo lo necesito). Me baj&eacute;
      tambi&eacute;n el &uacute;ltimo paquete de PCMCIA
      (<tt>pcmcia-cs-3.0.4</tt>) y compil&eacute; los m&oacute;dulos
      de soporte de la tarjeta SCSI y de la tarjeta de red.
    </p>

    <p>
      Entonces tecle&eacute; <tt>make dep; make zlilo; make modules;
      make modules_install</tt> y esper&eacute; unos 15
      minutos. Cuando todo acab&oacute;, el nuevo kernel y los nuevos
      m&oacute;dulos estaban compilados y situados en su
      localizaci&oacute;n correcta. Comprob&eacute; que el fichero del
      kernel <tt>/vmlinuz</tt> era m&aacute;s nuevo y pequeño que el
      antiguo, grabado como <tt>/vmlinuz.old</tt>, y
      reinici&eacute;... sólo para comprobar que la m&aacute;quina ya
      no arrancaba, parando incluso antes de que se monte
      ning&uacute;n sistema de ficheros. La secuencia normal de
      mensajes de arranque se paraba despu&eacute;s de comprobar las
      particiones en <tt>VFS: mounted root (ext2 filesystem)
      readonly</tt>. Ning&uacute;n sistema de ficheros se montaba como
      lectura-escritura y ning&uacute;n script de
      inicializaci&oacute;n (iniciados por <tt>INIT</tt>) se
      ejecutaba. Glups.
    </p>
    
    <p>
      Despu&eacute;s de reiniciar con el disco de arranque de
      Slackware que ten&iacute;a el viejo kernel, devolv&iacute; la
      vida al sistema, y empez&eacute; a mirar por la
      configuraci&oacute;n del kernel y a pensar qu&eacute; es lo que
      estaba mal en el nuevo kernel. Pronto lo encontr&eacute;: estaba
      tan empeñado en la idea de hacerlo todo modular que hab&iacute;a
      cometido el est&uacute;pido error de compilar el soporte para
      todos los formatos de ejecutables (i.e.  <tt>a.out</tt>,
      <tt>ELF</tt> y <tt>java</tt>) como m&oacute;dulos. El kernel y
      todos los programas se compilan como <tt>ELF</tt>. As&iacute;
      pues, cuando el kernel se inicia, no pod&iacute;a ejecutar los
      programas a no ser que cargue el m&oacute;dulo para el formato
      <tt>ELF</tt>, pero para cargar el m&oacute;dulo necesita
      ejecutar el programa <tt>insmod</tt>, que est&aacute; en formato
      <tt>ELF</tt>. La manera correcta es compilar el soporte para
      <tt>ELF</tt> dentro del kernel, no como m&oacute;dulo. Es una
      cosa natural, ya que la mayor&iacute;a de programas de hoy en
      d&iacute;a est&aacute;n compilados como
      <tt>ELF</tt>. Despu&eacute;s de recompilar el kernel con este
      simple cambio, pude reiniciar sin ning&uacute;n problema.
    </p>
    <p>
      Entonces me fui al directorio <tt>/lib/modules</tt> y
      borr&eacute; todos los m&oacute;dulos m&aacute;s antiguos que
      los reci&eacute;n compilados. Esto elimin&oacute; los mensajes
      sobre m&oacute;dulos incompatibles al arrancar.  Tambi&eacute;n
      edit&eacute; el script de inicializaci&oacute;n
      <tt>/etc/rc.d/rc.S</tt> para habilitar <tt>kerneld</tt>, el
      "daemon" que carga y descarga m&oacute;dulos
      autom&aacute;ticamente. Con <tt>kerneld</tt> no es necesario
      cargar y descargar los m&oacute;dulos del kernel a mano usando
      <tt>insmod</tt> y <tt>rmmod</tt> (auqne tambi&eacute;n se puede
      hacer). El comando <tt>lsmod</tt> lista todos los modules
      cargados actualmente por el kernel.
    </p>
    <table width="400" align="left" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080">
	      Tube que añadir la línea alias scsi_hostadapter ppa al
	      fichero /etc/conf.modules para que el módulo de puerto
	      paralelo ppa se cargara automáticamente cuando yo
	      intentara montar un disco ZIP (/dev/sda)
	    </font>
	  </center>
	</td>
      </tr>
      </table>  
    
    <p>
      <tt>kerneld</tt> funcinaba perfectamente, cargando los
      m&oacute;dulos cuando se necesitaban y descarg&aacute;ndolos
      cuando no se hab&iacute;an utilizado durante un rato. Tube que
      añadir la l&iacute;nea <tt>alias scsi_hostadapter ppa</tt> al
      fichero <tt>/etc/conf.modules</tt> para que el m&oacute;dulo de
      puerto paralelo <tt>ppa</tt> se cargara autom&aacute;ticamente
      cuando yo intentara montar un disco ZIP
      (<tt>/dev/sda</tt>). Esto lo tendr&iacute;a que cambiar si usase
      una tarjeta SCSI en lugar del adaptador del puerto paralelo.
    </p>
    <a name="BA"></a><h3>&Uacute;ltimos detalles</h3>

    <p>
      Algunos pequeñas cosillas de configuraci&oacute;n quedaban
      despu&eacute;s de recompilar el nuevo kernel. Eran: configurar
      el acceso a dispositvos de almacenamiento externo (la
      disquetera, el CDROM y la unidad ZIP), soportar dos ratones a la
      vez, soportar el idioma ruso y configurar el controlador de
      ventanas fvwm2.
    </p>

    <p>
      El script de instalaci&oacute;n de Slackware hab&iacute;a creado
      el directorio <tt>/mnt</tt> bajo el cual puso los subdirectorios
      <tt>/mnt/floppy</tt> y <tt>/mnt/cdrom</tt> para montar los
      sistemas de ficheros de los disquetes y del CDROM. Al principio
      decid&iacute; que tenerlos en un directorio separado no era tan
      conveniente, y cre&eacute; los directorios <tt>/floppy</tt> y
      <tt>/cdrom</tt> en el directorio ra&iacute;z. Pero luego me di
      cuenta que necesitaba m&aacute;s directorios para montar
      dispositivos con diferentes opciones, y en lugar de tenerlos
      todos en el directorio ra&iacute;z, volv&iacute; a crear el
      &aacute;rbol <tt>/mnt</tt>.
    </p>
    
    <p>
      Tambi&eacute;n cambi&eacute; las opciones de montado en
      <tt>/etc/fstab</tt>.  Despu&eacute;s de la instalaci&oacute;n
      este fichero conten&iacute;a opciones por defecto bastante
      razonables, pero no eran suficientes para mis necesidades.
      Primero, hice las l&iacute;neas para la disquetera, el CDROM y
      el ZIP; tuve que deshabilitar la opci&oacute;n de montado
      autom&aacute;tico y permitir a todos los usuarios montarlos (la
      opci&oacute;n <tt>user</tt>): </p>

    <pre>
/dev/fd0   /mnt/floppy	vfat	user,noauto,noexec,nonumtail  0 0
/dev/sda4  /mnt/zip	vfat	user,noauto,noexec,nonumtail  0 0
/dev/hdc  /mnt/cdrom	iso9660	user,noauto,noexec	      0 0
</pre>

    <p>Atenci&oacute;n a la opci&oacute;n <tt>noexec</tt> para
    sistemas de ficheros DOS: hace que los ficheros de esta unidad no
    sean ejecutables, que probablemente sea algo razonable. La
    opci&oacute;n <tt>nonumtail</tt> previene la creaci&oacute;n de
    nombres feos: el fichero <tt>longname.file</tt> se llamar&aacute;
    <tt>longname.fil</tt> en lugar de <tt>longna~1.fil</tt>, si no hay
    conflictos de nombres. El sistema de ficheros <tt>vfat</tt>
    soporta nombres largos de manera compatible con DOS, al contrario
    que el viejo tipo <tt>msdos</tt>, por qu&eacute; no usarlo,
    pues. </p>

    <p>El paquete <tt>mtools</tt> me dio algunos problemas: o le das
    permisos de lectura/escritura a <tt>/dev/fd0</tt> o solo el
    superuser puede leer y escribir al disquete. Poni&eacute;ndole el
    bit <tt>setuid</tt> al fichero mtools no hizo nada. Decid&iacute;
    que montar&iacute;a los dispositivos a mano. </p> <p>La historia
    con el rat&oacute;n fue relativamente sencilla porque ya la
    sufr&iacute; cuando configuraba mi anterior port&aacute;til. El
    port&aacute;til lleva un touchpad incorporado (que
    t&eacute;cnicamente es un rat&oacute;n PS/2), y yo quer&iacute;a
    usar tambi&eacute;n un rat&oacute;n externo conectado al puerto
    serie. Los dos ratones se pueden soportar simult&aacute;neamente
    usando el programa <tt>gpm</tt> ("general purpose mouse"). El
    programa sirve para dos cosas: primero, en c&oacute;nsolas de
    texto habilitar el uso del rat&oacute;n como puntero (en

  <table width="300" align="left" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080">
Los dos ratones se pueden soportar simultáneamente usando el programa
gpm ("general purpose mouse")
	    </font>
	  </center>
	</td>
      </tr>
      </table>  
    aplicaciones que lo soporten) as&iacute; como proporcionar
    funciones de cortar y pegar; segundo, <tt>gpm</tt> puede unir dos
    ratones diferentes (que pueden ser cualesquiera, como bus mouse,
    PS/2, serie u otros) en un puntero l&oacute;gico
    &uacute;nico. Todo lo que se necesita es una l&iacute;nea de
    comandos concreta. La sintaxis es un poco rara pero hay
    explicaciones claras y ejemplos en la p&aacute;gina del manual
    (<tt>man gpm</tt>). El programa <tt>gpm</tt> se inicia en el
    script de inicializaci&oacute;n <tt>/etc/rc.d/rc.local</tt>, ya
    que ya le hab&iacute;a dicho a Slackware que lo instalé y
    activé. Modifiqu&eacute; la l&iacute;nea del <tt>gpm</tt> en ese
    fichero para que quede as&iacute;: </p>

<p><pre>
gpm -t ps2 -m /dev/psaux -2 -M -t mman -m /dev/cua0 -3 -R 
</pre>

      <p>Esto se interpreta como: el primer rat&oacute;n es del tipo
      PS/2 en el puerto auxiliar, tiene dos botones; el segundo
      rat&oacute;n (<tt>-M</tt>) es del tipo [Logitech] MouseMan,
      conectado el puerto serie 1 (<tt>/dev/cua0</tt>), tiene tres
      botones y <tt>-R</tt> significa que ambos ratones deben estar
      disponibles para las sesiones de X como un solo
      rat&oacute;n. (La opci&oacute;n <tt>-R</tt> no es necesaria si
      se usa la versi&oacute;n <tt>gpm</tt> 1.14 o posterior.)
      Despu&eacute;s de modificar esta l&iacute;nea, mat&eacute; y
      reinici&eacute; <tt>gpm</tt> (<tt>gpm -k;
      /etc/rc.d/rc.local</tt>) y entonces los dos ratones funcionaron
      inmediatamente y sin problemas. Pod&iacute;a incluso enchufar el
      rat&oacute;n serie mientras ya estaba trabajando en X y
      voil&aacute;, funcionaba directamente. Estas cosas sin
      imposibles en el llamado sistema operativo "windows": siempre te
      dice que reinicies el ordenador para que el "nuevo hardware"
      funcione. </p>

      <p>Lo siguiente que me ocup&oacute; fue instalar el soporte para
      caract&eacute;res Cir&iacute;licos. Ten&iacute;a que ser capaz
      de leer, y ocasionalmente escribir, texto ruso. Instal&eacute;
      soporte para cir&iacute;lico solo en X. Esto consiste en dos
      partes: conseguir las fuentes cir&iacute;licas y conseguir la
      distribuci&oacute;n cir&iacute;lica del teclado. Hay varias
      p&aacute;ginas en la red que explican todos los detalles de la
      "cirilizaci&oacute;n del Unix". Slackware proporciona un
      conjunto de fuentes KOI-8. El "Cyrillic How-To" hace referencia
      a la colecci&oacute;n VakuFonts creada por Serge Vakulenko
      (<tt>vak@kiae.su</tt>).  Se puede encontrar en la
      colecci&oacute;n de <a href="#ref4">cosas de cir&iacute;lico para
      el X Window System</a>. Me baj&eacute; dos paquetes que
      proporcionan fuentes id&eacute;nticas en los c&oacute;digos
      KOI-8 y CP-1251 (o "Windows"), desempaquet&eacute; los ficheros
      de fuentes (<tt>*.pcf.gz</tt>) en los subdirectorios
      <tt>koi8-r</tt> y <tt>x-cp1251</tt> del directorio principal de
      fuentes de X window <tt>/usr/X11R6/lib/X11R6/fonts/</tt> (que en
      mi sistema Slackware se accede m&aacute;s f&aacute;cil por el
      link <tt>/etc/X11/fonts</tt>). Entonces instal&eacute; las
      fuentes añadiendo estos dos subdirectorios al "FontPath" en el
      fichero <tt>/etc/X11/XF86Config</tt>.  Despu&eacute;s de esto,
      reinici&eacute; X window y todas las fuentes estaban
      disponibles, por lo que pude configurar Netscape (usaba la
      versi&oacute;n 4.05) para usar autom&aacute;ticamente estas
      fuentes para los c&oacute;digos correspondientes <tt>koi8-r</tt>
      y <tt>x-cp1251</tt>.  </p>

      <p>Ahora necestiba un driver de teclado ruso. Us&eacute; el
      programa <tt>xrus</tt>, que es simple y no intrusivo. Lo
      encontr&eacute; en <a href="#ref5">Moshkow's Library, the page on
      Cyrillization</a> y despu&eacute;s de modificar su fichero de
      recursos <tt>/etc/X11/app-defaults/Xrus</tt> y su
      disposici&oacute;n del teclado seg&uacute;n mis conocimientos de
      la m&aacute;quina de escribr rusa :) me sent&iacute;
      c&oacute;modo escribiendo en ruso. </p>

      <p>El paso final era instalar algunos programas para convertir
      ficheros entre los dos c&oacute;digos rusos. Us&eacute; un
      script hecho en casa muy b&aacute;sico que llam&eacute; <a
      href="../../common/src/article70/323_pl.html"><tt>323</tt></a>. Puede convertir entre CP866
      ("DOS" o "alternativo"), KOI-8, CP1251 ("Windows"), y
      c&oacute;digos de Macintosh. Cre&eacute; hard links a
      <tt>323</tt> llamados <tt>koi2win</tt>, <tt>alt2mac</tt> etc
      (<tt>ln 323 koi2win</tt> etc.)  y el script
      autom&aacute;ticamente determina qu&eacute; hacer
      bas&aacute;ndose en su nombre. Usando este script y las fuentes
      instaladas uno puede leer la mayor parte de textos en ruso. </p>


      <table width="200" align="right" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080">

		Ahora necestiba un driver de teclado ruso.
	    </font>
	  </center>
	</td>
      </tr>
      </table>  
      <p>Todo estaba listo en X window system, excepto el controlador
      de ventanas <tt>fvwm2</tt>. Todos sus ajustes est&aacute;n
      controlados por un simple fichero de recursos
      <tt>~/.fvwm2rc</tt> o (si este fichero no existe) por el fichero
      para todo el sistema <tt>/etc/X11/fvwm2/system.fvwm2rc</tt>. Vi
      que el fichero proporcionado por Slackware ten&iacute;a muchas
      cosas comentadas que no eran muy &uacute;tiles o no
      funcionaban. Las cosas b&aacute;sicas que yo quer&iacute;a del
      controlador de ventanas eran: mostrar algunos botones para
      llamar un pequeño n&uacute;mero de programas muy &uacute;tiles;
      responder al teclado y al rat&oacute;n en operaciones con
      ventanas, como mover y mostrar ventanas; y mostar un men&uacute;
      con todas las aplicaciones de X window instaladas.  Idealmente
      todo deber&iacute;a ser accesible desde el teclado sin usar el
      rat&oacute;n. </p>

      <p>Empez&eacute; con el fichero de recursos porporcionado y lo
      edit&eacute; muchas veces, leyendo la larga y a veces densa
      p&aacute;gina del manual (<tt>man fvwm2</tt>) para descubrir
      c&oacute;mo se llamaban las diversas funciones, añadiendo
      cambios poco a poco. En particular, estaba interesado en hacer
      que las teclas de "Windows 95" sean &uacute;tiles para algunas
      cosas.  El resultado est&aacute; <a
      href="../../common/src/article70/fvwm2rc.html">aqu&iacute;</a>, con, espero, suficientes
      comentarios para ver c&oacute;mo funciona. </p>

<a name="DU"></a><h3>Conexión vía módem a la GNU</h3>

      <p>El acceso por m&oacute;dem a mi proveedor local de red estuvo
      en marcha y funcionando en tan poco tiempo que me qued&eacute;
      alucinado. Despu&eacute;s de leer los manuales de
      configuraci&oacute;n de PPP, algo complicados y con aspecto
      antiguo, incluyendo la "Gu&iacute;a de Instalaci&oacute;n",
      ten&iacute;a la impresi&oacute;n que instalar PPP era un poco
      complicado. Sin embargo, probando al azar los comandos que
      empezaban con <tt>ppp</tt> descubr&iacute; que Slackware incluye
      un script llamado <tt>pppsetup</tt> que me pregunt&oacute; las
      cosas correctas sobre mi m&oacute;dem y mi proveedor de PPP. No
      sab&iacute;a una de las respuestas: si el "protocolo de
      autentificaci&oacute;n" era "PAP", "CHAP", o
      "CHAP-Microsoft". Eleg&iacute; (al azar) "CHAP" y segu&iacute;
      con la configuraci&oacute;n. Pronto todo estuvo listo, y me dijo
      que usara dos comandos autoexplicativos, <tt>ppp-go</tt> y
      <tt>ppp-off</tt> para controlar la conexi&oacute;n PPP, y
      tambi&eacute;n hab&iacute;a un texto detallado,
      <tt>/etc/ppp/pppsetup.txt</tt>, que describ&iacute;a todo lo que
      se le hab&iacute;a hecho al sistema durante la ejecuci&oacute;n
      de <tt>pppsetup</tt>. En este fichero, me dec&iacute;a que
      ejecutara <tt>ifconfig</tt> para ver si la conexi&oacute;n PPP
      se hab&iacute;a establecido correctamente, y tambi&eacute;n me
      indicaba la existencia de los ficheros de log
      <tt>/var/log/messages</tt> y <tt>/var/log/debug</tt> en caso que
      tubiera problemas (ya que la opci&oacute;n de <tt>debug</tt> del
      fichero de opciones de PPP <tt>/etc/ppp/options</tt> estaba
      activada por defecto; m&aacute;s tarde la desactiv&eacute; ya
      que el fichero de debug se estaba llenando con la
      informaci&oacute;n, ahora in&uacute;til, de los mensajes de
      <tt>pppd</tt>).
 </p>

      <p>Todo parec&iacute;a de color de rosa, pero cuando conecte el
      m&oacute;dem a la l&iacute;nea telef&oacute;nica, el comando
      <tt>ppp-go</tt> no parec&iacute;a crear una conexi&oacute;n. El
      fichero <tt>/var/log/debug</tt> conten&iacute;a muchos mensajes;
      mir&eacute; hacia el final del fichero y encontr&eacute; un
      intercambio no exitoso entre el <tt>pppd</tt> y el host
      remoto. Uno de los mensajes recibidos del host remoto
      dec&iacute;a <tt>&lt;auth pap&gt;</tt>.  Aj&aacute;,
      dije. Deber&iacute;a haber elegido autentificaci&oacute;n "PAP"
      en lugar de "CHAP". Rehice el comando <tt>pppsetup</tt> y la
      conexi&oacute;n PPP estuvo funcionando en un momento. Como nota,
      decir que el comando <tt>pppscript</tt> contiene algunas
      funciones que hacen <tt>grep</tt>'s de los ficheros de log del
      sistema e imprimen mensajes tales como "Parece que quieren
      PAP...", y cosas as&iacute;, pero por alguna raz&oacute;n estas
      funciones est&aacute;n comentadas. ¿Existe alguna versi&oacute;n
      mejor de <tt>pppsetup</tt>?, ¿quiz&aacute;s su desarrollo no
      est&aacute; finalizado?
 </p>


      <table width="200" align="right" border="0" cellspacing="5" cellpadding="5" >
	<tr>
	  <td>  
	    <center>
	      <font face="helvetica" size="+2" color="#004080">

Algún día instalaré una utilidad más amigable o aprenderé Perl/Tk y la escribiré yo
mismo. O me cambiaré a RedHat, cuando su controlador de escritorio orientado a objetos GNOME esté maduro. 
	    </font>
	  </center>
	</td>
      </tr>
      </table>  

      <p>A pesar de que ahora PPP funciona bien y puedo usar programas
      como <tt>fetchmail</tt>, <tt>ncftp</tt>, <tt>Pine</tt>,
      <tt>netscape</tt> y otros maravillos programas sin problemas, no
      estoy completamente satisfecho con la configuraci&oacute;n. Me
      gustar&iacute;a que el proceso de llamada sea m&aacute;s
      controlable y los mensajes de error que produzca, si los
      produce, sean visibles al usuario. En el caso en que la
      conexi&oacute;n se rompa por alguna raz&oacute;n, me
      gustar&iacute;a que hubiera alg&uacute;n m&eacute;todo para
      saberlo, sin entrar como root y mirar los logs del
      sistema. Quiz&aacute;s los Linux m&aacute;s comerciales vengan
      con utilidades para hacer conexiones PPP m&aacute;s amigables
      para el usuario (¿quiz&aacute;s <tt>gppp</tt>?), pero seguro que
      esas utilidades necesitan un mont&oacute;n de cosas oscuras para
      poderse instalar o no funcionan si no es en su ambiente
      nativo. Alg&uacute;n d&iacute;a instalar&eacute; una utilidad
      m&aacute;s amigable o aprender&eacute; Perl/Tk y la
      escribir&eacute; yo mismo. O me cambiar&eacute; a RedHat, cuando
      su controlador de escritorio orientado a objetos <tt>GNOME</tt>
      est&eacute; maduro. </p>

      <p>Otra cosilla del PPP es que el script <tt>ppp-go</tt> debe
      ser iniciado por el superuser. Al principio pens&eacute; poner
      llamada bajo demanda, pero el kernel, por alguna raz&oacute;n,
      no conten&iacute;a una versi&oacute;n del driver PPP (2.3) que
      soportara esta funci&oacute;n. Entonces escarb&eacute; entre los
      archivos de red y encontr&eacute; un pequeño programa en C, "ppp
      para mortales", que b&aacute;sicamente llama a la funci&oacute;n
      <tt>setuid(0)</tt> para hacerse root y entonces ejecuta el
      script <tt>ppp-go</tt>. La compil&eacute; y la instal&eacute; en
      el path con el bit de <tt>setuid</tt> a 1 (<tt>chmod 4755
      ppp_for_mortals</tt>). Despu&eacute;s de esto, pude ejecutar
      este programa como usuario para iniciar o parar la
      conexi&oacute;n PPP. </p>

      <a name="AT"></a><h3>Ap&eacute;ndice: el Hardware</h3>

      <p><dt>Especificaciones del ordenador:

<dd>Pentium CPU, 133MHz
<dd>16MB RAM actualizada a 48MB
<dd>Disco duro de 1.3GB, interface EIDE
<dd>Pantalla 12" TFT LCD, resoluci&oacute;n 800x600, control de brillo manual
<dd>Tarjeta de v&iacute;deo Chips&Technologies 65550 con 2MB RAM, hasta color
verdadero en el modo 800x600

<p><dt>Dispositivos perif&eacute;ricos:

<dd>Touch-pad de 2 botones incorporado
<dd>2 slots de expansi&oacute;n PCMCIA-II
<dd>M&oacute;dem incorporado (28.8 kbps), comparte COM2 con el puerto IRDA
<dd>ESS AudioDrive incorporado, una tarjeta de sonido de 16 bit "compatible SB"
<dd>"docking unit" con CDROM y unidad de disquetes (no hay disquetera en la 
unidad base)
<dd>CDROM: IDE/ATAPI, velocidad 8X, conectada al controlador IDE secundario

<p><dt>Informaci&oacute;n de configuraci&oacute;n de Linux:

<dd>Linux OS kernel versi&oacute;n 2.0.34
<dd>Distribuci&oacute;n: Slackware Linux 3.5 (preparada por Patrick Volkerding)
<dd>Vendedor: Cheapbytes (<tt>www.cheapbytes.com</tt>)

<p><dt>Estado del soporte a perif&eacute;ricos:

<dd>Rat&oacute;n PS/2 incorporado junto a un rat&oacute;n externo PS/2 o un 
rat&oacute;n serie, completamente soportado
<dd>Tarjeta de sonido incorporada: funciona, excepto que se acopla si el 
volumen no est&aacute; bajo
<dd>M&oacute;dem incorporado: funciona, probado con Minicom
<dd>Adaptador de V&iacute;deo: plenamente soportado en los modos 640x480, 
800x600 y 1024x768 (imagen parcial en la pantalla) en 8, 16 y 24 bits de 
color, con 60HZ, 56Hz y 52Hz de refresco vertical (aceptable en una pantalla 
TFT LCD), con aceleraci&oacute;n de v&iacute;deo.
<dd>CDROM y unidad de disquetes en la "docking unit": plenamente soportadas
<dd>Control Avanzado de Energ&iacute;a (APM): plenamente soportado

<p><hr>

<a name="REFS"></a><h3>Referencias</h3>

<ul>

<a name="ref1"></a><li>Mi p&aacute;gina, <a href="../../common/src/article70/Linux_on_laptop.html">Linux on LapNote P150</a>.

<a name="ref2"></a><li>Ver <a href="http://linuxwww.db.erau.edu/ldp/ldp.html">Linux Documentation Project (http://linuxwww.db.erau.edu/ldp/ldp.html)</a>, sitio web p&uacute;blico (un mirror alem&aacute;n).

<a name="ref3"></a><li>La <a href="http://www.cs.utexas.edu/users/kharker/linux-laptop/">Linux on Laptops page (http://www.cs.utexas.edu/users/kharker/linux-laptop/)</a> por Kenneth E. Harker, sitio web p&uacute;blico.

<a name="ref4"></a><li><a href="ftp://ftp.funet.fi/pub/culture/russian/comp/xwin">Cyrillic stuff for X
Window</a>, sitio FTP p&uacute;blico (ftp://ftp.funet.fi/pub/culture/russian/comp/xwin).

<a name="ref5"></a><li><a href="http://moshkow.relline.ru:5000/koi/CYRILLIC">Maksim Moshkow's Library page on Cyrillization (http://moshkow.relline.ru:5000/koi/CYRILLIC)</a>, sitio web p&uacute;blico.


</ul>
    
    <hr noshade="noshade" size="1">
    
    <p align="right"><i>Texto original en Inglés. Traducido por <a href="mailto:lastras@writeme.com">Hugo Lastras</A></i></p>

    <!-- ARTICLE FOOT -->
    <br clear="all">
    <center>
      <table width="95%">

	<tr>
	  <td align="center" bgcolor="#666666"  >
	    <font color="#ffffff"  >
	      Páginas web mantenidas por Miguel Ángel Sepúlveda<br>
	      &copy; Serge Winitzki 1998<br>
	      <b>LinuxFocus 1998</b>
	    </font>
	  </td>
	</tr>

      </table>
    </center></lu>



  </BODY>

</HTML>






