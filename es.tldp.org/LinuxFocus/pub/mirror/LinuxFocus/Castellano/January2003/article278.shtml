<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.34">
 <META NAME="LFCATEGORY" CONTENT="SystemAdministration">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf278, SystemAdministration: Automatizando la administraci&oacute;n de sistemas con ssh y scp</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 p.cl { color:#EE9500 }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 .mark  { background-color:#e6e6ff }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://www.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Erdal Mutlu
 =LF=CAT___: SystemAdministration
 =LF=TITLE_: Automatizando la administraci&oacute;n de sistemas con ssh y scp
 =LF=NUMBER: 278
 =LF=ANAME_: article278.html
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top"><A class="nodec" href="../"><FONT color=
                 "#DDDDDD" size="2">Hogar</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Mapa</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Indice</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../Search/"><FONT color=
                 "#DDDDDD" size="2">Busqueda</FONT></A> </TD>
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/"><FONT color=
           "#FFFFFF">Noticias</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/"><FONT color=
           "#FFFFFF">Arca</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/"><FONT color=
           "#FFFFFF">Enlaces</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">Sobre LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!--#include virtual="../../dynahead.shtml" -->

<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT BIO ABOUT THE AUTHOR -->
<TABLE ALIGN=LEFT BORDER=0  WIDTH="190" summary="about the author">
<TR>
<TD>

<!-- 2pdaIgnoreStart -->
<!-- PALM DOC -->
<TABLE BORDER=0 hspace=4 vspace=4 summary="pda download"> <TR> <TD>
<font size=1> <img src="../../common/images/2doc.gif" width=34 align=left border=0 height=22 alt="convert to palm"><a href="http://cgi.linuxfocus.org/cgi-bin/2ztxt">Convert to GutenPalm</a><br>or <a href="http://cgi.linuxfocus.org/cgi-bin/2pda">to PalmDoc</a></font>
</TD> </TR> </TABLE>
<!-- END PALM DOC -->
<!-- 2pdaIgnoreStop -->
<br>
<IMG SRC="../../common/images/erdalmutlu.gif" ALT="[Photo of the Author]" WIDTH=107 HEIGHT=139>
<BR>por  Erdal Mutlu <br> <small>&lt;erdal(at)linuxfocus.org&gt;</small>
<BR><BR>
<I>Sobre el autor:</I><BR>
<!-- aboutauthor_start -->
<P>Erdal es uno de los editores turcos de LF.
Actualmente trabaja como administrador de sistemas para
<a href=http://www.linotype.com>Linotype Library</a>.
Siendo un gran fan de Linux desde sus a&ntilde;os de universitario, le gusta
trabajar y desarrollar en este entorno.
</P>
<!-- aboutauthor_stop -->
<!-- TRANSLATED TO es -->
<BR><BR><I>Taducido al espa&ntilde;ol por:</I><BR>
Javier G&oacute;mez Sierras <small>&lt;jgomsi(at)obelix.umh.es&gt;</small>
<br>
<!--
 =LF=TRANSTO=es: Javier G&oacute;mez Sierras
-->
<!-- TRANSLATED TO STOP -->
<BR><i>Contenidos</i>:
<UL>
  <LI><A HREF="#278lfindex0">Introducci&oacute;n</A></LI>
  <LI><A HREF="#278lfindex1">&iquest;Por qu&eacute; usar ssh?</A></LI>
  <LI><A HREF="#278lfindex2">Copiando ficheros y directorios usando scp</A></LI>
  <LI><A HREF="#278lfindex3">Login remoto usando ssh</A></LI>
  <LI><A HREF="#278lfindex4">Ejecutando comandos usando ssh</A></LI>
  <LI><A HREF="#278lfindex5">Conect&aacute;ndose a un ordenador remoto sin contrase&ntilde;a</A></LI>
  <LI><A HREF="#278lfindex6">El script</A></LI>
  <LI><A HREF="#278lfindex7">Una sencilla copia de seguridad de tus ficheros de configuraci&oacute;n</A></LI>
  <LI><A HREF="#278lfindex8">Conclusi&oacute;n</A></LI>
  <LI><A HREF="#278lfindex9">Referencias</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=278">Formulario de "talkback" para este art&iacute;culo</A></LI>
</UL>

</TD></TR></TABLE>
<!-- HEAD OF THE ARTICLE -->
<br>&nbsp;
<table border="0"><tr><td>
<H2>Automatizando la administraci&oacute;n de sistemas con ssh y scp</H2>
 <img src="../../common/images/illustration278.gif" width="320" height="95"
alt="[Illustration]" HSPACE=10>
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Resumen</i>:
<P>
<!-- articleabstract_start -->

si tienes un gran n&uacute;mero de sistemas Linux/Unix que administrar, entonces
ciertamente necesitar&aacute;s algunos scripts para ayudarte a automatizar
algunas de tus tareas. Deber&iacute;as haberte dado cuenta durante el trabajo de
todos los d&iacute;as que haces las mismas o similares cosas en cada equipo.
Quiz&aacute; hallas pensado en alguna forma de automatizar estas tareas. Esto es
especialmente cierto para mantener grandes n&uacute;meros de equipos Linux/Unix
que est&aacute;n configurados identicamente. En este art&iacute;culo mostrar&eacute; una manera
de hacer esto usando las utilidades de ssh.

<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- BODY OF THE ARTICLE -->


<A NAME="278lfindex0">&nbsp;</A>
<H2>Introducci&oacute;n</H2>

La idea es encontrar una manera de copiar algunos ficheros desde el
ordenador delante del que yo me siento a una serie de ordenadores y
servidores, y despu&eacute;s ejecutar algunos comandos en esas m&aacute;quinas, como
ejecutar una instalaci&oacute;n rpm o cambiar algunas opciones de sistema.
A veces necesitar&iacute;amos primero ejecutar unos comandos en esas m&aacute;quinas y
despu&eacute;s conseguir unos ficheros que pueden ser el resultado de los
comandos ejecutados.
<p>
Para seguir este art&iacute;culo necesitar&aacute;s algunos conocimientos b&aacute;sicos de
programaci&oacute;n en shell. Para conocer algo m&aacute;s sobre la programaci&oacute;n en shell
lee el art&iacute;culo de LinuxFocus de Katja and Guido Socher llamado
LinuxFocus' <a href=../September2001/article216.shtml>Programaci&oacute;n en
  Shell</a> escrito por Katja y Guido Socher. Tambi&eacute;n tendr&aacute;s que conocer las
utilidades de ssh, como ssh-keygen, ssh-add, ssh, scp o sftp. Hay una
implementaci&oacute;n libre del protocolo SSH bajo Linux:
<a href="http://www.openssh.org">OpenSSH</a>, que contiene todas estas
herramientas. Las p&aacute;ginas man tambi&eacute;n est&aacute;n disponibles.
</p>

<A NAME="278lfindex1">&nbsp;</A>
<H2>&iquest;Por qu&eacute; usar ssh?</H2>

La respuesta es una pregunta: &iquest;por qu&eacute; no? Uno puede usar rsh-rcp o
telnet-ftp, no son adecuadas en entornos inseguros como Internet o quiz&aacute;
una intranet. Ssh proporciona una comunicaci&oacute;n segura cifrada entre dos
m&aacute;quinas a trav&eacute;s de una red insegura. No voy a hablar sobre las
implicaciones de seguridad al usar estos protocolos. Mira el art&iacute;culo
<a href="../May2001/article202.shtml">A trav&eacute;s del t&uacute;nel</a> de
Georges Tarbouriech.<br>
En realidad, los he usado en los anteriores scripts que estaban basados en
telnet/ftp.

<A NAME="278lfindex2">&nbsp;</A>
<H2>Copiando ficheros y directorios usando scp</H2>

Para copiar un fichero de un directorio local a un ordenador remoto se
puede usar el siguiente comando:
<p class="code">scp /ruta/al/fichero/fichero1 usuario@ordenador_remoto:/directorioremoto/nuevofichero</p>
En este ejemplo se copia el fichero con nombre fichero1 de la carpeta
local al ordenador remoto (ordenador_remoto puede ser la IP o nombre de la
m&aacute;quina remota) en en directorio /directorioremoto con el nuevo nombre
"nuevofichero". Se te pedir&aacute; que te autentifiques como &uacute;suario'. Si te
autentificas correctamente y el usuario remoto tiene los persisos
necesarios, se copiar&aacute; el fichero.
Uno puede omitir el nombre de fichero de destino. En este caso el fichero
se copiar&aacute; con el nombre original. En pocas palabras, esto significa que
se puede renombrar los ficheros mientras se copian. <br>
Lo contrario tambi&eacute;n es posible: se puede copiar un fichero remoto a un
directorio local:
<p class="code">scp usuario@ordenador_remoto:/directorioremoto/fichero
/ruta/a/la/carpeta/local/nuevofichero</p>
Hay tambi&eacute;n una caracter&iacute;stica muy buena del comando scp. Puedes copiar
directorios recursivamente especificando la opci&oacute;n '-r'.
<p class="code">scp -r usuarior@ordenador_remoto:/directorioremoto .</p>
El comando anterior copia el directorio 'directorioremoto' y todos sus
directorios y ficheros del ordenador remoto al directorio en el que
estemos con el mismo nombre.
<p>
<b>Nota:</b> Se asume que tienes el demonio sshd corriendo en el host
remoto.
</p>

<A NAME="278lfindex3">&nbsp;</A>
<H2>Login remoto usando ssh</H2>

En vez de rlogin o telnet se puede usar el modo m&aacute;s seguro, que es ssh:
<p class="code">ssh erdal@helvetica.fonts.de</p>
Dependiendo de tu configuraci&oacute;n, tendr&aacute;s que introducir o una contrase&ntilde;a o
una frase de contrase&ntilde;a (passphrase). En este caso, nos estamos conectando
al ordenador remoto helvetica.fonts.de con la cuenta de usuario remota
"erdal". El comando ssh tiene una serie de opciones que se pueden usar en
funci&oacute;n de nuestras necesidades. &Eacute;chale un vistazo a la p&aacute;gina man de ssh.

<A NAME="278lfindex4">&nbsp;</A>
<H2>Ejecutando comandos usando ssh</H2>

Existe la posibilidad de ejecutar comandos en la m&aacute;quina remota
usando ssh :
<p class="code">ssh erdal@helvetica.fonts.de df -H</p>

Esto se parece bastante a la sintaxis de remote login (rlogin). La &uacute;nica
difecencia est&aacute; despu&eacute;s de la parte del nombre de m&aacute;quina. El comando (en
este ejemplo 'df -H')  se escribe para que sea ejecutado en la m&aacute;quina
remota. La salida del comando se muestra en tu terminal.

<A NAME="278lfindex5">&nbsp;</A>
<H2>Conect&aacute;ndose a un ordenador remoto sin contrase&ntilde;a</H2>

En vez de usar la autentificaci&oacute;n por contrase&ntilde;a, se puede usar un
par de claves (p&uacute;blica/privada). Necesitas generar tu par de claves.
Existe una utilidad llamada ssh-keygen, que puede ser utilizada para
generar dichas claves para ssh:
<p class="code">ssh-keygen -b 1024 -t dsa</p>
Se pedir&aacute; el nombre de la clave privada. Normalmente, el nombre de la
clave p&uacute;blica es el mismo que el de la privada a&ntilde;adi&eacute;ndole '.pub'.
En este ejemplo '-b 1024' es el n&uacute;mero de bits en la clave a crear. Si
se especifica nada se usar&aacute; el valor por defecto. El par&aacute;metro '-t dsa'
se usa para especificar el tipo de clave. Los valores posibles son 'rsa1'
para la versi&oacute;n 1 del protocolo y 'rsa' o 'dsa' para la versi&oacute;n 2. Yo
recomiendo usar la versi&oacute;n 2 de SSH. Pero si tienes servidores antiguos
que s&oacute;lo soportan la versi&oacute;n 1 del protocolo necesitar&aacute;s especificar
'-t rsa1' y crar otro par de claves. Puedes forzar a ssh a usar la versi&oacute;n
1 o 2 del protocolo especificando un '-1' o '-2' respectivamente.
<p>
Para usar tu clave, debes instalar tu clave p&uacute;blica en la m&aacute;quina remota.
El contenido del fichero de clave p&uacute;blica deber&iacute;a ser copiado o a&ntilde;adido al
fichero $HOME/.ssh/authorized_keys o $HOME/.ssh/authorized_keys2. Ten
cuidado y no mezcles las claves para los diferentes versiones del
protocolo. El fichero authorized_keys se usa para la versi&oacute;n 1 del
protocolo. El authorized_keys2 se usa para la versi&oacute;n 2. Si instalaste
tu clave p&uacute;blica correctamente, la pr&oacute;xima vez que te conectes a ese
ordenador tendr&aacute;s que introducir tu passphrase y si no es correcta,
entonces tendr&aacute;s que introducir la contrase&ntilde;a del usuario remoto. Puedes
restringir la conexi&oacute;n a tu equipo para que s&oacute;lo se use la autentificaci&oacute;n
de clave p&uacute;blica editando el fichero de configuraci&oacute;n del sshd.
El nombre del fichero es/etc/ssh/sshd_config y el par&aacute;metro que tienes que
cambiar es 'PasswordAuthentication'. Cambia el valor de este par&aacute;metro a
no (PasswordAuthentication no) y reinicia tu sshd.</p>
<p>
Hasta este punto todo est&aacute; bien. Tenemos una forma segura de copiar y
ejecutar comandos en una m&aacute;quina remota. Pero, para automatizar algunas
tareas no deber&iacute;amos necesitar teclear contrase&ntilde;as o passphrases. Porque
si no, no podremos automatizar nada. Una soluci&oacute;n podr&iacute;a ser escribir en
cada script que lo requiera la contrase&ntilde;a o passhrase, que no es una para
nada una buena idea. La mejor forma es usar el gestor de claves
(key-agent) para que maneje nuestras passphrases. ssh-agent es un programa
para gestionar las claves privadas usadas para la autentificaci&oacute;n con
clave p&uacute;blica. Inicia un gestor de claves :
<p class="code">ssh-agent $BASH</p>
y a&ntilde;&aacute;dele tus claves privadas usando
<p class="code">ssh-add .ssh/id_dsa</p>
o
<p class="code">ssh-add .ssh/identity</p>
id_dsa es fichero de la clave privada DSA e identity es el fichero de la
clave privada RSA1.
Estos son los nombres de fichero por defecto dados durante la generaci&oacute;n
de claves via ssh-keygen. Por supuesto se te pedir&aacute; que introduzcas tu
passphrase antes de que el ssh-add a&ntilde;ada tu clave al ssh-agent. Puedes
listar las claves a&ntilde;adidas con en siguiente comando:
<p class="code">ssh-add -l</p>
</p>

<p>
Ahora, si te conectas a un servidor que tenga tu clave en el fichero
autorizado, entonces &iexcl;estar&aacute;s automaticamente conectado sin tener que
teclear nada! El ssh-agent se encargar&aacute; del proceso de autentificaci&oacute;n.
</p>

<p>
Cuando se usa ssh-agent como se ha descrito arriba, s&oacute;lo se puede usar
dentro del terminal donde se inici&oacute; el ssh-agent. Si se desea usar el
ssh-agent desde cualquier terminal que se abra, es necesario hacer un poco
m&aacute;s de trabajo. Yo escrib&iacute; el siguiente peque&ntilde;o script para iniciar el
agente:
</p>

<pre>
#!/bin/sh
#
# Erdal mutlu
#
# Iniciando un ssh-agent para ser usado en tareas programas (batch).

fichero_agent_info=~/.ssh/agent_info

if [ -f $fichero_agent_info ]; then
 echo "Fichero agent info : $fichero_agent_info existe."
 echo "aseg&uacute;rese de que ning&uacute;n ssh-agent se est&aacute; ejecutando
 y despu&eacute;s borre este fichero."
 exit 1
fi

ssh-agent | head -2 &gt; $fichero_agent_info
chmod 600 $fichero_agent_info
exit 0
</pre>
<br><br>

<p>
El anterior script comprueba si existe un fichero llamado agent_info en el
directorio personal del usuario que es donde estan normalmente los
ficheros de los usuarios de ssh. En nuestro caso el directorio es '.ssh/'.
Si el fichero existe se le avisa al usuario que existe el fichero y
muestra un peque&ntilde;o mensaje sobre qu&eacute; puede hacerse. Si el usuario no est&aacute;
ejecutando ya el ssh-agent entonces el o ella tiene que borrar el fichero
e iniciar el script de nuevo. El scripts ejecuta el ssh-agent y captura
las dos primeras l&iacute;neas en el fichero agent_info. Esta informaci&oacute;n ser&aacute;
utilizada por otras utililidades de ssh m&aacute;s tarde. Lo siguiente es una
l&iacute;nea para cambiar el modo del fichero, de manera que s&oacute;lo el propietario
del fichero pueda leerlo y escribir en &eacute;l.
</p>

<p>
Cuando tu agente est&eacute; ejecutandose puedes a&ntilde;adirle tus claves. Pero antes
de esto, debes hacer un source del fichero agent_info, de manera que las
herramientas ssh sepan d&oacute;nde est&aacute; tu agente:
</p>
<p class="code">source ~/.ssh/agent_info or . ~/.ssh/agent_info</p>
<p>Y a&ntilde;ade tus claves con ssh-add. Puedes a&ntilde;adir las siguientes l&iacute;neas a
tu fichero .bashrc de manera que cada vez que habras un terminal nuevo, se
realice automaticamente el source del fichero agent_info:
</p>

<pre>
if [ -f .ssh/agent_info ]; then
. .ssh/agent_info
fi
</pre>

<p>
<b>AVISO:</b> Debes asegurar la m&aacute;quina desde la que uses ssh-agent y el
script autom&aacute;tico que voy a describir aqu&iacute;. De lo contrario, si alguien
tiene accesto a tu cuenta, entonces &eacute;l o ella tendr&aacute; acceso a todos los
servidores a los que t&uacute; tengas acceso con las claves ssh. &iexcl;Todo tiene un
precio!
</p>

<A NAME="278lfindex6">&nbsp;</A>
<H2>El script</H2>

<p>
Es hora de explicar c&oacute;mo vamos a automatizar algunos trabajos de un
administrador de sistemas. La idea es ejecutar una serie de comandos para
una lista de m&aacute;quinas y descargar o subir una serie de ficheros desde o a
estas m&aacute;quinas. Esto es lo que los administradores de sistemas tienen que
hacer a menudo. Aqu&iacute; est&aacute; el script:
</p>

<pre>
#!/bin/sh

# Instalando cualquier cosa usando Secure SHELL y SSH agent
# Erdal MUTLU
# 11.03.2001


##################################################################
#                     Funciones                                  #
##################################################################
### Copiar ficheros entre m&aacute;quinas
copiar_ficheros()
{
 if [ $fichero_de_ficheros != "ficheros_vacio.txt" ];then
  cat $fichero_de_ficheros | grep -v "#" | while read -r linea
  do
   direccion=`echo ${linea} | cut -d " " -f 1`
   fichero1=`echo ${linea}     | cut -d " " -f 2`
   fichero2=`echo ${linea}     | cut -d " " -f 3`

   case ${direccion} in
      "l2r") :	### De la m&aacute;quina local (localhost) a la m&aacute;quina remota (host)
          echo "$fichero1  --&gt; ${host}:${fichero2}"
          scp $fichero1 root@${host}:${fichero2}
      ;;
      "r2l") :	### De la m&aacute;quina remota a la m&aacute;quina local
          echo "${host}:${fichero2}  --&gt; localhost:${fichero2}"
          scp root@${host}:${fichero1} ${fichero2}
      ;;
      *)
          echo "Direcci&oacute;n desconocida de la copia : ${direccion}"
          echo "Debe ser o local o remota."
      ;;
   esac
  done
 fi
}

### Ejecutar comandos en m&aacute;quinas remotas
ejecutar_comandos()
{
 if [ $fichero_de_comandos != "comandos_vacio.txt" ];then
  cat $fichero_de_comandos | grep -v "#" |  while read -r linea
  do
   linea_del_comando="${linea}"
   echo "Ejecutando $linea_del_comando ..."
   ssh -x -a root@${host}  ${linea_del_comando} &amp;
   wait $!
   echo "Ejecuci&oacute;n de $linea_del_comando OK."
  done
 fi
}

### Funci&oacute;n que engloba a las funciones ejecutar_comandos y copiar_ficheros
hacerlo()
{
 cat $fichero_de_host | grep -v "#" | while read -r host
 do
  echo "host=$host procesando..."
  case "${modo}" in
	"1")
		copiar_ficheros
		ejecutar_comandos
		;;
	"2")
		ejecutar_comandos
		copiar_ficheros
		;;
	*)
		echo "$0 : Modo desconocido : ${modo}"
		;;
  esac
  echo "host=$host ok."
  echo "------------------------------------------------------------------"
 done
}

##################################################################
### El programa empieza aqu&iacute;
##################################################################

if [ $# -ne 4 ]; then
 echo "Uso : $0 modo fichero_de_host fichero_de_ficheros fichero_de_comandos"
 echo ""
 echo "modo es 1 o 2 "
 echo "    1 : primero copia ficheros y despu&eacute;s ejecuta comandos."
 echo "    2 : primero ejecuta comandos y despu&eacute;s copia ficheros."
 echo "Si el nombre de ficheros.txt es ficheros_vacio.txt entonces no se procesa."
 echo "Si el nombre de comandos.txt es comandos_vacio.txt entonces no se procesa."
 exit
fi


modo=$1
fichero_de_host=$2
fichero_de_ficheros=$3
fichero_de_comandos=$4

fichero_agent_info=~/.ssh/agent_info
if [ -f $fichero_agent_info ]; then
 . $fichero_agent_info
fi

if [ ! -f $fichero_de_host ]; then
 echo "Fichero de hosts : &iexcl;$fichero_de_host no existe!"
 exit 1
fi

if [ $fichero_de_ficheros != "ficheros_vacio.txt" -a ! -f $fichero_de_ficheros ]; then
  echo  "Fichero de ficheros : &iexcl;$fichero_de_ficheros no existe!"
  exit 1
fi

if [ $fichero_de_comandos != "comandos_vacio.txt" -a ! -f $fichero_de_comandos ]; then
 echo  "Fichero de comandos : &iexcl;$fichero_de_comandos no existe!"
 exit 1
fi

#### Ahora hacerlo todo
hacerlo
</pre>


<p>
Guardemos el script como ainstal.sh (automated installation -instalaci&oacute;n
automatizada) e intentemos ejecutarlo sin ning&uacute;n par&aacute;metro. Obtendremos el
siguiente mensaje:
</p>
<p class="code">./ainstall.sh</p>

<table border=0 bgcolor="#aedbe8"><tr><td>
<pre>
Uso : ./ainstall.sh modo fichero_de_host fichero_de_ficheros fichero_de_comandos

modo es 1 o 2
        1 : primero copia ficheros y despu&eacute;s ejecuta comandos.
        2 : primero ejecuta comandos y despu&eacute;s copia ficheros.
Si el nombre de ficheros.txt es ficheros_vacio.txt entonces no se procesa.
Si el nombre de comandos.txt es comandos_vacio.txt entonces no se procesa.
</pre>
</td></tr></table>

<p>
Como dice el mensaje si no quieres ejecutar ning&uacute;n comando, entonces llama
al argumento comandos.txt comandos_vacio.txt y si no quieres transferir
ning&uacute;n fichero llama al argumento fichero_de_ficheros ficheros_vacio.txt.
Unas veces s&oacute;lo necesitar&aacute;s ejecutar unos comandos, mientras que otras
s&oacute;lo tranferir unos ficheros.
</p>

<p>
Antes de explicar el script l&iacute;nea a l&iacute;nea permitidme que de un posible
ejemplo de uso: Supongamos que has a&ntilde;adido un servidor DNS secundario a tu
red y quieres a&ntilde;adirlo al fichero /etc/resolv.conf. Para simplificar
supongamos tambi&eacute;n que todas tus m&aacute;quinas usan el mismo fichero
resolv.conf. Por lo tanto lo &uacute;nico que tienes que hacer es copiar el nuevo
fichero resolv.conf a todas las m&aacute;quinas.<br>
Primero necesitas una lista de tus m&aacute;quinas. Vamos a escribir todos las
m&aacute;quinas en un fichero llamado hosts.txt. El formato del fichero hosts.txt
es que tal que cada l&iacute;nea contiene &uacute;nicamente el nombre de m&aacute;quina o su
IP. Aqu&iacute; tienes un ejemplo:
</p>

<table border=0 bgcolor="#aedbe8"><tr><td>
<pre>
#############################################################################
#### Cada l&iacute;nea contiene el nombre de m&aacute;quina o direcci&oacute;n IP de cada m&aacute;quina.
#### Las l&iacute;neas que empiezan o contienen el car&aacute;cter # se ignoran.
#############################################################################
helvetica.fonts.de
optima.fonts.de
zaphino
vectora
#10.10.10.162
10.10.10.106
193.103.125.43
10.53.103.120
</pre>
</td></tr></table>

<p>
Como se puede ver en el ejemplo, se pueden especificar nombres de m&aacute;quinas
completos o simplemente la parte de la m&aacute;quina (sin el dominio). Despu&eacute;s
es necesario crear un fichero donde se especificar&aacute;n los ficheros a
transferir. Hay dos tipos de transferencia posible:
</p>

<ul>
<li>De la m&aacute;quina local a las m&aacute;quinas listadas en el fichero hosts.txt.
Este es nuestro caso.</li>
<li>De cada m&aacute;quina listada en el fichero hosts.txt a la m&aacute;quina local.
Este ser&aacute; cuando necesitemos recibir ciertos ficheros de todas las
m&aacute;quinas. Por ejemplo el uso con nuestro sencillo script de copias de
seguridad, que describir&eacute; m&aacute;s abajo en este mismo art&iacute;culo.</li>
</ul>
<p>
Los ficheros a transferir se especifican en otro fichero. Guardemos
este fichero como fichero_de_ficheros.txt. El formato del fichero
fichero_de_ficheros.txt es el siguiente: Cada l&iacute;nea incluye informaci&oacute;n
para copiar un &uacute;nico fichero. Hay dos posibles sentidos de copia: l2r
(local a remoto) y r2l (remoto a local). l2r se usa cuando se copia un fichero
de la m&aacute;quina local a una m&aacute;quina remota. r2l se usa cuando se copia un
fichero desde una m&aacute;quina remota a la m&aacute;quina local. Despu&eacute;s de la
palabra clave que indica el sentido se especifican dos nombres de fichero.
Dichos campos se separan por espacio o tabulador. El primer fichero se
copia al segundo fichero de acuerdo con el sentido especificado por la
palabra clave. El nombre de fichero para los ficheros de la m&aacute;quina remota
deber&iacute;a ser una ruta completa, de otro modo se copiar&aacute; en el directorio
home del root. Este es nuestro fichero_de_ficheros.txt :
</p>
<table border=0 bgcolor="#aedbe8"><tr><td>
<pre>
############################################################################
# La estructura del fichero es :
# - El significado de los campos es : es l2r (localhost a remoto) y r2l
# (m&aacute;quina remota a local).
#       r2l  fichero1   fichero2
#         significa copiar el fichero1 desde la m&aacute;quina remota
#         (m&aacute;quinas especificadas en el fichero hosts.txt) a la local como
#         fichero2.
#       l2r     fichero1   fichero2
#         significa copiar el fichero1 de la m&aacute;quina local a la
#         remota (m&aacute;quinas especificadas en el fichero hosts.txt) como fichero2
#         fichero1 y fichero2 son los ficheros en las m&aacute;quinas
#         correspondientes.
#
#       Nota: el orden en que se usan local y remoto especifica la
#       direcci&oacute;n del proceso de copia.
############################################################################
l2r     resolv.conf     /etc/resolv.conf
</pre>
</td></tr></table>

<p>
Como puedes ver ya he incluido una descripci&oacute;n de c&oacute;mo se estructura el
fichero. Normalmente incluyo esta descripci&oacute;n en cada fichero
fichero_de_ficheros.txt que utilizo. Es una soluci&oacute;n sencilla pero my
buena para la documentaci&oacute;n. En nuestro ejemplo queremos copiar el fichero
resolv.conf a una m&aacute;quina remota como /etc/resolv.conf. Con &aacute;nimo de
demostraci&oacute;n despu&eacute;s de copiar el fichero a las m&aacute;quinas destino a&ntilde;ad&iacute;
unos comandos para cambiar el propietario y el grupo y mostrar el
contenido de /etc/resolv.conf. Los comandos a ejecutar se especifican en
un fichero a parte. Al fichero con los comandos lo llamaremos
fichero_de_comandos.txt. Aqu&iacute; se muestra su contenido:
</p>

<table border=0 bgcolor="#aedbe8"><tr><td>
<pre>
###########################################################################
# La estructura de este fichero es: Cada l&iacute;nea contiene un comando a
# ejecutar. Cada comando se trata por separado.
###########################################################################
chown root.root /etc/resolv.conf
chmod 644 /etc/resolv.conf
cat /etc/resolv.conf
</pre>
</td></tr></table>

<p>
El fichero de comandos contiene los comandos a ser ejecutados en cada
m&aacute;quina listada en el fichero hosts.txt. Los comandos se ejecutan
secuencialmente, esto significa que primero se ejecuta el primer comando y
despu&eacute;s el segundo, y as&iacute; con el resto.
</p>

<p>
Ok, ahora tienes todos los ficheros necesarios para este sencillo
ejemplo. La &uacute;nica cosa que falta por especificar el la opci&oacute;n 'modo', que
especifica cu&aacute;l de los dos ficheros: fichero_de_comandos.txt o
fichero_de_ficheros.txt se ha de procesar primero.
Uno puede transferir los ficheros listados en fichero_de_ficheros.txt y
despu&eacute;s ejecutar todos los comandos en la m&aacute;quina destino, esto es el
modo=1. Y lo contrario, ejecutar los comandos y despu&eacute;s tranferir los
ficheros, que es el modo=2. Ahora puedes ejecutar el script con los
argumentos necesarios como sigue:
</p>
<p class="code">./ainstall.sh 1 hosts.txt fichero_de_ficheros.txt fichero_de_comandos.txt</p>

<p>
Un peque&ntilde;o consejo: normalmente yo siempre a&ntilde;ado el prefijo ficheros_ al
fichero ficheros.txt y despu&eacute;s le doy un nombre corto descriptivo, como
ficheros_resolvconf.txt. Tambi&eacute;n aplico la misma t&eacute;cnica a hosts.txt y
comandos.txt.
</p>

<p>
Es hora de explicar un poco m&aacute;s sobre el propio script. El programa
comienza comprobando el n&uacute;mero de argumentos y si no es 4 entonces muestra
el modo de empleo. Si el n&uacute;mero de argumentos es el correcto, cada
argumento es asignado a su variable correspondiente. Despu&eacute;s si existe el
fichero '~/.ssh/agent_info', se carga su contenido. Este fichero contiene
informaci&oacute;n sobre el agente ssh en ejecuci&oacute;n. Si no usas un agente,
entonces tendr&aacute;s que introducir las contrase&ntilde;as o frases de paso
manualmente, lo que significa que no hay automatizaci&oacute;n :). Despu&eacute;s se
comprueba que existe cada fichero (hosts, ficheros y comandos). Tambi&eacute;n
hay una comprobaci&oacute;n especial para el fichero ficheros_vacio.txt y
comandos_vacio.txt. Si especificaste dicho nombre, entonces no es
necesario comprobar la existencia del fichero. He cambiado esta parte del
script durante la redacci&oacute;n de este art&iacute;culo. Antes, s&oacute;lo era:
</p>

<pre>
if [ -f $fichero_de_host -a -f $fichero_de_ficheros -a -f $fichero_de_comandos ]; then
 echo "$fichero_de_host $fichero_de_ficheros $fichero_de_comandos"
 hacerlo
else
 echo "no existe $fichero_de_host o $fichero_de_ficheros o $fichero_de_comandos"
 exit
fi
</pre>

<p>
En este caso ten&iacute;a que tener los ficheros con el nombre:
ficheros_vacio.txt y comandos_vacio.txt. Aunque en realidad no era un
problema, porque estaba trabajando &uacute;nicamente en un directorio.<br>
Al final vienen la llamada a la funci&oacute;n 'hacerlo'. Todo se controla en
esta funci&oacute;n. La funci&oacute;n tiene un bucle hecho con 'cat' y 'while', que
para cada m&aacute;quina listada en '$fichero_de_host' llama a las funciones
copiar_ficheros y ejecutar_comandos de acuerdo al 'modo'. As&iacute; que se
realiza el trabajo para cada m&aacute;quina. La variable 'host' contiene el
nombre de m&aacute;quina o IP actual.<br>
Veamos la funci&oacute;n copiar_ficheros. Esta funci&oacute;n primero comprueba si el
valor de 'fichero_de_ficheros' es igual a 'ficheros_vacio.txt' o no. Si es
igual entonces no se hace nada. Si no, entonces en cada l&iacute;nea del fichero
'$fichero_de_ficheros', las variables 'direccion', 'fichero1' y 'fichero2'
contienen la direcci&oacute;n de la copia, el nombre del primer fichero y el
nombre del segundo respectivamente. De acuerdo con el valor de la variable
'direccion', se realiza una copia usando scp.<br>
Para finalizar veamos lo que se hace en la funci&oacute;n ejecutar_comandos.
La funci&oacute;n comprueba si el valor de 'fichero_de_comandos' es igual o no a
'comandos_vacio'. Si es igual no se hace nada. Si no, entonces cada
comando del fichero '$fichero_de_comandos' se ejecuta en la m&aacute;quina remota
mediante ssh. Despu&eacute;s de ejecutar el comando ssh hay una llamada al
comando wait con el par&aacute;metro '$!'. Este comando se asegura que cada
comando se ejecuta uno detr&aacute;s de otro. '$!' se expande al ID de proceso
del comando m&aacute;s reciente ejecutado en segundo plano.<br>
Es todo. Simple, &iquest;no es cierto?
<p/>

<A NAME="278lfindex7">&nbsp;</A>
<H2>Una sencilla copia de seguridad de tus ficheros de configuraci&oacute;n</H2>

<p>
Aqu&iacute; se presenta un uso m&aacute;s avanzado del script. La idea es hacer una
copia de seguridad de los ficheros de configuraci&oacute;n de tus m&aacute;quinas o
servidores. Para ello escrib&iacute; este peque&ntilde;o script que usa ainstall.sh :
</p>

<pre>
#!/bin/sh

directorio_del_servidor=${HOME}/erdal/sh/CopiasegServidor

if [ ! -d $directorio_del_servidor ]; then
 echo "Directorio : $directorio_del_servidor no existe."
 exit 1
fi

cd $directorio_del_servidor

servidores=ll_servidores.txt
prog=${HOME}/erdal/sh/einstall_sa.sh

cat $servidores | grep -v "#" | while read -r host
do
  echo $host &gt; host.txt
  $prog 1 host.txt ficheros_vacio.txt
  servidores/${host}/comandos_hacer_copiaseg.txt
  $prog 1 host.txt ficheros_copiaseg.txt comandos_vacio.txt
  mv -f copiaseg.tgz servidores/${host}/copiaseg/`date +%Y%m%d`.tgz
  rm -f host.txt
done

exit 0
</pre>
<p>
Tienes que tener un directorio especial llamado servidores. En este
directorio deben haber dos ficheros: ficheros_copiaseg.txt y
ll_servidores.txt. Aqu&iacute; tienes el 'ficheros_copiaseg.txt' :
</p>
<p class="code">
r2l /root/copiaseg.tgz copiaseg.tgz
</p>

<p>
'll_servidores.txt' contiene los nombres o direcciones IP de los hosts
sobre los que se realizar&aacute; la copia de seguridad. Cada nombre de m&aacute;quina
listado en el fichero 'll_servidores.txt' debe tener un directorio con el
mismo nombre y dentro de este directorio debe haber un fichero llamado
comandos_hacer_copiasegs.txt, que contenga un comando para hacer un
fichero /root/copiaseg.tgz de los ficheros de configuraci&oacute;n de esa
m&aacute;quina. Y un directorio llamado copiaseg. Todas las copias de seguridad
de esa m&aacute;quina se almacenar&aacute;n en ese directorio. Si el contenido del
fichero ll_servidores.txt es :
</p>
<table border=0 bgcolor="#aedbe8"><tr><td>
<pre>
servidor_de_ficheros
servidor_de_bbdd
10.10.10.1
servidor_de_aplicaciones
</pre>
</td></tr></table>

<p>
entonces la estructura de directorio de tu directorio '$servidores' debe
ser la siguiente:
</p>
<table border=0 bgcolor="#aedbe8"><tr><td>
<pre>
servidores
|-- ficheros_copiaseg.txt
|-- ll_servidores.txt
|-- hacer_copiaseg_servidor.sh
|-- 10.10.10.1
|   |-- copiaseg
|   `-- comandos_hacer_copiaseg.txt
|-- servidor_de_aplicaciones
|   |-- copiaseg
|   `-- comandos_hacer_copiaseg.txt
|-- servidor_de_bbdd
|   |-- copiaseg
|   `-- comandos_hacer_copiaseg.txt
|-- servidor_de_ficheros
    |-- copiaseg
    `-- comandos_hacer_copiaseg.txt
</pre>
</td></tr></table>
<p>
Y aqu&iacute; tienes algunos ejemplos para los ficheros comandos_hacer_copiaseg.txt:
</p>

<p class="code">
tar cfz /root/copiaseg.tgz /etc/samba /etc/atalk /etc/named.conf /var/named/zones
</p>
<p>El anterior comandos_hacer_copiaseg.txt se usa para hacer una copia de
seguridad de samba, atalk y la configuraci&oacute;n del servidor de nombres y los
ficheros de zonas.</p>
<p class="code">
tar cfz /root/copiaseg.tgz /etc/httpd /usr/local/apache
</p>
<p>El anterior comandos_hacer_copiaseg.txt se usa para hacer una copia de
seguridad de la configuraci&oacute;n y los ficheros de un servidor apache.</p>
<p class="code">
tar cfz /root/copiaseg.tgz /etc/squid /etc/named.conf
</p>
<p>El anterior comandos_hacer_copiaseg.txt se usa para hacer una copia de
seguridad de las configuraciones del servidor proxy squid y el servidor
de nombres secundario.</p>
<p>
Usando el anterior script y creando los ficheros
comandos_hacer_copiaseg.txt de acuerdo con tus necesidades puedes hacer
copias de seguridad de las configuraciones de tus servidores.
</p>

<A NAME="278lfindex8">&nbsp;</A>
<H2>Conclusi&oacute;n</H2>

El script ainstall.sh permite automatizar algunas tareas de la
administraci&oacute;n de sistemas. El script se basa en un uso sencillo de las
herramientas de ssh. Este script te ser&aacute; de mucha utilidad cuando tengas
un gran n&uacute;mero de sistemas id&eacute;nticos.
<A NAME="278lfindex9">&nbsp;</A>
<H2>Referencias</H2>

<ul>
<li>SSH, The Secure Shell: The Definitive Guide, by Daniel J. Barrett and
Richard Silverman.</li>
<li><a href="../May2001/article202.shtml">A trav&eacute;s del t&uacute;nel</a>, de
Georges Tarbouriech.</li>
<li><a href=../September2001/article216.shtml>Programaci&oacute;n en shell</a>,
de Katja and Guido Socher.</li>
</ul>


<!-- vim: set sw=2 ts=2 et tw=74: -->

<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Formulario de "talkback" para este art&iacute;culo</h2>
Cada art&iacute;culo tiene su propia p&aacute;gina de "talkback". A trav&eacute;s de esa p&aacute;gina puedes enviar un comentario o consultar los comentarios de otros lectores
<center>
<table border="0"  CELLSPACING="2" CELLPADDING="1" summary="tb-button-outerpart">
 <tr BGCOLOR="#C2C2C2"><td align=center>
  <table border="3"  CELLSPACING="2" CELLPADDING="1" summary="tb-button">
   <tr BGCOLOR="#C2C2C2"><td align=center>
    <A href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=278"><b>&nbsp;Ir a la p&aacute;gina de "talkback"&nbsp;</b></a>
   </td></tr></table>
</td></tr></table>
</center>

<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#9999AA" WIDTH="50%">
<A HREF="../../common/lfteam.html">Contactar con el equipo de LinuFocus</A>
<BR><FONT COLOR="#FFFFFF">&copy; Erdal Mutlu, <a href="../../common/copy.html">FDL</a> <BR><a href="http://www.linuxfocus.org">LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#9999AA">
<!-- TRANSLATION INFO -->
<font size=2>Informaci&oacute;n sobre la traducci&oacute;n:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Erdal Mutlu <small>&lt;erdal(at)linuxfocus.org&gt;</small></font></td></tr>
  <tr><td><font size="2">en --&gt; es: Javier G&oacute;mez Sierras &lt;jgomsi(at)obelix.umh.es&gt;</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2003-02-28, generated by lfparser version 2.34</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
