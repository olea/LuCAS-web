<?xml version="1.0" encoding="utf8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  ><head><meta http-equiv="Content-Type" content="text/html; charset=utf8" /><meta content="HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org" /><link rel="stylesheet" type="text/css" href="../../tigris.css" /><title>Manpage of BASH</title></head><body><p>
  
</p><h1>BASH</h1><p>

Section: User Commands (1)<br />
Updated: 1 Abril 1998<br /><a href="#index">Index</a> <a href="http://localhost/cgi-bin/man/man2html">Return to Main
Contents</a>
</p><hr /><a id="lbAB"> </a><h2>NOMBRE</h2><p>

bash - GNU Bourne-Again SHell (el Shell de Bourne otra vez, de GNU)
<a id="lbAC"> </a> 
</p><h2>SINOPSIS</h2><b>bash</b><p> [opciones] [fichero] <a id="lbAD"> </a> 
</p><h2>DERECHOS DE COPIA</h2><p>

Bash es Copyright © 1989, 1991, 1993, 1995, 1996 por la Free
Software Foundation, Inc. <a id="lbAE"> </a> 
</p><h2>DESCRIPCIÓN</h2><b>Bash</b><p> es un intérprete de un lenguaje de órdenes compatible
con <b>sh</b> que ejecuta órdenes leídas desde la entrada estándar
o desde un fichero. <b>Bash</b> también incorpora características
útiles tomadas de los shells de <i>Korn</i> y <i>C</i> (<b>ksh</b>
y <b>csh</b>). 
</p><p><b>Bash</b> está pensado con la intención de ser una
implementación conforme con la especificación POSIX de Shell y
Herramientas, de la IEEE (Grupo de Trabajo 1003.2 de la IEEE). <a id="lbAF"> </a></p><h2>OPCIONES</h2><p>

Además de las opciones de un solo carácter documentadas en la
descripción de la orden interna <b>set</b>, <b>bash</b> interpreta
las siguientes opciones cuando es llamado: 
</p><dl compact="compact"><dt><b>-c</b> <i>cadena</i></dt>

<dd>Si la opción <b>-c</b> está presente, entonces las órdenes se
leen de <i>cadena</i>. Si hay argumentos tras la <i>cadena</i>, se
asignan a los parámetros posicionales, empezando por
<b>$0</b>.</dd>

<dt><b>-r</b></dt>

<dd>Si la opción <b>-r</b> está presente, entonces el shell se
vuelve <i>restringido</i> (vea <font size="-1"><b>SHELL
RESTRINGIDO</b></font> más abajo).</dd>

<dt><b>-i</b></dt>

<dd>Si la opción <b>-i</b> está presente, el shell es
<i>interactivo</i>.</dd>

<dt><b>-s</b></dt>

<dd>Si la opción <b>-s</b> está presente, o si no quedan argumentos
tras el procesado de las opciones, entonces las órdenes se leen
desde la entrada estándar. Esta opción permite definir los
parámetros posicionales cuando se llama a un shell
interactivo.</dd>

<dt><b>-D</b></dt>

<dd>Se muestra en la salida estándar una lista de cadenas de
caracteres entrecomilladas precedidas por <b>$</b>. Estas cadenas
son las que están sujetas a traducción cuando la localización en
curso no es C ni POSIX. Esta opción implica también la <b>-n</b>;
no se ejecuta ninguna orden.</dd>

<dt><b>--</b></dt>

<dd>Un <b>--</b> señala el fin de las opciones e inhabilita
cualquier posterior procesado de opciones. Cualesquier argumentos
tras <b>--</b> se tratan como nombres de fichero y argumentos. Un
argumento <b>-</b> es equivalente a <b>--</b>.</dd>
</dl><p><b>Bash</b> también interpreta una variedad de opciones
multi-carácter. Estas opciones deben aparecer en la línea de
órdenes antes de las opciones de un solo carácter para que puedan
ser reconocidas.</p><dl compact="compact"><dt><b>--dump-po-strings</b></dt>

<dd>Equivalente a <b>-D</b>, pero la salida es en el formato de un
fichero <b>po</b> (objeto portable), del <i>gettext</i> de
GNU.</dd>

<dt><b>--dump-strings</b></dt>

<dd>Equivalente a <b>-D</b>.</dd>

<dt><b>--help</b></dt>

<dd>Muestra un mensaje de modo de empleo en la salida estándar y
acaba con éxito.</dd>

<dt><b>--login</b></dt>

<dd>Hace que <b>bash</b> actúe como si se le hubiera llamado como
un shell de entrada (vea <font size="-1"><b>LLAMADA</b></font> más
abajo).</dd>

<dt><b>--noediting</b></dt>

<dd>No utiliza la biblioteca de GNU <b>readline</b> para leer
líneas de órdenes en interactivo.</dd>

<dt><b>--noprofile</b></dt>

<dd>No lee ni el fichero de arranque de sistema <i>/etc/profile</i>
ni ninguno de los ficheros de inicio personales
<i>~/.bash_profile</i>, <i>~/.bash_login</i>, ni <i>~/.profile</i>.
Por omisión, <b>bash</b> lee estos ficheros cuando se le llama como
un shell de entrada (vea <font size="-1"><b>LLAMADA</b></font> más
adelante).</dd>

<dt><b>--norc</b></dt>

<dd>No lee ni ejecuta el fichero de inicio personal
<i>~/.bashrc</i> si el shell es interactivo. Esta opción está
activa de forma predeterminada si el shell se llama como
<b>sh</b>.</dd>

<dt><b>--posix</b></dt>

<dd>Cambia el comportamiento de <b>bash</b> donde la operación
normal difiera del estándar POSIX 1003.2, de forma que concuerde
con éste.</dd>

<dt><b>--rcfile</b> <i>fichero</i></dt>

<dd>Ejecuta órdenes desde <i>fichero</i> en vez de desde el fichero
de inicio personal estándar <i>~/.bashrc</i> si el shell es
interactivo (vea <font size="-1"><b>LLAMADA</b></font> más
abajo).</dd>

<dt><b>--restricted</b></dt>

<dd>El shell se vuelve restringido (vea <font size="-1"><b>SHELL
RESTRINGIDO</b></font> más abajo).</dd>

<dt><b>--verbose</b></dt>

<dd>Equivale a <b>-v</b>.</dd>

<dt><b>--version</b></dt>

<dd>Muestra información en la salida estándar sobre la versión de
esta instanciación de <b>bash</b> y acaba con éxito.</dd>
</dl><a id="lbAG"> </a><h2>ARGUMENTOS</h2><p>

Si quedan argumentos tras el procesado de las opciones, y no se han
dado ni la opción <b>-c</b> ni la <b>-s</b>, se supone que el
primer argumento es el nombre de un fichero que contiene órdenes
del shell. Si <b>bash</b> se llama de esta manera, <b>$0</b> se
define con el nombre del fichero, y los parámetros posicionales se
definen con los restantes argumentos. <b>Bash</b> lee y ejecuta
órdenes de este fichero, luego acaba. El estado de salida de
<b>bash</b> es el de la última orden ejecutada en el guión. Si no
se ejecuta ninguna orden, el estado de salida es 0. <a id="lbAH"> </a> 
</p><h2>LLAMADA</h2><p>

Un <i>shell de entrada</i> es aquél cuyo primer carácter del
argumento cero es un <b>-</b>, o uno que ha sido llamado con la
opción <b>--login</b>. 
</p><p>Un shell <i>interactivo</i> es uno cuya entrada y salida
estándares están conectadas a terminales (según determina <i><a href="http://localhost/cgi-bin/man/man2html?3+isatty">isatty</a></i>(3)),
o uno que ha sido llamado con la opción <b>-i</b>. <font size="-1">Se define</font> <b>PS1</b> y <b>$-</b> incluye <b>i</b>
si <b>bash</b> es interactivo, permitiendo así a un guión del shell
o a un fichero de arranque el comprobar este estado.</p><p>Los siguientes párrafos describen cómo <b>bash</b> ejecuta sus
ficheros de arranque. Si cualquiera de los ficheros existe pero no
puede leerse, <b>bash</b> informa de un error. Las tildes de la ñ
se expanden en nombres de ficheros como se describe más abajo en
<b>Expansión de la tilde</b> en la sección <font size="-1"><b>EXPANSIÓN</b>.</font></p><p>Cuando <b>bash</b> se llama como un shell de entrada
interactivo, primero lee y ejecuta órdenes desde el fichero
<i>/etc/profile</i>, si es que existe. Tras leer ese fichero, busca
<i>~/.bash_profile</i>, <i>~/.bash_login</i>, y <i>~/.profile</i>,
en ese orden, y lee y ejecuta órdenes del primero de ellos que
exista y se pueda leer. La opción <b>--noprofile</b> puede
emplearse cuando se llame al shell para inhibir este
comportamiento.</p><p>Cuando un shell de entrada termina, <b>bash</b> lee y ejecuta
órdenes desde el fichero <i>~/.bash_logout</i>, si existe.</p><p>Cuando se arranca un shell interactivo que no es de entrada,
<b>bash</b> lee y ejecuta órdenes desde <i>~/.bashrc</i>, si es que
existe. Esto puede evitarse mediante la opción <b>--norc</b>. La
opción <b>--rcfile</b> <i>fichero</i> forzará a <b>bash</b> a leer
y ejecutar órdenes desde <i>fichero</i> en vez de
<i>~/.bashrc</i>.</p><p>Cuando <b>bash</b> se arranque de forma no interactiva, por
ejemplo para ejecutar un guión del shell, busca la variable <font size="-1"><b>BASH_ENV</b></font> en el entorno, expande su valor si
está definida, y utiliza el valor expandido como el nombre de un
fichero a leer y ejecutar. <b>Bash</b> se comporta como si se
ejecutaran las siguientes órdenes:</p><dl compact="compact"><dd><tt>if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi</tt></dd>
</dl><p>pero el valor de la variable <font size="-1"><b>PATH</b></font>
no se emplea para buscar el nombre del fichero.</p><p>Si <b>bash</b> se llama con el nombre <b>sh</b>, intenta imitar
el comportamiento de arranque de versiones históricas de <b>sh</b>
tanto como sea posible, pero sin salirse del estándar POSIX. Cuando
se llama como un shell interactivo de entrada, primero intenta leer
y ejecutar órdenes desde <i>/etc/profile</i> y <i>~/.profile</i>,
en ese orden. La opción <b>--noprofile</b> puede emplearse para
inhibir este comportamiento. Cuando se llama como un shell
interactivo con el nombre <b>sh</b>, <b>bash</b> busca la variable
<font size="-1"><b>ENV</b>,</font> expande su valor si está
definida, y emplea el valor expandido como el nombre de un fichero
a leer y ejecutar. Como un shell llamado como <b>sh</b> no intenta
leer y ejecutar órdenes desde cualquier otro fichero de arranque,
la opción <b>--rcfile</b> no tiene efecto. Un shell no interactivo
llamado con el nombre <b>sh</b> no intenta leer ningún fichero de
arranque. Cuando se llama como <b>sh</b>, <b>bash</b> entra en modo
<i>posix</i> después de leer los ficheros de arranque.</p><p>Cuando <b>bash</b> se arranca en modo <i>posix</i>, como ocurre
cuando se da la opción de línea de órdenes <b>--posix</b>, sigue el
estándar POSIX para los ficheros de arranque. En este modo, los
shells interactivos expanden la variable <font size="-1"><b>ENV</b></font> y se leen y ejecutan órdenes desde el
fichero cuyo nombre es el valor expandido de dicha variable. No se
lee ningún otro fichero de arranque.</p><p><b>Bash</b> intenta determinar cuándo está siendo llamado por el
duende de shell remoto, usualmente <i>rshd</i>. Si <b>bash</b>
determina que está siendo ejecutado por <i>rshd</i>, lee y ejecuta
órdenes desde <i>~/.bashrc</i>, si tal fichero existe y se puede
leer. Esto no lo hará si se le llama con el nombre <b>sh</b>. La
opción <b>--norc</b> puede emplearse para inhibir este
comportamiento, y la opción <b>--rcfile</b> puede utilizarse para
forzar la lectura de otro fichero, pero <i>rshd</i> no llama
generalmente al shell con estas opciones ni permite que se den. <a id="lbAI"> </a></p><h2>DEFINICIONES</h2><p>Las siguientes definiciones se usan a través del resto de este
documento.</p><dl compact="compact"><dt><b>blanco</b></dt>

<dd>Un espacio en blanco o tabulación (tab).</dd>

<dt><b>palabra</b></dt>

<dd>Una secuencia de caracteres considerados por el shell como una
sola unidad. También se conoce como un <b>lexema</b> (token).</dd>

<dt><b>nombre</b></dt>

<dd>Una <i>palabra</i> que consiste solamente en caracteres
alfanuméricos y subrayados, y comienza con un carácter alfabético o
un subrayado. También se llama <b>identificador</b>.</dd>

<dt><b>metacarácter</b></dt>

<dd>Un carácter que, cuando no está entrecomillado, separa
palabras. Uno de los siguientes:<br /><dl compact="compact"><dd>
<p><b>| &amp; ; ( ) &lt; &gt; espacio tab</b></p>
</dd>
</dl></dd>
</dl><dl compact="compact"><dt><b>operador de control</b></dt>

<dd>Un <i>lexema</i> que realiza una función de control. Es uno de
los siguientes símbolos: 
<dl compact="compact"><dd>
<p><b>|| &amp; &amp;&amp; ; ;; ( ) | &lt;nueva-línea&gt;</b></p>
</dd>
</dl></dd>
</dl><a id="lbAJ"> </a><h2>PALABRAS RESERVADAS</h2><i>Palabras reservadas</i><p> son palabras que tienen un significado
especial para el shell. Las siguientes palabras se reconocen como
reservadas cuando no van entrecomilladas y, o son la primera
palabra de una orden simple (vea <font size="-1"><b>GRAMÁTICA DEL
SHELL</b></font> más abajo) o la tercera palabra de una orden
<b>case</b> o <b>for</b>: 
</p><p><b>! case do done elif else esac fi for function if in select
then until while { } time [[ ]]</b> <a id="lbAK"> </a></p><h2>GRAMÁTICA DEL SHELL</h2><a id="lbAL"> </a><h3>Órdenes simples</h3><p>Una <i>orden simple</i> es una secuencia de asignaciones
opcionales de variables seguida por palabras separadas por
<b>blancos</b> y redirecciones, y terminadas por un <i>operador de
control</i>. La primera palabra especifica la orden a ser
ejecutada. Las palabras restantes se pasan como argumentos a la
orden pedida.</p><p>El valor devuelto de una <i>orden simple</i> es su estado de
salida, ó 128+<i>n</i> si la orden ha terminado debido a la señal
<i>n</i>. <a id="lbAM"> </a></p><h3>Tuberías</h3><p>Una <i>tubería</i> es una secuencia de una o más órdenes
separadas por el carácter <b>|</b>. El formato de una tubería
es:</p><dl compact="compact"><dd>
<p>[<b>time</b> [<b>-p</b>]] [ ! ] <i>orden</i> [ <b>|</b>
<i>orden2</i> ... ]</p>
</dd>
</dl><p>La salida estándar de <i>orden</i> se conecta a la entrada
estándar de <i>orden2</i>. Esta conexión se realiza antes que
cualquier redirección especificada por la orden (vea <font size="-1"><b>REDIRECCIÓN</b></font> más abajo).</p><p>Si la palabra reservada <b>!</b> precede una tubería, el estado
de salida de ésta es el NO lógico del de la última orden. De otro
modo, el estado de la tubería es el de salida de la última orden.
El shell espera que todas las órdenes de la tubería terminen antes
de devolver un valor.</p><p>Si la palabra reservada <b>time</b> precede una tubería, se
informa del tiempo transcurrido, así como del de usuario y sistema,
consumido en la ejecución de la tubería, cuando ésta termina. La
opción <b>-p</b> cambia el formato de salida al especificado por
POSIX. La variable <font size="-1"><b>TIMEFORMAT</b></font> puede
definirse como una cadena de caracteres de formato que especifique
cómo la información de tiempos debería mostrarse; vea la
descripción de <font size="-1"><b>TIMEFORMAT</b></font> bajo
<b>Variables del Shell</b> más abajo.</p><p>Cada orden en una tubería se ejecuta como un proceso separado
(esto es, en un subshell). <a id="lbAN"> </a></p><h3>Listas</h3><p>Una <i>lista</i> es una secuencia de una o más tuberías
separadas por uno de los operadores <b>;</b>, <b>&amp;</b>,
<b>&amp;&amp;</b>, o <b>||</b>, y terminada opcionalmente por uno
de <b>;</b>, <b>&amp;</b>, o <b>&lt;nueva-línea&gt;</b>.</p><p>De estos operadores de listas, <b>&amp;&amp;</b> y <b>||</b>
tienen igual precedencia, seguidos por <b>;</b> y <b>&amp;,</b> que
tienen igual precedencia.</p><p>Si una orden se termina mediante el operador de control
<b>&amp;</b>, el shell ejecuta la orden en <i>segundo plano</i> en
un subshell. El shell no espera que la orden acabe, y el estado
devuelto es 0. Las órdenes separadas por un <b>;</b> se ejecutan
secuencialmente; el shell espera que cada orden termine, por orden.
El estado devuelto es el estado de salida de la última orden
ejecutada.</p><p>Los operadores de control <b>&amp;&amp;</b> y <b>||</b> denotan
listas Y (AND) y O (OR) respectivamente. Una lista Y tiene la
forma</p><dl compact="compact"><dd>
<p><i>orden</i> <b>&amp;&amp;</b> <i>orden2</i></p>
</dd>
</dl><p><i>orden2</i> se ejecuta si y sólo si <i>orden</i> devuelve un
estado de salida 0.</p><p>Una lista O tiene la forma</p><dl compact="compact"><dd>
<p><i>orden</i> <b>||</b> <i>orden2</i></p>
</dd>
</dl><p><i>orden2</i> se ejecuta si y sólo si <i>orden</i> devuelve un
estado de salida distinto de cero. El estado de salida de las
listas Y y O es el de la última orden ejecutada en la lista. <a id="lbAO"> </a></p><h3>Órdenes compuestas</h3><p>Una <i>orden compuesta</i> es una de las siguientes:</p><dl compact="compact"><dt>(<i>lista</i>)</dt>

<dd><i>lista</i> se ejecuta en un subshell. Después de que la orden
se completa, las asignaciones a variables y órdenes internas que
afectaran al entorno del shell no permanecen en efecto. El estado
de retorno es el de salida de <i>lista</i>.</dd>

<dt>{ <i>lista</i>; }</dt>

<dd><i>lista</i> se ejecuta simplemente en el entorno del shell en
curso. <i>lista</i> debe terminarse con un salto de línea o un
punto y coma. Esto se conoce como una <i>orden de grupo</i>. El
estado de retorno es el de salida de <i>lista</i>.</dd>

<dt>((<i>expresión</i>))</dt>

<dd>La <i>expresión</i> se evalúa de acuerdo a las reglas descritas
abajo bajo la sección <font size="-1"><b>EVALUACIÓN</b>ARITMÉTICA<b>.</b></font> Si el valor de
la expresión es distinto de cero, el estado de retorno es 0; de
otro modo el estado de retorno es 1. Esto es equivalente
exactamente a <b>let "</b><i>expresión</i>".</dd>

<dt><b>[[</b> <i>expresión</i> <b>]]</b></dt>

<dd>Devuelve un estado de 0 ó 1 dependiendo de la evaluación de la
expresión condicional <i>expresión</i>. Las expresiones se componen
de las primarias descritas adelante bajo <font size="-1"><b>EXPRESIONES</b>CONDICIONALES<b>.</b></font> No tienen
lugar división de palabras ni expansión de nombres de camino en las
palabras entre el <b>[[</b> y el <b>]]</b>; sí se realizan la
expansión de tilde, expansión de parámetros y variables, expansión
aritmética, sustitución de orden, sustitución de proceso y
eliminación de comillas. 
<p>Cuando se emplean los operadores <b>==</b> y <b>!=</b>, la
cadena a la derecha del operador se considera un patrón y se hace
concordar de acuerdo a las reglas descritas más adelante bajo el
epígrafe <b>Concordancia de patrones</b>. El valor devuelto es 0 si
la cadena concuerda o no concuerda con el patrón, respectivamente,
y 1 en otro caso. Cualquier parte del patrón puede entrecomillarse
para forzar la concordancia como una cadena de caracteres pura.</p>

<p>Las expresiones pueden combinarse mediante los siguientes
operadores, listados en orden decreciente de precedencia:</p>

<dl compact="compact"><dd>
<dl compact="compact"><dt><b>(</b> <i>expresión</i> )</dt>

<dd>Devuelve el valor de <i>expresión</i>. Esto puede emplearse
para cambiar la precedencia normal de los operadores.</dd>

<dt><b>!</b> <i>expresión</i></dt>

<dd>Verdad si <i>expresión</i> es falsa.</dd>

<dt><i>expresión1</i> <b>&amp;&amp;</b> <i>expresión2</i></dt>

<dd>Verdad si ambas <i>expresión1</i> y <i>expresión2</i> son
verdaderas.</dd>

<dd><i>expresión1</i> <b>||</b> <i>expresión2</i> Verdad si una al
menos de <i>expresión1</i> o <i>expresión2</i> es verdad.</dd>
</dl></dd>
</dl></dd>
</dl><p>Los operadores <b>&amp;&amp;</b> y <b>||</b> no ejecutan
<i>expresión2</i> si el valor de <i>expresión1</i> es suficiente
para determinar el valor de retorno de la expresión condicional
entera.</p><dl compact="compact"><dt><b>for</b> <i>nombre</i> [ <b>in</b> <i>palabra</i>; ]
<b>do</b> <i>lista</i> ; <b>done</b></dt>

<dd>La lista de palabras que va detrás de <b>in</b> se expande,
generando una lista de elementos. La variable <i>nombre</i> se
define como cada elemento de la lista en cada iteración, y
<i>lista</i> se ejecuta cada vez. Si la <i>palabra</i> de <b>in</b>
se omite, la orden <b>for</b> ejecuta <i>lista</i> una vez para
cada parámetro posicional que esté definido (vea <font size="-1"><b>PARÁMETROS</b></font> más abajo). El estado de retorno
es el de salida de la última orden que se ejecuta. Si la expansión
de los elementos después del <b>in</b> resulta en una lista vacía,
no se ejecuta ninguna orden y el estado de salida es 0.</dd>

<dt><b>select</b> <i>nombre</i> [ <b>in</b> <i>palabra</i>; ]
<b>do</b> <i>lista</i> ; <b>done</b></dt>

<dd>La lista de palabras que sigue a <b>in</b> se expande,
generando una lista de elementos. El conjunto de palabras
expandidas se muestra en la salida estándar de errores, cada una
precedida por un número. Si la <i>palabra</i> del <b>in</b> se
omite, se muestran los parámetros posicionales (vea <font size="-1"><b>PARÁMETROS</b></font> más abajo). Entonces se muestra
el indicador <b>PS3</b> y se lee una línea desde la entrada
estándar. Si la línea consiste en un número correspondiente a una
de las palabras mostradas, entonces el valor de <i>nombre</i> se
pone a esa palabra. Si la línea está vacía, las palabras y el
indicador se muestran de nuevo. Si se lee EOF, la orden se
completa. Cualquier otro valor leída hace que <i>nombre</i> se
ponga a un valor vacío. La línea leída se guarda en la variable
<b>REPLY</b>. La <i>lista</i> se ejecuta tras cada selección hasta
que se ejecute una orden <b>break</b> o <b>return</b>. El estado de
salida de <b>select</b> es el de la última orden ejecutada en
<i>lista</i>, o cero si no se ha ejecutado ninguna orden.</dd>

<dt><b>case</b> <i>palabra</i> <b>in</b> [ ( <i>patrón</i> [
<b>|</b> <i>patrón</i> ]</dt>

<dd>Una orden <b>case</b> expande primero <i>palabra</i>, e intenta
hacerla concordar contra cada <i>patrón</i> por turnos, empleando
las mismas reglas de concordancia que para la expansión de nombres
de caminos (vea <b>Expansión de nombre de camino</b> más abajo).
Cuando se encuentre una concordancia, se ejecuta la <i>lista</i>
correspondiente. Tras la primera concordancia, no se intentan más.
El estado de salida es cero si no concuerda ningún patrón. De otro
modo, es el estado de salida de la última orden ejecutada en
<i>lista</i>.</dd>

<dt><b>if</b> <i>lista</i>; <b>then</b> <i>lista;</i> [ <b>elif</b>
<i>lista</i>; <b>then</b> <i>lista</i>; ] ... [ <b>else</b>
<i>lista</i>; ] <b>fi</b></dt>

<dd>La <i>lista</i> <b>if</b> se ejecuta. Si su estado de salida es
cero, se ejecuta la <i>lista</i> <b>then</b>. De otro modo, se
ejecuta por turno cada <i>lista</i> <b>elif</b>, y si su estado de
salida es cero, se ejecuta la <i>lista</i> <b>then</b>
correspondiente y la orden se completa. Si no, se ejecuta la
<i>lista</i> <b>then</b> si está presente. El estado de salida es
el de la última orden ejecutada, o cero si ninguna condición fue
verdadera.</dd>

<dd><b>while</b> <i>lista</i>; <b>do</b> <i>lista</i>;
<b>done</b></dd>

<dt><b>until</b> <i>lista</i>; <b>do</b> <i>lista</i>;
<b>done</b></dt>

<dd>La orden <b>while</b> ejecuta continuamente la <i>lista</i>
<b>do</b> siempre que la última orden de <i>lista</i> devuelva un
estado de salida cero. La orden <b>until</b> es idéntica a la
<b>while</b>, excepto en que la comprobación es al revés; la
<i>lista</i> <b>do</b> se ejecuta mientras que la última orden en
<i>lista</i> devuelva un estado de salida distinto de cero. El
estado de salida de las órdenes <b>while</b> y <b>until</b> es el
de la última orden de la <i>lista</i> <b>do</b> ejecutada, o cero
si no se ejecutó ninguna orden.</dd>

<dt>[ <b>function</b> ] <i>nombre</i> () { <i>lista</i>; }</dt>

<dd>Esto define una función llamada <i>nombre</i>. El <i>cuerpo</i>
de la función es la <i>lista</i> de órdenes entre { y } . Esta
lista se ejecuta cada vez que se especifica <i>nombre</i> como el
nombre de una orden simple. El estado de salida de una función es
el de la última orden ejecutada en el cuerpo. (Vea <font size="-1"><b>FUNCIONES</b></font> más abajo.)</dd>
</dl><a id="lbAP"> </a><h2>COMENTARIOS</h2><p>

En un shell no interactivo, o en uno interactivo en el que la
opción <b>interactive_comments</b> de la orden interna <b>shopt</b>
está activa (vea <font size="-1"><b>ÓRDENES INCORPORADAS DEL
SHELL</b></font> más abajo), una palabra que empiece por <b>#</b>
hace que esa palabra y todos los caracteres que queden en esa línea
no sean tenidos en cuenta. Un shell interactivo sin la opción
<b>interactive_comments</b> habilitada, no admite comentarios. La
opción <b>interactive_comments</b> está activa de forma
predeterminada en shells interactivos. <a id="lbAQ"> </a> 
</p><h2>ENTRECOMILLADO</h2><p>

El <i>entrecomillado</i> se emplea para quitar el significado
especial para el shell de ciertos metacaracteres o palabras. Puede
emplearse para que no se traten caracteres especiales de forma
especial, para que palabras reservadas no sean reconocidas como
tales, y para evitar la expansión de parámetros. 
</p><p>Cada uno de los <i>metacaracteres</i> listados a continuación
bajo el epígrafe <font size="-1"><b>DEFINICIONES</b></font> tiene
un significado especial para el shell y deben ser protegidos o
entrecomillados si quieren representarse a sí mismos. Hay 3
mecanismos de protección: el <i>carácter de escape</i>, comillas
simples, y comillas dobles.</p><p>Una barra inclinada inversa no entrecomillada (<b>\</b>) es el
<i>carácter de escape</i>. Preserva el valor literal del siguiente
carácter que lo acompaña, con la excepción de &lt;nueva-línea&gt;.
Si aparece un par <b>\</b>&lt;nueva-línea&gt; y la barra invertida
no está ella misma entre comillas, el <b>\</b>&lt;nueva-línea&gt;
se trata como una continuación de linea (esto es, se quita del
flujo de entrada y no se tiene efectivamente en cuenta).</p><p>Encerrar caracteres entre apóstrofos preserva el valor literal
de cada carácter entre las comillas. Una comilla simple no puede
estar entre comillas simples, ni siquiera precedida de una barra
invertida.</p><p>Encerrar caracteres entre comillas dobles preserva el valor
literal de todos los caracteres de dentro de las comillas, con la
excepción de <b>$</b>, <b>`</b>, y <b>\</b>. Los caracteres
<b>$</b> y <b>`</b> mantienen sus significados especiales dentro de
comillas dobles. La barra invertida mantiene su significado
especial solamente cuando está seguida por uno de los siguientes
caracteres: <b>$</b>, <b>`</b>, <b>"</b>", <b>\</b>, o
<b>&lt;nueva-línea&gt;</b>. Una comilla doble puede ser
entrecomillada entre otras comillas dobles precediéndola de una
barra invertida.</p><p>Los parámetros especiales <b>*</b> y <b>@</b> tienen un
significado especial cuando están entre comillas dobles (vea <font size="-1"><b>PARÁMETROS</b></font> más abajo).</p><p>Las palabras de la forma <b>$</b>'<i>cadena</i>' se tratan de
forma especial. La palabra se expanda a <i>cadena</i>, con los
caracteres protegidos par barra invertida reemplazados según
especifica el estándar ANSI/ISO de C. Las secuencias de escape con
barra invertida, si están presentes, se descodifican como
sigue:</p><dl compact="compact"><dd>
<dl compact="compact"><dt><b>\a</b></dt>

<dd>alerta (campana)</dd>

<dt><b>\b</b></dt>

<dd>espacio-atrás</dd>

<dt><b>\e</b></dt>

<dd>un carácter de escape (ESC)</dd>

<dt><b>\f</b></dt>

<dd>nueva página</dd>

<dt><b>\n</b></dt>

<dd>nueva linea</dd>

<dt><b>\r</b></dt>

<dd>retorno de carro</dd>

<dt><b>\t</b></dt>

<dd>tabulación horizontal</dd>

<dt><b>\v</b></dt>

<dd>tabulación vertical</dd>

<dt><b>\\</b></dt>

<dd>barra invertida</dd>

<dt><b>\</b><i>nnn</i></dt>

<dd>el carácter cuyo código es el valor octal <i>nnn</i> (de uno a
tres dígitos)</dd>

<dt><b>\x</b><i>nnn</i></dt>

<dd>el carácter cuyo código es el valor hexadecimal <i>nnn</i></dd>
</dl></dd>
</dl><p>El resultado traducido es entrecomillado con comillas simples,
como si el signo de dólar no hubiera estado presente.</p><p>Una cadena entre comillas dobles precedida por un signo de dólar
(<b>$</b>) hará que la cadena se traduzca según la localización en
curso. Si ésta es <b>C</b> o <b>POSIX</b>, el signo de dólar no se
tiene en cuenta. Si la cadena se traduce y reemplaza, el reemplazo
se entrecomilla con comillas dobles. <a id="lbAR"> </a></p><h2>PARÁMETROS</h2><p>

Un <i>parámetro</i> es una entidad que almacena valores. Puede ser
un <i>nombre</i>, un número, o uno de los caracteres especiales
listados a continuación bajo el epígrafe <b>Parámetros
especiales</b>. En lo que se refiere al shell, una <i>variable</i>
es un parámetro identificado por un <i>nombre</i>. 
</p><p>Un parámetro está definido si se le ha asignado un valor. La
cadena vacía es un valor válido. Una vez que una variable está
definida, sólo puede quitarse de la lista de variables mediante la
orden interna <b>unset</b> (vea <font size="-1"><b>ÓRDENES INTERNAS
DEL SHELL</b></font> más adelante).</p><p>A una <i>variable</i> se le puede asignar un valor mediante una
sentencia de la forma</p><dl compact="compact"><dd>
<p><i>nombre</i>=[<i>valor</i>]</p>
</dd>
</dl><p>Si no se da el <i>valor</i>, a la variable se asigna la cadena
vacía. Todos los <i>valores</i> están sujetos a expansión de tilde,
de parámetros y variables, de cadena, de orden, aritmética, y
eliminación de comillas (vea <font size="-1"><b>EXPANSIÓN</b></font> más abajo). Si la variable tiene
activado su atributo <b>integer</b> (vea <b>declare</b> más abajo
en <font size="-1"><b>ÓRDENES</b>INTERNAS<b>DEL</b>SHELL<b>)</b></font>
entonces <i>valor</i> está sujeto a expansión aritmética incluso si
no se emplea la expansión $((...)) (vea <b>Expansión aritmética</b>
más adelante). No se realiza la división de palabras, con la
excepción de <b>"$@"</b> como se explica más adelante bajo el
epígrafe <b>Parámetros especiales</b>. La expansión de nombres de
camino no se efectúa. <a id="lbAS"> </a></p><h3>Parámetros posicionales</h3><p>Un <i>parámetro posicional</i> es un parámetro denotado por uno
o más dígitos, distintos del simple 0. Los parámetros posicionales
se asignan a partir de los argumentos del shell cuando éste es
llamado, y pueden ser reasignados mediante la orden interna
<b>set</b>. Los parámetros posicionales no pueden ser asignados con
sentencias de asignación. Los parámetros posicionales se reemplazan
temporalmente cuando se ejecuta una función del shell (vea <font size="-1"><b>FUNCIONES</b></font> abajo).</p><p>Cuando un parámetro posicional consistente en más de un solo
dígito se expande, debe rodearse por llaves (vea <font size="-1"><b>EXPANSIÓN</b></font> abajo). <a id="lbAT"> </a></p><h3>Parámetros especiales</h3><p>El shell trata de forma especial a ciertos parámetros. Éstos
sólo pueden referenciarse; no se permite asignarles nada.</p><dl compact="compact"><dt><b>*</b></dt>

<dd>Se expande a los parámetros posicionales, empezando por 1.
Cuando la expansión ocurre entre comillas dobles, se expande a una
sola palabra con el valor de cada parámetro separado por el primer
carácter de la variable especial <font size="-1"><b>IFS</b>.</font>
Esto es, "<b>$*</b>" es equivalente a
"<b>$1</b><i>c</i><b>$2</b><i>c</i><b>...</b>", donde <i>c</i> es
el primer carácter del valor de la variable <font size="-1"><b>IFS</b>.</font> Si <font size="-1"><b>IFS</b></font>
no está definida, los parámetros se separan por espacios. Si <font size="-1"><b>IFS</b></font> es la cadena vacía, los parámetros se
juntan sin ningún separador.</dd>

<dt><b>@</b></dt>

<dd>Se expande a los parámetros posicionales, empezando desde 1.
Cuando la expansión ocurre dentro de comillas dobles, cada
parámetro se expande a una palabra separada. Esto es, "<b>$@</b>"
es equivalente a "<b>$1</b>" "<b>$2</b>" ... Cuando no hay
parámetros posicionales, "<b>$@</b>" y <b>$@</b> se expanden a nada
(esto es, se borran).</dd>

<dt><b>#</b></dt>

<dd>Se expande al número en base 10 de parámetros
posicionales.</dd>

<dt><b>?</b></dt>

<dd>Se expande al estado de la tubería más recientemente ejecutada
en primer plano.</dd>

<dt><b>-</b></dt>

<dd>Se expande a las opciones del shell activas actualmente según
se hayan especificado en la llamada, mediante la orden interna
<b>set</b>, o las que haya puesto el mismo shell (como la opción
<b>-i</b>).</dd>

<dt><b>$</b></dt>

<dd>Se expande al PID del shell. En un subshell (), se expande al
PID del shell actual, no al del subshell.</dd>

<dt><b>!</b></dt>

<dd>Se expande al PID de la orden más recientemente ejecutada en
segundo plano (asíncronamente).</dd>

<dt><b>0</b></dt>

<dd>Se expande al nombre del shell o guión del shell. Este
parámetro se pone en el inicio del shell. Si <b>bash</b> se llama
con un fichero de órdenes, <b>$0</b> se pone al nombre de ese
fichero. Si <b>bash</b> se arranca con la opción <b>-c</b>,
entonces <b>$0</b> se pone al primer argumento tras la cadena que
se va a ejecutar, si hay alguno presente. Si no, se pone al nombre
de fichero empleado para llamar a <b>bash</b>, como se da en el
argumento cero.</dd>

<dt><b>_</b></dt>

<dd>En el arranque del shell, se pone al nombre absoluto de fichero
del shell o guión del shell que se está ejecutando, tal como se ha
pasado en la lista de argumentos. Subsecuentemente, se expande al
último argumento de la orden anterior, tras la expansión. También
se pone al nombre completo del fichero de cada orden ejecutada, y
se pone en el entorno exportado a esa orden. Cuando se está
comprobando si hay correo nuevo, este parámetro contiene el nombre
del fichero de correo o buzón que se está comprobando
actualmente.</dd>
</dl><a id="lbAU"> </a><h3>Variables del shell</h3><p>El shell pone automáticamente las siguientes variables:</p><dl compact="compact"><dt><b>PPID</b></dt>

<dd>El PID del proceso padre del shell. Esta variable es de lectura
exclusiva.</dd>

<dt><b>PWD</b></dt>

<dd>El directorio de trabajo actual como lo pone la orden
<b>cd</b>.</dd>

<dt><b>OLDPWD</b></dt>

<dd>El directorio de trabajo anterior como lo puso la orden
<b>cd</b>.</dd>

<dt><b>REPLY</b></dt>

<dd>La línea de entrada leída por la orden interna <b>read</b>
cuando no se le dan argumentos.</dd>

<dt><b>UID</b></dt>

<dd>Se expande al UID del usuario en curso, puesta en el arranque
del shell. Esta variable es de lectura exclusiva.</dd>

<dt><b>EUID</b></dt>

<dd>Se expande al UID efectivo del usuario en curso, puesta en el
arranque del shell. Esta variable es de lectura exclusiva.</dd>

<dt><b>GROUPS</b></dt>

<dd>Una variable vector conteniendo la lista de grupos de los que
el usuario actual es miembro. Esta variable es de lectura
exclusiva.</dd>

<dt><b>BASH</b></dt>

<dd>Se expande al nombre completo del fichero empleado para llamar
a esta instancia de <b>bash</b>.</dd>

<dt><b>BASH_VERSION</b></dt>

<dd>Se expande a una cadena que describe la versión de esta
instancia de <b>bash</b>.</dd>

<dt><b>BASH_VERSINFO</b></dt>

<dd>Una variable vector de lectura exclusiva cuyos miembros
contienen información de versión para esta instancia de
<b>bash</b>. Los valores asignados a los miembros del vector son
como sigue: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>BASH_VERSINFO[</b>0]</dt>

<dd>El número mayor de versión (la <i>distribución</i>).</dd>

<dt><b>BASH_VERSINFO[</b>1]</dt>

<dd>El número menor de versión (la <i>versión</i>).</dd>

<dt><b>BASH_VERSINFO[</b>2]</dt>

<dd>El nivel de parcheo.</dd>

<dt><b>BASH_VERSINFO[</b>3]</dt>

<dd>La versión de construcción.</dd>

<dt><b>BASH_VERSINFO[</b>4]</dt>

<dd>El estado de la distribución (por ejemplo, <i>beta1</i>).</dd>

<dt><b>BASH_VERSINFO[</b>5]</dt>

<dd>El valor de <b>MACHTYPE</b>.</dd>
</dl></dd>
</dl></dd>

<dt><b>SHLVL</b></dt>

<dd>Se incrementa en uno cada vez que se arranca una nueva
instancia de <b>bash</b>.</dd>

<dt><b>RANDOM</b></dt>

<dd>Cada vez que este parámetro sea referenciado, se genera un
entero aleatorio entre 0 y 32767. La secuencia de números
aleatorios puede iniciarse asignando un valor a <font size="-1"><b>RANDOM</b>.</font> Si <font size="-1"><b>RANDOM</b></font> no está definido, pierde sus
propiedades especiales, incluso si posteriormente es
redefinido.</dd>

<dt><b>SECONDS</b></dt>

<dd>Cada vez que este parámetro es referenciado, se devuelve en él
el número de segundos transcurridos desde la llamada al shell. Si
se asigna un valor a <font size="-1"><b>SECONDS</b>,</font> el
valor devuelto en posteriores referencias es el número de segundos
desde la asignación más el valor asignado. Si <font size="-1"><b>SECONDS</b></font> no está definido, pierde sus
propiedades especiales, incluso si posteriormente es
redefinido.</dd>

<dt><b>LINENO</b></dt>

<dd>Cada vez que este parámetro es referenciado, el shell sustituye
un número en base 10 representando el número de línea secuencial
actual (empezando por 1) dentro de un guión o función. Si no
estamos en un guión o función, no se garantiza que el valor
sustituido tenga significado. Si <font size="-1"><b>LINENO</b></font> no está definido, pierde sus
propiedades especiales, incluso si posteriormente es
redefinido.</dd>

<dt><b>HISTCMD</b></dt>

<dd>El número de "historia", o índice en la lista "histórica", de
la orden actual. Si <font size="-1"><b>HISTCMD</b></font> no está
definido, pierde sus propiedades especiales, incluso si
posteriormente es redefinido.</dd>

<dt><b>DIRSTACK</b></dt>

<dd>Una variable vector (vea <b>Vectores</b> más abajo) que aloja
los contenidos actuales de la pila de directorios. Los directorios
aparecen en la pila en el orden en el que se muestran con la orden
interna <b>dirs</b>. La asignación a miembros de este vector puede
emplearse para modificar directorios que ya estén en la pila, pero
entonces deben utilizarse las órdenes internas <b>pushd</b> y
<b>popd</b> para añadir y quitar directorios. La asignación a esta
variable no cambiará el directorio de trabajo. Si <font size="-1"><b>DIRSTACK</b></font> no está definido, pierde sus
propiedades especiales, incluso si posteriormente es
redefinido.</dd>

<dt><b>PIPESTATUS</b></dt>

<dd>Una variable vector (vea <b>Vectores</b> más abajo) que
contiene una lista de valores de estado de salida de los procesos
en la tubería en primer plano ejecutada más recientemente (que
puede contener una sola orden).</dd>

<dt><b>OPTARG</b></dt>

<dd>El valor del último argumento que es una opción procesado por
la orden interna <b>getopts</b> (vea <font size="-1"><b>ÓRDENES
INTERNAS DEL SHELL</b></font> más abajo).</dd>

<dt><b>OPTIND</b></dt>

<dd>El índice del siguiente argumento a ser procesado por la orden
interna <b>getopts</b> (vea <font size="-1"><b>ÓRDENES INTERNAS DEL
SHELL</b></font> más abajo).</dd>

<dt><b>HOSTNAME</b></dt>

<dd>Puesto automáticamente al nombre del anfitrión (computador)
actual.</dd>

<dt><b>HOSTTYPE</b></dt>

<dd>Puesto automáticamente a una cadena que describe de forma
unívoca el tipo de máquina en la que <b>bash</b> se está
ejecutando. El valor predefinido depende del sistema.</dd>

<dt><b>OSTYPE</b></dt>

<dd>Puesto automáticamente a una cadena que describe el sistema
operativo en el que <b>bash</b> se está ejecutando. El valor
predefinido depende del sistema. En Linux es "linux".</dd>

<dt><b>MACHTYPE</b></dt>

<dd>Puesto automáticamente a una cadena que describe completamente
el tipo de sistema en el que <b>bash</b> se está ejecutando, en el
formato estándar de GNU <i>cpu-compañía-sistema</i>. El valor
predefinido depende del sistema.</dd>

<dt><b>SHELLOPTS</b></dt>

<dd>Una lista, de elementos separados por dos puntos, de opciones
activas del shell. Cada palabra en la lista es un argumento válido
para la opción <b>-o</b> de la orden interna <b>set</b> (vea <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> abajo). Las
opciones que aparecen en <font size="-1"><b>SHELLOPTS</b></font>
son aquéllas que aparecen como <i>on</i> en <b>set -o</b>. Si esta
variable está en el ambiente cuando <b>bash</b> empieza, cada
opción del shell en la lista se activará antes de leer cualquier
fichero de inicio. Esta variable es de lectura exclusiva.</dd>
</dl><p>El shell hace uso de las siguientes variables. En algunos casos,
<b>bash</b> asigna un valor predeterminado a una variable; estos
casos se dicen abajo.</p><dl compact="compact"><dt><b>IFS</b></dt>

<dd>El <i>Separador Interno de Campo</i> que se emplea para la
división de palabras tras la expansión y para dividir líneas en
palabras con la orden interna <b>read</b>. El valor predeterminado
es ``&lt;espacio&gt;&lt;tab&gt;&lt;nueva-línea&gt;''.</dd>

<dt><b>PATH</b></dt>

<dd>El camino de búsqueda para órdenes, programas ejecutables. Es
una lista de directorios separados por dos puntos en los cuales el
shell busca órdenes (vea <font size="-1"><b>EJECUCIÓN DE
ÓRDENES</b></font> más abajo). El camino predeterminado depende del
sistema, y lo pone el administrador que instala <b>bash</b>. Un
valor común es ``/usr/local/bin:/bin:/usr/bin:.''.</dd>

<dt><b>HOME</b></dt>

<dd>El directorio inicial de trabajo del usuario en curso; el
argumento predeterminado para la orden interna <b>cd</b>. El valor
de esta variable se usa también cuando se realiza la expansión de
tilde.</dd>

<dt><b>CDPATH</b></dt>

<dd>El camino de búsqueda para la orden <b>cd</b>. Es una lista de
directorios separados por dos puntos en los cuales el shell busca
directorios destino especificados por la orden <b>cd</b>. Un valor
de muestra es ``.:~:/usr''.</dd>

<dt><b>BASH_ENV</b></dt>

<dd>Si este parámetro está definido cuando <b>bash</b> está
ejecutando un guión del shell, su valor se interpreta como un
nombre de fichero que contiene órdenes para iniciar el shell, como
en <i>~/.bashrc</i>. El valor de <font size="-1"><b>BASH_ENV</b></font> está sujeto a expansión de
parámetros, sustitución de órdenes y expansión aritmética, antes de
ser interpretado como un nombre de fichero. <font size="-1"><b>PATH</b></font> no se usa para buscar el nombre de
fichero resultante.</dd>

<dt><b>MAIL</b></dt>

<dd>Si este parámetro está puesto a un nombre de fichero y la
variable <font size="-1"><b>MAILPATH</b></font> no está definida,
<b>bash</b> informa al usuario de la llegada de correo en el
fichero especificado.</dd>

<dt><b>MAILCHECK</b></dt>

<dd>Especifica cuán a menudo (en segundos) <b>bash</b> comprueba si
hay correo nuevo. El valor predeterminado es 60 s. Cuando es tiempo
de comprobar si hay correo, el shell lo hace antes de mostrar el
indicador primario. Si esta variable no está definida, el shell no
comprueba si hay correo nuevo.</dd>

<dt><b>MAILPATH</b></dt>

<dd>Una lista de nombres de fichero separados por dos puntos donde
hay que comprobar si hay correo nuevo. El mensaje que haya que
mostrar cuando llegue correo a un fichero particular puede
especificarse separando el nombre de fichero del mensaje con un
'?'. Cuando se use en el texto del mensaje, <b>$_</b> se expande al
nombre del fichero de correo en curso. Ejemplo: 
<dl compact="compact"><dd>
<p><b>MAILPATH</b>='/var/spool/mail/bfox?"Tienes
carta":~/shell-mail?"¡$_ tiene carta!"'</p>

<p><b>Bash</b> proporciona un valor predeterminado para esta
variable, pero la localización de los ficheros de correo del
usuario que emplea es dependiente del sistema (e.g.,
/var/spool/mail/<b>$USER</b>).</p>
</dd>
</dl></dd>

<dt><b>PS1</b></dt>

<dd>El valor de este parámetro se expande (vea <font size="-1"><b>INDICADORES</b></font> abajo) y se emplea como la
cadena del indicador primario. El valor predeterminado es
``<b>\s-\v\$</b> ''.</dd>

<dt><b>PS2</b></dt>

<dd>El valor de este parámetro se expande como con <b>PS1</b> y se
emplea como la cadena del indicador secundario. El valor
predeterminado es ``<b>&gt;</b> ''.</dd>

<dt><b>PS3</b></dt>

<dd>El valor de este parámetro se emplea como el indicador para la
orden <b>select</b> (vea <font size="-1"><b>GRAMÁTICA DEL
SHELL</b></font> más arriba).</dd>

<dt><b>PS4</b></dt>

<dd>El valor de este parámetro se expande como con <b>PS1</b> y el
valor se imprime antes de cada orden que <b>bash</b> muestra
durante una traza de ejecución. El primer carácter de <font size="-1"><b>PS4</b></font> se replica múltiples veces, tantas como
sean necesarias, para indicar múltiples niveles de indirección. El
valor predeterminado es ``<b>+</b> ''.</dd>

<dt><b>TIMEFORMAT</b></dt>

<dd>El valor de este parámetro se emplea como una cadena de formato
para especificar cómo debe mostrarse la información de tiempos para
tuberías precedidas por la palabra reservada <b>time</b>. El
carácter <b>%</b> introduce una secuencia de escape que se expande
a un valor de tiempo o a otra información. Las secuencias de escape
y sus significados son como sigue; los corchetes denotan partes
opcionales. 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>%%</b></dt>

<dd>Un <b>%</b> literal.</dd>

<dt><b>%[</b><i>p</i>][l]R</dt>

<dd>El tiempo total transcurrido en segundos.</dd>

<dt><b>%[</b><i>p</i>][l]U</dt>

<dd>El número de segundos de CPU gastados en modo usuario.</dd>

<dt><b>%[</b><i>p</i>][l]S</dt>

<dd>El número de segundos de CPU gastados en modo sistema.</dd>

<dt><b>%P</b></dt>

<dd>El porcentaje de CPU, computado como (%U + %S) ÷ %R.</dd>
</dl></dd>
</dl></dd>

<dd>La <i>p</i> opcional es un dígito que especifica la
<i>precisión</i>, el número de decimales. Un valor de 0 hace que no
se muestre ningún decimal, ni el punto o coma decimal. Como mucho
se pueden especificar tres decimales; valores de <i>p</i> mayores
de 3 se cambian a 3. Si <i>p</i> no se especifica, se usa
precisamente el valor 3.</dd>

<dd>La <i>l</i> opcional especifica un formato más largo,
incluyendo minutos, en la forma <i>MM</i>m<i>SS</i>.<i>FF</i>s. El
valor de <i>p</i> determina si se incluye o no la fracción.</dd>

<dd>Si esta variable no está definida, <b>bash</b> actúa como si
tuviera el valor <b>$'\nreal\t%3lR\nuser\t%3lU\nsys %3lS'</b>. Si
el valor es nulo, no se muestra ninguna información de tiempos. Se
añade un salto de línea al final cuando se muestra la cadena de
formato.</dd>

<dt><b>HISTSIZE</b></dt>

<dd>El número de órdenes a recordar en la historia de órdenes (vea
<font size="-1"><b>HISTORIA</b></font> abajo). El valor
predeterminado es 500.</dd>

<dt><b>HISTFILE</b></dt>

<dd>El nombre del fichero en el que se guarda la historia de
órdenes (vea <font size="-1"><b>HISTORIA</b></font> abajo). El
valor predeterminado es <i>~/.bash_history</i>. Si no está
definido, no se guarda la historia de órdenes cuando se acaba un
shell interactivo.</dd>

<dt><b>HISTFILESIZE</b></dt>

<dd>El número máximo de líneas contenidas en el fichero de
historia. Cuando se asigna un valor a esta variable, el fichero de
historia se trunca, si es menester, para contener no más de ese
número de líneas. El valor predeterminado es 500. El fichero de
historia se trunca también a este tamaño tras escribir en él cuando
un shell interactivo termina.</dd>

<dt><b>OPTERR</b></dt>

<dd>Si se pone al valor 1, <b>bash</b> muestra mensajes de error
generados por la orden interna <b>getopts</b> (vea <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> abajo). <font size="-1"><b>OPTERR</b></font> se inicia a 1 cada vez que se llama
al shell o cuando se ejecuta un guión del shell.</dd>

<dt><b>LANG</b></dt>

<dd>Empleado para determinar la categoría de localización
("escenario") para cualquier categoría no seleccionada
específicamente con una variable de las que empiezan por
<b>LC_</b>.</dd>

<dt><b>LC_ALL</b></dt>

<dd>Esta variable tiene preferencia sobre el valor de <b>LANG</b> y
de cualquier otra variable de las que empiecen por <b>LC_</b>
especificando una categoría de localización.</dd>

<dt><b>LC_COLLATE</b></dt>

<dd>Esta variable determina el orden de clasificación empleado
cuando se ordene el resultado de una expansión de nombres de
caminos, y determina el comportamiento de expresiones de rango,
clases de equivalencia, y secuencias de clasificación dentro de
expansiones de nombres de caminos y concordancia de patrones.</dd>

<dt><b>LC_CTYPE</b></dt>

<dd>Esta variable determina la interpretación de caracteres y el
comportamiento de clases de caracteres dentro de expansiones de
nombres de caminos y concordancia de patrones.</dd>

<dt><b>LC_MESSAGES</b></dt>

<dd>Esta variable determina la localización empleada para traducir
cadenas entrecomilladas con comillas dobles precedidas por un
<b>$</b>.</dd>

<dt><b>PROMPT_COMMAND</b></dt>

<dd>Si está definido, el valor se ejecuta como una orden antes de
mostrarse cada indicador primario.</dd>

<dt><b>IGNOREEOF</b></dt>

<dd>Controla la acción de un shell interactivo al recibir un
carácter <font size="-1"><b>EOF</b></font> como sola entrada. Si
está definido, el valor es el número de caracteres <font size="-1"><b>EOF</b></font> consecutivos que deben teclearse como
los primeros caracteres de una línea de entrada antes de que
<b>bash</b> acabe. Si la variable existe pero no tiene un valor
numérico, o ninguno, el valor predeterminado es 10. Si no existe,
<font size="-1"><b>EOF</b></font> significa el final de la entrada
para el shell.</dd>

<dt><b>TMOUT</b></dt>

<dd>Si se define a un valor mayor que cero, el valor se interpreta
como el número de segundos que hay que esperar una entrada después
de mostrarse el indicador primario. <b>Bash</b> termina después de
esperar ese número de segundos si no recibe ninguna entrada.</dd>

<dt><b>FCEDIT</b></dt>

<dd>El editor predeterminado para la orden interna <b>fc</b>.</dd>

<dt><b>FIGNORE</b></dt>

<dd>Una lista de sufijos separados por dos puntos que no hay que
tener en cuenta cuando se realice una terminación de nombres de
ficheros (vea <font size="-1"><b>READLINE</b></font> abajo). Un
nombre de fichero cuyo sufijo concuerde con una de las entradas en
<font size="-1"><b>FIGNORE</b></font> se excluye de la lista de
nombres de ficheros a completar. Un valor de muestra es
``.o:~''.</dd>

<dt><b>GLOBIGNORE</b></dt>

<dd>Una lista de patrones separados por dos puntos que definen en
conjunto de nombres de ficheros que no hay que tener en cuenta en
la expansión de nombres de caminos. Si un nombre de fichero que
concordaba en un patrón de expansión de nombres de caminos también
concuerda con uno de los patrones en <font size="-1"><b>GLOBIGNORE</b>,</font> se quita de la lista de
concordancias.</dd>

<dt><b>INPUTRC</b></dt>

<dd>El nombre de fichero para el de inicio de <b>readline</b>, en
vez del predeterminado <i>~/.inputrc</i> (vea <font size="-1"><b>READLINE</b></font> abajo).</dd>

<dt><b>HISTCONTROL</b></dt>

<dd>Si se define a un valor de <i>ignorespace</i>, las líneas que
comiencen con un carácter <b>espacio</b> no se meten en la lista de
historia. Si se pone a un valor de <i>ignoredups</i>, las líneas
que concuerden con la última línea de la historia, no se meten. Un
valor de <i>ignoreboth</i> combina las dos opciones. Si no está
definido, o si lo está a otro valor distinto de los de antes, todas
las líneas leídas por el analizador léxico se guardan en la lista
de la historia, sujeto esto al valor de <b>HISTIGNORE</b>. La
función de esta variable ha sido tomada por <b>HISTIGNORE</b>. La
segunda línea y siguientes de una orden compuesta multi-línea no se
comprueban, y se añaden a la historia sin importar el valor de
<b>HISTCONTROL</b>.</dd>

<dt><b>HISTIGNORE</b></dt>

<dd>Una lista de patrones separados por dos puntos empleados para
decidir qué líneas de órdenes deben guardarse en la lista de
historia. Cada patrón se ancla al principio de la línea y debe
especificar la línea completamente (no se añade ningún `<b>*</b>').
Cada patrón se comprueba con la línea tras aplicarse las
comprobaciones especificadas por <b>HISTCONTROL</b>. Además de los
caracteres normales de concordancia de patrones del shell,
`<b>&amp;</b>' concuerda con la línea de historia anterior.
`<b>&amp;</b>' puede protegerse empleando una barra inversa. Ésta
se quita antes de intentarse una concordancia. La segunda línea y
siguientes de una orden compuesta multi-línea no se comprueban, y
se añaden a la historia sin importar el valor de
<b>HISTIGNORE</b>.</dd>

<dt><b>histchars</b></dt>

<dd>Los dos o tres caracteres que controlan la expansión y
separación en lexemas de la historia (vea <font size="-1"><b>EXPANSIÓN DE HISTORIA</b></font> abajo). El primer
carácter es el <i>carácter de expansión de historia</i>, el
carácter que señala el comienzo de una expansión de historia,
normalmente `<b>!</b>'. El segundo carácter es el carácter de
<i>sustitución rápida</i>, que se usa como una abreviatura para
reejecutar la orden anterior, sustituyendo una cadena por otra en
la orden. El valor predeterminado es `<b>^</b>'. El tercer
carácter, opcional, es el carácter que indica que el resto de la
línea es un comentario cuando se encuentra como el primer carácter
de una palabra, normalmente es `<b>#</b>'. El carácter de
comentario de historia hace que la sustitución de historia se salte
en el resto de palabras de la línea. No hace que necesariamente el
analizador léxico del shell trate al resto de la línea como un a un
comentario.</dd>

<dt><b>HOSTFILE</b></dt>

<dd>Contiene el nombre de un fichero con el mismo formato que
<i>/etc/hosts</i> que debería leerse cuando el shell necesite
completar un nombre de anfitrión (computador). El fichero puede ser
cambiado interactivamente; la siguiente vez que se intente
completar un nombre de computador, <b>bash</b> añade el contenido
del nuevo fichero a la base de datos ya existente.</dd>

<dt><b>auto_resume</b></dt>

<dd>Esta variable controla cómo el shell interactúa con el usuario
para el control de trabajos. Si esta variable está definida, las
órdenes simples de una palabra sin redirección se tratan como
candidatas para reanudar un trabajo existente parado. No se permite
ninguna ambigüedad; si hay más de un trabajo que empiece con la
cadena tecleada, se selecciona el trabajo al que se ha accedido más
recientemente. El <i>nombre</i> de un trabajo parado, en este
contexto, es la línea de órdenes empleada para arrancarlo. Si se
define al valor <i>exact</i>, la cadena suministrada debe concordar
exactamente con el nombre de un trabajo parado; si se define como
<i>substring</i>, la cadena suministrada necesita concordar con una
subcadena del nombre de un trabajo parado. El valor
<i>substring</i> proporciona una funcionalidad análoga a la del
identificador de trabajo <b>%?</b> (vea <font size="-1"><b>CONTROL
DE TRABAJOS</b></font> adelante). Si se pone a cualquier otro
valor, la cadena suministrada debe ser un prefijo del nombre de un
trabajo parado; esto proporciona una funcionalidad análoga a la del
identificador de trabajo <b>%</b>.</dd>
</dl><a id="lbAV"> </a><h3>Vectores</h3><b>Bash</b><p> proporciona variables vectores, monodimensionales.
Cualquier variable puede usarse como un vector; la orden interna
<b>declare</b> declarará un vector explícitamente. No hay un límite
máximo en el tamaño de un vector, ni ningún requisito para que los
miembros se indexen o asignen de forma contigua. Los vectores se
indexan empleando enteros y su primer elemento es el de índice
cero, como en C. 
</p><p>Un vector se crea automáticamente si se asigna algo a una
variable con la sintaxis <i>nombre</i>[<i>índice</i>]=<i>valor</i>.
El <i>índice</i> se trata como una expresión aritmética que debe
evaluarse a un número mayor o igual a cero. Para declarar un vector
explícitamente, emplee <b>declare -a</b> <i>nombre</i> (vea <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> abajo). También
se acepta <b>declare -a</b> <i>nombre</i>[<i>índice</i>], donde el
<i>índice</i> no se tiene en cuenta. Se pueden especificar
atributos para una variable vector mediante las órdenes internas
<b>declare</b> y <b>readonly</b>. Cada atributo se aplica a cada
uno de los miembros del vector.</p><p>Se asignan valores a los vectores mediante asignaciones
compuestas de la forma <i>nombre</i>=<b>(</b>valor<i>1</i> ...
valor<i>n</i><b>)</b>, donde cada <i>valor</i> es de la forma
[<i>índice</i>]=<i>cadena</i>. Sólo <i>cadena</i> es necesario. Si
se suministra el índice entre corchetes y la asignación, se asigna
a ese índice; si no, el índice del elemento asignado es el último
índice al que la sentencia le asignó algo, más uno. Los índices
empiezan en cero. Esta sintaxis también la acepta la orden interna
<b>declare</b>. Se puede asignar a los elementos individuales del
vector empleando la sintaxis
<i>nombre</i>[<i>índice</i>]=<i>valor</i>, ya presentada antes.</p><p>Cualquier elemento de un vector puede referenciarse mediante
${<i>nombre</i>[<i>índice</i>]}. Las llaves son necesarias para
evitar conflictos con la expansión de nombres de caminos. Si
<i>índice</i> es <b>@</b> o <b>*</b>, la palabra se expande a todos
los miembros de <i>nombre</i>. Estos índices difieren solamente
cuando la palabra aparece entre comillas dobles. Si la palabra está
entre comillas dobles, ${<i>nombre</i>[*]} se expande a una sola
palabra con el valor de cada miembro del vector separados por el
primer carácter de la variable especial <font size="-1"><b>IFS</b>,</font> y ${<i>nombre</i>[@]} expande cada
elemento de <i>nombre</i> a una palabra separada. Cuando no hay
miembros del vector, ${<i>nombre</i>[@]} se expande a nada. Esto es
análogo a la expansión de los parámetros especiales <b>*</b> y
<b>@</b> (vea <b>Parámetros especiales</b> arriba).
${#<i>nombre</i>[<i>índice</i>]} se expande a la longitud de
${<i>nombre</i>[<i>índice</i>]}. Si <i>índice</i> es <b>*</b> o
<b>@</b>, la expansión es el número de elementos del vector.
Referenciar una variable vector sin índice es equivalente a
referenciar el elemento cero.</p><p>La orden interna <b>unset</b> se emplea para destruir vectores.
<b>unset</b> <b>nombre</b>[<i>índice</i>] destruye el elemento del
vector con el <i>índice</i> especificado. <b>unset</b>
<i>nombre</i>, donde <i>nombre</i> es un vector, o <b>unset</b>
<i>nombre</i>[<i>índice</i>], donde <i>índice</i> es <b>*</b> o
<b>@</b>, borra el vector entero.</p><p>Las órdenes internas <b>declare</b>, <b>local</b>, y
<b>readonly</b> aceptan cada una una opción <b>-a</b> para
especificar un vector (array). La orden interna <b>read</b> acepta
una <b>-a</b> para asignar una lista de palabras leídas desde la
entrada estándar a un vector. Las órdenes internas <b>set</b> y
<b>declare</b> muestran valores de un vector en una manera tal que
les permite ser reutilizadas como asignaciones. <a id="lbAW"> </a></p><h2>EXPANSIÓN</h2><p>

La expansión se realiza en la línea de órdenes una vez que la orden
ha sido dividida en palabras. Hay siete clases de expansión:
<i>expansión de llaves</i>, <i>expansión de tilde</i>, <i>expansión
de parámetro y variable</i>, <i>sustitución de orden</i>,
<i>expansión aritmética</i>, <i>división de palabras,</i>
<i>expansión de nombre de camino</i>. 
</p><p>La orden de las expansiones es: expansión de llaves, de tilde,
de parámetro, variable y aritmética, y sustitución de orden (hechas
de izquierda a derecha), división de palabras, y expansión de
nombre de camino.</p><p>En sistemas que puedan admitirla, hay una expansión adicional
disponible: <i>sustitución de proceso</i>.</p><p>Sólo la expansión de llaves, división de palabras, y expansión
de nombre de camino, pueden cambiar el número de palabras de la
expansión; las otras expanden una palabra simple a otra palabra
simple. Las únicas excepciones a esto son las expansiones de
"<b>$@</b>" y "<b>${</b><i>nombre</i><b>[@]}</b>" como se ha
explicado más arriba (vea <font size="-1"><b>PARÁMETROS</b>).</font> <a id="lbAX"> </a></p><h3>Expansión de llaves</h3><p>La <i>expansión de llaves</i> es un mecanismo por el cual pueden
generarse cadenas arbitrarias. Este mecanismo es similar a la
<i>expansión de nombre de camino</i>, pero los nombres de ficheros
no necesitan existir. Los patrones a ser expandidos con la
expansión de llaves toman la forma de un <i>preámbulo</i> opcional
seguido por una serie de cadenas separadas por comas entre un par
de llaves, seguido por un <i>post scriptum</i> opcional. El
preámbulo sirve de prefijo a cada cadena de entre las llaves, y el
post scriptum se añade luego a cada cadena resultante, expandiendo
de izquierda a derecha.</p><p>Las expansiones de llaves pueden anidarse. Los resultados de
cada cadena expandida no se ordenan; se preserva el orden de
izquierda a derecha. Por ejemplo, a<b>{</b>d,c,b<b>}</b>e se
expande a `ade ace abe'.</p><p>La expansión de llaves se realiza antes que cualquier otra, y
cualquier carácter especial para otras expansiones se preserva en
el resultado. Es estrictamente textual. <b>Bash</b> no aplica
ninguna interpretación sintáctica al contexto de la expansión ni al
texto entre las llaves.</p><p>Una expansión de llaves correctamente formada debe contener
llaves de apertura y cierre sin entrecomillar, y por lo menos una
coma sin entrecomillar. Cualquier expansión de llaves formada
incorrectamente se deja tal cual. Una <b>{</b> o <b>,</b> puede
protegerse con una barra invertida para evitar que sea considerada
como parte de una expansión de llaves.</p><p>Esta construcción se emplea normalmente como una abreviatura
cuando el prefijo común de las cadenas a generar es mayor que en el
ejemplo de antes:</p><dl compact="compact"><dd>
<p>mkdir /usr/local/src/bash/{old,new,dist,bugs}</p>
</dd>
</dl><p>

o 
</p><dl compact="compact"><dd>chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}</dd>
</dl><p>La expansión de llaves introduce una pequeña incompatibilidad
con versiones históricas de <b>sh</b>. <b>sh</b> no trata
especialmente a las llaves de apertura o cierre cuando aparecen
como parte de una palabra, y las deja en la entrada. <b>Bash</b>
quita las llaves de palabras, como una consecuencia de la expansión
de llaves. Por ejemplo, una palabra introducida a <b>sh</b> como
<i>fichero{1,2}</i> aparece así mismo en la entrada. La misma
palabra se muestra como <i>fichero1 fichero2</i> tras la expansión
hecha por <b>bash</b>. Si se desea una compatibilidad estricta con
<b>sh</b>, arranque <b>bash</b> con la opción <b>+B</b> o
inhabilite la expansión de llaves con la opción <b>+B</b> de la
orden interna <b>set</b> (vea <font size="-1"><b>ÓRDENES INTERNAS
DEL SHELL</b></font> abajo). <a id="lbAY"> </a></p><h3>Expansión de tilde</h3><p>Si una palabra comienza con un carácter tilde de la ñ sin
entrecomillar (`<b>~</b>'), todos los caracteres que precedan a la
primera barra inclinada sin entrecomillar (o todos los caracteres,
si no hay ninguna barra inclinada sin proteger), se consideran un
<i>prefijo-tilde</i>. Si ninguno de los caracteres en el
prefijo-tilde están protegidos, los caracteres en el prefijo-tilde
que siguen a la tilde se tratan como un posible <i>nombre de
entrada</i> de usuario (login). Si este nombre de entrada es la
cadena vacía, la tilde se reemplaza con el valor del parámetro del
shell <font size="-1"><b>HOME</b>.</font> Si <font size="-1"><b>HOME</b></font> no está definida, se sustituye en su
lugar el directorio de trabajo inicial del usuario que está
ejecutando el shell. De otra forma, el prefijo-tilde se reemplaza
con el directorio de trabajo inicial (de casa) asociado con el
nombre de entrada especificado.</p><p>Si el prefijo-tilde es un `~+', el valor de la variable del
shell <font size="-1"><b>PWD</b></font> reemplaza al prefijo-tilde.
Si el prefijo-tilde es un `~-', el valor de la variable del shell
<font size="-1"><b>OLDPWD</b>,</font> si está definido, se
sustituye. Si los caracteres que siguen a la tilde en el
prefijo-tilde consisten en un número <i>N</i>, prefijado
opcionalmente por un `+' o un `-', el prefijo-tilde se reemplaza
con el elemento correspondiente de la pila de directorios, como lo
mostraría la orden interna <b>dirs</b> llamada con el prefijo-tilde
como argumento. Si los caracteres tras la tilde en el prefijo-tilde
consisten en un número sin un `+' ni `-' iniciales, se supone
`+'.</p><p>Si el nombre de entrada es inválido, o si la expansión de tilde
falla, la palabra se deja tal cual.</p><p>A cada asignación de variable se comprueba si hay prefijos-tilde
sin entrecomillar inmediatamente tras un <b>:</b> o un <b>=</b>. En
estos casos, la expansión de tilde también tiene lugar.
Consecuentemente, uno puede usar nombres de ficheros con tildes en
asignaciones a <font size="-1"><b>PATH</b>,</font> <font size="-1"><b>MAILPATH</b>,</font> y <font size="-1"><b>CDPATH</b>,</font> y el shell asigna el valor
expandido. <a id="lbAZ"> </a></p><h3>Expansión de parámetro</h3><p>El carácter `<b>$</b>' introduce la expansión de parámetro,
sustitución de orden, o expansión aritmética. El nombre de
parámetro o símbolo a ser expandido puede estar encerrado entre
llaves, que son opcionales pero sirven para proteger a la variable
en la expansión de caracteres que la sigan y puedan interpretarse
como parte de su nombre.</p><p>Cuando se empleen llaves, la de cierre es la primera `<b>}</b>'
no protegida con una barra invertida o en una cadena
entrecomillada, y no dentro de una expansión aritmética empotrada,
sustitución de orden, o expansión de parámetro.</p><dl compact="compact"><dt>${<i>parámetro</i>}</dt>

<dd>Se sustituye el valor de <i>parámetro</i>. Se requieren llaves
cuando <i>parámetro</i> es un parámetro posicional de más de un
dígito, o cuando <i>parámetro</i> viene seguido por un carácter que
no debe interpretarse como parte de su nombre.</dd>
</dl><p>Si el primer carácter de <i>parámetro</i> es un signo de cierre
de exclamación, se introduce un nivel de indirección de variable.
<b>Bash</b> emplea el valor de la variable formada a partir del
resto de <i>parámetro</i> como el nombre de la variable; luego,
esta variable se expande y ese valor se emplea en el resto de la
sustitución, en vez del propio valor de <i>parámetro</i>. Esto se
conoce como <i>expansión indirecta</i>.</p><p>En cada uno de los casos anteriores, <i>palabra</i> está sujeta
a expansión de tilde, expansión de parámetro, sustitución de orden,
y expansión aritmética. Cuando no se realiza la expansión de
subcadena, <b>bash</b> comprueba si un parámetro está sin definir o
es nulo; si omitimos los dos puntos la comprobación sólo es para la
no definición del parámetro.</p><dl compact="compact"><dt>${<i>parámetro</i><b>:-</b><i>palabra</i>}</dt>

<dd><b>Emplear valores predeterminados</b>. Si <i>parámetro</i> no
está definido o está vacío, se sustituye la expansión de
<i>palabra</i>. De otro modo, se sustituye el valor de
<i>parámetro</i>.</dd>

<dt>${<i>parámetro</i><b>:=</b><i>palabra</i>}</dt>

<dd><b>Asignar valores predeterminados</b>. Si <i>parámetro</i> no
está definido o es nulo, la expansión de <i>palabra</i> se asigna a
<i>parámetro</i>. Luego, el valor de <i>parámetro</i> se sustituye.
No se puede asignar nada de esta manera a los parámetros
posicionales ni a los especiales.</dd>

<dt>${<i>parámetro</i><b>:?</b><i>palabra</i>}</dt>

<dd><b>Muestra un error si no está definido o está vacío</b>. Si
<i>parámetro</i> es nulo o no está definido, la expansión de
<i>palabra</i> (o un mensaje a tal efecto si <i>palabra</i> no está
presente) se escribe en la salida estándar de errores y el shell,
si no es interactivo, acaba. De otra manera, se sustituye el valor
de <i>parámetro</i>.</dd>

<dt>${<i>parámetro</i><b>:+</b><i>palabra</i>}</dt>

<dd><b>Emplear un valor alternativo</b>. Si <i>parámetro</i> está
vacío o no está definido, no se sustituye nada; de otro modo, se
sustituye la expansión de <i>palabra</i>.</dd>

<dd>${<i>parámetro</i><b>:</b><i>desplazamiento</i>}</dd>

<dt>
${<i>parámetro</i><b>:</b><i>desplazamiento</i><b>:</b><i>longitud</i>}</dt>

<dd><b>Expansión de subcadena.</b> Expande hasta <i>longitud</i>
caracteres de <i>parámetro</i>, empezando en los caracteres
especificados por <i>desplazamiento</i>. Si se omite la
<i>longitud</i>, se expande a la subcadena de <i>parámetro</i>,
empezando en el carácter especificado por <i>desplazamiento</i>.
<i>longitud</i> y <i>desplazamiento</i> son expresiones aritméticas
(vea <font size="-1"><b>EVALUACIÓN ARITMÉTICA</b></font> más
abajo). <i>longitud</i> debe evaluarse a un número mayor o igual a
cero. Si <i>desplazamiento</i> se evalúa a un número menor que
cero, el valor se emplea como un desplazamiento desde el final del
valor de <i>parámetro</i>. Si <i>parámetro</i> es <b>@</b>, el
resultado es <i>longitud</i> parámetros posicionales empezando en
<i>desplazamiento</i>. Si <i>parámetro</i> es un nombre de vector
indexado por @ o *, el resultado es <i>longitud</i> miembros del
vector empezando con ${<i>parámetro</i>[<i>desplazamiento</i>]}. La
indexación de la subcadena empieza por cero a menos que se empleen
los parámetros posicionales, en cuyo caso empieza por 1.</dd>

<dt>${<b>#</b><i>parámetro</i>}</dt>

<dd>Se sustituye la longitud en caracteres del valor de
<i>parámetro</i>. Si <i>parámetro</i> es <b>*</b> o <b>@</b>, el
valor sustituido es el número de parámetros posicionales. Si
<i>parámetro</i> es un nombre de vector indexado por <b>*</b> o
<b>@</b>, el valor sustituido es el número de elementos en el
vector.</dd>

<dd>${<i>parámetro</i><b>#</b><i>palabra</i>}</dd>

<dt>${<i>parámetro</i><b>##</b><i>palabra</i>}</dt>

<dd>La <i>palabra</i> se expande para producir un patrón lo mismo
que en una expansión de nombre de camino. Si el patrón concuerda
con el principio del valor de <i>parámetro</i>, entonces el
resultado de la expansión es el valor expandido de <i>parámetro</i>
con el patrón más corto que concuerde (el caso ``<b>#</b>) o con el
patrón más largo que concuerde (el caso ``<b>##</b>'') eliminado.
Si <i>parámetro</i> es <b>@</b> o <b>*</b>, la operación de borrado
del patrón se aplica a cada parámetro posicional por turnos, y la
expansión es la lista resultante. Si <i>parámetro</i> es una
variable vector indexada con <b>@</b> o <b>*</b>, la operación de
borrado del patrón se aplica a cada miembro del vector por orden, y
la expansión es la lista resultante.</dd>

<dd>${<i>parámetro</i><b>%</b><i>palabra</i>}</dd>

<dt>${<i>parámetro</i><b>%%</b><i>palabra</i>}</dt>

<dd>La <i>palabra</i> se expande para producir un patrón justo como
en la expansión de nombre de camino. Si el patrón concuerda con una
porción del final del valor expandido de <i>parámetro</i>, entonces
el resultado de la expansión es el valor expandido de
<i>parámetro</i> con el patrón más corto que concuerde (el caso
``<b>%</b>'') o el más largo (el caso ``<b>%%</b>'') borrado. Si
<i>parámetro</i> es <b>@</b> o <b>*</b>, la operación de borrado
del patrón se aplica a cada parámetro posicional por orden, y la
expansión es la lista resultante. Si <i>parámetro</i> es una
variable vector indexada por <b>@</b> o <b>*</b>, la operación de
borrado del patrón se aplica a cada miembro del vector por orden, y
la expansión es la lista resultante.</dd>

<dd>
${<i>parámetro</i><b>/</b><i>patrón</i><b>/</b><i>cadena</i>}</dd>

<dt>
${<i>parámetro</i><b>//</b><i>patrón</i><b>/</b><i>cadena</i>}</dt>

<dd>El <i>patrón</i> se expande para producir un patrón justo como
en la expansión de nombre de camino. <i>parámetro</i> se expande y
la concordancia más larga de <i>patrón</i> contra este valor se
reemplaza por <i>cadena</i>. En la primera forma, sólo se reemplaza
la primera concordancia. La segunda forma hace que todas las
concordancias de <i>patrón</i> se reemplacen con <i>cadena</i>. Si
<i>patrón</i> empieza por <b>#</b>, debe concordar con el principio
de la <i>cadena</i>. Si <i>patrón</i> empieza por <b>%</b>, debe
concordar con el final de la <i>cadena</i>. Si <i>cadena</i> está
vacía, las concordancias de <i>patrón</i> se borran y el <b>/</b>
que sigue al <i>patrón</i> puede omitirse. Si <i>parámetro</i> es
<b>@</b> o <b>*</b>, la operación de sustitución se aplica a cada
parámetro posicional por orden, y la expansión es la lista
resultante. Si <i>parámetro</i> es una variable vector indexada por
<b>@</b> o <b>*</b>, la operación de sustitución se aplica a cada
miembro del vector por orden, y la expansión es la lista
resultante.</dd>
</dl><a id="lbBA"> </a><h3>Sustitución de orden</h3><p><i>La sustitución de orden</i> permite a la salida de una orden
reemplazar al nombre de la orden. Hay dos formas:</p><dl compact="compact"><dd>
<p><b>$(</b><i>orden</i><b>)</b></p>
</dd>
</dl><p>

u 
</p><dl compact="compact"><dd><b>`</b><i>orden</i><b>`</b></dd>
</dl><p><b>Bash</b> realiza la expansión ejecutando <i>orden</i> y
reemplazando la sustitución de orden con la salida estándar de la
orden, quitando los saltos de línea finales. Los saltos de línea
empotrados no se borran, pero pueden ser eliminados durante la
división de palabras. La sustitución de orden <b>$(cat</b>
<i>fichero</i>) puede reemplazarse por lo equivalente pero más
rápido <b>$(&lt;</b> <i>fichero</i>).</p><p>Cuando se emplea la forma de sustitución al viejo estilo con las
comillas inversas, la barra invertida mantiene su significado
literal excepto cuando es seguida por <b>$</b>, <b>`</b>, o
<b>\</b>. La primera comilla inversa no precedida por una barra
invertida termina la sustitución de orden. Cuando se emplea la
forma $(<i>orden</i>), todos los caracteres entre los paréntesis
forman parte de la orden; ninguno se trata especialmente.</p><p>Las sustituciones de orden pueden anidarse. Para anidar cuando
se emplee la forma de comillas inversas, proteja las comillas
inversas internas con barras inversas.</p><p>Si la sustitución aparece dentro de las dobles comillas, la
división de palabras y la expansión de nombres no se realiza en los
resultados. <a id="lbBB"> </a></p><h3>Expansión aritmética</h3><p>La expansión aritmética permite la evaluación de una expresión
aritmética y la sustitución del resultado. El formato para la
expansión aritmética es:</p><dl compact="compact"><dd>
<p><b>$((</b><i>expresión</i><b>))</b></p>
</dd>
</dl><p>La <i>expresión</i> se trata como si estuviera entre comillas
dobles, pero un signo de doble comilla dentro de los paréntesis no
se trata especialmente. Todos los lexemas en la expresión están
sujetos a expansión de parámetro, expansión de cadena, sustitución
de orden, y eliminación de comillas. Las sustituciones aritméticas
pueden anidarse.</p><p>La evaluación se realiza de acuerdo a las reglas listadas más
abajo en <font size="-1"><b>EVALUACIÓN</b>ARITMÉTICA<b>.</b></font>
Si <i>expresión</i> no es válida, <b>bash</b> imprime un mensaje
indicando el fallo y no ocurre ninguna sustitución. <a id="lbBC"> </a></p><h3>Sustitución de proceso</h3><p>La <i>sustitución de proceso</i> se admite en sistemas que
acepten tuberías con nombre (<i>FIFOs</i>) o el método
<b>/dev/fd</b> de nombrar ficheros abiertos. Toma una de las formas
siguientes: <b>&lt;(</b><i>lista</i><b>)</b> o
<b>&gt;(</b><i>lista</i><b>)</b>. El proceso <i>lista</i> se
ejecuta con su entrada o salida conectada a un <i>FIFO</i> o a
algún fichero en <b>/dev/fd</b>. El nombre de este fichero se pasa
como argumento a la orden en curso como el resultado de la
expansión. Si se emplea la forma <b>&gt;(</b><i>lista</i><b>)</b>,
escribir en el fichero proporciona la entrada para <i>lista</i>. Si
se emplea la forma <b>&lt;(</b><i>lista</i><b>)</b>, el fichero
pasado como argumento deberá leerse para obtener la salida de
<i>lista</i>.</p><p>Cuando esté disponible, se realiza la <i>sustitución de
proceso</i> simultáneamente con la expansión de parámetro y
variable, sustitución de orden y expansión aritmética. <a id="lbBD"> </a></p><h3>División de palabras</h3><p>El shell examina los resultados de la expansión de parámetro,
sustitución de orden y expansión aritmética que no ocurrieron
dentro de comillas dobles para realizar la <i>división de
palabras</i>.</p><p>El shell trata cada carácter de <font size="-1"><b>IFS</b></font> como un delimitador, y divide los
resultados de las otras expansiones en palabras separadas por estos
caracteres. Si <font size="-1"><b>IFS</b></font> no está definido,
o su valor es exactamente
<b>&lt;espacio&gt;&lt;tab&gt;&lt;nueva-línea&gt;</b>, el valor
predeterminado, entonces cualquier secuencia de caracteres de <font size="-1"><b>IFS</b></font> sirve para delimitar palabras. Si <font size="-1"><b>IFS</b></font> tiene algún otro valor, entonces las
secuencias de los caracteres blancos <b>espacio</b> y
<b>tabulador</b> no se tienen en cuenta al principio y al final de
la palabra, siempre que el carácter de espacio en blanco esté en el
valor de <font size="-1"><b>IFS</b></font> (un carácter de espacio
en blanco de <font size="-1"><b>IFS</b>).</font> Cualquier carácter
en <font size="-1"><b>IFS</b></font> que no sea espacio en blanco
de <font size="-1"><b>IFS</b>,</font> junto con cualquier carácter
de espacio en blanco adyacente de <font size="-1"><b>IFS</b>,</font> delimita un campo. Una secuencia de
caracteres de espacio en blanco de <font size="-1"><b>IFS</b></font> también se trata como un delimitador.
Si el valor de <font size="-1"><b>IFS</b></font> es nulo, no se
realiza la división de palabras.</p><p>Los argumentos nulos explícitos (<b>""</b> o <b>''</b>) se
mantienen. Los argumentos nulos no protegidos implícitos,
resultantes de la expansión de <i>parámetros</i> que no tienen
valores, se eliminan. Si un parámetro sin ningún valor se expande
dentro de comillas dobles, el resultado es un argumento nulo, y es
mantenido.</p><p>Observe que si no hay expansión, tampoco se realiza la división
de palabras. <a id="lbBE"> </a></p><h3>Expansión de nombre de camino</h3><p>Tras la división de palabras, a menos que la opción <b>-f</b>
esté puesta, <b>bash</b> examina cada palabra buscando los
caracteres <b>*</b>, <b>?</b>, <b>(</b>, y <b>[</b>. Si uno de
estos caracteres aparece, entonces la palabra se considera como un
<i>patrón</i>, y se reemplaza por una lista ordenada
alfabéticamente de nombres de ficheros que concuerden con el
patrón. Si no se encuentran nombres de ficheros concordantes, y la
opción del shell <b>nullglob</b> está deshabilitada, la palabra se
deja tal cual. Si la opción <b>nullglob</b> está puesta, y no ha
habido ninguna concordancia, la palabra se elimina. Si la opción
del shell <b>nocaseglob</b> está puesta, la búsqueda de la
concordancia se realiza sin importar si los caracteres alfabéticos
son letras mayúsculas o minúsculas. Cuando un patrón se usa para
expansión de nombre de camino, el carácter <b>``.''</b> al
principio de un nombre o inmediatamente después de una barra
inclinada debe concordar explícitamente, a menos que esté puesta la
opción del shell <b>dotglob</b>. En la concordancia de un nombre de
camino, el carácter de barra inclinada debe siempre coincidir
explícitamente. En otros casos, el carácter <b>``.''</b> no se
trata de forma especial. Vea la descripción de <b>shopt</b> más
abajo en <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font>
para una descripción de las opciones del shell <b>nocaseglob</b>,
<b>nullglob</b>, y <b>dotglob</b>.</p><p>La variable del shell <font size="-1"><b>GLOBIGNORE</b></font>
puede utilizarse para restringir el conjunto de nombres de ficheros
que concuerden con un <i>patrón</i>. Si <font size="-1"><b>GLOBIGNORE</b></font> está definido, cada nombre de
fichero concordante que también coincida con uno de los patrones en
<font size="-1"><b>GLOBIGNORE</b></font> se quita de la lista de
concordancias. Los nombres de fichero <b>``.''</b> y <b>``..''</b>
nunca son tenidos en cuenta, incluso cuando <font size="-1"><b>GLOBIGNORE</b></font> esté puesto. Sin embargo,
definir <font size="-1"><b>GLOBIGNORE</b></font> tiene el efecto de
activar la opción del shell <b>dotglob</b>, de modo que todos los
otros nombres de fichero que comiencen con un <b>``.''</b>
concordarán. Para obtener el comportamiento antiguo de no hacer
caso de nombres de ficheros que comienzan con un <b>``.''</b>, haga
que <b>``.*''</b> sea uno de los patrones de <font size="-1"><b>GLOBIGNORE</b>.</font> La opción <b>dotglob</b> está
deshabilitada cuando <font size="-1"><b>GLOBIGNORE</b></font> no
está definido.</p><p><b>Patrones</b></p><p>Cualquier carácter que aparezca en un patrón, aparte de los
especiales descritos más adelante, concuerda consigo mismo. El
carácter NUL no puede estar en un patrón. Los caracteres de patrón
especiales deben protegerse si han de concordar literalmente
consigo mismos.</p><p>Los caracteres de patrón especiales tienen los siguientes
significados:</p><dl compact="compact"><dt><b>*</b></dt>

<dd>Concuerda con cualquier cadena de caracteres, incluida la
cadena vacía.</dd>

<dt><b>?</b></dt>

<dd>Concuerda con un solo carácter cualquiera.</dd>

<dt><b>[...]</b></dt>

<dd>Concuerda con uno de los caracteres entre corchetes. Un par de
caracteres separados por un signo menos denota un <i>rango</i>;
cualquier carácter léxicamente entre esos dos, incluidos,
concuerda. Si el primer carácter tras el <b>[</b> es un <b>!</b> o
un <b>^</b>, entonces la concordancia es con cualquier carácter de
los que no estén entre los corchetes. Un <b>-</b> puede
representarse para la concordancia incluyéndolo como el primer o
último carácter del conjunto. Un <b>]</b> puede hacerse concordar
incluyéndolo como el primer carácter del conjunto.<br /><p>Dentro de <b>[</b> y <b>]</b>, se pueden especificar <i>clases
de caracteres</i> mediante la sintaxis
<b>[:</b><i>clase</i><b>:]</b>, donde <i>clase</i> es una de las
siguientes clases definidas en el estándar POSIX.2:</p>
</dd>
</dl><dl compact="compact"><dd><b>alnum alpha ascii blank cntrl digit graph lower print punct
space upper xdigit</b><br />
 Una clase de caracteres concuerda con cualquier carácter que
pertenezca a esa clase.<br /><p>Dentro de <b>[</b> y <b>]</b>, una <i>clase de equivalencia</i>
se puede especificar empleando la sintaxis
<b>[=</b><i>c</i><b>=]</b>, que concuerda con todos los caracteres
con el mismo peso de clasificación (tal como lo defina la
localización en curso) que el carácter <i>c</i>.<br /></p>

<p>Dentro de <b>[</b> y <b>]</b>, la sintaxis
<b>[.</b><i>símbolo</i><b>.]</b> concuerda con el símbolo de
clasificación <i>símbolo</i>.</p>
</dd>
</dl><p>Si la opción del shell <b>extglob</b> se activa usando la orden
interna <b>shopt</b>, se reconocen algunos operadores de patrones
extendidos. En la siguiente descripción, una <i>lista-patrón</i> es
una lista de uno o más patrones separados por un <b>|</b>. Se
pueden formar patrones compuestos usando uno o más de los
siguientes sub-patrones:</p><dl compact="compact"><dd>
<dl compact="compact"><dt><b>?(</b><i>lista-patrón</i><b>)</b></dt>

<dd>Concuerda con ninguna o una ocurrencia de los patrones
dados</dd>

<dt><b>*(</b><i>lista-patrón</i><b>)</b></dt>

<dd>Concuerda con ninguna o más ocurrencias de los patrones
dados</dd>

<dt><b>+(</b><i>lista-patrón</i><b>)</b></dt>

<dd>Concuerda con una o más ocurrencias de los patrones dados</dd>

<dt><b>@(</b><i>lista-patrón</i><b>)</b></dt>

<dd>Concuerda exactamente con uno de los patrones dados</dd>

<dt><b>!(</b><i>lista-patrón</i><b>)</b></dt>

<dd>Concuerda con cualquier cosa excepto con uno de los patrones
dados</dd>
</dl></dd>
</dl><a id="lbBF"> </a><h3>Eliminación de comillas</h3><p>Tras las expansiones precedentes, todas las ocurrencias no
entrecomilladas de los caracteres <b>\</b>, <b>'</b>, y <b>"</b>
que no resulten de una de las expansiones anteriores, se eliminan.
<a id="lbBG"> </a></p><h2>REDIRECCIÓN</h2><p>

Antes de que se ejecute una orden, su entrada y salida pueden ser
<i>redirigidas</i> usando una notación especial interpretada por el
shell. La redirección también se puede emplear para abrir y cerrar
ficheros en el entorno de ejecución del shell en curso. Los
operadores de redirección siguientes pueden preceder o aparecer en
cualquier sitio de una <i>orden simple</i> o pueden ir detrás de
una <i>orden</i>. Las redirecciones se procesan en el orden en el
que aparecen, de izquierda a derecha. 
</p><p>En las descripciones siguientes, si se omite el número del
descriptor de fichero, y el primer carácter del operador de
redirección es <b>&lt;</b>, la redirección se refiere a la entrada
estándar (descriptor de fichero 0). Si el primer carácter del
operador de redirección es <b>&gt;</b>, la redirección se refiere a
la salida estándar (descriptor de fichero 1).</p><p>La palabra tras el operador de redirección en las descripciones
siguientes, a menos que se diga otra cosa, está sujeta a la
expansión de llaves, expansión de tilde, expansión de parámetro,
sustitución de orden, expansión aritmética, eliminación de
comillas, y expansión de nombre de camino. Si se expande a más de
una palabra, <b>bash</b> informa de un error.</p><p>Observe que el orden de las redirecciones es significativo. Por
ejemplo, la orden</p><dl compact="compact"><dd>
<p>ls <b>&gt;</b> listadir 2<b>&gt;&amp;</b>1</p>
</dd>
</dl><p>dirige la salida estándar normal y la de errores, ambas, al
fichero <i>listadir</i>, mientras que la orden</p><dl compact="compact"><dd>
<p>ls 2<b>&gt;&amp;</b>1 <b>&gt;</b> listadir</p>
</dd>
</dl><p>dirige solamente la salida estándar al fichero <i>listadir</i>,
porque la salida de errores estándar se ha duplicado como salida
estándar antes de que ésta se redirigiera a <i>listadir</i>.</p><p>Un fallo en la apertura o creación de un fichero hace que la
redirección fracase. <a id="lbBH"> </a></p><h3>Redirección de la entrada</h3><p>La redirección de la entrada hace que el fichero cuyo nombre
resulte de la expansión de <i>palabra</i> se abra para lectura en
el descriptor de fichero <i>n</i>, o la entrada estándar
(descriptor de fichero 0) si no se especificó <i>n</i>.</p><p>El formato general para la redirección de la entrada es:</p><dl compact="compact"><dd>
<p>[<i>n</i>]<b>&lt;</b><i>palabra</i></p>
</dd>
</dl><a id="lbBI"> </a><h3>Redirección de la salida</h3><p>la redirección de la salida hace que el fichero cuyo nombre
resulte de la expansión de <i>palabra</i> se abra para escritura en
el descriptor de fichero <i>n</i>, o la salida estándar (descriptor
de fichero 1) si <i>n</i> no se especificó. Si el fichero no existe
se crea; si existe se trunca a longitud cero, se vacía.</p><p>El formato general para la redirección de la salida es:</p><dl compact="compact"><dd>
<p>[<i>n</i>]<b>&gt;</b><i>palabra</i></p>
</dd>
</dl><p>Si el operador de redirección es <b>&gt;</b>, y la opción
<b>noclobber</b> de la orden interna <b>set</b> ha sido activada,
la redirección fallará si el nombre de fichero resultante de la
expansión de <i>palabra</i> existiera y fuera un fichero regular.
Si el operador de redirección es <b>&gt;|</b>, o es <b>&gt;</b> y
la opción <b>noclobber</b> de la orden interna <b>set</b> no está
activada, la redirección se intenta incluso si el fichero nombrado
por <i>palabra</i> existe. <a id="lbBJ"> </a></p><h3>Añadir a la salida redirigida</h3><p>La redirección de la salida en esta forma hace que el fichero
cuyo nombre resulte de la expansión de <i>palabra</i> se abra para
añadir en el descriptor de fichero <i>n</i>, o la salida estándar
(descriptor de fichero 1) si <i>n</i> no se especificó. Si el
fichero no existe, se crea.</p><p>El formato general para añadir a la salida es:</p><dl compact="compact"><dd>
<p>[<i>n</i>]<b>&gt;&gt;</b><i>palabra</i></p>
</dd>
</dl><p><a id="lbBK"> </a></p><h3>Redirección de la salida estándar normal y de errores</h3><p><b>Bash</b> permite que ambas salidas estándares, la normal
(descriptor de fichero 1) y la de errores (descriptor de fichero 2)
se redirijan hacia el fichero cuyo nombre sea la expansión de
<i>palabra</i> con esta construcción.</p><p>hay dos formatos para la redirección de la salida estándar y la
salida de errores:</p><dl compact="compact"><dd>
<p><b>&amp;&gt;</b><i>palabra</i></p>
</dd>
</dl><p>

y 
</p><dl compact="compact"><dd><b>&gt;&amp;</b><i>palabra</i></dd>
</dl><p>De las dos formas, es preferible la primera. Ésta es
semánticamente equivalente a</p><dl compact="compact"><dd>
<p><b>&gt;</b><i>palabra</i> 2<b>&gt;&amp;</b>1</p>
</dd>
</dl><a id="lbBL"> </a><h3>Documentos internos</h3><p>Este tipo de redirección instruye al shell a leer la entrada
desde la fuente en curso hasta que vea una línea que contenga
solamente <i>palabra</i> (sin blancos detrás). Todas las líneas
leídas hasta ese punto se emplean como la entrada estándar de una
orden.</p><p>El formato de los documentos internos es como sigue:</p><dl compact="compact"><dd>
<pre>
<b>&lt;&lt;</b>[<b>-</b>]<i>palabra</i>
                       <i>documento-interno</i>
<i>delimitador</i>
</pre>
</dd>
</dl><p>No se realiza la expansión de parámetro, sustitución de orden,
expansión de nombre de camino ni expansión aritmética en
<i>palabra</i>. Si cualquier carácter de <i>palabra</i> está
entrecomillado, el <i>delimitador</i> es el resultado de la
eliminación de comillas en <i>palabra</i>, y las líneas en el
documento interno no se expanden. Si <i>palabra</i> no está
entrecomillada, todas las líneas del documento interno están
sujetas a expansión de parámetro, sustitución de orden y expansión
aritmética. En el último caso, el par <b>\&lt;nueva-línea&gt;</b>
no se tiene en cuenta, y debe emplearse <b>\</b> para proteger los
caracteres <b>\</b>, <b>$</b>, y <b>`</b>.</p><p>Si el operador de redirección es <b>&lt;&lt;-</b>, entonces se
quitan de las líneas de la entrada todos los caracteres de
tabulación iniciales, así como de la línea que contiene
<i>delimitador</i>. Esto permite que los documentos internos dentro
de guiones del shell se sangren de manera natural. <a id="lbBM"> </a></p><h3>Duplicación de descriptores de fichero</h3><p>El operador de redirección</p><dl compact="compact"><dd>
<p>[<i>n</i>]<b>&lt;&amp;</b><i>palabra</i></p>
</dd>
</dl><p>se emplea para duplicar descriptores de ficheros de entrada. Si
<i>palabra</i> se expande a uno o más dígitos, el descriptor de
fichero denotado por <i>n</i> se hace ser una copia de este
descriptor de fichero. Si los dígitos en <i>palabra</i> no
especifican un descriptor de fichero abierto para entrada, se
produce un error de redirección. Si <i>palabra</i> se evalúa a
<b>-</b>, el descriptor de fichero <i>n</i> se cierra. Si <i>n</i>
no se especifica, se emplea la entrada estándar (descriptor de
fichero 0).</p><p>El operador</p><dl compact="compact"><dd>
<p>[<i>n</i>]<b>&gt;&amp;</b><i>palabra</i></p>
</dd>
</dl><p>se emplea similarmente para duplicar descriptores de ficheros de
salida. Si <i>n</i> no se especificó, se emplea la salida estándar
(descriptor de fichero 1). Si los dígitos en <i>palabra</i> no
especifican un descriptor de fichero abierto para salida, se
produce un error de redirección. Como un caso especial, si <i>n</i>
se omite, y <i>palabra</i> no se expande a uno o más dígitos, se
redirigen la salida estándar y la salida estándar de errores como
se describió con anterioridad. <a id="lbBN"> </a></p><h3>Apertura de descriptores de ficheros para lectura y
escritura</h3><p>El operador de redirección</p><dl compact="compact"><dd>
<p>[<i>n</i>]<b>&lt;&gt;</b><i>palabra</i></p>
</dd>
</dl><p>hace que el fichero cuyo nombres sea la expansión de
<i>palabra</i> se abra para lectura y para escritura en el
descriptor de fichero <i>n</i>, o en el descriptor de fichero 0 si
no se especifica <i>n</i>. Si el fichero no existe, se crea. <a id="lbBO"> </a></p><h2>ALIAS</h2><p>

Los alias permiten que una cadena se sustituya por una palabra
cuando se emplee como la primera palabra de una orden simple. El
shell mantiene una lista de <i>alias</i> que pueden ponerse y
quitarse con las órdenes internas <b>alias</b> y <b>unalias</b>
(vea <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font>
abajo). Se mira a ver si la primera palabra de cada orden, si no
está entrecomillada, tiene un alias. Si es así, cada palabra se
reemplaza con el texto del alias. El nombre del alias y el texto de
reemplazo pueden contener cualquier entrada válida para el shell,
incluyendo los <i>metacaracteres</i> listados arriba, con la
excepción de que el nombre del alias no puede contener un <i>=</i>.
La primera palabra del texto de reemplazo se comprueba si es un
alias, pero si es un alias idéntico al que se está expandiendo, no
se expande una segunda vez. Esto significa que uno puede poner un
alias <b>ls</b> a <b>ls -F</b>, por ejemplo, y <b>bash</b> no
intenta expandir recursivamente el texto de reemplazo. Si el último
carácter del valor del alias es un <i>blanco</i>, entonces la
siguiente palabra de la orden que sigue al alias también se mira
para la expansión de alias. 
</p><p>Los alias se crean y listan con la orden <b>alias</b>, y se
quitan con la orden <b>unalias</b>.</p><p>No hay ningún mecanismo para poder usar argumentos en el texto
de reemplazo. Si se necesitan, debería emplearse mejor una función
del shell.</p><p>Los alias no se expanden cuando el shell no es interactivo, a
menos que se haya puesto la opción <b>expand_aliases</b> mediante
<b>shopt</b> (vea la descripción de <b>shopt</b> bajo <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> abajo).</p><p>Las reglas que conciernen a la definición y uso de los alias son
algo confusas. <b>Bash</b> siempre lee por lo menos una línea
completa de entrada antes de ejecutar cualquiera de las órdenes de
esa línea. Los alias se expanden cuando se lee una orden, no cuando
se ejecuta. Por lo tanto, una definición de alias que aparezca en
la misma línea que otra orden no tiene efecto hasta que se lea la
siguiente línea de entrada. Las órdenes que sigan a la definición
de alias en esa línea no se ven afectadas por el nuevo alias. Este
comportamiento también hay que tenerlo en cuenta cuando se ejecutan
funciones. Los alias se expanden cuando se lee una definición de
función, no cuando la función se ejecuta, porque una definición de
función es en sí misma una orden compuesta. Como consecuencia, los
alias definidos en una función no están disponibles hasta después
de que esa función se ejecute. Para asegurarse, ponga siempre las
definiciones de alias en una línea separada, y no emplee la orden
<b>alias</b> en órdenes compuestas.</p><p>Para casi cualquier propósito, los alias pueden sustituirse por
funciones del shell. <a id="lbBP"> </a></p><h2>FUNCIONES</h2><p>

Una función del shell, definida como se describió anteriormente
bajo <font size="-1"><b>GRAMÁTICA</b>DEL<b>SHELL</b>,</font> guarda
una serie de órdenes para una ejecución posterior. Las funciones se
ejecutan en el contexto del shell en curso; no se crea ningún nuevo
proceso para interpretarlas (en contraste con la ejecución de un
guión del shell). Cuando una función se ejecuta, los argumentos de
la función se convierten en los parámetros posicionales durante su
ejecución. El parámetro especial <b>#</b> se actualiza para
reflejar el cambio. El parámetro posicional 0 permanece intacto.
Todos los demás aspectos del entorno de ejecución del shell son
idénticos entre una función y quien la llama con la excepción de
que la trampa <font size="-1"><b>DEBUG</b></font> (vea la
descripción de la orden interna <b>trap</b> bajo <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> más adelante) no
se hereda. 
</p><p>Variables locales a la función se pueden declarar con la orden
interna <b>local</b>. Normalmente, las variables y sus valores se
comparten entre la función y quien la llama, como variables
globales.</p><p>Si se ejecuta la orden interna <b>return</b> en una función,
éste se acaba y la ejecución se reanuda con la siguiente orden tras
la llamada a la función. Cuando una función se completa, los
valores de los parámetros posicionales y el parámetro especial
<b>#</b> se restauran a los valores que tenían antes de la
ejecución de la función.</p><p>Los nombres de función y sus definiciones pueden listarse con la
opción <b>-f</b> de las órdenes internas <b>declare</b> o
<b>typeset</b>. La opción <b>-F</b> de <b>declare</b> o
<b>typeset</b> listará solamente los nombres de las funciones. Las
funciones pueden exportarse de modo que los subshells las tengan
definidas automáticamente con la opción <b>-f</b> de la orden
interna <b>export</b>.</p><p>Las funciones pueden ser recursivas. No se impone ningún límite
en el número de llamadas recursivas. <a id="lbBQ"> </a></p><h2>EVALUACIÓN ARITMÉTICA</h2><p>

El shell permite que se evalúen expresiones aritméticas, bajo
ciertas circunstancias (vea la orden interna <b>let</b> y
<b>Expansión aritmética</b>). La evaluación se hace con enteros
largos sin comprobación de desbordamiento, aunque la división por 0
se atrapa y se señala como un error. La lista siguiente de
operadores se agrupa en niveles de operadores de igual precedencia.
Los niveles se listan en orden de precedencia decreciente. 
</p><dl compact="compact"><dt><b>- +</b></dt>

<dd>menos y más unarios</dd>

<dt><b>! ~</b></dt>

<dd>negación lógica y de bits</dd>

<dt><b>**</b></dt>

<dd>exponenciación</dd>

<dt><b>* / %</b></dt>

<dd>multiplicación, división, resto</dd>

<dt><b>+ -</b></dt>

<dd>adición, sustracción</dd>

<dt><b>&lt;&lt; &gt;&gt;</b></dt>

<dd>desplazamientos de bits a izquierda y derecha</dd>

<dt><b>&lt;= &gt;= &lt; &gt;</b></dt>

<dd>comparación</dd>

<dt><b>== !=</b></dt>

<dd>igualdad y desigualdad</dd>

<dt><b>&amp;</b></dt>

<dd>Y de bits (AND)</dd>

<dt><b>^</b></dt>

<dd>O exclusivo de bits (XOR)</dd>

<dt><b>|</b></dt>

<dd>O inclusivo de bits (OR)</dd>

<dt><b>&amp;&amp;</b></dt>

<dd>Y lógico (AND)</dd>

<dt><b>||</b></dt>

<dd>O lógico (OR)</dd>

<dt><i>expr</i>?<i>expr</i>:<i>expr</i></dt>

<dd>evaluación condicional</dd>

<dt><b>= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</b></dt>

<dd>asignación</dd>
</dl><p>Se permite que las variables del shell actúen como operandos; se
realiza la expansión de parámetro antes de la evaluación de la
expresión. El valor de un parámetro se fuerza a un entero largo
dentro de una expresión. Una variable del shell no necesita tener
activado su atributo de entero para emplearse en una expresión.</p><p>Las constantes con un 0 inicial se interpretan como números
octales. Un 0x ó 0X inicial denota un número en hexadecimal. De
otro modo, los números toman la forma [<i>base#</i>]n, donde
<i>base</i> es un número en base 10 entre 2 y 64 que representa la
base aritmética, y <i>n</i> es un número en esa base. Si
<i>base</i> se omite, entonces se emplea la base 10. Los dígitos
mayores que 9 se representan por las letras minúsculas, las metras
mayúsculas, _, y @, en este orden. Si <i>base</i> es menor o igual
que 36, las letras minúsculas y mayúsculas pueden emplearse
indistintamente para representar números entre 10 y 35.</p><p>Los operadores se evalúan en orden de precedencia. Las
sub-expresiones entre paréntesis se evalúan primero y pueden
sustituir a las reglas de precedencia anteriores. <a id="lbBR"> </a></p><h2>EXPRESIONES CONDICIONALES</h2><p>

Las expresiones condicionales son empleadas por la orden compuesta
<b>[[</b> y por las órdenes internas <b>test</b> y <b>[</b> para
comprobar los atributos de ficheros y realizar comparaciones de
cadenas y aritméticas. Las expresiones se forman a partir de las
primarias monarias o binarias siguientes. Si cualquier argumento
<i>fichero</i> de una de estas primarias es de la forma
/dev/fd/<i>n</i>, entonces se comprueba el descriptor de fichero
<i>n</i>. 
</p><dl compact="compact"><dt><b>-a</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe.</dd>

<dt><b>-b</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y es un fichero especial de
bloques.</dd>

<dt><b>-c</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y es un fichero especial de
caracteres.</dd>

<dt><b>-d</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y es un directorio.</dd>

<dt><b>-e</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe.</dd>

<dt><b>-f</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y es un fichero regular.</dd>

<dt><b>-g</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y tiene el bit SGID.</dd>

<dt><b>-k</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y tiene el bit ``pegajoso''
(STIcky).</dd>

<dt><b>-p</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y es una tubería con nombre
(FIFO).</dd>

<dt><b>-r</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y se puede leer.</dd>

<dt><b>-s</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y tiene un tamaño mayor que
cero.</dd>

<dt><b>-t</b> <i>fd</i></dt>

<dd>Verdad si el descriptor de fichero <i>fd</i> está abierto y se
refiere a una terminal.</dd>

<dt><b>-u</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y tiene el bit SUID.</dd>

<dt><b>-w</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y se puede modificar.</dd>

<dt><b>-x</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y es ejecutable.</dd>

<dt><b>-O</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y su propietario es el UID
efectivo.</dd>

<dt><b>-G</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y su grupo es el GID
efectivo.</dd>

<dt><b>-L</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y es un enlace simbólico o
blando.</dd>

<dt><b>-S</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y es un zócalo (socket).</dd>

<dt><b>-N</b> <i>fichero</i></dt>

<dd>Verdad si <i>fichero</i> existe y ha sido modificado desde que
se leyó la última vez.</dd>

<dt><i>fichero1</i> -<b>nt</b> <i>fichero2</i></dt>

<dd>Verdad si <i>fichero1</i> es más reciente (según la fecha de
modificación) que <i>fichero2</i>.</dd>

<dt><i>fichero1</i> -<b>ot</b> <i>fichero2</i></dt>

<dd>Verdad si <i>fichero1</i> es más antiguo que
<i>fichero2</i>.</dd>

<dt><i>fichero1</i> <b>-ef</b> <i>fichero2</i></dt>

<dd>Verdad si <i>fichero1</i> y <i>fichero2</i> tienen los mismos
números de nodo-í y de dispositivo.</dd>

<dt><b>-o</b> <i>nombre-opción</i></dt>

<dd>Verdad si la opción del shell <i>nombre-opción</i> está
activada. Vea la lista de opciones bajo la descripción de la opción
<b>-o</b> de la orden interna <b>set</b> más abajo.</dd>

<dt><b>-z</b> <i>cadena</i></dt>

<dd>Verdad si la longitud de <i>cadena</i> es cero.</dd>

<dt><b>-n</b> <i>cadena</i></dt>

<dt><i>cadena</i></dt>

<dd>Verdad si la longitud de <i>cadena</i> no es cero.</dd>

<dt><i>cadena1</i> <b>==</b> <i>cadena2</i></dt>

<dd>Verdad si las cadenas son iguales. También se puede emplear
<b>=</b> en vez de <b>==</b>.</dd>

<dt><i>cadena1</i> <b>!=</b> <i>cadena2</i></dt>

<dd>Verdad si las cadenas no son iguales.</dd>

<dt><i>cadena1</i> <b>&lt;</b> <i>cadena2</i></dt>

<dd>Verdad si <i>cadena1</i> se ordena lexicográficamente antes de
<i>cadena2</i> en la localización en curso.</dd>

<dt><i>cadena1</i> <b>&gt;</b> <i>cadena2</i></dt>

<dd>Verdad si <i>cadena1</i> se clasifica lexicográficamente tras
<i>cadena2</i> en la localización en curso.</dd>

<dt><i>arg1</i> <b>OP</b> <i>arg2</i></dt>

<dd><font size="-1"><b>OP</b></font> es uno de <b>-eq</b>,
<b>-ne</b>, <b>-lt</b>, <b>-le</b>, <b>-gt</b>, o <b>-ge</b>. Estos
operadores aritméticos binarios devuelven verdadero si <i>arg1</i>
es igual a, distinto de, menor que, menor o igual a, mayor que, o
mayor o igual a <i>arg2</i>, respectivamente. <i>Arg1</i> y
<i>arg2</i> pueden ser enteros positivos o negativos.</dd>
</dl><a id="lbBS"> </a><h2>EXPANSIÓN DE ORDEN SIMPLE</h2><p>

Cuando se ejecuta una orden simple, el shell realiza las siguientes
expansiones, asignaciones y redirecciones, de izquierda a derecha. 
</p><dl compact="compact"><dt>1.</dt>

<dd>Las palabras que el analizador ha marcado como asignaciones de
variables (aquéllas que preceden al nombre de la orden) y
redirecciones se guardan para un procesado posterior.</dd>

<dt>2.</dt>

<dd>Las palabras que no sean asignaciones de variables ni
redirecciones se expanden. Si tras la expansión quedan aún
palabras, la primera palabra se toma como el nombre de la orden y
las palabras restantes son los argumentos.</dd>

<dt>3.</dt>

<dd>Se ejecutan las redirecciones como se describió más arriba bajo
<font size="-1"><b>REDIRECCIÓN</b>.</font></dd>

<dt>4.</dt>

<dd>El texto tras el <b>=</b> en cada asignación de variable está
sujeto a expansión de tilde, expansión de parámetro, sustitución de
orden, expansión aritmética y eliminado de comillas antes de ser
asignado a la variable.</dd>
</dl><p>Si no resulta ningún nombre de orden, las asignaciones de
variables afectan al entorno actual del shell. De otro modo, las
variables se añaden al entorno de la orden ejecutada y no afectan
al entorno del shell en curso. Si cualquiera de las asignaciones
intenta dar un valor a una variable de lectura exclusiva, se
produce un error, y la orden acaba con un estado distinto de
cero.</p><p>Si no resulta ningún nombre de orden, se hacen las
redirecciones, pero no afectan al entorno del shell en curso. Un
error de redirección hace que el shell acabe con un estado distinto
de cero.</p><p>Si hay un nombre de orden tras la expansión, la ejecución
procede como se describió antes. De otro modo, la orden sale. Si
una de las expansiones contenía una sustitución de orden, el estado
de salida de la orden es el de la última sustitución de orden
realizada. Si no había sustituciones de órdenes, la orden acaba con
un estado de cero. <a id="lbBT"> </a></p><h2>EJECUCIÓN DE ÓRDENES</h2><p>

Después de que una orden ha sido dividida en palabras, si el
resultado es una orden simple y una lista opcional de argumentos,
tienen lugar las siguientes acciones. 
</p><p>Si el nombre de la orden no contiene barras inclinadas, el shell
intenta localizarla. Si existe una función del shell con ese
nombre, esa función se llama como se describió arriba en <font size="-1"><b>FUNCIONES</b>.</font> Si el nombre no coincide con el
de ninguna función, el shell lo busca en la lista de órdenes
internas. Si se encuentra, se llama a la orden interna
correspondiente.</p><p>Si el nombre no es ni una función del shell ni una orden
interna, y no contiene barras inclinadas, <b>bash</b> busca en cada
elemento de <font size="-1"><b>PATH</b></font> un directorio que
contenga un fichero ejecutable con ese nombre. <b>Bash</b> emplea
una tabla de dispersión (hash) para recordar los nombres de camino
completos de los ficheros ejecutables (vea <b>hash</b> en <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> abajo). Sólo se
realiza una búsqueda completa de los directorios de <font size="-1"><b>PATH</b></font> si la orden no se encuentra en la
tabla de dispersión. Si la búsqueda no es satisfactoria, el shell
muestra un mensaje de error y devuelve un estado de salida de
127.</p><p>Si la búsqueda fue exitosa, o si el nombre de la orden contiene
una o más barras inclinadas, el shell ejecuta el programa con ese
nombre en un entorno de ejecución separado. El argumento 0 se pone
al nombre dado, y el resto de argumentos de la orden se ponen a los
argumentos dados, si los hay.</p><p>Si esta ejecución fallara porque el fichero no tuviera un
formato ejecutable, y el fichero no fuera un directorio, se supone
que es un <i>guión del shell</i>, un fichero que contiene órdenes
del shell. Se crea un subshell para ejecutarlo. Este subshell se
reinicia a sí mismo, así que el efecto es el mismo que si se
hubiera llamado a un nuevo shell para manejar el guión, con la
excepción de que el hijo retiene las localizaciones de órdenes
recordadas por el padre (vea <b>hash</b> abajo en <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b>).</font></p><p>Si el programa es un fichero que empieza con los dos caracteres
<b>#!</b>, el resto de la primera línea especifica un intérprete
para el programa. El shell ejecuta el intérprete especificado en
sistemas operativos que no manejen por sí mismos este formato de
ejecutable. Los argumentos del intérprete consisten en un solo
argumento opcional tras el nombre del intérprete en la primera
linea del programa, seguido del nombre del programa, seguido por
los argumentos de la orden, si los hubiera. <a id="lbBU"> </a></p><h2>ENTORNO DE EJECUCIÓN DE ÓRDENES</h2><p>

El shell tiene un <i>entorno de ejecución</i>, que consiste en lo
siguiente: 
</p><dl compact="compact"><dt>*</dt>

<dd>ficheros abiertos heredados por el shell en la llamada, quizás
modificada por redirecciones suministradas a la orden interna
<b>exec</b></dd>

<dt>*</dt>

<dd>el directorio de trabajo en curso, establecido por <b>cd</b>,
<b>pushd</b> o <b>popd</b>, o heredado por el shell en la
llamada</dd>

<dt>*</dt>

<dd>la máscara de modo de creación de ficheros, establecida por
<b>umask</b> o heredada del padre del shell</dd>

<dt>*</dt>

<dd>las trampas en curso establecidas por <b>trap</b></dd>

<dt>*</dt>

<dd>parámetros del shell que han sido establecidos por asignaciones
de variables o con <b>set</b>, o heredados del padre del shell en
el entorno</dd>

<dt>*</dt>

<dd>funciones del shell definidas durante la ejecución o heredadas
del padre del shell en el entorno</dd>

<dt>*</dt>

<dd>opciones activadas en la llamada (bien por omisión o mediante
argumentos en la línea de órdenes) o por <b>set</b></dd>

<dt>*</dt>

<dd>opciones activadas mediante <b>shopt</b></dd>

<dt>*</dt>

<dd>alias del shell definidos con <b>alias</b></dd>

<dt>*</dt>

<dd>varios identificadores de proceso, incluyendo los de trabajos
en segundo plano, el valor de <b>$$</b>, y el valor de
<b>$PPID</b></dd>
</dl><p>Cuando una orden simple distinta de una interna o una función
del shell se va a ejecutar, se llama en un entorno de ejecución
separado que consiste en lo siguiente. A menos que se diga otra
cosa, los valores se heredan del shell.</p><dl compact="compact"><dt>*</dt>

<dd>los ficheros abiertos del shell, más las modificaciones y
adiciones especificadas en la orden por redirecciones</dd>

<dt>*</dt>

<dd>el directorio de trabajo en curso</dd>

<dt>*</dt>

<dd>la máscara de modo de creación de ficheros</dd>

<dt>*</dt>

<dd>variables del shell marcadas para la exportación, junto con
variables exportadas para la orden, pasadas en el entorno</dd>

<dt>*</dt>

<dd>las trampas capturadas por el shell se restauran a los valores
del padre del shell, y las trampas que no son tenidas en cuenta por
el shell tampoco lo son</dd>
</dl><p>Una orden llamada en este entorno separado no puede afectar al
entorno de ejecución del shell.</p><p>La sustitución de órdenes y las órdenes asíncronas se llaman en
un entorno de subshell que es un duplicado del entorno del shell,
excepto que las trampas capturadas por el shell se restauran a los
valores que el shell heredó de su padre en la llamada. Las órdenes
internas que se llaman como parte de una tubería se ejecutan
también en un entorno de subshell. Los cambios hechos al entorno
del subshell no pueden afectar al entorno de ejecución del shell.
<a id="lbBV"> </a></p><h2>ENTORNO</h2><p>

Cuando se llama a un programa, se le da un vector de cadenas de
caracteres llamado el <i>entorno</i>. Esto es una lista de parejas
<i>nombre</i>-<i>valor</i>, de la forma <i>nombre</i>=valor. 
</p><p>El shell le permite manipular el entorno de varias maneras. En
la hora de la llamada, el shell escudriña el entorno y crea un
parámetro para cada nombre encontrado, marcándolo automáticamente
para la <i>exportación</i> a procesos hijos. Las órdenes ejecutadas
heredan el entorno. Las órdenes <b>export</b> y <b>declare -x</b>
permiten añadir y quitar parámetros y funciones del entorno. Si el
valor de un parámetro en el entorno se modifica, el nuevo valor
pasa a formar parte del entorno, reemplazando al antiguo. El
entorno heredado por cualquier orden ejecutada consiste en el
entorno inicial del shell, cuyos valores pueden ser modificados en
el shell, menos las parejas quitadas mediante la orden <b>unset</b>
más las adiciones con las órdenes <b>export</b> y <b>declare
-x</b>.</p><p>El entorno para cualquier <i>orden simple</i> o función puede
aumentarse temporalmente prefijándola con asignaciones de
parámetros, como se describió arriba en <font size="-1"><b>PARÁMETROS</b>.</font> Estas sentencias de asignación
afectan solamente al entorno visto por esa orden.</p><p>Si la opción <b>-k</b> está puesta (vea la orden interna
<b>set</b> más adelante), entonces <i>todas</i> las asignaciones de
parámetros se ponen en el entorno para una orden, no sólo las que
preceden a su nombre.</p><p>Cuando <b>bash</b> llama a una orden externa, la variable
<b>_</b> se pone con el nombre completo del fichero de la orden y
se pasa a esa orden en su entorno. <a id="lbBW"> </a></p><h2>ESTADO DE SALIDA</h2><p>

Para los propósitos del shell, una orden que acabe con un estado de
salida cero, ha tenido éxito. Un estado de salida de cero indica
éxito. Un estado de salida distinto de cero indica fallo. Cuando
una orden termina por una señal fatal, <b>bash</b> emplea el valor
de 128+<b>señal</b> como el estado de salida. 
</p><p>Si una orden no se encuentra, el proceso hijo creado para
ejecutarla devuelve un estado de 127. Si una orden se encuentra
pero no es ejecutable, el estado de salida es 126.</p><p>Si una orden falla debido a un error durante la expansión o
redirección, el estado de salida es mayor que cero.</p><p>Las órdenes incorporadas en el shell devuelven un estado de 0
(<i>verdad</i>) si acaban con éxito, y distinto de cero
(<i>falso</i>) si ocurre un error mientras se ejecutan. Todas las
órdenes internas devuelven un estado de salida de 2 para indicar un
modo de empleo incorrecto.</p><p>El propio <b>bash</b> devuelve el estado de salida de la última
orden ejecutada, a menos que ocurra un error de sintaxis, en cuyo
caso acaba con un estado distinto de cero. Vea también la orden
interna <b>exit</b> abajo. <a id="lbBX"> </a></p><h2>SEÑALES</h2><p>

Cuando <b>bash</b> es interactivo, en la ausencia de trampas, no
hace caso de <font size="-1"><b>SIGTERM</b></font> (de modo que
<b>kill 0</b> no mata un shell interactivo), y se captura y maneja
<font size="-1"><b>SIGINT</b></font> (de manera que la orden
interna <b>wait</b> es interrumpible). En todos los casos,
<b>bash</b> no hace caso de <font size="-1"><b>SIGQUIT</b>.</font>
Si el control de trabajos tiene efecto, <b>bash</b> no hace caso de
<font size="-1"><b>SIGTTIN</b>,</font> <font size="-1"><b>SIGTTOU</b>,</font> y <font size="-1"><b>SIGTSTP</b>.</font> 
</p><p>Los trabajos síncronos empezados por <b>bash</b> tienen
manejadores de señal puestos a los valores heredados por el shell
de su padre. Cuando el control de trabajo no está en efecto, las
órdenes internas no hacen caso de <font size="-1"><b>SIGINT</b></font> ni <font size="-1"><b>SIGQUIT</b></font> tampoco. Las órdenes ejecutadas
como resultado de sustitución de orden no hacen caso de las señales
de control de trabajo generadas mediante el teclado <font size="-1"><b>SIGTTIN</b>,</font> <font size="-1"><b>SIGTTOU</b>,</font> ni <font size="-1"><b>SIGTSTP</b>.</font></p><p>El shell, de forma predeterminada, acaba cuando recibe una señal
<font size="-1"><b>SIGHUP</b>.</font> Antes de salir, reenvía la
señal <font size="-1"><b>SIGHUP</b></font> a todos los trabajos, en
ejecución o parados. A los trabajos parados se les envía <font size="-1"><b>SIGCONT</b></font> para asegurarse de que reciben la
señal <font size="-1"><b>SIGHUP</b>.</font> Para prevenir que el
shell envíe la señal a un trabajo particular, debería quitarse de
la lista de trabajos con la orden interna <b>disown</b> (vea <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> más abajo) o
marcarlo para no recibir <font size="-1"><b>SIGHUP</b></font>
empleando <b>disown -h</b>.</p><p>Si la opción del shell <b>huponexit</b> se ha puesto mediante
<b>shopt</b>, <b>bash</b> envía una señal <font size="-1"><b>SIGHUP</b></font> a todos los trabajos cuando un shell
de entrada interactivo se acaba.</p><p>Cuando <b>bash</b> recibe una señal para la que se ha puesto una
trampa mientras se se está esperando que una orden se complete, la
trampa no se ejecutará hasta que la orden se complete. Cuando
<b>bash</b> está esperando una orden asíncrona mediante la orden
interna <b>wait</b>, la recepción de una señal para la que se ha
definido una trampa, hará que la orden interna <b>wait</b> regrese
inmediatamente con un estado de salida mayor que 128,
inmediatamente tras que se ejecute la trampa. <a id="lbBY"> </a></p><h2>CONTROL DE TRABAJOS</h2><p>

El <i>control de trabajos</i> se refiere a la capacidad de parar
selectivamente (<i>suspender</i>) la ejecución de procesos y
continuar (<i>reanudar</i>) su ejecución posteriormente. Un usuario
emplea esta facilidad típicamente a través de una interfaz
interactiva suministrada conjuntamente por el controlador de
terminal del sistema y <b>bash</b>. 
</p><p>El shell asocia un <i>trabajo</i> con cada tubería. Mantiene una
tabla de trabajos ejecutándose actualmente, que pueden listarse con
la orden <b>jobs</b>. Cuando <b>bash</b> arranca un trabajo
asíncronamente (en <i>segundo plano</i>), imprime una línea con un
aspecto como ésta:</p><dl compact="compact"><dd>
<p>[1] 25647</p>
</dd>
</dl><p>indicando que este trabajo es el número 1 y que el PID del
último proceso en la tubería asociada con él es 25647. Todos los
procesos en una misma tubería son miembros del mismo trabajo.
<b>Bash</b> emplea la abstracción del <i>trabajo</i> como la base
para el control de trabajos.</p><p>Para facilitar la implementación de la interfaz del usuario al
control de trabajos, el sistema mantiene la noción de un
<i>identificador (ID) de grupo de procesos de la terminal en
curso.</i> Los miembros de este grupo de procesos (procesos cuyo
PGID es igual al PGID de la terminal en curso) reciben señales
generadas por el teclado como <font size="-1"><b>SIGINT</b>.</font>
Se dice que estos procesos están en <i>primer plano</i>. Los
procesos en <i>segundo plano</i> son aquéllos cuyo PGID difiere del
de la terminal; tales procesos son inmunes a señales generadas
desde el teclado. Sólo los procesos en primer plano tienen
permitido leer o escribir en la terminal. A los procesos en segundo
plano que intenten leer de (o escribir en) la terminal, el
controlador de terminal les manda una señal <font size="-1"><b>SIGTTIN (SIGTTOU)</b></font> que, a menos que sea
capturada, suspende el proceso.</p><p>Si el sistema operativo en el que <b>bash</b> se está
ejecutando, admite el control de trabajos (Linux lo admite, por
supuesto), <b>bash</b> le permite usarlo. Teclear el carácter
<i>suspender</i> (típicamente <b>^Z</b>, Control-Z) mientras que un
proceso se está ejecutando, hace que ese proceso se pare y le
devuelve a Ud. al <b>bash</b>. Teclear el carácter <i>suspensión
diferida</i> (típicamente <b>^Y</b>, Control-Y) hace que el proceso
se pare cuando intente leer entrada desde la terminal, y el control
se devuelve a <b>bash</b>. El usuario puede entonces manipular el
estado de este trabajo, empleando la orden <b>bg</b> para continuar
con él en segundo plano, la orden <b>fg</b> para continuar con él
en primer plano, o la orden <b>kill</b> para matarlo. Un <b>^Z</b>
tiene efecto inmediatamente, y tiene el efecto adicional colateral
de que la salida pendiente y lo que haya en el búfer de entrada del
teclado se descartan.</p><p>Hay varias formas de referirse a un trabajo en el shell. El
carácter <b>%</b> introduce un nombre de trabajo. El trabajo número
<i>n</i> puede ser referenciado como <b>%n</b>. Un trabajo puede
ser referenciado utilizando un prefijo del nombre empleado para
arrancarlo, o usando una subcadena que aparezca en su línea de
órdenes. Por ejemplo. <b>%ce</b> se refiere a un trabajo <b>ce</b>
parado. Si un prefijo concuerda con más de un trabajo, <b>bash</b>
informa de un error. Usar <b>%?ce</b>, por otra parte, se refiere a
cualquier trabajo que contenga la cadena <b>ce</b> en su línea de
órdenes. Si la subcadena concuerda con más de un trabajo,
<b>bash</b> informa de un error. Los símbolos <b>%%</b> y <b>%+</b>
se refieren a la noción que tiene el shell del <i>trabajo en
curso</i>, que es el último trabajo parado mientras estaba en
primer plano o se arrancó en segundo plano. El <i>trabajo
anterior</i> puede referenciarse usando <b>%-</b>. En la salida
relativa a trabajos (e.g., la salida de la orden <b>jobs</b>), el
trabajo actual se marca siempre con un <b>+</b>, y el anterior con
un <b>-</b>.</p><p>Si simplemente damos el nombre de un trabajo, esto puede traerlo
a primer plano: <b>%1</b> es un sinónimo de <b>``fg %1''</b>, que
trae el trabajo número 1 desde el segundo plano al primero.
Similarmente, <b>``%1 &amp;''</b> reanuda el trabajo 1 en el
segundo plano, equivalente a <b>``bg %1''</b>.</p><p>El shell se entera inmediatamente de cuando un trabajo cambia de
estado. Normalmente, <b>bash</b> espera hasta que está a punto de
mostrar un indicador antes de informar de cambios en el estado de
un trabajo, para no interrumpir cualquier otra salida. Si la opción
<b>-b</b> de la orden interna <b>set</b> está activada, <b>bash</b>
informa de tales cambios inmediatamente.</p><p>Si se intenta salir de <b>bash</b> mientras hay trabajos
parados, el shell muestra un mensaje de aviso. La orden <b>jobs</b>
se puede usar entonces para inspeccionar sus estados. Si se hace un
segundo intento de salir sin ninguna otra orden intermedia, el
shell no muestra ningún otro aviso, y los trabajos parados se hacen
terminar. <a id="lbBZ"> </a></p><h2>INDICADORES</h2><p>

Cuando se ejecuta interactivamente, <b>bash</b> muestra el
indicador primario <font size="-1"><b>PS1</b></font> cuando está
dispuesto para leer una orden, y el secundario <font size="-1"><b>PS2</b></font> cuando necesita más entrada para
completar una orden. <b>Bash</b> permite que estas cadenas
indicadoras se personalicen insertando un número de caracteres
especiales protegidos con la barra inversa, que se interpretan como
sigue: 
</p><dl compact="compact"><dd>
<dl compact="compact"><dt><b>\a</b></dt>

<dd>un carácter de alerta ASCII (07)</dd>

<dt><b>\d</b></dt>

<dd>la fecha en el formato "Día-Semana Mes Día" (ejemplo, "Tue May
26") en inglés</dd>

<dt><b>\e</b></dt>

<dd>un carácter de escape (ESC) ASCII (033)</dd>

<dt><b>\h</b></dt>

<dd>el nombre del computador anfitrión hasta el primer `.'</dd>

<dt><b>\H</b></dt>

<dd>el nombre del computador anfitrión completo</dd>

<dt><b>\n</b></dt>

<dd>salto de línea</dd>

<dt><b>\r</b></dt>

<dd>retorno de carro</dd>

<dt><b>\s</b></dt>

<dd>el nombre del shell, el nombre base de <b>$0</b> (la porción
que sigue a la última barra inclinada)</dd>

<dt><b>\t</b></dt>

<dd>la hora actual en el formato de 24 horas HH:MM:SS</dd>

<dt><b>\T</b></dt>

<dd>la hora actual en el formato de<tt>        </tt>12 horas
HH:MM:SS<br /></dd>

<dt><b>\@</b></dt>

<dd>la hora actual en el formato de 12 horas con indicador
AM/PM</dd>

<dt><b>\u</b></dt>

<dd>el nombre de usuario del usuario en curso</dd>

<dt><b>\v</b></dt>

<dd>la versión de <b>bash</b> (e.g., 2.00)</dd>

<dt><b>\V</b></dt>

<dd>la distribución de <b>bash</b>, versión + nivel de parcheo
(e.g., 2.00.0)</dd>

<dt><b>\w</b></dt>

<dd>el directorio de trabajo en curso</dd>

<dt><b>\W</b></dt>

<dd>el nombre base del directorio de trabajo</dd>

<dt><b>\!</b></dt>

<dd>el número de historia de esta orden</dd>

<dt><b>\#</b></dt>

<dd>el número de orden de esta orden</dd>

<dt><b>\$</b></dt>

<dd>si el UID efectivo es 0 (el super-usuario), un <b>#</b>, si no
un <b>$</b></dd>

<dt><b>\</b><i>nnn</i></dt>

<dd>el carácter correspondiente al número octal <i>nnn</i></dd>

<dt><b>\\</b></dt>

<dd>una barra inclinada invertida</dd>

<dt><b>\[</b></dt>

<dd>empieza una secuencia de caracteres no imprimibles, que pueden
emplearse para empotrar una secuencia de control del terminal en el
indicador</dd>

<dt><b>\]</b></dt>

<dd>termina una secuencia de caracteres no imprimibles</dd>
</dl></dd>
</dl><p>El número de orden y el número de historia son usualmente
diferentes: el número de historia de una orden es su posición en la
lista de historia, que puede incluir órdenes restauradas desde el
fichero de historia (vea <font size="-1"><b>HISTORIA</b></font> más
abajo), mientras que el número de orden es la posición en la
secuencia de órdenes ejecutadas durante la sesión de shell actual.
Después de que la cadena es descodificada, se expande mediante la
expansión de parámetros, sustitución de órdenes, expansión
aritmética, expansión de cadena, y eliminación de comillas, sujeta
al valor de la opción del shell <b>promptvars</b> (vea la
descripción de la orden <b>shopt</b> bajo <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> más adelante).
<a id="lbCA"> </a></p><h2>READLINE</h2><i>Readline</i><p> (leer línea) es la biblioteca que maneja la lectura
de la entrada cuando se usa un shell interactivo, a menos que se
haya dado la opción <b>--noediting</b> cuando se llamó. De forma
predeterminada, las órdenes de edición de la línea son similares a
las de emacs. También se dispone de una interfaz de edición de
líneas al estilo de vi. Para desactivar la edición de líneas una
vez que el shell está en ejecución, use las opciones <b>+o
emacs</b> o <b>+o vi</b> de la orden interna <b>set</b> (vea <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> abajo). <a id="lbCB"> </a> 
</p><h3>Notación de Readline</h3><p>En esta sección, se emplea la notación al estilo de emacs para
denotar las teclas. Las teclas de control se representan por medio
de C-<i>tecla</i>; así, C-n significa Control-N. De forma similar,
las teclas <i>meta</i> (Alt) se representan con M-<i>tecla</i>, de
forma que M-x significa Meta-X. (En teclados sin tecla <i>meta</i>,
M-<i>x</i> significa ESC <i>x</i>, i.e., pulsar la tecla de escape
(Esc) y luego la tecla <i>x</i>. Esto hace que ESC sea el
<i>prefijo meta</i>. La combinación M-C-<i>x</i> quiere decir
ESC-Control-<i>x</i>, o pulsar la tecla Escape y luego mantener
presionada la tecla Control mientras se pulsa la tecla
<i>x</i>.)</p><p>Las órdenes de readline pueden recibir <i>argumentos</i>
numéricos que actúan normalmente como un número de repetición.
Algunas veces, empero, lo que tiene significado es el signo del
argumento. Pasar un argumento negativo a una orden que actúa en la
dirección adelante (p. ej., <b>kill-line</b>) hace que esa orden
actúe en la dirección contraria, hacia atrás. Las órdenes cuyo
comportamiento con argumentos se desvíe de esto se señalan más
adelante.</p><p>Cuando una orden se describe como que <i>corta</i> texto, el
texto borrado se guarda para una posible futura recuperación
(<i>pegado</i>). El texto cortado se guarda en un <i>anillo de
corte</i>. Cortes consecutivos hacen que el texto se acumule en una
unidad, que puede pegarse toda de golpe, de una vez. Las órdenes
que no cortan texto separan los trozos de texto en el anillo de
corte. <a id="lbCC"> </a></p><h3>Inicio de Readline</h3><p>Readline se personaliza poniendo órdenes en un fichero de inicio
(el fichero <i>inputrc</i>). El nombre de este fichero se toma del
valor de la variable <font size="-1"><b>INPUTRC</b>.</font> Si esta
variable no está definida, el valor predeterminado es
<i>~/.inputrc</i>. Cuando un programa que hace uso de la biblioteca
readline arranca, el fichero de inicio se lee, y se establecen las
definiciones de teclas y variables. Sólo se permiten unas pocas
construcciones básicas en el fichero de inicio de readline. Las
líneas en blanco no se tienen en cuenta. Las líneas que comiencen
con un <b>#</b> son comentarios. Las líneas que comiencen con un
<b>$</b> indican construcciones condicionales. Otras líneas
representan definiciones de teclas y definiciones de variables.</p><p>Las definiciones predeterminadas de teclas pueden cambiarse con
un fichero <i>inputrc</i>. Otros programas que usen esta biblioteca
pueden añadir sus propias órdenes y definiciones.</p><p>Por ejemplo, el poner</p><dl compact="compact"><dd>
<p>M-Control-u: universal-argument</p>
</dd>
</dl><p>

o 
</p><dl compact="compact"><dd>C-Meta-u: universal-argument</dd>
</dl><p>

dentro del fichero <i>inputrc</i> haría que M-C-u ejecutara la
orden de readline <i>universal-argument</i>. 
</p><p>Se reconocen los siguientes nombres simbólicos de caracteres:
<i>RUBOUT</i>, <i>DEL</i>, <i>ESC</i>, <i>LFD</i>, <i>NEWLINE</i>,
<i>RET</i>, <i>RETURN</i>, <i>SPC</i>, <i>SPACE</i>, y <i>TAB</i>.
Además de los nombres de órdenes, readline permite que se enlace
una tecla cualquiera a una cadena de caracteres que se inserta
cuando la tecla se pulse (una <i>macro</i>). <a id="lbCD"> </a></p><h3>Definiciones de teclas de Readline</h3><p>La sintaxis para controlar las definiciones de teclas en el
fichero <i>inputrc</i> es simple. Todo lo que se requiere es el
nombre de la orden o el texto de una macro y una secuencia de
teclas con la cual debe enlazarse. El nombre se puede especificar
en una de dos formas: como un nombre simbólico de tecla,
posiblemente con prefijos <i>Meta-</i> o <i>Control-</i>, o como
una secuencia de teclas. Cuando se use la forma
<b>nombre-tecla</b>:<i>nombre-función</i> o <i>macro</i>,
<i>nombre-tecla</i> es el nombre de una tecla en inglés. Por
ejemplo:</p><dl compact="compact"><dd>Control-u: universal-argument<br />
 Meta-Rubout: backward-kill-word<br />
 Control-o: "&gt; salida"</dd>
</dl><p>En el ejemplo de arriba, <i>C-u</i> se enlaza a la función
<b>universal-argument</b>, <i>M-DEL</i> se vincula a la función
<b>backward-kill-word</b>, y <i>C-o</i> se define como que se
ejecute la macro expresada en la parte derecha (esto es, insertar
el texto <i>&gt; salida</i> en la línea).</p><p>En la segunda forma, <b>"sectecla"</b>:<i>nombre-función</i> o
<i>macro</i>, <b>sectecla</b> difiere de la <b>nombre-tecla</b> de
antes en que las cadenas que representan una secuencia entera de
teclas pueden especificarse poniendo la secuencia entre comillas
dobles. Así se pueden utilizar algunas teclas de escape al estilo
de GNU Emacs, como en el siguiente ejemplo.</p><dl compact="compact"><dd>"\C-u": universal-argument<br />
 "\C-x\C-r": re-read-init-file<br />
 "\e[11~": "Tecla de Función 1"</dd>
</dl><p>En este ejemplo, <i>C-u</i> se enlaza de nuevo a la función
<b>universal-argument</b>. <i>C-x C-r</i> se vincula a la función
<b>re-read-init-file</b>, y <i>ESC [ 1 1 ~</i> se define como que
se inserte el texto <b>Tecla de Función 1</b>. El conjunto completo
de las secuencias de escape al estilo de GNU Emacs es</p><dl compact="compact"><dd>
<dl compact="compact"><dt><b>\C-</b></dt>

<dd>prefijo de control</dd>

<dt><b>\M-</b></dt>

<dd>prefijo meta</dd>

<dt><b>\e</b></dt>

<dd>un carácter de Escape</dd>

<dt><b>\\</b></dt>

<dd>barra inclinada inversa</dd>

<dt><b>\</b></dt>

<dd>una " literal</dd>

<dt><b>\'</b></dt>

<dd>un ' literal</dd>
</dl></dd>
</dl><p>Además de las secuencias de escape al estilo de GNU Emacs, se
dispone de un segundo conjunto de escapes con la barra
invertida:</p><dl compact="compact"><dd>
<dl compact="compact"><dt><b>\a</b></dt>

<dd>alerta (campana)</dd>

<dt><b>\b</b></dt>

<dd>espacio atrás</dd>

<dt><b>\d</b></dt>

<dd>borrado</dd>

<dt><b>\f</b></dt>

<dd>salto de página</dd>

<dt><b>\n</b></dt>

<dd>salto de línea</dd>

<dt><b>\r</b></dt>

<dd>retorno de carro</dd>

<dt><b>\t</b></dt>

<dd>tabulador horizontal</dd>

<dt><b>\v</b></dt>

<dd>tabulador vertical</dd>

<dt><b>\</b><i>nnn</i></dt>

<dd>el carácter cuyo código es el valor octal <i>nnn</i> (de 1 a 3
dígitos)</dd>

<dt><b>\x</b><i>nnn</i></dt>

<dd>el carácter cuyo código es el valor hexadecimal <i>nnn</i> (de
1 a 3 dígitos)</dd>
</dl></dd>
</dl><p>Cuando se mete el texto de una macro, se deben emplear comillas
simples o dobles para indicar una definición de macro. El texto no
entrecomillado se supone un nombre de función. En el cuerpo de la
macro, los escapes con barra inversa de arriba se expanden. La
barra inversa protegerá a cualquier otro carácter en el texto de la
macro, incluyendo a " y a '.</p><p><b>Bash</b> permite mostrar o modificar las definiciones de
teclas en curso mediante la orden interna <b>bind</b>. El modo de
edición puede cambiarse durante una sesión interactiva empleando la
opción <b>-o</b> de la orden interna <b>set</b> (vea <font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> abajo). <a id="lbCE"> </a></p><h3>Variables de Readline</h3><p>Readline tiene variables que se pueden usar para personalizar
más aún su comportamiento. Una variable se puede definir en el
fichero <i>inputrc</i> con una sentencia de la forma</p><dl compact="compact"><dd>
<p><b>set</b> <i>nombre-variable</i> <i>valor</i></p>
</dd>
</dl><p>Excepto cuando se diga, las variables de readline pueden tomar
los valores <b>On</b> u <b>Off</b>. Las variables y sus valores
predeterminados son:</p><dl compact="compact"><dt><b>bell-style (audible)</b></dt>

<dd>Controla qué pasa cuando readline quiere tocar el pito de la
terminal. Si se define como <b>none</b>, readline nunca toca el
pito. Si se pone a <b>visible</b>, readline usa una alerta visible
si está disponible. Si se pone como <b>audible</b>, readline
intenta hacer sonar el pito de la terminal.</dd>

<dt><b>comment-begin (``#'')</b></dt>

<dd>La cadena que se inserta cuando se ejecuta la orden de
<b>readline</b> <b>insert-comment</b>. Esta orden está enlazada a
<b>M-#</b> en modo emacs y a <b>#</b> en modo vi.</dd>

<dt><b>completion-ignore-case (Off)</b></dt>

<dd>Si se pone a <b>On</b>, readline realiza la concordancia y
terminación de nombres de ficheros sin importar si las letras son
mayúsculas o minúsculas.</dd>

<dt><b>completion-query-items (100)</b></dt>

<dd>Esto determina cuándo se pregunta al usuario si quiere ver el
número de terminaciones posibles generadas por la orden
<b>possible-completions</b>. Puede ponerse a cualquier valor entero
mayor o igual a cero. Si el número de posibles terminaciones es
mayor o igual que el valor de esta variable, al usuario se le
pregunta si desea o no verlas; si no, simplemente se muestran en la
terminal.</dd>

<dt><b>convert-meta (On)</b></dt>

<dd>Si se pone a <b>On</b>, readline convertirá caracteres con el
octavo bit a uno a una secuencia de teclas ASCII poniendo el octavo
bit a cero y prefijando un carácter Esc (en efecto, usando Esc como
el <i>prefijo meta</i>).</dd>

<dt><b>disable-completion (Off)</b></dt>

<dd>Si se pone a <b>On</b>, readline inhibirá la terminación de
palabras. Los caracteres para la terminación se insertarán en la
línea como si se hubieran hecho corresponder con
<b>self-insert</b>.</dd>

<dt><b>editing-mode (emacs)</b></dt>

<dd>Controla si readline empieza con un conjunto de definiciones de
teclas similar a las de <i>emacs</i> o <i>vi</i>.
<b>editing-mode</b> puede ponerse a los valores <b>emacs</b> o
<b>vi</b>.</dd>

<dt><b>enable-keypad (Off)</b></dt>

<dd>Cuando se pone a <b>On</b>, readline intentará activar el
teclado auxiliar cuando se llame. Algunos sistemas necesitan esto
para activar las teclas de flechas de cursor.</dd>

<dt><b>expand-tilde (Off)</b></dt>

<dd>Si se pone a <b>on</b>, la expansión de tilde se realiza cuando
readline intenta la terminación de palabras.</dd>

<dt><b>horizontal-scroll-mode (Off)</b></dt>

<dd>Cuando se pone a <b>On</b>, esto hace que readline use una sola
línea para pantalla, haciendo rodar la entrada horizontalmente en
una sola línea de la pantalla cuando ésta es más larga que la
anchura de la pantalla; en lugar de seguir en la línea
siguiente.</dd>

<dt><b>input-meta (Off)</b></dt>

<dd>Si se pone a <b>On</b>, readline habilitará la entrada de 8
bits (esto es, no pondrá a cero el octavo bit de los caracteres que
lea), sin importar lo que la terminal diga que admite. El nombre
<b>meta-flag</b> es un sinónimo para esta variable.</dd>

<dt><b>keymap (emacs)</b></dt>

<dd>Establece el mapa de teclado actual para readline. El conjunto
de nombres de mapas de teclado válidos es <i>emacs, emacs-standard,
emacs-meta, emacs-ctlx, vi, vi-command</i>, y <i>vi-insert</i>.
<i>vi</i> es equivalente a <i>vi-command</i>; <i>emacs</i> es
equivalente a <i>emacs-standard</i>. El valor predeterminado es
<i>emacs</i>; el valor de <b>editing-mode</b> también afecta al
mapa de teclado predeterminado.</dd>

<dt><b>mark-directories (On)</b></dt>

<dd>Si se pone a <b>On</b>, los nombres de directorios completados
tendrán una barra inclinada añadida al final.</dd>

<dt><b>mark-modified-lines (Off)</b></dt>

<dd>Si se pone a <b>On</b>, las líneas de historia que hayan sido
modificadas se muestran con un asterisco precediéndolas
(<b>*</b>).</dd>

<dt><b>output-meta (Off)</b></dt>

<dd>Si se pone a <b>On</b>, readline mostrará directamente los
caracteres con el octavo bit a uno, en vez de como una secuencia de
escape prefijada con meta.</dd>

<dt><b>print-completions-horizontally (Off)</b></dt>

<dd>Si se pone a <b>On</b>, readline mostrará terminaciones con
concordancias clasificadas horizontalmente en orden alfabético, en
vez de verticalmente.</dd>

<dt><b>show-all-if-ambiguous (Off)</b></dt>

<dd>Esto altera el comportamiento predeterminado de las funciones
de terminación. Si se pone a <b>on</b>, las palabras que tienen más
de una posible terminación hacen que las concordancias se muestren
inmediatamente en vez de tocarse el pito de la terminal.</dd>

<dt><b>visible-stats (Off)</b></dt>

<dd>Si se pone a <b>On</b>, se añade un carácter que represente un
tipo de fichero según lo que devuelve <i><a href="http://localhost/cgi-bin/man/man2html?2+stat">stat</a></i>(2)
cuando se listan las terminaciones posibles.</dd>
</dl><a id="lbCF"> </a><h3>Construcciones condicionales de Readline</h3><p>Readline implementa una facilidad similar en espíritu a las
características de compilación condicional del preprocesador de C
que permite que las definiciones de teclas y variables se realicen
en función de pruebas o condiciones. Hay cuatro directivas del
analizador que se usan.</p><dl compact="compact"><dt><b>$if</b></dt>

<dd>La construcción <b>$if</b> permite que las definiciones se
hagan según el modo de edición, la terminal en uso, o la aplicación
que haga uso de readline. El texto de la condición se extiende
hasta el final de la línea; no se requieren caracteres para
aislarla. 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>mode</b></dt>

<dd>La forma <b>mode=</b> de la directiva <b>$if</b> se usa para
ver si readline está en modo emacs o vi. Esto se puede emplear en
conjunción con la orden <b>set keymap</b>, por ejemplo, para poner
el teclado en los mapas <i>emacs-standard</i> y <i>emacs-ctlx</i>
sólo si readline está arrancando en modo emacs.</dd>

<dt><b>term</b></dt>

<dd>La forma <b>term=</b> puede emplearse para incluir definiciones
de teclas específicas de una terminal determinada, quizás para
enlazar las secuencias de teclas generadas por las teclas de
función de la terminal. La palabra en la parte derecha del <b>=</b>
se prueba contra el nombre completo de la terminal y contra la
porción del nombre de la terminal antes del primer <b>-</b>. Esto
permite que <i>sun</i> concuerde con <i>sun</i> y con
<i>sun-cmd</i>, por ejemplo.</dd>

<dt><b>application</b></dt>

<dd>La construcción <b>application</b> se emplea para incluir
definiciones específicas de la aplicación. Cada programa que usa la
biblioteca readline define el <i>nombre de la aplicación</i>, y en
un fichero de arranque se puede comprobar si existe un valor en
particular. Esto se podría emplear para enlazar secuencias de
teclas a funciones útiles para un programa específico. Por ejemplo,
la orden siguiente añade una secuencia de teclas que entrecomilla
la palabra en curso o la anterior en bash: 
<dl compact="compact"><dd>
<pre>
<b>$if</b> Bash
# Entrecomilla la palabra actual o previa
"\C-xq": "\eb\"\ef\""
<b>$endif</b>
</pre>
</dd>
</dl></dd>
</dl></dd>
</dl></dd>

<dt><b>$endif</b></dt>

<dd>Esta orden, como se ha visto en el ejemplo precedente, termina
una orden <b>$if</b>.</dd>

<dt><b>$else</b></dt>

<dd>Las órdenes en esta rama de la directiva <b>$if</b> se ejecutan
si la comprobación falla.</dd>

<dt><b>$include</b></dt>

<dd>Esta directiva toma como argumento un solo nombre de fichero y
lee órdenes y definiciones de ese fichero. Por ejemplo, la
siguiente directiva leería de <i>/etc/inputrc</i>: 
<dl compact="compact"><dd>
<pre>
<b>$include</b>  <i>/etc/inputrc</i>
</pre>
</dd>
</dl></dd>
</dl><a id="lbCG"> </a><h3>Búsquedas</h3><p>Readline proporciona órdenes para buscar a través de la historia
de órdenes (vea <font size="-1"><b>HISTORIA</b></font> abajo)
líneas que contengan una cadena especificada. Hay dos modos de
búsqueda: <i>incremental</i> y <i>no incremental</i>.</p><p>La búsqueda incremental comienza antes de que el usuario haya
acabado de teclear la cadena a buscar. Tan pronto como se teclea
cada carácter de la cadena de búsqueda, readline muestra la
siguiente entrada de la historia que concuerde con la cadena que se
esté tecleando hasta este punto. Una búsqueda incremental requiere
solamente tantos caracteres como se necesiten para encontrar la
entrada deseada en la lista de historia. El carácter Escape se
emplea para terminar una búsqueda incremental. Control-J también
dará por terminada la búsqueda. Control-G parará abruptamente una
búsqueda incremental y restaurará la línea original. Cuando la
búsqueda se termine, la entrada de la historia que contuviera la
cadena de búsqueda se convierte en la línea en curso. Para
encontrar otras entradas en la lista de historia, teclee Control-S
o Control-R, según sea apropiado. Esto buscará hacia atrás o
adelante en la historia la siguiente entrada concordante con la
cadena de búsqueda tecleada hasta este punto. Cualquier otra
secuencia de teclas asociada a una orden de readline terminará la
búsqueda y ejecutará esa orden. Por ejemplo, una <i>nueva-línea</i>
terminará la búsqueda y aceptará la línea, ejecutando de ese modo
la orden de la lista de historia.</p><p>Las búsquedas no incrementales leen la cadena de búsqueda entera
antes de empezar a buscar en las líneas de la lista de historia. La
cadena de búsqueda puede ser tecleada por el usuario o ser parte de
los contenidos de la línea en curso. <a id="lbCH"> </a></p><h3>Nombres de órdenes de Readline</h3><p>Lo siguiente es una lista de los nombres de las órdenes y las
secuencias de teclas predeterminadas a las que están asociadas. Los
nombres de órdenes sin una secuencia de tecla acompañante
pertenecen a órdenes que no están asociadas a ninguna secuencia de
teclas de forma predeterminada. <a id="lbCI"> </a></p><h3>Órdenes para el movimiento</h3><dl compact="compact"><dt><b>beginning-of-line (C-a)</b></dt>

<dd>Mover al principio de la línea en curso.</dd>

<dt><b>end-of-line (C-e)</b></dt>

<dd>Mover al final de la línea.</dd>

<dt><b>forward-char (C-f)</b></dt>

<dd>Mover un carácter hacia adelante.</dd>

<dt><b>backward-char (C-b)</b></dt>

<dd>Mover un carácter hacia atrás.</dd>

<dt><b>forward-word (M-f)</b></dt>

<dd>Mover adelante hasta el final de la siguiente palabra. Las
palabras se componen de caracteres alfanuméricos (letras y
dígitos).</dd>

<dt><b>backward-word (M-b)</b></dt>

<dd>Mover atrás hasta el principio de esta palabra o la anterior.
Las palabras se componen de caracteres alfanuméricos (letras y
dígitos).</dd>

<dt><b>clear-screen (C-l)</b></dt>

<dd>Limpiar la pantalla dejando la línea en curso al principio de
la pantalla. Con un argumento, refresca la línea en curso sin
borrar la pantalla.</dd>

<dt><b>redraw-current-line</b></dt>

<dd>Refrescar la línea en curso.</dd>
</dl><a id="lbCJ"> </a><h3>Órdenes para manipular la lista de historia</h3><dl compact="compact"><dt><b>accept-line (Nueva-línea, Intro)</b></dt>

<dd>Aceptar la línea sin importar dónde esté el cursor. Si esta
línea no está vacía, añadirla a la lista de historia de acuerdo con
el estado de la variable <font size="-1"><b>HISTCONTROL</b>.</font>
Si la línea es una de las de la historia, modificada, entonces
restaurar la línea de la historia a su estado original.</dd>

<dt><b>previous-history (C-p)</b></dt>

<dd>Obtener la orden anterior de la lista de historia, moviéndose
hacia atrás en ella.</dd>

<dt><b>next-history (C-n)</b></dt>

<dd>Obtener la orden siguiente de la lista de historia, moviéndose
hacia delante en ella.</dd>

<dt><b>beginning-of-history (M-&lt;)</b></dt>

<dd>Mover a la primera línea de la lista de historia.</dd>

<dt><b>end-of-history (M-&gt;)</b></dt>

<dd>Mover al final de la historia de entrada; esto es, la línea que
está siendo introducida en la actualidad.</dd>

<dt><b>reverse-search-history (C-r)</b></dt>

<dd>Buscar hacia atrás empezando en la línea en curso y moviéndose
`arriba' a través de la lista de historia si es necesario. Esta
búsqueda es incremental.</dd>

<dt><b>forward-search-history (C-s)</b></dt>

<dd>Buscar hacia adelante empezando en la linea en curso y
moviéndose `abajo' a través de la lista de historia si es
necesario. Esta búsqueda es incremental.</dd>

<dt><b>non-incremental-reverse-search-history (M-p)</b></dt>

<dd>Buscar hacia atrás a través de la lista de historia empezando
en la línea en curso empleando una búsqueda no incremental de una
cadena suministrada por el usuario.</dd>

<dt><b>non-incremental-forward-search-history (M-n)</b></dt>

<dd>Buscar hacia delante a través de la lista de historia empezando
en la línea en curso empleando una búsqueda no incremental de una
cadena suministrada por el usuario.</dd>

<dt><b>history-search-forward</b></dt>

<dd>Buscar hacia delante a través de la lista de historia una
cadena de caracteres entre el comienzo de la línea en curso y la
posición actual del cursor (el <i>punto</i>). Esta búsqueda no es
incremental.</dd>

<dt><b>history-search-backward</b></dt>

<dd>Buscar hacia atrás a través de la lista de historia una cadena
de caracteres entre el comienzo de la línea en curso y la posición
actual del cursor (el <i>punto</i>). Esta búsqueda no es
incremental.</dd>

<dt><b>yank-nth-arg (M-C-y)</b></dt>

<dd>Insertar el primer argumento de la orden anterior (normalmente
la segunda palabra de la línea previa) en el punto (la posición
actual del cursor). Con un argumento <i>n</i>, insertar la
<i>n</i>-sima palabra de la orden anterior (las palabras en la
orden anterior empiezan con la palabra 0). Un argumento negativo
inserta la <i>n</i>-sima palabra desde el final de la orden
anterior.</dd>

<dt><b>yank-last-arg (M-., M-_)</b></dt>

<dd>Insertar el último argumento de la orden anterior (la última
palabra de la entrada anterior de la lista de historia). Con un
argumento, se comporta exactamente como <b>yank-nth-arg</b>.
Llamadas sucesivas a <b>yank-last-arg</b> mueven hacia atrás en la
lista de historia, insertando cada vez el último argumento de cada
línea.</dd>

<dt><b>shell-expand-line (M-C-e)</b></dt>

<dd>Expandir la línea como hace el shell. Esto realiza la expansión
de alias y de historia así como todas las expansiones de palabra
del shell. Vea <font size="-1"><b>EXPANSIÓN DE HISTORIA</b></font>
abajo para una descripción de la expansión de historia.</dd>

<dt><b>history-expand-line (M-^)</b></dt>

<dd>Realizar la expansión de historia en la línea en curso. Vea
<font size="-1"><b>EXPANSIÓN DE HISTORIA</b></font> abajo para una
descripción de la expansión de historia.</dd>

<dt><b>magic-space</b></dt>

<dd>Efectuar la expansión de historia en la línea en curso e
insertar un espacio. Vea <font size="-1"><b>EXPANSIÓN DE
HISTORIA</b></font> abajo para una descripción de la expansión de
historia.</dd>

<dt><b>alias-expand-line</b></dt>

<dd>Realizar la expansión de alias en la línea en curso. Vea <font size="-1"><b>ALIAS</b></font> arriba para una descripción de la
expansión de alias.</dd>

<dt><b>history-and-alias-expand-line</b></dt>

<dd>Realizar la expansión de historia y alias en la línea en
curso.</dd>

<dt><b>insert-last-argument (M-., M-_)</b></dt>

<dd>Un sinónimo para <b>yank-last-arg</b>.</dd>

<dt><b>operate-and-get-next (C-o)</b></dt>

<dd>Aceptar la línea en curso para la ejecución y obtener la línea
siguiente relativa a la actual desde la lista de historia, para la
edición. Cualquier argumento no se tiene en cuenta.</dd>
</dl><a id="lbCK"> </a><h3>Órdenes para cambiar el texto</h3><dl compact="compact"><dt><b>delete-char (C-d)</b></dt>

<dd>Borrar el carácter bajo el cursor. Si el punto está al
principio de la línea, no hay caracteres en la línea, y el último
carácter tecleado no estaba asociado a <b>delete-char</b>, entonces
devolver <font size="-1"><b>EOF</b>.</font></dd>

<dt><b>backward-delete-char (&lt;X], DEL)</b></dt>

<dd>Borrar el carácter tras el cursor. Cuando se da un argumento
numérico, guardar el texto borrado en el anillo de corte.</dd>

<dt><b>quoted-insert (C-q, C-v)</b></dt>

<dd>Añadir el siguiente carácter tecleado a la línea tal cual. Así
es como se pueden insertar caracteres como <b>C-q</b>, por
ejemplo.</dd>

<dt><b>tab-insert (C-v TAB)</b></dt>

<dd>Insertar un carácter de tabulación.</dd>

<dt><b>self-insert (a, b, A, 1, !, ...)</b></dt>

<dd>Insertar el carácter tecleado.</dd>

<dt><b>transpose-chars (C-t)</b></dt>

<dd>Arrastrar el carácter antes del punto hacia adelante sobre el
carácter en el punto. El punto se mueve adelante también. Si el
punto está al final de la línea, entonces transpone los dos
caracteres antes del punto. Los argumentos negativos no
funcionan.</dd>

<dt><b>transpose-words (M-t)</b></dt>

<dd>Arrastrar la palabra tras el cursor al lugar pasado la palabra
enfrente del cursor, moviendo el cursor también sobre esa
palabra.</dd>

<dt><b>upcase-word (M-u)</b></dt>

<dd>Poner en mayúsculas la palabra en curso (o la siguiente). Con
un argumento negativo, pone la anterior, pero no mueve el
punto.</dd>

<dt><b>downcase-word (M-l)</b></dt>

<dd>Poner en minúsculas la palabra en curso (o la siguiente). Con
un argumento negativo, pone la anterior, pero no mueve el
punto.</dd>

<dt><b>capitalize-word (M-c)</b></dt>

<dd>Poner en mayúscula la inicial de la palabra en curso (o la
siguiente). Con un argumento negativo, pone la anterior, pero no
mueve el punto.</dd>
</dl><a id="lbCL"> </a><h3>Cortar y pegar</h3><dl compact="compact"><dt><b>kill-line (C-k)</b></dt>

<dd>Cortar el texto desde la posición actual del cursor hasta el
final de la línea.</dd>

<dt><b>backward-kill-line (C-x DEL)</b></dt>

<dd>Cortar hacia atrás hasta el principio de la línea.</dd>

<dt><b>unix-line-discard (C-u)</b></dt>

<dd>Cortar hacia atrás desde el punto hasta el principio de la
línea. El texto cortado se guarda en el anillo de corte.</dd>

<dt><b>kill-whole-line</b></dt>

<dd>Cortar todos los caracteres de la línea en curso, sin importar
dónde esté el cursor.</dd>

<dt><b>kill-word (M-d)</b></dt>

<dd>Cortar desde el cursor hasta el final de la palabra en curso, o
si entre palabras, hasta el final de la siguiente. Los extremos de
las palabras son los mismos que los empleados por
<b>forward-word</b>.</dd>

<dt><b>backward-kill-word (M-DEL)</b></dt>

<dd>Cortar la palabra tras el cursor. Los extremos de las palabras
son los mismos que los empleados por <b>backward-word</b>.</dd>

<dt><b>unix-word-rubout (C-w)</b></dt>

<dd>Cortar la palabra tras el cursor, empleando el espacio en
blanco como un límite de palabra. Los extremos de las palabras son
diferentes de los de <b>backward-kill-word</b>.</dd>

<dt><b>delete-horizontal-space (M-\)</b></dt>

<dd>Borrar todos los espacios y tabuladores alrededor del
punto.</dd>

<dt><b>kill-region</b></dt>

<dd>Cortar el texto entre el punto y la <i>marca</i> (posición
registrada del cursor). Este texto se conoce como la
<i>región</i>.</dd>

<dt><b>copy-region-as-kill</b></dt>

<dd>Copiar el texto en la región al anillo de corte.</dd>

<dt><b>copy-backward-word</b></dt>

<dd>Copiar la palabra antes del punto al búfer de corte. Los
extremos de palabras son los mismos que con
<b>backward-word</b>.</dd>

<dt><b>copy-forward-word</b></dt>

<dd>Copiar la palabra que sigue al punto al búfer de corte. Los
extremos de palabra son los mismos que con
<b>forward-word</b>.</dd>

<dt><b>yank (C-y)</b></dt>

<dd>Pegar la cima del anillo de corte en el búfer en donde esté el
cursor.</dd>

<dt><b>yank-pop (M-y)</b></dt>

<dd>Rotar en el anillo de corte, y pegar la nueva cima. Sólo
funciona tras un <b>yank</b> o <b>yank-pop</b>.</dd>
</dl><a id="lbCM"> </a><h3>Argumentos numéricos</h3><dl compact="compact"><dt><b>digit-argument (M-0, M-1, ..., M--)</b></dt>

<dd>Añadir este dígito al argumento, acumulándolo, o comenzar con
un nuevo argumento. M-- empieza un argumento negativo.</dd>

<dt><b>universal-argument</b></dt>

<dd>Ésta es otra forma de especificar un argumento. Si esta orden
se hace seguir de uno o más dígitos, opcionalmente con un signo
menos inicial, estos dígitos definen el argumento. Si a la orden
siguen dígitos, ejecutar de nuevo <b>universal-argument</b>
finaliza el argumento numérico, pero si no, no se tiene en cuenta.
Como un caso especial, si a esta orden sigue inmediatamente un
carácter que no es ni un dígito ni un signo menos, el número del
argumento para la siguiente orden se multiplica por cuatro. El
número del argumento es inicialmente uno, así que ejecutar esta
función por primera vez hace que el número del argumento sea
cuatro, una segunda vez lo hace dieciséis, y así
sucesivamente.</dd>
</dl><a id="lbCN"> </a><h3>Terminación</h3><dl compact="compact"><dt><b>complete (TAB)</b></dt>

<dd>Intentar realizar una terminación del texto antes del punto.
<b>Bash</b> intenta la terminación tratando al texto como una
variable (si el texto comienza con <b>$</b>), como un nombre de
usuario (si el texto empieza con <b>~</b>), como un nombre de
computador anfitrión (si el texto comienza con <b>@</b>), o como
una orden (incluyendo alias y funciones), por este orden. Si nada
de esto concuerda, se intenta la terminación de un nombre de
fichero.</dd>

<dt><b>possible-completions (M-?)</b></dt>

<dd>Listar las terminaciones posibles del texto antes del
punto.</dd>

<dt><b>insert-completions (M-*)</b></dt>

<dd>Insertar todas las terminaciones del texto antes del punto que
habrían sido generadas por <b>possible-completions</b>.</dd>

<dt><b>menu-complete</b></dt>

<dd>Similar a <b>complete</b>, pero reemplaza la palabra a ser
completada con una sola concordancia de la lista de terminaciones
posibles. La ejecución repetida de <b>menu-complete</b> camina por
la lista de terminaciones posibles, insertando cada concordancia
por turnos. Al final de la lista de terminaciones, se hace sonar el
pito de la terminal y el texto original se restaura. Un argumento
<i>n</i> mueve <i>n</i> posiciones hacia delante en la lista de
concordancias; un argumento negativo se puede emplear para moverse
hacia atrás en la lista. Esta orden está pensada para ser asociada
a <b>TAB</b>, pero no está asociada a ninguna tecla de forma
predeterminada.</dd>

<dt><b>complete-filename (M-/)</b></dt>

<dd>Intentar la terminación de un nombre de fichero en el texto
antes del punto.</dd>

<dt><b>possible-filename-completions (C-x /)</b></dt>

<dd>Listar las posibles terminaciones del texto antes del punto,
tratándolo como un nombre de fichero.</dd>

<dt><b>complete-username (M-~)</b></dt>

<dd>Intentar la terminación del texto antes del punto, tratándolo
como un nombre de usuario.</dd>

<dt><b>possible-username-completions (C-x ~)</b></dt>

<dd>Listar las posibles terminaciones del texto antes del punto,
tratándolo como un nombre de usuario.</dd>

<dt><b>complete-variable (M-$)</b></dt>

<dd>Intentar la terminación del texto antes del punto, tratándolo
como una variable del shell.</dd>

<dt><b>possible-variable-completions (C-x $)</b></dt>

<dd>Listar las posibles terminaciones del texto antes del punto,
tratándolo como una variable del shell.</dd>

<dt><b>complete-hostname (M-@)</b></dt>

<dd>Intentar la terminación del texto antes del punto, tratándolo
como un nombre de computador anfitrión.</dd>

<dt><b>possible-hostname-completions (C-x @)</b></dt>

<dd>Listar las posibles terminaciones del texto antes del punto,
tratándolo como un nombre de computador anfitrión.</dd>

<dt><b>complete-command (M-!)</b></dt>

<dd>Intentar la terminación del texto antes del punto, tratándolo
como un nombre de orden. La terminación de orden intenta hacer
concordar el texto con alias, palabras reservadas, funciones del
shell, órdenes internas del shell, y finalmente nombres de ficheros
ejecutables, en ese orden.</dd>

<dt><b>possible-command-completions (C-x !)</b></dt>

<dd>Listar las posibles terminaciones del texto antes del punto,
tratándolo como un nombre de orden.</dd>

<dt><b>dynamic-complete-history (M-TAB)</b></dt>

<dd>Intentar la terminación del texto antes del punto, comparando
el texto con líneas de la lista de historia buscando concordancias
para la terminación.</dd>

<dt><b>complete-into-braces (M-{)</b></dt>

<dd>Efectuar la terminación de nombres de ficheros y devolver la
lista de terminaciones posibles encerrada entre llaves de forma que
la lista esté disponible al shell (vea <b>Expansión de llaves</b>
arriba).</dd>
</dl><a id="lbCO"> </a><h3>Macros de teclado</h3><dl compact="compact"><dt><b>start-kbd-macro (C-x ()</b></dt>

<dd>Empezar a grabar los caracteres tecleados, en la macro de
teclado en curso.</dd>

<dt><b>end-kbd-macro (C-x ))</b></dt>

<dd>Parar de grabar los caracteres tecleados en la macro de teclado
en curso, y almacenar la definición.</dd>

<dt><b>call-last-kbd-macro (C-x e)</b></dt>

<dd>Reejecutar la última macro de teclado definida, haciendo que
los caracteres en la macro aparezcan como si se hubieran pulsado en
el teclado.</dd>
</dl><a id="lbCP"> </a><h3>Miscelánea</h3><dl compact="compact"><dt><b>re-read-init-file (C-x C-r)</b></dt>

<dd>Leer los contenidos del fichero <i>inputrc</i>, e incorporar
cualesquiera definiciones de teclas o asignaciones de variables que
se hubieran encontrado en él.</dd>

<dt><b>abort (C-g)</b></dt>

<dd>Terminar abruptamente la orden de edición en curso y tocar el
pito de la terminal (según el establecimiento de
<b>bell-style</b>).</dd>

<dt><b>do-uppercase-version (M-a, M-b, M-</b><i>x</i>, ...)</dt>

<dd>Si el carácter meta <i>x</i> está en minúscula, ejecutar la
orden que esté asociada al carácter correspondiente en
mayúscula.</dd>

<dt><b>prefix-meta (ESC)</b></dt>

<dd>Convertir en meta el siguiente carácter tecleado. <font size="-1"><b>ESC</b></font> <b>f</b> es equivalente a
<b>Meta-f</b>.</dd>

<dt><b>undo (C-_, C-x C-u)</b></dt>

<dd>Deshacer de forma incremental, recordado separadamente para
cada línea.</dd>

<dt><b>revert-line (M-r)</b></dt>

<dd>Deshacer todos los cambios hechos a esta línea. Esto es como
ejecutar la orden <b>undo</b> las veces suficientes como para
devolver la línea a su estado inicial.</dd>

<dt><b>tilde-expand (M-~)</b></dt>

<dd>Efectuar la expansión de tilde en la palabra en curso.</dd>

<dt><b>set-mark (C-@, M-&lt;espacio&gt;)</b></dt>

<dd>Establecer la marca en el punto actual. Si se da un argumento
numérico, la marca se establece en esa posición.</dd>

<dt><b>exchange-point-and-mark (C-x C-x)</b></dt>

<dd>Cambia el punto con la marca. La posición actual del cursor se
pone en la posición guardada, y la vieja posición del cursor se
guarda como la marca.</dd>

<dt><b>character-search (C-])</b></dt>

<dd>Se lee un carácter y el punto se mueve a la siguiente
ocurrencia de ese carácter. Un argumento numérico negativo hace que
la búsqueda sea de las ocurrencias anteriores.</dd>

<dt><b>character-search-backward (M-C-])</b></dt>

<dd>Se lee un carácter y el punto se mueve a la anterior ocurrencia
de ese carácter. Un argumento numérico negativo hace que la
búsqueda sea de las ocurrencias siguientes.</dd>

<dt><b>insert-comment (M-#)</b></dt>

<dd>El valor de la variable de <b>readline</b> <b>comment-begin</b>
se inserta al principio de la línea en curso, y la línea se acepta
como si se hubiera tecleado Intro (nueva-línea). Esto convierte la
línea en curso en un comentario del shell.</dd>

<dt><b>glob-expand-word (C-x *)</b></dt>

<dd>La palabra antes del punto se trata como un patrón para la
expansión de nombres de caminos y la lista de nombres de fichero
concordantes se inserta, reemplazando a la palabra.</dd>

<dt><b>glob-list-expansions (C-x g)</b></dt>

<dd>Mostrar la lista de expansiones que habrían sido generadas por
<b>glob-expand-word</b> y redibujar la línea.</dd>

<dt><b>dump-functions</b></dt>

<dd>Mostrar todas las funciones y sus asociaciones de teclas en el
flujo de salida de readline. Si se da un argumento numérico, la
salida se formatea de tal modo que pueda formar parte de un fichero
<i>inputrc</i>.</dd>

<dt><b>dump-variables</b></dt>

<dd>Mostrar todas las variables de readline a las que se puedan
asignar valores, y éstos, en el flujo de salida de readline. Si se
da un argumento numérico, la salida se formatea de tal manera que
pueda formar parte de un fichero <i>inputrc</i>.</dd>

<dt><b>dump-macros</b></dt>

<dd>Mostrar todas las secuencias de teclas de readline asociadas a
macros y las cadenas de caracteres asociadas correspondientes. Si
se da un argumento numérico, la salida se formatea de tal manera
que pueda formar parte de un fichero <i>inputrc</i>.</dd>

<dt><b>display-shell-version (C-x C-v)</b></dt>

<dd>Mostrar información de versión acerca de la instancia actual de
<b>bash</b>.</dd>
</dl><a id="lbCQ"> </a><h2>HISTORIA</h2><p>

Cuando se habilita la opción <b>-o history</b> de la orden interna
<b>set</b>, el shell da acceso a la <i>historia de órdenes</i>, la
lista de órdenes tecleadas con anterioridad. El texto de los
últimos <font size="-1"><b>HISTSIZE</b></font> mandatos (por
omisión, 500) se guarda en una lista de historia. El shell almacena
cada orden en la lista de historia antes de la expansión de
parámetros y variables (vea <font size="-1"><b>EXPANSIÓN</b></font>
arriba) pero tras efectuar la expansión de historia, sujeta a los
valores de las variables del shell <font size="-1"><b>HISTIGNORE</b></font> e <font size="-1"><b>HISTCONTROL</b>.</font> En el arranque, la historia se
inicia a partir del fichero nombrado en la variable <font size="-1"><b>HISTFILE</b></font> (por omisión
<i>~/.bash_history</i>). <font size="-1"><b>HISTFILE</b></font> se
trunca, si es necesario, para contener no más de <font size="-1"><b>HISTFILESIZE</b></font> líneas. Cuando un shell
interactivo termina, las últimas <font size="-1"><b>HISTSIZE</b></font> líneas se copian de la lista de
historia a <font size="-1"><b>HISTFILE</b>.</font> Si la opción del
shell <b>histappend</b> está activa (vea la descripción de
<b>shopt</b> bajo <font size="-1"><b>ÓRDENES INTERNAS DEL
SHELL</b></font> más adelante), las líneas se añaden al fichero de
historia; si no, el fichero de historia se sobreescribe. Si <font size="-1"><b>HISTFILE</b></font> no está definido, o si no se puede
escribir en el fichero de historia, la historia no se guarda. Tras
guardar la historia, el fichero de historia se trunca para contener
no más de <font size="-1"><b>HISTFILESIZE</b></font> líneas. Si
<font size="-1"><b>HISTFILESIZE</b></font> no está definido, no se
trunca. 
</p><p>La orden interna <b>fc</b> (vea <font size="-1"><b>ÓRDENES
INTERNAS DEL SHELL</b></font> abajo) puede emplearse para listar o
editar y re-ejecutar una porción de la lista de historia. La orden
interna <b>history</b> se puede utilizar para mostrar o modificar
la lista de historia y manipular el fichero de historia. Cuando se
emplea la edición de líneas de órdenes, están disponibles las
órdenes de búsqueda en cada modo de edición que proporcionan acceso
a la lista de historia.</p><p>El shell permite el control sobre qué órdenes se guarden en la
lista de historia. Las variables <font size="-1"><b>HISTCONTROL</b></font> y <font size="-1"><b>HISTIGNORE</b></font> se pueden definir de forma que
el shell guarde solamente un subconjunto de las órdenes
introducidas. La opción del shell <b>cmdhist</b>, si está
habilitada, hace que el shell intente guardar cada línea de una
orden multi-línea en la misma entrada de la historia, añadiendo
punto y comas donde sea necesario para preservar la corrección
sintáctica. La opción del shell <b>lithist</b> hace que el shell
guarde la orden con saltos de línea empotrados en vez de punto y
comas. Vea la descripción de la orden interna <b>shopt</b> abajo en
<font size="-1"><b>ÓRDENES INTERNAS DEL SHELL</b></font> para
información sobre cómo establecer y anular opciones del shell. <a id="lbCR"> </a></p><h2>EXPANSIÓN DE HISTORIA</h2><p>El shell admite una característica de expansión de historia que
es parecida a la expansión de historia en <b>csh</b>. Esta sección
describe qué características sintácticas están disponibles. Esta
característica está habilitada de forma predeterminada en shells
interactivos, y puede ser desactivada mediante la opción <b>+H</b>
de la orden interna <b>set</b> (vea <font size="-1"><b>ÓRDENES
INTERNAS DEL SHELL</b></font> abajo). Los shells no interactivos no
realizan la expansión de la historia de forma predeterminada.</p><p>Las expansiones de historia introducen palabras desde la lista
de historia en el flujo de entrada, facilitando así la repetición
de órdenes, la inserción de argumentos de una orden anterior en la
línea de entrada en curso, o la corrección rápida de errores en una
orden anterior.</p><p>La expansión de historia se realiza inmediatamente tras la
lectura de una línea completa, antes de que el shell la divida en
palabras. Tiene lugar en dos fases. En la primera se determina qué
línea de la lista de historia hay que emplear durante la
sustitución. En la segunda se seleccionan porciones de esa línea
para su inclusión en la actual. La línea seleccionada desde la
historia es el <i>evento</i>, y la porción de esa línea sobre la
que se actúa son <i>palabras</i>. Se dispone de varios
<i>modificadores</i> para manipular las palabras seleccionadas. La
línea se divide en palabras de la misma manera que cuando se lee la
entrada, de forma que ciertas palabras separadas por
<i>meta-caracteres</i> rodeadas por comillas se consideran una sola
palabra. Las expansiones de historia se introducen por la aparición
del carácter de expansión de historia, que es por omisión <b>!</b>.
Sólo las barras inversas (<b>\</b>) y las comillas simples pueden
proteger al carácter de expansión de historia.</p><p>Se pueden emplear ciertas opciones que se ponen con la orden
interna <b>shopt</b> para cambiar el comportamiento de la expansión
de historia. Si la opción del shell <b>histverify</b> está activa
(vea la descripción de la orden interna <b>shopt</b>), y se está
usando <b>readline</b>, las sustituciones de historia no se pasan
inmediatamente al analizador del shell. En vez de eso, la línea
expandida se vuelve a cargar en el búfer de edición de
<b>readline</b> para una modificación posterior. Si se está usando
<b>readline</b> y la opción del shell <b>histreedit</b> está
activada, una sustitución de historia fallida se volverá a cargar
en el búfer de edición de <b>readline</b> para su corrección. La
opción <b>-p</b> de la orden interna <b>history</b> se puede
emplear para ver qué hará una expansión de historia antes de
usarse. La opción <b>-s</b> de la orden interna <b>history</b> se
puede emplear para añadir órdenes al final de la lista de historia
sin ejecutarlas realmente, de modo que estén disponibles para
rellamadas posteriores.</p><p>El shell permite el control de los diversos caracteres empleados
por el mecanismo de expansión de historia (vea la descripción de
<b>histchars</b> arriba en <b>Variables del shell</b>). <a id="lbCS"> </a></p><h3>Designadores de eventos</h3><p>Un designador de evento es una referencia a una entrada de línea
de orden en la lista de historia.</p><dl compact="compact"><dt><b>!</b></dt>

<dd>Comenzar una sustitución de historia, excepto cuando le siga un
<b>blanco</b>, salto de línea, = o (.</dd>

<dt><b>!</b><i>n</i></dt>

<dd>Referirse a la línea de órdenes número <i>n</i>.</dd>

<dt><b>!-</b><i>n</i></dt>

<dd>Referirse a la línea de orden en curso menos <i>n</i>.</dd>

<dt><b>!!</b></dt>

<dd>Referirse a la orden anterior. Esto es lo mismo que `!-1'.</dd>

<dt><b>!</b><i>cadena</i></dt>

<dd>Referirse a la orden más reciente que comience con
<i>cadena</i>.</dd>

<dt><b>!?</b><i>cadena</i><b>[?]</b></dt>

<dd>Referirse a la orden más reciente que contenga <i>cadena</i>.
El <b>?</b> del final puede omitirse si a <i>cadena</i> le sigue
inmediatamente un salto de línea.</dd>

<dt><font size="+2"><b>^</b></font><i>cadena1</i><font size="+2">^</font><i>cadena2</i><font size="+2">^</font></dt>

<dd>Sustitución rápida. Repetir la última orden, reemplazando
<i>cadena1</i> con <i>cadena2</i>. Equivalente a
``!!:s/<i>cadena1</i>/<i>cadena2</i>/'' (vea <b>Modificadores</b>
abajo).</dd>

<dt><b>!#</b></dt>

<dd>La línea de orden entera tecleada hasta ahora.</dd>
</dl><a id="lbCT"> </a><h3>Designadores de palabras</h3><p>Los designadores de palabras se emplean para seleccionar las
palabras que se deseen del evento. Un <b>:</b> separa la
especificación de evento del designador de palabra. Puede omitirse
si el designador de palabra comienza con un <b>^</b>, <b>$</b>,
<b>*</b>, <b>-</b>, o <b>%</b>. Las palabras se numeran desde el
principio de la línea, con la primera palabra denotada por 0
(cero). Las palabras se insertan en la línea en curso separadas por
espacios simples.</p><dl compact="compact"><dt><b>0 (cero)</b></dt>

<dd>La palabra número 0. Para el shell, ésta es la palabra de la
orden.</dd>

<dt><i>n</i></dt>

<dd>La <i>n</i>-sima palabra.</dd>

<dt><b>^</b></dt>

<dd>El primer argumento. Esto es, la palabra número 1.</dd>

<dt><b>$</b></dt>

<dd>El último argumento.</dd>

<dt><b>%</b></dt>

<dd>La palabra que concordaba con la más reciente búsqueda con
`?<i>cadena</i>?'.</dd>

<dt><i>x</i><b>-</b>y</dt>

<dd>Un rango de palabras; `-<i>y</i>' abrevia `0-<i>y</i>'.</dd>

<dt><b>*</b></dt>

<dd>Todas las palabras menos la número cero. Esto es un sinónimo de
`<i>1-$</i>'. No es un error emplear <b>*</b> si sólo hay una
palabra en el evento; en este caso se devuelve la cadena
vacía.</dd>

<dt><b>x*</b></dt>

<dd>Abreviatura de <i>x-$</i>.</dd>

<dt><b>x-</b></dt>

<dd>Abrevia <i>x-$</i> como <b>x*</b>, pero omite la última
palabra.</dd>
</dl><p>Si se suministra un designador de palabra sin una especificación
de evento, se usa la orden anterior como el evento. <a id="lbCU"> </a></p><h3>Modificadores</h3><p>Tras el designador opcional de palabra, puede haber una
secuencia de uno o más de los siguientes modificadores, precedido
cada uno por un `:'.</p><dl compact="compact"><dt><b>h</b></dt>

<dd>Quitar un componente final de nombre de fichero, dejando sólo
la parte izquierda.</dd>

<dt><b>t</b></dt>

<dd>Quitar todos los primeros componentes de un nombre de fichero,
dejando la última parte.</dd>

<dt><b>r</b></dt>

<dd>Quitar un sufijo final de la forma <i>.xxx</i>, dejando el
nombre base.</dd>

<dt><b>e</b></dt>

<dd>Quitar todo salvo el sufijo final.</dd>

<dt><b>p</b></dt>

<dd>Mostrar la nueva orden pero no ejecutarla.</dd>

<dt><b>q</b></dt>

<dd>Entrecomillar las palabras sustituidas, escapando de
posteriores sustituciones.</dd>

<dt><b>x</b></dt>

<dd>Entrecomillar las palabras sustituidas como con <b>q</b>, pero
romper entre palabras en los <b>blancos</b> y saltos de línea.</dd>

<dt><b>s/</b><i>viejo</i>/<i>nuevo</i>/</dt>

<dd>Substituir <i>nuevo</i> por la primera ocurrencia de
<i>viejo</i> en la línea de evento. Se puede emplear cualquier
delimitador en vez de /. El delimitador final es opcional si es el
último carácter de la línea de evento. El delimitador puede
entrecomillarse en <i>viejo</i> y <i>nuevo</i> con una sola barra
inclinada inversa. Si &amp; aparece en <i>nuevo</i>, se reemplaza
por <i>viejo</i>. Una sola barra inversa protegerá el &amp;. Si
<i>viejo</i> está vacío, se pone al último <i>viejo</i>
substituido, o, si no tuvo lugar ninguna sustitución de historia
previa, a la última <i>cadena</i> en una búsqueda del tipo
<b>!?</b><i>cadena</i><b>[?]</b>.</dd>

<dt><b>&amp;</b></dt>

<dd>Repetir la sustitución anterior.</dd>

<dt><b>g</b></dt>

<dd>Hace que los cambios se apliquen sobre la línea entera de
evento. Esto se emplea en conjunción con `<b>:s</b>' (p.ej.,
`<b>:gs/</b><i>viejo</i>/<i>nuevo</i>/') o `<b>:&amp;</b>'. Si se
usa con `<b>:s</b>', cualquier delimitador se puede utilizar en
lugar de /, y el delimitador final es opcional si es el último
carácter de la linea de evento.</dd>
</dl><a id="lbCV"> </a><h2>ÓRDENES INTERNAS DEL SHELL</h2><p>A menos que se diga otra cosa, cada orden interna documentada en
esta sección que acepte opciones precedidas por <b>-</b> también
acepta <b>--</b> para significar el final de las opciones.</p><dl compact="compact"><dt><b>:</b> [<i>argumentos</i>]</dt>

<dd>Sin efecto; la orden no hace nada más que expandir
<i>argumentos</i> y realizar cualquier redirección que se haya
especificado. Se devuelve un código de salida cero.</dd>

<dd><b>.</b> <i>nombre-fichero</i> [<i>argumentos</i>]</dd>

<dt><b>source</b> <i>nombre-fichero</i> [<i>argumentos</i>]</dt>

<dd>Lee y ejecuta órdenes desde <i>nombre-fichero</i> en el entorno
actual del shell y devuelve el estado de salida de la última orden
ejecutada desde <i>nombre-fichero</i>. Si <i>nombre-fichero</i> no
contiene una barra inclinada, se usan los nombres de fichero en
<font size="-1"><b>PATH</b></font> para encontrar el directorio que
contenga a <i>nombre-fichero</i>. El fichero que se busca en <font size="-1"><b>PATH</b></font> no necesita ser ejecutable. Se busca
en el directorio de trabajo si no se encontró el fichero en <font size="-1"><b>PATH</b>.</font> Si la opción <b>sourcepath</b> de la
orden interna <b>shopt</b> está desactivada, la búsqueda en <font size="-1"><b>PATH</b></font> no se realiza. Si se suministran
<i>argumentos</i>, se convierten en los parámetros posicionales
cuando se ejecuta <i>nombre-fichero</i>. Si no, los parámetros
posicionales permanecen inalterados. El estado de retorno es el de
la última orden de dentro del guión (0 si no se ejecutó ninguna
orden), y `falso' si <i>nombre-fichero</i> no se encontró o no se
pudo leer.</dd>

<dt><b>alias</b> [<b>-p</b>] [<i>nombre</i>[=<i>valor</i>]
...]</dt>

<dd><b>Alias</b> sin argumentos o con la opción <b>-p</b> muestra
la lista de alias en la forma <b>alias</b>
<i>nombre</i>=<i>valor</i> en la salida estándar. Cuando se dan
argumentos, se define un alias para cada <i>nombre</i> cuyo
<i>valor</i> se da. Un espacio extra tras <i>valor</i> hace que en
la siguiente palabra se realice la sustitución de alias cuando el
alias se expande. Para cada <i>nombre</i> en la lista de argumentos
para el que no se suministre un <i>valor</i>, se muestran el nombre
y el valor del alias. <b>Alias</b> devuelve `verdad' a menos que se
dé un <i>nombre</i> para el que no se haya definido un alias.</dd>

<dt><b>bg</b> [<i>espectrab</i>]</dt>

<dd>Reanuda el trabajo suspendido <i>espectrab</i> en segundo
plano, como si se hubiera arrancado con <b>&amp;</b>. Si
<i>espectrab</i> no está presente, se emplea la noción que tiene el
shell del <i>trabajo en curso</i>. <b>bg</b> <i>espectrab</i>
devuelve 0 a menos que se ejecute cuando el control de trabajos
esté deshabilitado, o cuando se ejecute con el control de trabajos
habilitado si <i>espectrab</i> no se encontró, o cuando se hubo
arrancado sin control de trabajos.</dd>

<dd><b>bind</b> [<b>-m</b> <i>mapatecl</i>] [<b>-lpsvPSV</b>]</dd>

<dt><b>bind</b> [<b>-m</b> <i>mapatecl</i>] [<b>-q</b>
<i>función</i>] [<b>-u</b> <i>función</i>] [<b>-r</b>
<i>sectecl</i>]</dt>

<dt><b>bind</b> [<b>-m</b> <i>mapatecl</i>] <b>-f</b>
<i>nombre-fichero</i></dt>

<dt><b>bind</b> [<b>-m</b> <i>mapatecl</i>]
<i>sectecl</i>:<i>nombre-función</i></dt>

<dd>Muestra las asociaciones actuales de <b>readline</b> de teclas
y funciones, o asocia una secuencia de teclas a una función o macro
de <b>readline</b>. La sintaxis aceptada es idéntica a la de
<i>.inputrc</i>, pero cada asociación debe pasarse como un
argumento separado; p.ej., '"\C-x\C-r": re-read-init-file'. Las
opciones, si se dan, tienen los siguientes significados: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>-m</b> <i>mapatecl</i></dt>

<dd>Usar <i>mapatecl</i> como el mapa de teclado que va a verse
afectado por subsiguientes asociaciones. Los nombres aceptables de
<i>mapatecl</i> son <i>emacs, emacs-standard, emacs-meta,
emacs-ctlx, vi, vi-command</i> y <i>vi-insert</i>. <i>vi</i>
equivale a <i>vi-command</i>; <i>emacs</i> es equivalente a
<i>emacs-standard</i>.</dd>

<dt><b>-l</b></dt>

<dd>Lista los nombres de todas las funciones de
<b>readline</b>.</dd>

<dt><b>-p</b></dt>

<dd>Muestra los nombres de funciones de <b>readline</b> de tal
forma que puedan volver a ser leídas.</dd>

<dt><b>-P</b></dt>

<dd>Lista los nombres de funciones de <b>readline</b> actuales y
las asociaciones.</dd>

<dt><b>-v</b></dt>

<dd>Muestra los nombres de variables de <b>readline</b> y los
valores de tal manera que puedan volver a ser leídas.</dd>

<dt><b>-V</b></dt>

<dd>Lista los nombres de variables de <b>readline</b> actuales y
los valores.</dd>

<dt><b>-s</b></dt>

<dd>Muestra las secuencias de teclas de <b>readline</b> asociadas a
macros y las cadenas correspondientes de tal manera que puedan ser
leídas de nuevo.</dd>

<dt><b>-S</b></dt>

<dd>Muestra las secuencias de teclas de <b>readline</b> asociadas a
macros y las cadenas de caracteres correspondientes.</dd>

<dt><b>-f</b> <i>nombre-fichero</i></dt>

<dd>Lee las asociaciones de teclas desde
<i>nombre-fichero</i>.</dd>

<dt><b>-q</b> <i>función</i></dt>

<dd>Pregunta qué teclas llaman a la <i>función</i>
especificada.</dd>

<dt><b>-u</b> <i>función</i></dt>

<dd>Desenlaza todas las teclas asociadas a la <i>función</i>
nombrada.</dd>

<dt><b>-r</b> <i>sectecl</i></dt>

<dd>Borra cualquier asociación actual de <i>sectecl</i>.</dd>
</dl><p>El valor devuelto es 0 a menos que se dé una opción no
reconocida o que ocurra un error.</p>
</dd>
</dl></dd>

<dt><b>break</b> [<i>n</i>]</dt>

<dd>Sale de un bucle <b>for</b>, <b>while</b>, <b>until</b>, o
<b>select</b>. Si se especifica <i>n</i>, sale de <i>n</i> niveles.
<i>n</i> debe ser &gt; 1. Si <i>n</i> es mayor que el número de
bucles, se sale de todos. El valor devuelto es 0 a menos que el
shell no esté ejecutando un bucle cuando se ejecute
<b>break</b>.</dd>

<dt><b>builtin</b> <i>orden-interna</i> [<i>argumentos</i>]</dt>

<dd>Ejecuta la orden interna del shell especificada, pasándole los
<i>argumentos</i>, y devuelve su estado de salida. Esto es útil
cuando se define una función cuyo nombre es el mismo que una orden
interna del shell, reteniendo la funcionalidad de esa orden interna
dentro de la función. Por ejemplo, la orden interna <b>cd</b> se
puede redefinir normalmente de esta manera. El estado de salida es
`falso' si <i>orden-interna</i> no es una orden incorporada del
shell.</dd>

<dt><b>cd</b> [<b>-LP</b>] [<i>dir</i>]</dt>

<dd>Cambia el directorio de trabajo en curso a <i>dir</i>. La
variable <font size="-1"><b>HOME</b></font> contiene el nombre del
directorio predeterminado <i>dir</i>. La variable <font size="-1"><b>CDPATH</b></font> define el camino de búsqueda del
directorio que contenga <i>dir</i>. Los nombres de directorios
alternativos en <font size="-1"><b>CDPATH</b></font> se separan por
dos puntos (:). Un nombre de directorio vacío en <font size="-1"><b>CDPATH</b></font> es lo mismo que el directorio de
trabajo en curso, o sea, ``<b>.</b>''. Si <i>dir</i> comienza con
una barra inclinada (/), entonces <font size="-1"><b>CDPATH</b></font> no se usa. La opción <b>-P</b> dice
que se va a emplear la estructura física de directorios en vez de
seguir enlaces simbólicos (vea también la opción <b>-P</b> de la
orden interna <b>set</b>); la opción <b>-L</b> hace que se sigan
siempre los enlaces simbólicos. El argumento <b>-</b> es
equivalente a <font size="-1"><b>$OLDPWD</b>.</font> El valor de
retorno es `verdad' si el directorio de trabajo se cambió con
éxito; `falso' en otro caso.</dd>

<dt><b>command</b> [<b>-pVv</b>] <i>orden</i> [<i>arg</i> ...]</dt>

<dd>Ejecuta <i>orden</i> con <i>args</i> suprimiendo la búsqueda
normal de funciones del shell. Sólo se ejecutarán órdenes
incorporadas en el shell o programas encontrados en la variable
<font size="-1"><b>PATH</b>.</font> Si se da la opción <b>-p</b>,
se busca la <i>orden</i> empleándose un valor predeterminado para
<b>PATH</b> que garantiza encontrar todas las utilidades estándar
del sistema. Si se da la opción <b>-V</b> o la <b>-v</b>, se
muestra una descripción de <i>orden</i>. La opción <b>-v</b>
muestra una sola palabra que indica la orden o nombre de fichero
ejecutable empleado para la llamada a <i>orden</i>; la opción
<b>-V</b> produce una descripción algo más prolija. Si se dan las
opciones <b>-V</b> o <b>-v</b>, el estado de salida es 0 si
<i>orden</i> se encontró, y 1 si no. Si no se da ninguna de las dos
opciones y ocurrió un error u <i>orden</i> no se encontró, el
estado de salida es 127. Si no, el estado de salida de
<b>command</b> es el estado de salida de <i>orden</i>.</dd>

<dt><b>continue</b> [<i>n</i>]</dt>

<dd>Reanuda la siguiente iteración del bucle <b>for</b>,
<b>while</b>, <b>until</b>, o <b>select</b> donde estamos. Si se
especifica <i>n</i>, la reanudación es en el <i>n</i>-simo bucle
que nos rodea. <i>n</i> debe ser &gt; 1. Si <i>n</i> es mayor que
el número de bucles que nos rodean, se reanuda el bucle más
exterior (el de ``más alto nivel''). El valor de retorno es 0 a
menos que el shell no esté ejecutando un bucle cuando se ejecute
<b>continue</b>.</dd>

<dd><b>declare</b> [<b>-afFirx</b>] [<b>-p</b>]
[<i>nombre</i>[=<i>valor</i>]]</dd>

<dt><b>typeset</b> [<b>-afFirx</b>] [<b>-p</b>]
[<i>nombre</i>[=<i>valor</i>]]</dt>

<dd>Declaran variables o les dan atributos. Si no se dan
<i>nombre</i>s, entonces muestran los valores de las variables. La
opción <b>-p</b> mostrará los atributos y valores de cada
<i>nombre</i>. Cuando se emplee <b>-p</b>, otras opciones que se
hayan dado no se tienen en cuenta. La opción <b>-F</b> inhibe la
presentación de las definiciones de funciones; sólo se muestran sus
nombres y atributos. La opción <b>-F</b> implica <b>-f</b>. Se
pueden emplear las siguientes opciones para restringir la salida a
variables con el atributo especificado o para dar atributos a
variables: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>-a</b></dt>

<dd>Cada <i>nombre</i> es una variable vector (vea <b>Vectores</b>
arriba).</dd>

<dt><b>-f</b></dt>

<dd>Usar solamente nombres de funciones.</dd>

<dt><b>-i</b></dt>

<dd>La variable se trata como un entero; se realiza la evaluación
aritmética (vea <font size="-1"><b>EVALUACIÓN</b>ARITMÉTICA<b>)</b></font> cuando a la
variable se le asigne un valor.</dd>

<dt><b>-r</b></dt>

<dd>Hace que <i>nombre</i>s sean de lectura exclusiva. A estos
nombres no se les pueden asignar valores por medio de subsiguientes
asignaciones, ni se puede anular su definición con
<b>unset</b>.</dd>

<dt><b>-x</b></dt>

<dd>Marca <i>nombre</i>s para la exportación a órdenes subsecuentes
a través del entorno.</dd>
</dl><p>Usar `+' en vez de `-' desactiva el atributo en vez de
activarlo, con la excepción de que no puede emplearse <b>+a</b>
para destruir una variable vector. Cuando se usa en una función,
hace local cada <i>nombre</i>, como con la orden interna
<b>local</b>. El valor de retorno es 0 a menos que se encuentre una
opción inválida, se intente definir una función utilizando "-f
fuu=bar", se intente asignar un valor a una variable de lectura
exclusiva, se intente asignar un valor a una variable vector sin
emplear la sintaxis de asignación compuesta (vea <b>Vectores</b>
arriba), uno de los <i>nombre</i>s no sea un nombre válido de
variable del shell, se intente desactivar el estado de lectura
exclusiva para una variable de sólo lectura, se intente desactivar
el estado de vector para una variable vector, o se intente mostrar
una función no existente con -f.</p>
</dd>
</dl></dd>

<dt><b>dirs [-clpv</b>] [+<i>n</i>] [-<i>n</i>]</dt>

<dd>Sin opciones, muestra la lista de directorios actualmente
recordados. La forma predeterminada de mostrarlos es en una sola
línea con los nombres de directorios separados por espacios. Los
directorios se añaden a la lista (en realidad, una pila) con la
orden <b>pushd</b>; la orden <b>popd</b> los quita de la pila. 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>+</b><i>n</i></dt>

<dd>Muestra la <i>n</i>-sima entrada contando desde la izquierda de
la lista mostrada por <b>dirs</b> cuando se llama sin opciones,
empezando por cero.</dd>

<dt><b>-</b><i>n</i></dt>

<dd>Muestra la <i>n</i>-sima entrada contando desde la derecha de
la lista mostrada por <b>dirs</b> cuando se llama sin opciones,
empezando por cero.</dd>

<dt><b>-c</b></dt>

<dd>Limpia la pila de directorios borrando todas las entradas.</dd>

<dt><b>-l</b></dt>

<dd>Produce un listado más largo; el formato predeterminado de
listado emplea una tilde de la eñe para señalar el directorio
inicial de trabajo (el "hogar").</dd>

<dt><b>-p</b></dt>

<dd>Muestra la pila de directorios con una entrada por cada
línea.</dd>

<dt><b>-v</b></dt>

<dd>Muestra la pila de directorios con una entrada por línea,
prefijando cada entrada con su índice en la pila.</dd>
</dl><p>El valor de retorno es 0 a menos que se dé una opción inválida o
que <i>n</i> indexe más allá del final de la pila de
directorios.</p>
</dd>
</dl></dd>

<dt><b>disown</b> [<b>-ar</b>] [<b>-h</b>] [<i>espectrab</i>
...]</dt>

<dd>Sin opciones, cada <i>espectrab</i> se quita de la tabla de
trabajos activos. Si se da la opción <b>-h</b>, cada
<i>espectrab</i> no se quita de la tabla, sino que se marca de
manera que no se le enviará la señal <font size="-1"><b>SIGHUP</b></font> si el shell recibe una señal <font size="-1"><b>SIGHUP</b>.</font> Si no hay ningún <i>espectrab</i>
presente, y ni se dan las opciones <b>-a</b> ni <b>-r</b>, se
utiliza el trabajo <i>en curso</i>. Si no se suministra
<i>espectrab</i>, la opción <b>-a</b> significa quitar o marcar
todos los trabajos; la opción <b>-r</b> sin un argumento
<i>espectrab</i> restringe la operación a los trabajos en
ejecución. El valor de retorno es 0 a menos que <i>espectrab</i> no
se refiera a un trabajo válido.</dd>

<dt><b>echo</b> [<b>-neE</b>] [<i>arg</i> ...]</dt>

<dd>Repite los <i>arg</i>s, separados por espacios, seguidos por un
salto de línea. El estado de retorno es siempre 0. Si se especifica
<b>-n</b>, se suprime el salto de línea final. Si se da la opción
<b>-e</b>, se activa la interpretación de los siguientes caracteres
de escape (con barra inversa). La opción <b>-E</b> desactiva la
interpretación de estos caracteres de escape, incluso en sistemas
donde se interpreten de forma predeterminada. <b>echo</b> no
interpreta <b>--</b> como el fin de las opciones. <b>echo</b>
interpreta las siguientes secuencias de escape: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>\a</b></dt>

<dd>alerta (pito)</dd>

<dt><b>\b</b></dt>

<dd>espacio atrás</dd>

<dt><b>\c</b></dt>

<dd>suprime el salto de línea final</dd>

<dt><b>\e</b></dt>

<dd>un carácter Escape</dd>

<dt><b>\f</b></dt>

<dd>salto de página</dd>

<dt><b>\n</b></dt>

<dd>nueva línea</dd>

<dt><b>\r</b></dt>

<dd>retorno de carro</dd>

<dt><b>\t</b></dt>

<dd>tabulador horizontal</dd>

<dt><b>\v</b></dt>

<dd>tabulador vertical</dd>

<dt><b>\\</b></dt>

<dd>barra inclinada invertida</dd>

<dt><b>\</b><i>nnn</i></dt>

<dd>el carácter cuyo código es el valor octal <i>nnn</i> (de uno a
tres dígitos)</dd>

<dt><b>\x</b><i>nnn</i></dt>

<dd>el carácter cuyo código es el valor hexadecimal <i>nnn</i> (de
uno a tres dígitos)</dd>
</dl></dd>
</dl></dd>

<dt><b>enable</b> [<b>-adnps</b>] [<b>-f</b> <i>nombre-fichero</i>]
[<i>nombre</i> ...]</dt>

<dd>Activa y desactiva órdenes internas incorporadas en el shell.
Desactivar una orden incorporada en el shell permite que un
programa cuya imagen ejecutable esté en el disco con el mismo
nombre, se ejecute sin tener que especificar un camino completo,
aun cuando el shell normalmente busca las órdenes internas antes
que las órdenes externas en disco. Si se da <b>-n</b>, cada
<i>nombre</i> se desactiva; si no, <i>nombre</i>s se activan. Por
ejemplo, para emplear el programa binario <b>test</b> encontrado en
el <font size="-1"><b>PATH</b></font> en vez de la versión
incorporada en el shell, ejecute <tt>enable -n test</tt>. La opción
<b>-f</b> significa cargar la nueva orden incorporada <i>nombre</i>
desde el objeto compartido <i>nombre-fichero</i>, en sistemas que
admiten la carga dinámica. La opción <b>-d</b> borrará una orden
interna cargada previamente con <b>-f</b>. Si no se dan argumentos
<i>nombre</i>, o si se da la opción <b>-p</b>, se muestra una lista
de órdenes internas del shell. Sin ninguna opción más, la lista
consiste en todas las órdenes internas activas. Si se da <b>-n</b>,
sólo se muestran las órdenes desactivadas. Si se da <b>-a</b>, la
lista impresa incluye todas las órdenes internas, con una
indicación en cada una de si está activada o no. Si se da
<b>-s</b>, la salida se restringe a las órdenes internas
<i>especiales</i> de POSIX. El valor de retorno es 0 a menos que un
<i>nombre</i> no sea una orden interna del shell o que haya un
problema cargando una nueva orden incorporada desde un objeto
compartido.</dd>

<dt><b>eval</b> [<i>arg</i> ...]</dt>

<dd>Los <i>arg</i>s se leen y concatenan juntos para formar una
sola orden. Entonces el shell lee y ejecuta esta orden, y su estado
de salida se devuelve como el valor de <b>eval</b>. Si no hay
<i>args</i>, o solamente argumentos vacíos, <b>eval</b> devuelve
0.</dd>

<dt><b>exec</b> [<b>-cl</b>] [<b>-a</b> <i>nombre</i>]
[<i>orden</i> [<i>argumentos</i>]]</dt>

<dd>Si se especifica <i>orden</i>, reemplaza al shell. No se crea
ningún proceso nuevo. Los <i>argumentos</i> se convierten en los
argumentos de <i>orden</i>. Si se da la opción <b>-l</b>, el shell
pone un guión en el argumento número cero pasado a <i>orden</i>.
Esto es lo que hace <i><a href="http://localhost/cgi-bin/man/man2html?1+login">login</a></i>(1).
La opción <b>-c</b> hace que <i>orden</i> se ejecute con un entorno
vacío. Si se da <b>-a ,</b> el shell pasa <i>nombre</i> como el
argumento número cero de la orden ejecutada. Si <i>orden</i> no
puede ejecutarse por alguna razón, un shell no interactivo se
acaba, a menos que se haya activado la opción del shell
<b>execfail</b>, en cuyo caso devuelve `fallo'. Un shell
interactivo devuelve `fallo' si el fichero no puede ejecutarse. Si
<i>orden</i> no se especifica, cualquier redirección tiene efecto
en el shell en curso, y el estado devuelto es 0. Si hay un error de
redirección, el estado de retorno es 1.</dd>

<dt><b>exit</b> [<i>n</i>]</dt>

<dd>Hace que el shell acabe con un estado de valor <i>n</i>. Si
<i>n</i> se omite, el valor de salida es el de la última orden
ejecutada. Se ejecuta una trampa puesta en <font size="-1"><b>EXIT</b></font> antes de que el shell termine.</dd>

<dd><b>export</b> [<b>-fn</b>] [<i>nombre</i>[=<i>palabra</i>]]
...</dd>

<dt><b>export -p</b></dt>

<dd>Los <i>nombres</i> suministrados se marcan para exportación
automática al entorno de órdenes que se ejecuten de ahí en
adelante. Si la opción <b>-f</b> se da, los <i>nombres</i> se
referirán a funciones. Si no se dan <i>nombres</i>, o si se da la
opción <b>-p</b>, se muestra una lista de todos los nombres que
están exportados en este shell. La opción <b>-n</b> hace que la
propiedad de exportación se quite de las variables nombradas; o
sea, que se quiten del entorno. <b>export</b> devuelve un estado de
salida de 0 a menos que se encuentre una opción inválida, uno de
los <i>nombre</i>s no sea un nombre válido de variable del shell, o
que se dé <b>-f</b> no siendo <i>nombre</i> una función.</dd>

<dd><b>fc</b> [<b>-e</b> <i>editor</i>] [<b>-nlr</b>]
[<i>primero</i>] [<i>último</i>]</dd>

<dt><b>fc</b> <b>-s</b> [<i>pat</i>=<i>rep</i>] [<i>ord</i>]</dt>

<dd>Corrige orden (Fix Command). En la primera forma, se selecciona
un rango de órdenes desde <i>primero</i> hasta <i>último</i> de la
lista de historia. <i>Primero</i> y <i>último</i> pueden
especificarse como una cadena de caracteres (para localizar la
última orden que empezara con esa cadena) o como un número (un
índice en la lista de historia, donde un número negativo se emplea
como un desplazamiento a partir del número de orden actual). Si no
se da <i>último</i>, se pone a la orden en curso para un listado
(de forma que <b>fc -l -10</b> muestra las 10 últimas órdenes) o a
<i>primero</i> en otro caso. Si no se especifica <i>primero</i>, se
pone a la orden previa para una edición y a -16 para un listado. 
<p>La opción <b>-n</b> suprime los números de orden en un listado.
La opción <b>-r</b> invierte el orden de los mandatos. Si se da la
opción <b>-l ,</b> las órdenes se listan en la salida estándar. Si
no, se llama al editor dado por <i>editor</i> en un fichero
conteniendo esas órdenes. Si no se da <i>editor</i>, se emplea el
valor de la variable <font size="-1"><b>FCEDIT</b>,</font> o el
valor de <font size="-1"><b>EDITOR</b></font> si <font size="-1"><b>FCEDIT</b></font> no está definido. Si no está
definida ni una variable ni otra, <b>vi</b> es el editor que se
empleará. Cuando la edición se haya completado, las órdenes
editadas se muestran y ejecutan.</p>

<p>En la segunda forma, <i>orden</i> se re-ejecuta tras que cada
instancia de <i>pat</i> se reemplace por <i>rep</i>. Un alias de
utilidad para emplear con esto es ``r=fc -s'', de tal modo que al
teclear ``r cc'' se ejecute la última orden que empezara con ``cc''
y que al teclear ``r'' se re-ejecute la última orden.</p>

<p>Si se usa la primera forma, el valor de retorno es 0 a menos que
se encuentre una opción inválida o que <i>primero</i> o
<i>último</i> especifiquen líneas de historia fuera de rango. Si se
suministra la opción <b>-e</b>, el valor de retorno es el de la
última orden ejecutada, o `fallo' si ocurre un error con el fichero
temporal de órdenes. Si se emplea la segunda forma, el estado de
retorno es de la orden reejecutada, a menos que <i>ord</i> no
especifique una línea válida de historia, en cuyo caso <b>fc</b>
devuelve `fallo'.</p>
</dd>

<dt><b>fg</b> [<i>espectrab</i>]</dt>

<dd>Reanuda <i>espectrab</i> en primer plano, y lo hace ser el
trabajo en curso. Si <i>espectrab</i> no está presente, se usa la
noción que tiene el shell del <i>trabajo en curso</i>. El valor de
retorno es el de la orden puesta en primer plano, o `fallo' si se
ejecuta <b>fg</b> cuando el control de trabajos está desactivado o,
cuando se ejecuta con el control de trabajos activado, si
<i>espectrab</i> no especifica un trabajo válido o <i>espectrab</i>
se refiere a una trabajo que se arrancó sin control de
trabajos.</dd>

<dt><b>getopts</b> <i>cadenaopcs</i> <i>nombre</i>
[<i>args</i>]</dt>

<dd><b>getopts</b> se usa en procedimientos del shell para analizar
los parámetros posicionales. <i>cadenaopcs</i> contiene las letras
de opción que se reconocerán; si a una letra le sigue un signo de
dos puntos, se espera que la opción tenga un argumento, que debería
estar separado de ella por espacio en blanco. Cada vez que se
llama, <b>getopts</b> pone la siguiente opción en la variable del
shell <i>nombre</i>, inicializando <i>nombre</i> si no existe, y el
índice del siguiente argumento a ser procesado en la variable <font size="-1"><b>OPTIND</b>.</font> <font size="-1"><b>OPTIND</b></font> se inicializa a 1 cada vez que se
llama al shell o al guión del shell. Cuando una opción requiera un
argumento, <b>getopts</b> pone ese argumento en la variable <font size="-1"><b>OPTARG</b>.</font> El shell no pone a cero <font size="-1"><b>OPTIND</b></font> automáticamente; debe ser puesto a
cero manualmente entre llamadas múltiples a <b>getopts</b> dentro
de la misma llamada al shell si hubiera que usar un nuevo conjunto
de parámetros. 
<p>Cuando se encuentra el fin de las opciones, <b>getopts</b> sale
con un valor de retorno mayor que cero. <b>OPTIND</b> se pone al
índice del primer argumento que no es una opción, y <b>nombre</b>
se pone a "?".</p>

<p><b>getopts</b> normalmente analiza los parámetros posicionales,
pero si se dan más argumentos en <i>args</i>, <b>getopts</b>
analiza aquéllos en su lugar.</p>

<p><b>getopts</b> puede informar de errores de dos maneras. Si el
primer carácter de <i>optstring</i> es dos puntos, se emplea un
informe de error <i>silencioso</i>. En un modo normal de operación
se muestran mensajes de diagnósticos cuando se encuentran opciones
inválidas o faltan argumentos de opciones que los requieran. Si la
variable <font size="-1"><b>OPTERR</b></font> se pone a 0, no se
mostrará ningún mensaje de error, incluso si el primer carácter de
<i>optstring</i> no es dos puntos.</p>

<p>Si se ve una opción inválida, <b>getopts</b> pone ? en
<i>nombre</i> y, si no estamos en el modo silencioso, se muestra un
mensaje de error y se anula <font size="-1"><b>OPTARG</b>.</font>
Si <b>getopts</b> es silencioso, el carácter de opción encontrado
se pone en <font size="-1"><b>OPTARG</b></font> y no se muestra
ningún mensaje de diagnóstico.</p>

<p>Si no se encuentra un argumento necesario, y <b>getopts</b> no
es silencioso, se pone un signo de cierre de interrogación
(<b>?</b>) en <i>nombre</i>, <b>OPTARG</b> se anula, y se muestra
un mensaje de diagnóstico. Si <b>getopts</b> es silencioso,
entonces se pone un signo de dos puntos (<b>:</b>) en <i>nombre</i>
y <font size="-1"><b>OPTARG</b></font> toma el valor del carácter
de opción encontrado.</p>

<p><b>getopts</b> devuelve `verdad' si una opción, especificada o
no, se encuentra. Devuelve `falso' si se encuentra el final de las
opciones o si ocurre un error.</p>
</dd>

<dt><b>hash</b> [<b>-r</b>] [<b>-p</b> <i>nombre-fichero</i>]
[<i>nombre</i>]</dt>

<dd>Para cada <i>nombre</i>, se determina el nombre completo del
fichero correspondiente buscando los directorios en <b>$PATH</b> y
dicho nombre completo se registra. Si se da la opción <b>-p</b> no
se busca en el PATH, y se emplea en su lugar <i>nombre-fichero</i>
como el nombre completo de fichero para la orden. La opción
<b>-r</b> hace que el shell se olvide de todas las localizaciones
registradas. Si no se dan argumentos, se muestra información acerca
de las órdenes recordadas. El estado de salida es `verdad' a menos
que un <i>nombre</i> no se encuentre o se dé una opción
inválida.</dd>

<dt><b>help</b> [<i>patrón</i>]</dt>

<dd>Muestra información de ayuda sobre las órdenes internas. Si se
especifica <i>patrón</i>, <b>help</b> da ayuda detallada sobre
todas las órdenes que concuerden con <i>patrón</i>; si no, se
muestra ayuda para todas las órdenes internas y estructuras de
control del shell. El estado de retorno es 0 a menos que ninguna
orden concuerde con <i>patrón</i>.</dd>

<dd><b>history</b> [<b>-c</b>] [<i>n</i>]</dd>

<dt><b>history</b> <b>-anrw</b> [<i>nombre-fichero</i>]</dt>

<dt><b>history</b> <b>-p</b> <i>arg</i> [<i>arg ...</i>]</dt>

<dt><b>history</b> <b>-s</b> <i>arg</i> [<i>arg ...</i>]</dt>

<dd>Sin opciones, muestra la lista de historia de órdenes con
números de línea. Las líneas marcadas con un <b>*</b> han sido
modificadas. Un argumento de <i>n</i> lista solamente las últimas
<i>n</i> líneas. Si <i>nombre-fichero</i> se da, se emplea como el
nombre del fichero de historia; si no, se usa el valor de <font size="-1"><b>HISTFILE</b>.</font> Las opciones, si se dan, tienen
los siguientes significados: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>-a</b></dt>

<dd>Añade las líneas de historia ``nuevas'' (las introducidas desde
el inicio de la sesión de <b>bash</b> en curso) al fichero de
historia.</dd>

<dt><b>-n</b></dt>

<dd>Lee las líneas de historia que aún no han sido leídas del
fichero de historia y las mete en la lista de historia actual.
Éstas son las líneas añadidas al fichero de historia desde el
comienzo de la sesión de <b>bash</b> actual.</dd>

<dt><b>-r</b></dt>

<dd>Lee los contenidos del fichero de historia y los usa como la
historia en curso.</dd>

<dt><b>-w</b></dt>

<dd>Escribe la historia en curso en el fichero de historia,
sobreescribiendo sus contenidos.</dd>

<dt><b>-c</b></dt>

<dd>Limpia la lista de historia borrando todas las entradas.</dd>

<dt><b>-p</b></dt>

<dd>Realiza la sustitución de historia de los siguientes
<i>args</i> y muestra el resultado en la salida estándar. No
almacena los resultados en el fichero de historia. Cada <i>arg</i>
debe protegerse para deshabilitar la expansión de historia
normal.</dd>

<dt><b>-s</b></dt>

<dd>Almacena los <i>args</i> en la lista de historia como una sola
entrada. La última orden en la lista de historia se elimina antes
de que se añadan los <i>args</i>.</dd>
</dl><p>El valor de retorno es 0 a menos que se encuentre una opción
inválida o que ocurra un error mientras se lee o se escribe el
fichero de historia.</p>
</dd>
</dl></dd>

<dd><b>jobs</b> [<b>-lnprs</b>] [ <i>espectrab</i> ... ]</dd>

<dt><b>jobs</b> <b>-x</b> <i>orden</i> [ <i>args</i> ... ]</dt>

<dd>La primera forma lista los trabajos activos. Las opciones
tienen los significados siguientes: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>-l</b></dt>

<dd>Lista PIDs además de la información normal.</dd>

<dt><b>-p</b></dt>

<dd>Lista solamente el PID del líder del grupo de proceso del
trabajo.</dd>

<dt><b>-n</b></dt>

<dd>Muestra información solamente sobre trabajos que han cambiado
de estado desde que se notificó al usuario por última vez de su
estado.</dd>

<dt><b>-r</b></dt>

<dd>Restringe la salida a los trabajos en ejecución.</dd>

<dt><b>-s</b></dt>

<dd>Restringe la salida a los trabajos parados.</dd>
</dl><p>Si se da <i>espectrab</i>, la salida se restringe a la
información sobre ese trabajo. El estado de retorno es cero a menos
que se encuentre una opción inválida o se suministre un
<i>espectrab</i> inválido.</p>

<p>Si se da la opción <b>-x</b>, <b>jobs</b> reemplaza cualquier
<i>espectrab</i> encontrado en <i>orden</i> o <i>args</i> con el ID
de grupo de proceso correspondiente, y ejecuta <i>orden</i>
pasándole <i>args</i>, devolviendo su estado de salida.</p>
</dd>
</dl></dd>

<dd><b>kill</b> [<b>-s</b> <i>nombre-señal</i> | <b>-n</b>
<i>numseñal</i> | <b>-</b><i>nombre-señal</i>] [<i>pid</i> |
<i>espectrab</i>] ...</dd>

<dt><b>kill</b> <b>-l</b> [<i>nombre-señal</i> |
<i>status_salida</i>]</dt>

<dd>Envía la señal especificada por <i>nombre-señal</i> o
<i>numseñal</i> a los procesos nombrados por <i>pid</i> o
<i>espectrab</i>. <i>nombre-señal</i> es o bien un nombre de señal
como <font size="-1"><b>SIGKILL</b></font> o un número de señal;
<i>numseñal</i> es un número de señal. Si <i>nombre-señal</i> es un
nombre de señal, éste puede darse con o sin el prefijo <font size="-1"><b>SIG</b>.</font> Si <i>nombre-señal</i> no está
presente, entonces se supone <font size="-1"><b>SIGTERM</b>.</font>
Un argumento de <b>-l</b> lista los nombres de señales. Si se
suministran más argumentos cuando se da <b>-l</b>, se listan los
nombres de las señales correspondientes a los argumentos, y el
estado de retorno es 0. El argumento <i>status_salida</i> de
<b>-l</b> es un número que especifica o bien un número de señal o
el estado de salida de un proceso terminado por una señal.
<b>kill</b> devuelve ``verdad'' si por lo menos se envió con éxito
una señal, o ``falso'' si ocurrió un error o se encontró una opción
inválida.</dd>

<dt><b>let</b> <i>arg</i> [<i>arg</i> ...]</dt>

<dd>Cada <i>arg</i> es una expresión aritmética a ser evaluada (vea
<font size="-1"><b>EVALUACIÓN</b>ARITMÉTICA<b>).</b></font> Si el
último <i>arg</i> se evalúa a 0, <b>let</b> devuelve 1; si no,
devuelve 0.</dd>

<dt><b>local</b> [<i>nombre</i>[=<i>valor</i>] ...]</dt>

<dd>Para cada argumento, se crea una variable local llamada
<i>nombre</i>, y se le asigna el valor <i>valor</i>. Cuando
<b>local</b> se emplea dentro de una función, hace que la variable
<i>nombre</i> tenga una visibilidad restringida a esa función y sus
hijas. Sin operandos, <b>local</b> escribe en la salida estándar
una lista de las variables locales. Es un error emplear
<b>local</b> fuera de una función. El estado de retorno es 0 a
menos que <b>local</b> se use fuera de una función, o se dé un
<i>nombre</i> inválido.</dd>

<dt><b>logout</b></dt>

<dd>Hace terminar un shell de entrada.</dd>

<dt><b>popd</b> [-<b>n</b>] [+<i>n</i>] [-<i>n</i>]</dt>

<dd>Quita entradas de la pila de directorios. Sin argumentos,
desapila el directorio de la cima de la pila, y realiza un
<b>cd</b> al nuevo directorio de la pila. Los argumentos, si se
suministran, tienen los siguientes significados: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>+</b><i>n</i></dt>

<dd>Quita la <i>n</i>-sima entrada contando desde la izquierda de
la lista mostrada por <b>dirs</b>, empezando por cero. Por ejemplo:
``popd +0'' quita el primer directorio, ``popd +1'' el
segundo.</dd>

<dt><b>-</b><i>n</i></dt>

<dd>Quita la <i>n</i>-sima entrada contando desde la derecha de la
lista mostrada por <b>dirs</b>, empezando por cero. Por ejemplo:
``popd -0'' quita el último directorio, ``popd -1'' el
penúltimo.</dd>

<dt><b>-n</b></dt>

<dd>Suprime el normal cambio de directorio cuando se desapilan
directorios, de forma que solamente la pila se manipula.</dd>
</dl><p>Si la orden <b>popd</b> es exitosa, también se realiza un
<b>dirs</b>, y el estado de retorno es 0. <b>popd</b> devuelve
`falso' si se encuentra una opción inválida, la pila de directorios
está vacía, se especifica una entrada de la pila de directorios no
existente, o falla el cambio de directorio.</p>
</dd>
</dl></dd>

<dt><b>printf</b> <i>formato</i> [<i>argumentos</i>]</dt>

<dd>Escribe los <i>argumentos</i> formateados en la salida estándar
bajo el control del <i>formato</i>. El <i>formato</i> es una cadena
de caracteres que contiene tres tipos de objetos: caracteres
normales, que simplemente se copian en la salida estándar,
caracteres de secuencias de escape, que se convierten y copian en
la salida estándar, y especificaciones de formato, cada una de las
cuales causa la impresión del siguiente <i>argumento</i> sucesivo
de una determinada manera. Además de los formatos estándares
normales de <i><a href="http://localhost/cgi-bin/man/man2html?1+printf">printf</a></i>(1),
%b hace que <b>printf</b> expanda las secuencias de escape de
barras inversas en el correspondiente <i>argumento</i>, y %q causa
que <b>printf</b> muestre en la salida el <i>argumento</i>
correspondiente en un formato tal que pueda ser reutilizado como
entrada para el shell. 
<p>El <i>formato</i> se reutiliza tanto como sea necesario para
consumir todos los <i>argumentos</i>. Si el <i>formato</i> requiere
más <i>argumentos</i> que los que se suministran, las
especificaciones de formato extra se comportan como si se hubiera
dado un valor cero o una cadena vacía, según lo apropiado.</p>
</dd>

<dd><b>pushd</b> [<b>-n</b>] [<i>dir</i>]</dd>

<dt><b>pushd</b> [<b>-n</b>] [+<i>n</i>] [-<i>n</i>]</dt>

<dd>Añade un directorio a la cima de la pila de directorios, o rota
la pila, haciendo que el directorio de trabajo en curso sea la
nueva cima de la pila. Sin argumentos, intercambia los dos
directorios de más arriba y devuelve 0, a menos que la pila de
directorios esté vacía. Los argumentos, si se suministran, tienen
los siguientes significados: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>+</b><i>n</i></dt>

<dd>Rota la pila de forma que el <i>n</i>-simo directorio (contando
desde la izquierda de la lista mostrada por <b>dirs</b>, empezando
por cero) esté en la cima.</dd>

<dt><b>-</b><i>n</i></dt>

<dd>Rota la pila de forma que el <i>n</i>-simo directorio (contando
desde la derecha de la lista mostrada por <b>dirs</b>, empezando
por cero) esté en la cima.</dd>

<dt><b>-n</b></dt>

<dd>Suprime el cambio normal de directorio cuando se añaden
directorios a la pila, de forma que solamente se manipula la
pila.</dd>

<dt><b>dir</b></dt>

<dd>Añade <i>dir</i> a la pila de directorios en la cima,
haciéndolo el nuevo directorio de trabajo.</dd>
</dl><p>Si la orden <b>pushd</b> acaba con éxito, se realiza un
<b>dirs</b> también. Si se emplea la primera forma, <b>pushd</b>
devuelve 0 a menos que falle el cambio a <i>dir</i>. Con la segunda
forma, <b>pushd</b> devuelve 0 a menos que la pila de directorios
esté vacía, que se especifique un elemento de la pila de
directorios inexistente, o que el cambio de directorio falle.</p>
</dd>
</dl></dd>

<dt><b>pwd</b> [<b>-LP</b>]</dt>

<dd>Muestra el nombre de fichero absoluto del directorio de trabajo
en curso. El nombre de fichero mostrado no contiene enlaces
simbólicos si se da la opción <b>-P</b> o está puesta la opción
<b>-o physical</b> de la orden interna <b>set</b>. Si se usa la
opción <b>-L</b>, los enlaces simbólicos se siguen. El estado de
retorno es 0 a menos que ocurra un error mientras se lea el nombre
del directorio actual o se dé una opción inválida.</dd>

<dt><b>read</b> [<b>-er</b>] [<b>-a</b> <i>array</i>] [<b>-p</b>
<i>prompt</i>] [<i>nombre</i> ...]</dt>

<dd>Se lee una línea desde la entrada estándar, y la primera
palabra se asigna al primer <i>nombre</i>, la segunda palabra al
segundo <i>nombre</i>, y así sucesivamente, con las palabras que
sobren y sus separadores intervinientes asignadas al último
<i>nombre</i>. Si hay menos palabras leídas de la entrada estándar
que nombres, a los sobrantes se les asignan valores vacíos. Se
emplean los caracteres en <font size="-1"><b>IFS</b></font> para
dividir la línea en palabras. Las opciones, si se dan, tienen los
siguientes significados: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>-r</b></dt>

<dd>Un par formado por una barra inclinada inversa y un salto de
línea a continuación sí es tenido en cuenta, y la barra inversa se
considera parte de la línea.</dd>

<dt><b>-p</b></dt>

<dd>Muestra <i>prompt</i>, sin un salto de línea al final, antes de
intentar leer nada de la entrada. El indicador se muestra solamente
si la entrada viene de una terminal.</dd>

<dt><b>-a</b></dt>

<dd>Las palabras se asignan secuencialmente a los elementos de la
variable vector <i>array</i>, empezando por 0. Se anula la posible
previa definición de <i>array</i> antes de que se asignen nuevos
valores. Otros argumentos <i>nombre</i> no se tienen en
consideración.</dd>

<dt><b>-e</b></dt>

<dd>Si la entrada estándar viene de una terminal, se emplea
<b>readline</b> (vea <font size="-1"><b>READLINE</b></font> arriba)
para obtener la línea.</dd>
</dl><p>Si no se suministran <i>nombres</i>, la línea leída se asigna a
la variable <font size="-1"><b>REPLY</b>.</font> El código de
retorno es cero, a menos que se llegue al fin de la entrada.</p>
</dd>
</dl></dd>

<dt><b>readonly</b> [<b>-apf</b>] [<i>nombre</i> ...]</dt>

<dd>Los <i>nombres</i> dados se marcan como de lectura exclusiva;
los valores de estos <i>nombres</i> no pueden cambiarse por
posteriores asignaciones. Si se da la opción <b>-f</b>, se marcan
así las funciones correspondientes a los <i>nombres</i>. La opción
<b>-a</b> restringe las variables a vectores. Si no se da ningún
argumento <i>nombre</i>, o si se da la opción <b>-p</b>, se muestra
una lista de todos los nombres de lectura exclusiva. La opción
<b>-p</b> hace que la salida se muestre en un formato que puede ser
reutilizado como entrada. El estado de retorno es 0 a menos que se
encuentre una opción inválida, uno de los <i>nombres</i> no sea un
nombre válido de variable del shell, o se dé <b>-f</b> con un
<i>nombre</i> que no es una función.</dd>

<dt><b>return</b> [<i>n</i>]</dt>

<dd>Hace que una función acabe y devuelva el valor especificado por
<i>n</i>. Si <i>n</i> se omite, el estado devuelto es el de la
última orden ejecutada en el cuerpo de la función. Si se emplea
fuera de una función, pero durante la ejecución de un guión por la
orden <b>.</b> (<b>source</b>), hace que el shell pare la ejecución
de ese guión y devuelva o <i>n</i> o el estado de salida de la
última orden ejecutada dentro del guión como el estado de salida
del guión. Si se emplea fuera de una función y no durante la
ejecución de un guión por <b>.</b>, el estado de salida es
`falso'.</dd>

<dt><b>set</b> [<b>--abefhkmnptuvxBCHP</b>] [<b>-o</b>
<i>opción</i>] [<i>arg</i> ...]</dt>

<dd>Sin opciones, se muestra el nombre y valor de cada variable del
shell en un formato que puede ser reutilizado como entrada. La
salida se clasifica según la localización en curso. Cuando se dan
opciones, se establecen o quitan atributos del shell. Cualesquier
argumentos que queden tras que se procesen las opciones se tratan
como valores para los parámetros posicionales y se asignan, en
orden, a <b>$1</b>, <b>$2</b>, <b>...</b> <b>$</b><i>n</i>. Las
opciones, si se especifican, tienen los siguientes significados: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>-a</b></dt>

<dd>Automáticamente marca variables, que se modifiquen o creen,
para exportación al entorno de las órdenes subsiguientes.</dd>

<dt><b>-b</b></dt>

<dd>Informa del estado de los trabajos en segundo plano terminados
inmediatamente, en vez de esperar a justo antes de mostrar el
siguiente indicador primario. Esto sólo es efectivo cuando el
control de trabajos está habilitado.</dd>

<dt><b>-e</b></dt>

<dd>Sale inmediatamente si una <i>orden simple</i> (vea <font size="-1"><b>GRAMÁTICA DEL SHELL</b></font> arriba) acaba con un
estado distinto de cero. El shell no acaba si la orden que falle es
parte de un bucle <i>until</i> o <i>while</i>, parte de una
sentencia <i>if</i>, parte de una lista <b>&amp;&amp;</b> o
<b>||</b>, o si el valor devuelto por la orden se invierte mediante
<b>!</b>.</dd>

<dt><b>-f</b></dt>

<dd>Deshabilita la expansión de nombres de caminos.</dd>

<dt><b>-h</b></dt>

<dd>Recuerda la localización de órdenes una vez que se buscan para
la 1ª ejecución. Esto está habilitado de forma predeterminada.</dd>

<dt><b>-k</b></dt>

<dd>Todos los argumentos en forma de sentencias de asignación se
ponen en el entorno para una orden, no solamente aquéllos que
precedan al nombre de la orden.</dd>

<dt><b>-m</b></dt>

<dd>Modo de monitor. Se habilita el control de trabajos. Esta
opción está puesta de forma predeterminada para shells interactivos
en sistemas que lo admitan (vea <font size="-1"><b>CONTROL DE
TRABAJOS</b></font> arriba). Los procesos en segundo plano se
ejecutan en un grupo de proceso separado, y se imprime cuando se
completan una línea conteniendo su estado de salida.</dd>

<dt><b>-n</b></dt>

<dd>Lee órdenes pero no las ejecuta. Esto puede emplearse para
comprobar si un guión del shell tiene errores de sintaxis. Para
shells interactivos esta opción no tiene efecto.</dd>

<dt><b>-o</b> <i>nombre-opción</i></dt>

<dd>El <i>nombre-opción</i> puede ser uno de los siguientes: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>allexport</b></dt>

<dd>Lo miso que <b>-a</b>.</dd>

<dt><b>braceexpand</b></dt>

<dd>Lo miso que <b>-B</b>.</dd>

<dt><b>emacs</b></dt>

<dd>Emplea una interfaz de edición de líneas de órdenes al estilo
de emacs. Esto está activo de forma predeterminada cuando el shell
es interactivo, a menos que se haya arrancado con la opción
<b>--noediting</b>.</dd>

<dt><b>errexit</b></dt>

<dd>Lo mismo que <b>-e</b>.</dd>

<dt><b>hashall</b></dt>

<dd>Lo mismo que <b>-h</b>.</dd>

<dt><b>histexpand</b></dt>

<dd>Lo mismo que <b>-H</b>.</dd>

<dt><b>history</b></dt>

<dd>Habilita la historia de órdenes, según se describió arriba bajo
<font size="-1"><b>HISTORIA</b>.</font> Esta opción está habilitada
por omisión en shells interactivos.</dd>

<dt><b>ignoreeof</b></dt>

<dd>El efecto es como si se hubiera ejecutado la orden del shell
<tt>IGNOREEOF=10</tt> (vea <b>Variables del shell</b> arriba).</dd>

<dt><b>keyword</b></dt>

<dd>Lo mismo que <b>-k</b>.</dd>

<dt><b>monitor</b></dt>

<dd>Lo mismo que <b>-m</b>.</dd>

<dt><b>noclobber</b></dt>

<dd>Lo mismo que <b>-C</b>.</dd>

<dt><b>noexec</b></dt>

<dd>Lo mismo que <b>-n</b>.</dd>

<dt><b>noglob</b></dt>

<dd>Lo mismo que <b>-f</b>.</dd>

<dt><b>notify</b></dt>

<dd>Lo mismo que <b>-b</b>.</dd>

<dt><b>nounset</b></dt>

<dd>Lo mismo que <b>-u</b>.</dd>

<dt><b>onecmd</b></dt>

<dd>Lo mismo que <b>-t</b>.</dd>

<dt><b>physical</b></dt>

<dd>Lo mismo que <b>-P</b>.</dd>

<dt><b>posix</b></dt>

<dd>Cambia el comportamiento de <b>bash</b> donde la operación
predeterminada difiera del estándar POSIX 1003.2, de forma que se
siga éste.</dd>

<dt><b>privileged</b></dt>

<dd>Lo mismo que <b>-p</b>.</dd>

<dt><b>verbose</b></dt>

<dd>Lo mismo que <b>-v</b>.</dd>

<dt><b>vi</b></dt>

<dd>Emplea una interfaz de edición de la línea de órdenes al estilo
de vi.</dd>

<dt><b>xtrace</b></dt>

<dd>Lo mismo que <b>-x</b>.</dd>
</dl><p>Si se da <b>-o</b> sin ningún <i>nombre-opción</i>, se muestran
los valores de las opciones activas. Si se da <b>+o</b> sin ningún
<i>nombre-opción</i>, se muestra en la salida estándar una serie de
órdenes <b>set</b> para recrear las opciones según están puestas o
no actualmente.</p>
</dd>
</dl></dd>

<dt><b>-p</b></dt>

<dd>Activa el modo <i>privilegiado</i>. En este modo, el fichero
correspondiente a <b>$ENV</b> no es procesado, las funciones del
shell no se heredan desde el entorno,y la variable
<b>SHELLOPTS</b>, si aparece en el entorno, no se tiene en
consideración. Esta opción se activa automáticamente en el arranque
si el identificador efectivo del usuario (o grupo) no es igual al
identificador real del usuario (o grupo). Desactivar esta opción
hace que los identificadores efectivos de usuario y grupo se pongan
con los valores de los identificadores reales de usuario y grupo
respectivamente.</dd>

<dt><b>-t</b></dt>

<dd>Sale tras leer y ejecutar una sola orden.</dd>

<dt><b>-u</b></dt>

<dd>Trata las variables no definidas como un error cuando realiza
la expansión de parámetros. Si la expansión se intenta hacer sobre
una variable no definida, el shell muestra un mensaje de error y,
si no es interactivo, sale con un estado distinto de cero.</dd>

<dt><b>-v</b></dt>

<dd>Repite en la salida las líneas de entrada del shell tras
leerlas.</dd>

<dt><b>-x</b></dt>

<dd>Tras expandir cada <i>orden simple</i>, muestra el valor
expandido de <font size="-1"><b>PS4</b>,</font> seguido por la
orden y sus argumentos expandidos.</dd>

<dt><b>-B</b></dt>

<dd>El shell realiza la expansión de llaves (vea <b>Expansión de
llaves</b> arriba). Esto está activado de forma
predeterminada.</dd>

<dt><b>-C</b></dt>

<dd>Si está activo, <b>bash</b> no sobreescribe un fichero
existente con los operadores de redirección <b>&gt;</b>,
<b>&gt;&amp;</b>, ni <b>&lt;&gt;</b>. Esto puede cambiarse cuando
se crean ficheros de salida mediante el empleo del operador
<b>&gt;|</b> en vez de <b>&gt;</b>.</dd>

<dt><b>-H</b></dt>

<dd>Permite la sustitución de historia mediante <b>!</b>. Esta
opción está activada por omisión cuando el shell es
interactivo.</dd>

<dt><b>-P</b></dt>

<dd>Si está activada, el shell no sigue enlaces simbólicos cuando
ejecuta órdenes como <b>cd</b> que cambian el directorio de
trabajo. En su lugar emplea la estructura de directorio física. De
forma predeterminada, <b>bash</b> sigue la cadena lógica de
directorios cuando ejecuta órdenes que cambian el directorio de
trabajo.</dd>

<dt><b>--</b></dt>

<dd>Si a esta opción no sigue ningún argumento más, entonces los
parámetros posicionales se anulan. Si no, los parámetros
posicionales se ponen con los valores dados por los <i>arg</i>s,
incluso si alguno de ellos comienza con un <b>-</b>.</dd>

<dt><b>-</b></dt>

<dd>Señala el final de las opciones, haciendo que el resto de
<i>arg</i>s se asignen a los parámetros posicionales. Las opciones
<b>-x</b> y <b>-v</b> se desactivan. Si no hay más <i>arg</i>s, los
parámetros posicionales permanecen sin cambios.</dd>
</dl><p>Las opciones están desactivadas de forma predeterminada a menos
que se diga otra cosa. Usar + en vez de - hace que estas opciones
se desactiven. Las opciones también pueden darse como argumentos al
llamar al shell. El conjunto de opciones activadas puede examinarse
en <b>$-</b>. El estado de retorno es siempre `verdad' a menos que
se encuentre una opción inválida.</p>
</dd>
</dl></dd>

<dt><b>shift</b> [<i>n</i>]</dt>

<dd>Los parámetros posicionales desde <i>n</i>+1 ... se renombran a
<b>$1</b> <b>...</b> Los parámetros representados por los números
desde <b>$#</b> hasta <b>$#</b>-<i>n</i>+1 se anulan. <i>n</i> debe
ser un número no negativo menor o igual a <b>$#</b>. Si <i>n</i> es
0, no se cambia ningún parámetro. Si <i>n</i> no se da, se supone
1. Si <i>n</i> es mayor que <b>$#</b>, los parámetros posicionales
no se cambian. El estado de retorno es mayor que cero si <i>n</i>
es mayor que <b>$#</b> o menor que cero; en otro caso es cero.</dd>

<dt><b>shopt</b> [<b>-pqsu</b>] [<b>-o</b>] [<i>nombreopc</i>
...]</dt>

<dd>Cambia los valores de variables que controlan un comportamiento
determinado opcional del shell. Sin opciones, o con la opción
<b>-p</b>, se muestra una lista de todas las opciones disponibles,
con una indicación en cada una de si está activa o no. La opción
<b>-p</b> hace que la salida se muestre de una forma tal que pueda
reutilizarse como entrada. Otras opciones tienen los significados
siguientes: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>-s</b></dt>

<dd>Activa (set) cada <i>nombreopc</i>.</dd>

<dt><b>-u</b></dt>

<dd>Desactiva (unset) cada <i>nombreopc</i>.</dd>

<dt><b>-q</b></dt>

<dd>Suprime la salida normal (modo silencioso); el estado de salida
indica si el <i>nombreopc</i> está activado o no. Si se dan varios
argumentos <i>nombreopc</i> con <b>-q</b>, el estado de salida es
cero si todos los <i>nombreopcs</i> están activados; distinto de
cero en otro caso.</dd>

<dt><b>-o</b></dt>

<dd>Restringe los valores de <i>nombreopc</i> a aquéllos definidos
para la opción <b>-o</b> de la orden interna <b>set</b>.</dd>
</dl><p>Si se emplean <b>-s</b> o <b>-u</b> sin argumentos
<i>nombreopc</i>, la lista mostrada se limita a aquellas opciones
que están activadas o desactivadas, respectivamente. A menos que se
diga otra cosa, las opciones de <b>shopt</b> están inactivas
(unset) de forma predeterminada.</p>

<p>El estado de retorno cuando se listan opciones es cero si todos
los <i>nombreopcs</i> están activos, distinto de cero en otro caso.
Cuando se activan o desactivan opciones, el estado de salida es
cero a menos que un <i>nombreopc</i> no sea una opción del shell
válida.</p>

<p>La lista de las opciones de <b>shopt</b> es:</p>

<dl compact="compact"><dt><b>cdable_vars</b></dt>

<dd>Si está activa, un argumento de la orden interna <b>cd</b> que
no sea un directorio, se supone el nombre de una variable cuyo
valor es el directorio al que hay que cambiarse.</dd>

<dt><b>cdspell</b></dt>

<dd>Si está activa, se corregirán pequeños errores que hubiera en
la escritura de un componente directorio de una orden <b>cd</b>.
Los errores que se buscan se refieren a caracteres transpuestos, un
carácter que falte, y un carácter que sobre. Si se encuentra una
corrección, se muestra el nombre de fichero corregido y la orden
procede. Esta opción sólo se emplea en shells interactivos.</dd>

<dt><b>checkhash</b></dt>

<dd>Si está activa, <b>bash</b> comprueba que una orden encontrada
en la tabla de dispersión existe antes de intentar ejecutarlo. Si
una orden en la tabla de dispersión ya no existe, se realiza una
búsqueda normal en el PATH.</dd>

<dt><b>checkwinsize</b></dt>

<dd>Si está activa, <b>bash</b> comprueba el tamaño de ventana tras
cada orden y, si es necesario, actualiza los valores de <font size="-1"><b>LINES</b></font> y <font size="-1"><b>COLUMNS</b>.</font></dd>

<dt><b>cmdhist</b></dt>

<dd>Si está activa, <b>bash</b> intenta guardar todas las líneas de
una orden de varias líneas en la misma entrada de historia. Esto
permite una re-edición fácil de dichas órdenes.</dd>

<dt><b>dotglob</b></dt>

<dd>Si está activa, <b>bash</b> incluye los nombres de ficheros que
comiencen con un `.' en los resultados de la expansión de nombres
de caminos.</dd>

<dt><b>execfail</b></dt>

<dd>Si está activa, un shell no interactivo no acabará si no puede
ejecutar el fichero especificado como un argumento de la orden
interna <b>exec</b>. Un shell interactivo no acaba si <b>exec</b>
falla.</dd>

<dt><b>expand_aliases</b></dt>

<dd>Si está activa, los alias se expanden como se describió arriba
bajo <font size="-1"><b>ALIAS</b>.</font> Esta opción está
habilitada de forma predeterminada para shells interactivos.</dd>

<dt><b>extglob</b></dt>

<dd>Si está activa, se habilitan las características de
concordancia de patrones extendidas descritas más arriba en
<b>Expansión de nombres de camino</b>.</dd>

<dt><b>histappend</b></dt>

<dd>Si está activa, la lista de historia se añade al fichero
nombrado según el valor de la variable <b>HISTFILE</b> cuando el
shell acaba, en vez de sobreescribir el fichero.</dd>

<dt><b>histreedit</b></dt>

<dd>Si está activa, y <b>readline</b> se está utilizando, se le da
al usuario la oportunidad de re-editar la sustitución de historia
fallida.</dd>

<dt><b>histverify</b></dt>

<dd>Si está activa, y <b>readline</b> se está utilizando, los
resultados de la sustitución de historia no se pasan inmediatamente
al analizador del shell. En vez de eso, la línea resultante se
carga en el búfer de edición de <b>readline</b>, permitiendo así
una modificación posterior.</dd>

<dt><b>hostcomplete</b></dt>

<dd>Si está activa, y <b>readline</b> se está utilizando,
<b>bash</b> intentará terminar de escribir un nombre de computador
anfitrión cuando se esté completando una palabra que contenga una
<b>@</b> (vea <b>Terminación</b> bajo <font size="-1"><b>READLINE</b></font> arriba). Esto está activado de
forma predeterminada.</dd>

<dt><b>huponexit</b></dt>

<dd>Si está activa, <b>bash</b> enviará una señal <font size="-1"><b>SIGHUP</b></font> a todos los trabajos cuando un shell
de entrada interactivo finalice.</dd>

<dt><b>interactive_comments</b></dt>

<dd>Si está activa, permite a una palabra que empiece por <b>#</b>
hacer que esa palabra y todos los caracteres restantes de esa línea
no sean tenidos en cuenta en un shell interactivo (vea <font size="-1"><b>COMENTARIOS</b></font> arriba). Esta opción está
habilitada por omisión.</dd>

<dt><b>lithist</b></dt>

<dd>Si está activa, y la opción <b>cmdhist</b> también lo está, las
órdenes multi-línea se guardan en la historia con saltos de línea
empotrados en vez de emplear como separador el punto y coma, donde
sea posible.</dd>

<dt><b>mailwarn</b></dt>

<dd>Si está activa, y a un fichero donde <b>bash</b> está buscando
correo nuevo se ha accedido desde la última vez que se buscó, se
muestra el mensaje ``The mail in <i>mailfile</i> has been read'', o
su equivalente en el idioma local, que en español sería ``El correo
en <i>buzón</i> ha sido leído''.</dd>

<dt><b>nocaseglob</b></dt>

<dd>Si está activa, <b>bash</b> busca concordancias de nombres de
ficheros sin importar mayúsculas o minúsculas cuando realice la
expansión de nombres de caminos (vea <b>Expansión de nombres de
caminos</b> arriba).</dd>

<dt><b>nullglob</b></dt>

<dd>Si está activa, <b>bash</b> permite que los patrones que no
concuerden con ningún fichero (vea <b>Expansión de nombres de
caminos</b> arriba) se expandan a una cadena vacía, en vez de a sí
mismos.</dd>

<dt><b>promptvars</b></dt>

<dd>Si está activa, las cadenas de caracteres que sirven de
indicadores están sujetas a expansión de variable y parámetro tras
ser expandidas como se describió en <font size="-1"><b>INDICADORES</b></font> arriba. Esta opción está activa
de forma predeterminada.</dd>

<dt><b>shift_verbose</b></dt>

<dd>Si está activa, la orden interna <b>shift</b> muestra un
mensaje de error cuando el número de shift excede al de parámetros
posicionales.</dd>

<dt><b>sourcepath</b></dt>

<dd>Si está activa, la orden interna <b>source</b> (<b>.</b>)
emplea el valor de <font size="-1"><b>PATH</b></font> para buscar
el directorio que contenga al fichero suministrado como argumento.
Esta opción está activa por omisión.</dd>
</dl></dd>
</dl></dd>

<dt><b>suspend</b> [<b>-f</b>]</dt>

<dd>Suspende la ejecución de este shell hasta que reciba una señal
<font size="-1"><b>SIGCONT</b>.</font> La opción <b>-f</b> dice que
no hay que protestar si éste es un shell de entrada; simplemente
suspenderlo de todas formas. El estado de retorno es 0 a menos que
el shell sea de entrada y la opción <b>-f</b> no se haya dado, o si
el control de trabajos no está habilitado.</dd>

<dd><b>test</b> <i>expr</i></dd>

<dt><b>[</b> <i>expr</i> <b>]</b></dt>

<dd>Devuelve un estado de 0 ó 1 dependiendo de la evaluación de la
expresión condicional <i>expr</i>. Cada operador y operando debe
ser un argumento separado. Las expresiones se componen de las
primarias descritas más arriba bajo <font size="-1"><b>EXPRESIONES</b>CONDICIONALES<b>.</b></font> 
<p>Las expresiones se pueden combinar mediante los operadores
siguientes, listados en orden decreciente de precedencia.</p>

<dl compact="compact"><dd>
<dl compact="compact"><dt><b>!</b> <i>expr</i></dt>

<dd>Verdad si <i>expr</i> es falsa.</dd>

<dt><b>(</b> <i>expr</i> )</dt>

<dd>Devuelve el valor de <i>expr</i>. Esto puede emplearse para
cambiar la precedencia normal de los operadores.</dd>

<dt><i>expr1</i> -<b>a</b> <i>expr2</i></dt>

<dd>Verdad si tanto <i>expr1</i> como <i>expr2</i> son verdad.</dd>

<dt><i>expr1</i> -<b>o</b> <i>expr2</i></dt>

<dd>Verdad si uno al menos de <i>expr1</i> o <i>expr2</i> es
verdad.</dd>
</dl><p><b>test</b> y <b>[</b> evalúan expresiones condicionales según
un conjunto de reglas basadas en el número de argumentos.</p>

<dl compact="compact"><dt>0 argumentos</dt>

<dd>La expresión es falsa.</dd>

<dt>1 argumento</dt>

<dd>La expresión es verdad si y sólo si el argumento no está
vacío.</dd>

<dt>2 argumentos</dt>

<dd>Si el primer argumento es <b>!</b>, la expresión es verdad si y
sólo si el segundo argumento es nulo. Si el primer argumento es uno
de los operadores condicionales monarios listados arriba en <font size="-1"><b>EXPRESIONES</b>CONDICIONALES<b>,</b></font> la
expresión es verdad si el test monario es verdad. Si el primer
argumento no es un operador condicional monario válido, la
expresión es falsa.</dd>

<dt>3 argumentos</dt>

<dd>Si el segundo argumento es uno de los operadores condicionales
binarios listados arriba en <font size="-1"><b>EXPRESIONES</b>CONDICIONALES<b>,</b></font> el
resultado de la expresión es el resultado del test binario
empleando el primer y tercer argumentos como operandos. Si el
primer argumento es <b>!</b>, el valor es la negación del test de
dos argumentos empleando el segundo y tercer argumentos. Si el
primer argumento es exactamente <b>(</b> y el tercer argumento es
exactamente <b>)</b>, el resultado es el test de un argumento del
segundo argumento. De otro modo, la expresión es falsa. Los
operadores <b>-a</b> y <b>-o</b> se consideran como operadores
binarios en este caso.</dd>

<dt>4 argumentos</dt>

<dd>Si el primer argumento es <b>!</b>, el resultado es la negación
de la expresión de tres argumentos compuesta por los argumentos
restantes. De otra forma, la expresión se analiza y evalúa de
acuerdo con la precedencia utilizando las reglas listadas
arriba.</dd>

<dt>5 ó más argumentos</dt>

<dd>La expresión se analiza y evalúa de acuerdo con la precedencia
usando las reglas mencionadas arriba.</dd>
</dl></dd>
</dl></dd>

<dt><b>times</b></dt>

<dd>Muestra los tiempos acumulados de usuario y sistema para el
shell y para procesos ejecutados desde él. El estado de retorno es
0.</dd>

<dt><b>trap</b> [<b>-lp</b>] [<i>arg</i>] [<i>nombre-señal</i>
...]</dt>

<dd>La orden <i>arg</i> va a leerse y ejecutarse cuando el shell
reciba la(s) señal(es) especificada(s) por <i>nombre-señal</i>. Si
<i>arg</i> está ausente o es <b>-</b>, todas las señales
especificadas se reestablecen a sus valores originales (los que
tenían cuando se entró en el shell). Si <i>arg</i> es la cadena
vacía, la señal especificada por cada <i>nombre-señal</i> no se
tiene en cuenta por parte del shell y de las órdenes que se llamen
desde él. Si <i>arg</i> es <b>-p</b> entonces se muestran las
órdenes de las trampas asociadas con cada <i>nombre-señal</i>. Si
no se pasan argumentos o si sólo se da <b>-p</b>, <b>trap</b>
muestra la lista de órdenes asociadas con cada número de señal.
Cada <i>nombre-señal</i> es o bien un nombre de señal de los
definidos en &lt;<i>signal.h</i>&gt;, o un número de señal. Si un
<i>nombre-señal</i> es <font size="-1"><b>EXIT</b></font> (0), la
orden <i>arg</i> se ejecuta cuando se sale del shell. Si un
<i>nombre-señal</i> es <font size="-1"><b>DEBUG</b>,</font> la
orden <i>arg</i> se ejecuta tras cada <i>orden simple</i> (vea
<font size="-1"><b>GRAMÁTICA DEL SHELL</b></font> arriba). La
opción <b>-l</b> hace que el shell muestre una lista de nombres de
señal y sus números correspondientes. Las señales que no se tienen
en cuenta ya cuando se entra en el shell no pueden ser atrapadas ni
restablecidas. Las señales atrapadas se reestablecen a sus valores
originales en un proceso hijo cuando se crea. El estado de retorno
es `falso' si cualquier <i>nombre-señal</i> no es válido; de otro
modo, <b>trap</b> devuelve `verdad'.</dd>

<dt><b>type</b> [<b>-atp</b>] <i>nombre</i> [<i>nombre</i>
...]</dt>

<dd>Sin opciones, indica cómo será interpretado cada <i>nombre</i>
si se usa como un nombre de orden. Si se emplea la opción
<b>-t</b>, <b>type</b> muestra una de las siguientes cadenas de
caracteres: <i>alias</i>, <i>keyword</i>, <i>function</i>,
<i>builtin</i>, o <i>file</i> si <i>nombre</i> es respectivamente
un alias, una palabra reservada del shell, una función, una orden
interna incorporada en el shell, o un fichero ejecutable de disco.
Si el <i>nombre</i> no se encuentra, no se muestra nada, y se
devuelve un estado de salida de `falso'. Si se emplea la opción
<b>-p</b>, <b>type</b> devuelve o bien el nombre del fichero de
disco que se ejecutaría si se especificara <i>nombre</i> como un
nombre de orden, o bien nada si <tt>type -t nombre</tt> no
devolviera <i>file</i>. Si una orden está en la tabla de
dispersión, <b>-p</b> muestra el valor de dicha tabla, no
necesariamente el fichero que aparezca primero en <font size="-1"><b>PATH</b>.</font> Si se emplea la opción <b>-a</b>,
<b>type</b> muestra todos los sitios que contengan un ejecutable
llamado <i>nombre</i>. Esto incluye alias y funciones, si y sólo si
la opción <b>-p</b> no se ha usado también. La tabla de dispersión
de las órdenes no se consulta cuando se emplea <b>-a</b>.
<b>type</b> devuelve `verdad' si cualquiera de los argumentos se
encuentra, `falso' si no se encuentra ninguno.</dd>

<dt><b>ulimit</b> [<b>-SHacdflmnpstuv</b> [<i>límite</i>]]</dt>

<dd>Proporciona control sobre los recursos disponibles para el
shell y para los procesos arrancados por él, en sistemas que
permitan tal control (Linux por ejemplo, y por supuesto). El valor
de <i>límite</i> puede ser un número en la unidad especificada para
el recurso, o el valor <b>unlimited</b>, o sea, ilimitado. Las
opciones <b>-H</b> y <b>-S</b> especifican que el límite para el
recurso dado va a ser duro o blando. Un límite duro es aquél que no
puede ser aumentado una vez puesto; un límite blando puede
incrementarse hasta el valor dado por el límite duro. Si no se
especifican ni <b>-H</b> ni <b>-S</b>, se establecen ambos límites.
Si <i>límite</i> se omite, se muestran los valores del límite
blando del recurso, a menos que se dé la opción <b>-H</b>. Cuando
se especifica más de un recurso, se imprime el nombre del límite y
la unidad antes del valor. Otras opciones se interpretan como
sigue: 
<dl compact="compact"><dd>
<dl compact="compact"><dt><b>-a</b></dt>

<dd>Se informa de todos los límites actuales</dd>

<dt><b>-c</b></dt>

<dd>El tamaño máximo de ficheros de volcados de memoria (core)</dd>

<dt><b>-d</b></dt>

<dd>El tamaño máximo del segmento de datos de un proceso</dd>

<dt><b>-f</b></dt>

<dd>El tamaño máximo de ficheros creados por el shell</dd>

<dt><b>-l</b></dt>

<dd>El tamaño máximo que puede ser bloqueado en memoria</dd>

<dt><b>-m</b></dt>

<dd>El tamaño del máximo conjunto residente (memoria)</dd>

<dt><b>-n</b></dt>

<dd>EL número máximo de descriptores de ficheros abiertos (la
mayoría de sistemas no permiten establecer este valor)</dd>

<dt><b>-p</b></dt>

<dd>El tamaño de una tubería en bloques de 512 B (esto puede no
estar establecido)</dd>

<dt><b>-s</b></dt>

<dd>El tamaño máximo de pila</dd>

<dt><b>-t</b></dt>

<dd>La máxima cantidad de tiempo de CPU en segundos</dd>

<dt><b>-u</b></dt>

<dd>El número máximo de procesos disponibles para un solo
usuario</dd>

<dt><b>-v</b></dt>

<dd>La máxima cantidad de memoria virtual disponible para el
shell</dd>
</dl><p>Si se da <i>límite</i>, es el nuevo valor del recurso
especificado (la opción <b>-a</b> es sólo para mostrar los
valores). Si no se da ninguna opción, entonces se supone <b>-f</b>.
Los valores están en incrementos de 1024 B, excepto para <b>-t</b>,
que está en segundos, <b>-p</b>, que está en unidades de bloques de
512 B, y <b>-n</b> y <b>-u</b>, que son valores adimensionales. El
estado de retorno es 0 a menos que se encuentre una opción
inválida, se dé como <i>límite</i> un argumento no numérico
distinto de <b>unlimited</b>, o bien ocurra un error mientras se
establece un nuevo límite.</p>
</dd>
</dl></dd>

<dt><b>umask</b> [<b>-p</b>] [<b>-S</b>] [<i>modo</i>]</dt>

<dd>La máscara de creación de ficheros del usuario se establece a
<i>modo</i>. Si <i>modo</i> empieza con un dígito, se interpreta
como un número octal; si no, se interpreta como un modo simbólico
similar al aceptado por <i><a href="http://localhost/cgi-bin/man/man2html?1+chmod">chmod</a></i>(1).
Si <i>modo</i> se omite, o si se da la opción <b>-S</b>, se muestra
el valor actual de la máscara. La opción <b>-S</b> hace que la
máscara se imprima en forma simbólica; la salida predeterminada es
como un número octal. Si se da la opción <b>-p</b> y <i>modo</i> se
omite, la salida es de tal forma que puede reutilizarse como
entrada. El estado de retorno es 0 si el modo se cambió
exitosamente o si no se dio el argumento <i>modo</i>, y `falso' en
otra circunstancia.</dd>

<dt><b>unalias</b> [-<b>a</b>] [<i>nombre</i> ...]</dt>

<dd>Quita <i>nombre</i>s de la lista de alias definidos. Si se da
la opción <b>-a</b>, se quitan todas las definiciones de alias. El
estado de salida es `verdad' a menos que un <i>nombre</i> dado no
sea un alias definido.</dd>

<dt><b>unset</b> [-<b>fv</b>] [<i>nombre</i> ...]</dt>

<dd>Para cada <i>nombre</i>, borra la variable o función
correspondiente. Si no se dan opciones, o se da la opción
<b>-v</b>, cada <i>nombre</i> se refiere a una variable del shell.
Las variables de lectura exclusiva no pueden borrarse. Si se
especifica <b>-f</b>, cada <i>nombre</i> se refiere a una función
del shell, y se borra la definición de la función. Cada variable o
función se quita del entorno pasado a órdenes subsiguientes. Si se
quita cualquiera de <font size="-1"><b>RANDOM</b>,</font> <font size="-1"><b>SECONDS</b>,</font> <font size="-1"><b>LINENO</b>,</font> <font size="-1"><b>HISTCMD</b>,</font> o <font size="-1"><b>DIRSTACK</b>,</font> pierde su propiedad especial,
incluso aunque más adelante se vuelva a definir. El estado de
salida es `verdad' a menos que <i>nombre</i> no exista o sea de
lectura exclusiva.</dd>

<dt><b>wait</b> [<i>n</i>]</dt>

<dd>Espera al proceso especificado y devuelve su estado de
terminación. <i>n</i> puede ser un identificador de proceso (PID) o
una especificación de trabajo; si se da una espec. de trabajo, se
espera a todos los procesos en la tubería de ese trabajo. Si
<i>n</i> no se da, se espera a todos los procesos hijos activos
actualmente, y el estado de retorno es cero. Si <i>n</i> especifica
un proceso o trabajo no existente, el estado de retorno es 127. De
otro modo, el estado de retorno es el estado de salida del último
proceso o trabajo al que se esperó.</dd>
</dl><a id="lbCW"> </a><h2>SHELL RESTRINGIDA</h2><p>Si <b>bash</b> se arranca con el nombre <b>rbash</b>, o se da la
opción <b>-r</b> en la llamada, el shell se convierte en
restringido. Un shell restringido se emplea para establecer un
ambiente más controlado que el que el shell estándar proporciona.
Se comporta de forma idéntica a <b>bash</b> con la excepción de que
lo siguiente no está permitido o no se realiza:</p><dl compact="compact"><dt>*</dt>

<dd>cambiar de directorio con <b>cd</b></dd>

<dt>*</dt>

<dd>establecer o anular los valores de <b>SHELL</b> o de
<b>PATH</b></dd>

<dt>*</dt>

<dd>especificar nombres de órdenes que contengan <b>/</b></dd>

<dt>*</dt>

<dd>especificar un nombre de fichero que contenga al menos una
<b>/</b> como un argumento de la orden interna <b>.</b>
(<b>source</b>)</dd>

<dt>*</dt>

<dd>importar definiciones de funciones desde el entorno del shell
en el arranque</dd>

<dt>*</dt>

<dd>analizar el valor de <b>SHELLOPTS</b> desde el entorno del
shell en el arranque</dd>

<dt>*</dt>

<dd>redirigir la salida usando los operadores de redirección &gt;,
&gt;|, &lt;&gt;, &gt;&amp;, &amp;&gt;, y &gt;&gt;</dd>

<dt>*</dt>

<dd>utilizar la orden interna <b>exec</b> para reemplazar el shell
por otro programa</dd>

<dt>*</dt>

<dd>añadir o eliminar órdenes incorporadas con las opciones
<b>-f</b> o <b>-d</b> de la orden interna <b>enable</b>.</dd>

<dt>*</dt>

<dd>dar la opción <b>-p</b> a la orden interna <b>command</b>.</dd>

<dt>*</dt>

<dd>desactivar el modo restringido con <b>set +r</b> o <b>set +o
restricted</b>.</dd>
</dl><p>Estas restricciones entran en vigor después de que se lean los
ficheros de arranque que hubiera.</p><p>Cuando se ejecuta una orden que resulta ser un guión del shell
(vea <font size="-1"><b>EJECUCIÓN DE ÓRDENES</b></font> arriba),
<b>rbash</b> desactiva todas las restricciones en el shell lanzado
para ejecutar el guión. <a id="lbCX"> </a></p><h2>VÉASE TAMBIÉN</h2><dl compact="compact"><dt><i>Bash Features</i> (Características de Bash), Brian Fox &amp;
Chet Ramey</dt>

<dt><i>The Gnu Readline Library</i> (La Biblioteca Readline de
GNU), Brian Fox &amp; Chet Ramey</dt>

<dt><i>The Gnu History Library</i> (La Biblioteca de Historia de
GNU), Brian Fox &amp; Chet Ramey</dt>

<dt><i>Portable Operating System Interface (POSIX) Part 2: Shell
and Utilities</i> (Interfaz para Sistemas Operativos Transportables
(POSIX) Parte 2: Shell y Utilidades), IEEE</dt>

<dt><i><a href="http://localhost/cgi-bin/man/man2html?1+zsh">zsh</a></i>(1),
<i><a href="http://localhost/cgi-bin/man/man2html?1+ash">ash</a></i>(1),
<i><a href="http://localhost/cgi-bin/man/man2html?1+sh">sh</a></i>(1),
<i><a href="http://localhost/cgi-bin/man/man2html?1+ksh">ksh</a></i>(1),
<i><a href="http://localhost/cgi-bin/man/man2html?1+csh">csh</a></i>(1),
<i><a href="http://localhost/cgi-bin/man/man2html?1+tcsh">tcsh</a></i>(1).</dt>

<dt><i><a href="http://localhost/cgi-bin/man/man2html?1+emacs">emacs</a></i>(1),
<i><a href="http://localhost/cgi-bin/man/man2html?1+vi">vi</a></i>(1)</dt>

<dt><i><a href="http://localhost/cgi-bin/man/man2html?3+readline">readline</a></i>(3)</dt>
</dl><a id="lbCY"> </a><h2>FICHEROS</h2><dl compact="compact"><dt><i>/bin/bash</i></dt>

<dd>La imagen ejecutable de <b>bash</b></dd>

<dt><i>/etc/profile</i></dt>

<dd>El fichero de inicio general, leído en shells de entrada</dd>

<dt><i>~/.bash_profile</i></dt>

<dd>El fichero de inicio personal, leído para shells de
entrada</dd>

<dt><i>~/.bashrc</i></dt>

<dd>El fichero individual de arranque para shells interactivos</dd>

<dt><i>~/.inputrc</i></dt>

<dd>El fichero de inicio individual de <i>readline</i></dd>
</dl><a id="lbCZ"> </a><h2>AUTORES</h2><p>

Brian Fox, Free Software Foundation <br /><a href="mailto:bfox@gnu.ai.MIT.Edu">bfox@gnu.ai.MIT.Edu</a> 
</p><p>Chet Ramey, Case Western Reserve University<br /><a href="mailto:chet@ins.CWRU.Edu">chet@ins.CWRU.Edu</a></p><p>Traducción al español: Gerardo Aburruzaga García, para el
proyecto PAMELI.<br /><a href="mailto:Gerardo@CICA.es">Gerardo@CICA.es</a> <a id="lbDA"> </a></p><h2>INFORMES DE FALLOS</h2><p>

Si Ud. encuentra un fallo en <b>bash,</b> debería informar de ello.
Pero primero debería asegurarse de que realmente es un fallo, y de
que aparece en la última versión de <b>bash</b> que tenga. 
</p><p>Una vez que Ud. ha determinado que realmente existe un fallo,
utilice la orden <i>bashbug</i> para enviar el informe
correspondiente. Si Ud. ha encontrado cómo corregirlo, ¡se le anima
a que nos mande también la corrección! Las sugerencias y los
informes de fallos `filosóficos' se pueden enviar por correo
electrónico a <i><a href="mailto:bug-bash@gnu.org">bug-bash@gnu.org</a></i> o se pueden
publicar en el grupo de discusiones de Usenet
<b>gnu.bash.bug</b>.</p><p>TODOS los informes de fallos deben incluir:</p><dl compact="compact"><dt>El número de versión de <b>bash</b></dt>

<dt>El tipo de computador (hardware) y el sistema operativo</dt>

<dt>El compilador que se empleó para compilarlo</dt>

<dt>Una descripción del comportamiento del fallo</dt>

<dt>Un corto guión o `receta' para reproducir el fallo</dt>
</dl><p><i>bashbug</i> inserta automáticamente los tres primeros puntos
en la plantilla que proporciona para escribir el informe del
fallo.</p><p>Los comentarios e informes de fallos que conciernan a esta
página de manual deben dirigirse a <i><a href="mailto:chet@ins.CWRU.Edu">chet@ins.CWRU.Edu</a></i>.</p><p>Los relativos a la traducción de esta página deben dirigirse a
<i><a href="mailto:gerardo@cica.es">gerardo@cica.es</a></i> o
discutirse en el marco del proyecto PAMELI; contacte con nosotros
en <i><a href="http://elcano.dif.um.es/~piernas/manpages-es">http://elcano.dif.um.es/~piernas/manpages-es</a></i>.
<a id="lbDB"> </a></p><h2>FALLOS</h2><p>Es demasiado grande y demasiado lento.</p><p>Hay algunas sutiles diferencias entre <b>bash</b> y versiones
tradicionales del shell de Bourne <b>sh</b>, mayormente debidas a
la especificación <font size="-1"><b>POSIX</b>.</font></p><p>Los alias son confusos en algunos casos.</p><p>Las órdenes internas del shell y las funciones no son
interrumpibles/rearrancables.</p><p>Las órdenes compuestas y las secuencias de órdenes de la forma
`a ; b ; c' no se manejan de forma muy elegante cuando se intenta
suspender el proceso. Cuando un proceso es parado, el shell ejecuta
inmediatamente la siguiente orden de la secuencia. Para remediar
esto es suficiente poner la secuencia de órdenes entre paréntesis;
así la forzamos a ejecutarse en un subshell, que puede pararse como
una unidad.</p><p>Las órdenes dentro de una sustitución de orden de tipo
<b>$(</b>...<b>)</b> no se analizan hasta que se intenta la
sustitución. Esto provocará un retraso en la aparición de mensajes
posibles de error hasta algún tiempo después de que se introduzca
la orden.</p><p>Las variables de tipo vector no pueden (aún) exportarse.</p><hr /><a id="index"> </a><h2>Index</h2><dl><dt><a href="#lbAB">NOMBRE</a></dt>

<dt><a href="#lbAC">SINOPSIS</a></dt>

<dt><a href="#lbAD">DERECHOS DE COPIA</a></dt>

<dt><a href="#lbAE">DESCRIPCIÓN</a></dt>

<dt><a href="#lbAF">OPCIONES</a></dt>

<dt><a href="#lbAG">ARGUMENTOS</a></dt>

<dt><a href="#lbAH">LLAMADA</a></dt>

<dt><a href="#lbAI">DEFINICIONES</a></dt>

<dt><a href="#lbAJ">PALABRAS RESERVADAS</a></dt>

<dt><a href="#lbAK">GRAMÁTICA DEL SHELL</a></dt>

<dd>
<dl><dt><a href="#lbAL">Órdenes simples</a></dt>

<dt><a href="#lbAM">Tuberías</a></dt>

<dt><a href="#lbAN">Listas</a></dt>

<dt><a href="#lbAO">Órdenes compuestas</a></dt>
</dl></dd>

<dt><a href="#lbAP">COMENTARIOS</a></dt>

<dt><a href="#lbAQ">ENTRECOMILLADO</a></dt>

<dt><a href="#lbAR">PARÁMETROS</a></dt>

<dd>
<dl><dt><a href="#lbAS">Parámetros posicionales</a></dt>

<dt><a href="#lbAT">Parámetros especiales</a></dt>

<dt><a href="#lbAU">Variables del shell</a></dt>

<dt><a href="#lbAV">Vectores</a></dt>
</dl></dd>

<dt><a href="#lbAW">EXPANSIÓN</a></dt>

<dd>
<dl><dt><a href="#lbAX">Expansión de llaves</a></dt>

<dt><a href="#lbAY">Expansión de tilde</a></dt>

<dt><a href="#lbAZ">Expansión de parámetro</a></dt>

<dt><a href="#lbBA">Sustitución de orden</a></dt>

<dt><a href="#lbBB">Expansión aritmética</a></dt>

<dt><a href="#lbBC">Sustitución de proceso</a></dt>

<dt><a href="#lbBD">División de palabras</a></dt>

<dt><a href="#lbBE">Expansión de nombre de camino</a></dt>

<dt><a href="#lbBF">Eliminación de comillas</a></dt>
</dl></dd>

<dt><a href="#lbBG">REDIRECCIÓN</a></dt>

<dd>
<dl><dt><a href="#lbBH">Redirección de la entrada</a></dt>

<dt><a href="#lbBI">Redirección de la salida</a></dt>

<dt><a href="#lbBJ">Añadir a la salida redirigida</a></dt>

<dt><a href="#lbBK">Redirección de la salida estándar normal y de
errores</a></dt>

<dt><a href="#lbBL">Documentos internos</a></dt>

<dt><a href="#lbBM">Duplicación de descriptores de fichero</a></dt>

<dt><a href="#lbBN">Apertura de descriptores de ficheros para
lectura y escritura</a></dt>
</dl></dd>

<dt><a href="#lbBO">ALIAS</a></dt>

<dt><a href="#lbBP">FUNCIONES</a></dt>

<dt><a href="#lbBQ">EVALUACIÓN ARITMÉTICA</a></dt>

<dt><a href="#lbBR">EXPRESIONES CONDICIONALES</a></dt>

<dt><a href="#lbBS">EXPANSIÓN DE ORDEN SIMPLE</a></dt>

<dt><a href="#lbBT">EJECUCIÓN DE ÓRDENES</a></dt>

<dt><a href="#lbBU">ENTORNO DE EJECUCIÓN DE ÓRDENES</a></dt>

<dt><a href="#lbBV">ENTORNO</a></dt>

<dt><a href="#lbBW">ESTADO DE SALIDA</a></dt>

<dt><a href="#lbBX">SEÑALES</a></dt>

<dt><a href="#lbBY">CONTROL DE TRABAJOS</a></dt>

<dt><a href="#lbBZ">INDICADORES</a></dt>

<dt><a href="#lbCA">READLINE</a></dt>

<dd>
<dl><dt><a href="#lbCB">Notación de Readline</a></dt>

<dt><a href="#lbCC">Inicio de Readline</a></dt>

<dt><a href="#lbCD">Definiciones de teclas de Readline</a></dt>

<dt><a href="#lbCE">Variables de Readline</a></dt>

<dt><a href="#lbCF">Construcciones condicionales de
Readline</a></dt>

<dt><a href="#lbCG">Búsquedas</a></dt>

<dt><a href="#lbCH">Nombres de órdenes de Readline</a></dt>

<dt><a href="#lbCI">Órdenes para el movimiento</a></dt>

<dt><a href="#lbCJ">Órdenes para manipular la lista de
historia</a></dt>

<dt><a href="#lbCK">Órdenes para cambiar el texto</a></dt>

<dt><a href="#lbCL">Cortar y pegar</a></dt>

<dt><a href="#lbCM">Argumentos numéricos</a></dt>

<dt><a href="#lbCN">Terminación</a></dt>

<dt><a href="#lbCO">Macros de teclado</a></dt>

<dt><a href="#lbCP">Miscelánea</a></dt>
</dl></dd>

<dt><a href="#lbCQ">HISTORIA</a></dt>

<dt><a href="#lbCR">EXPANSIÓN DE HISTORIA</a></dt>

<dd>
<dl><dt><a href="#lbCS">Designadores de eventos</a></dt>

<dt><a href="#lbCT">Designadores de palabras</a></dt>

<dt><a href="#lbCU">Modificadores</a></dt>
</dl></dd>

<dt><a href="#lbCV">ÓRDENES INTERNAS DEL SHELL</a></dt>

<dt><a href="#lbCW">SHELL RESTRINGIDA</a></dt>

<dt><a href="#lbCX">VÉASE TAMBIÉN</a></dt>

<dt><a href="#lbCY">FICHEROS</a></dt>

<dt><a href="#lbCZ">AUTORES</a></dt>

<dt><a href="#lbDA">INFORMES DE FALLOS</a></dt>

<dt><a href="#lbDB">FALLOS</a></dt>
</dl><hr /><p>
This document was created by <a href="http://localhost/cgi-bin/man/man2html">man2html</a>, using
the manual pages.<br />
Time: 20:28:05 GMT, January 21, 2005
</p></body></html>
