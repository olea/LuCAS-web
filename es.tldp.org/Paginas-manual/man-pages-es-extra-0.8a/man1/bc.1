.\"
.\" bc.1 - the *roff document processor source for the bc manual
.\"
.\" This file is part of GNU bc.
.\" Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.
.\"
.\" This program is free software; you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published by
.\" the Free Software Foundation; either version 2 of the License , or
.\" (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program; see the file COPYING.  If not, write to
.\" the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
.\"
.\" You may contact the author by:
.\" e-mail: phil@cs.wwu.edu
.\" us-mail: Philip A. Nelson
.\" Computer Science Department, 9062
.\" Western Washington University
.\" Bellingham, WA 98226-9062
.\"
.\"
.\" Traducido al Español el 7-Jul-1999 por J.Ramón Palacios
.\" <jotarp@iname.com>
.\"
.\"
.TH bc 1 .\" "Manual del comando" v1.04 "22 Junio 1995"
.SH NOMBRE
bc - Un lenguaje de cálculo de precisión arbitraria
.SH SINTAXIS
\fBbc\fR [ \fB-lwsqv\fR ] [opciones largas] [ \fI fichero ...\fR ]
.SH VERSIÓN
Esta página de manual documenta la versión 1.04 de GNU bc.
.SH DESCRIPCIÓN
\fBbc\fR es un lenguaje que permite la ejecución interactiva de sentencias
con precisión numérica arbitraria. La sintaxis es similar a la del lenguaje
de programación C. Se puede disponer de una biblioteca matemática estándar
a través de una opción en la línea de comando. En ese caso, la biblioteca
matemática se determina antes de procesar ningún fichero.
\fBbc\fR comienza procesando en orden todos los ficheros dados en la
línea de comando. Después de que todos los ficheros hayan sido procesados,
\fBbc\fR lee la entrada estándar. Todo el código es ejecutado tal y como
es leído. (Si un fichero contiene un comando que detiene el procesador
\fBbc\fR nunca leerá la entrada estándar.)
.PP
Esta versión de \fBbc\fR tiene varias ampliaciones adicionales a las
tradicionales implementaciones de \fBbc\fR y el estándar POSIX.
Las opciones en la línea de comando pueden causar que estas extensiones
impriman un aviso o sean rechazadas. Este documento describe el lenguaje
aceptado por este procesador. Las ampliaciones serán identificadas como tales.

.SS OPCIONES
.IP -l
Selecciona la biblioteca matemática estándar.
.IP -w
Da mensajes de advertencia ante las ampliaciones al \fBbc\fR de POSIX.
.IP -s
Procesa exactamente como el lenguaje \fBbc\fR de POSIX.
.IP -q
No imprime el habitual mensaje de bienvenida del GNU bc.
.IP -v
Imprime el número de versión el copyright y sale.
.IP --mathlib
Selecciona la biblioteca matemática estándar.
.IP --warn
Da mensajes de advertencia ante las ampliaciones al \fBbc\fR de POSIX.
.IP --standard
Procesa exactamente como el lenguaje \fBbc\fR de POSIX.
.IP --quiet
No imprime el habitual mensaje de bienvenida del GNU bc.
.IP --version
Imprime el número de versión el copyright y sale.
.SS NÚMEROS
El elemento más básico en \fBbc\fR es el número. Los números son de
precisión arbitraria, tanto en la parte entera como en la fraccionaria.
Todos los números son representados internamente en decimal y toda la
computación es hecha en decimal. (Esta versión trunca los resultados de
las operaciones división y multiplicación). Los números tienen dos atributos,
la longitud y la escala. La longitud es el número total de dígitos decimales
significativas y la escala el número de dígitos decimales tras la coma decimal.
Por ejemplo:
.nf
.RS
 .000001 tiene longitud 6 y escala 6.
 1935.000 tiene longitud 7 y escala 3.
.RE
.fi
.SS VARIABLES
Los números son almacenados en dos tipos de variables, variables simples
y matrices. Ambos tipos son designados por nombres. Estos nombres 
comienzan con una letra, seguida por cualquier número de letras, 
dígitos y caracteres de subrayado. Todas las letras deben ir en 
minúsculas. (Estos nombres alfanuméricos son una ampliación. En el
\fBbc\fR de POSIX todos los nombres son una sola letra minúscula).
El tipo de variable queda claro según el contexto ya que a todas las 
variables de tipo matriz les sigue unos corchetes ([]).
.PP
Hay cuatro variables especiales, \fBscale\fR, \fBibase\fR, \fBobase\fR y
\fBlast\fR. \fBscale\fR define como son tratadas los dígitos tras la coma
decimal en algunas operaciones. El valor por defecto de \fBscale\fR es 0.
\fBibase\fR y \fBobase\fR definen la base numérica de conversión para la
entrada y la salida. El valor por defecto para ambos es la base 10.
\fBlast\fR (una ampliación) es la variable en la que se guardar el 
último número mostrado. Todo esto será tratado en detalle cuando 
proceda. Todas estas variables pueden tener un valor asignado así como ser 
usadas en expresiones.
.SS COMENTARIOS
Los comentarios en \fBbc\fR comienzan con los caracteres \fB/*\fR y 
finalizan con los caracteres \fB*/\fR. Los comentarios pueden empezar 
en cualquier lugar y aparecen como un solo espacio en la entrada. (Esto 
hace que delimiten otros elementos de entrada. Por ejemplo, un 
comentario no puede encontrarse en medio del nombre de una variable). 
Los comentarios pueden incluir saltos de línea. 
.PP
Para poder usar macros (scripts) en \fBbc\fR, la posibilidad de incluir 
comentarios de una sola línea ha sido añadida como ampliación. Estos 
comienzan con el carácter \fB#\fR y continúan hasta el final de la 
línea. El final de línea no es parte del comentario y es procesado de 
forma normal.
.SS EXPRESIONES
Los números son manipulados por las expresiones y las sentencias. Como 
el lenguaje fue diseñado para ser interactivo, las sentencias y 
expresiones son ejecutadas tan pronto como es posible. No hay programa 
principal ("main"). En su lugar, el código es ejecutado tal y como se 
encuentra. (Las funciones, tratadas en detalle más abajo, se definen 
cuando se encuentran).
.PP
Una constante es la expresión más simple. \fBbc\fR convierte 
internamente las constantes en números decimales usando la base de 
entrada activa, especificada por la variable \fBibase\fR. (Hay una 
excepción en las funciones). Los valores permitidos para \fBibase\fR van 
del 2 hasta el 16. Si se asigna un valor a \fBibase\fR fuera de este rango
se cambiará por 2 ó 16. Los números en la entrada pueden formarse con 
los caracteres 0-9 y A-F. (Nota: Deben ir en mayúsculas. Las minúsculas 
son nombres de variables). Los números de un solo dígito tienen siempre 
el valor del dígito, sea cual sea el valor de \fBibase\fR. (ej. A = 
10.). En los números de más de un dígito \fBbc\fR cambia todos los 
dígitos mayores o iguales a ibase al valor de \fBibase\fR-1. Esto hace 
que el número \fBFFF\fR sea siempre el mayor número de 3 dígitos de la 
base de entrada.
.PP
Las expresiones más complejas son similares a muchos otros lenguajes
de alto nivel. Como sólo hay un tipo de número, no hay reglas para mezclar 
tipos. En cambio, hay reglas para la escala de las expresiones. Cada 
expresión tiene una escala. Esta es derivada de la escala de los números 
originales, la operación realizada y, en muchos casos, el valor de la 
variable \fBscale\fR. Los valores permitidos para \fBscale\fR son desde 0 
hasta el máximo número representable por un entero en C.
.PP
En las siguientes descripciones de expresiones permitidas, "expr" se usa 
para indicar un expresión completa y "var" una variable, simple o 
matricial. Una variable simple es, simplemente
.RS
\fInombre\fR
.RE
y una matriz se designa así
.RS
\fInombre\fR[\fIexpr\fR]
.RE
Si no se especifica la escala del resultado, esta será la máxima escala de 
las expresiones implicadas.
.IP "- expr"
El resultado es la expresión negada.
.IP "++ var"
La variable es incrementada en uno y el nuevo valor es el resultado de la 
expresión.
.IP "-- var"
La variable es decrementada en uno y el nuevo valor es el resultado de la 
expresión.
.IP "var ++"
El resultado de la expresión es el valor de la variable y entonces la 
variable es incrementada en uno.
.IP "var --"
El resultado de la expresión es el valor de la variable y entonces la 
variable es decrementada en uno.
.IP "expr + expr"
El resultado de la expresión es la suma de las dos expresiones.
.IP "expr - expr"
El resultado de la expresión es la diferencia de las dos expresiones.
.IP "expr * expr"
El resultado de la expresión es el producto de las dos expresiones.
.IP "expr / expr"
El resultado de la expresión es el cociente de las dos expresiones.
La escala del resultado es el valor de la variable \fBscale\fR.
.IP "expr % expr"
El resultado de la expresión es el "resto" y se calcula de la siguiente 
manera. Para calcular a%b, primero se calcula a/b en \fBscale\fR dígitos. 
Este resultado es usado para calcular a-(a/b)*b a la escala que resulte mayor, 
\fBscale\fR+scale(b) ó scale(a). Si \fBscale\fR vale cero y ambas 
expresiones son enteros esta expresión calcula el resto entero.
.IP "expr ^ expr"
El resultado de la expresión es el valor de la primera elevada a la 
segunda. La segunda expresión debe ser un entero. (Si la segunda expresión 
no es un entero, se genera un mensaje de advertencia y la expresión es 
truncada a un valor entero). La escala del resultado es \fBscale\fR si el 
exponente es negativo. Si el exponente es positivo la escala del resultado 
es el mínimo de estos valores: la escala de la base por el exponente o el 
máximo de \fBscale\fR y la escala de la base. (ej. scale(a^b) = 
min(scale(a)*b, max( \fBscale\fR, scale(a))).). Hay que tener en cuenta que 
el resultado de expr^0 siempre será 1.
.IP "( expr )"
Altera la precedencia estándar para forzar la evaluación de la expresión.
.IP "var = expr"
Se asigna a la variable el valor de la expresión.
.IP "var <op>= expr"
Es equivalente a "var = var <op> expr" con la excepción de que "var" sólo 
es evaluada una vez. Esto puede afectar si "var" es una matriz.
.PP
Las expresiones relacionales son de un tipo especial que siempre se evalúan 
a 0 ó 1, 0 si la relación es falsa y 1 si la relación es verdadera. Pueden 
aparecer en cualquier expresión permitida. (El \fBbc\fR de POSIX sólo permite el 
uso de expresiones relacionales en las sentencias if, while y for y sólo 
una expresión relacional en cada una de ellas). Los operadores relacionales 
son:
.IP "expr1 < expr2"
El resultado es 1 si expr1 es estrictamente menor que expr2.
.IP "expr1 <= expr2"
El resultado es 1 si expr1 es menor o igual que expr2.
.IP "expr1 > expr2"
El resultado es 1 si expr1 es estrictamente mayor que expr2.
.IP "expr1 >= expr2"
El resultado es 1 si expr1 es mayor o igual que expr2.
.IP "expr1 == expr2"
El resultado es 1 si expr1 es igual a expr2.
.IP "expr1 != expr2"
El resultado es 1 si expr1 no es igual a expr2.
.PP
Las operaciones booleanas también están permitidas. (El \fBbc\fR de POSIX 
NO tiene operaciones booleanas). El resultado de toda operación booleana es 
0 ó 1 (falso o verdadero) como en las expresiones relacionales. Los 
operadores booleanos son:
.IP "!expr"
El resultado es 1 si expr es 0.
.IP "expr && expr"
El resultado es 1 si ambas expresiones son distintas de 0.
.IP "expr || expr"
El resultado es 1 si alguna de las expresiones es distinta de 0.
.PP
La precedencia de las expresiones es la siguiente (de menor a mayor):
.nf
.RS
operador || , asociativo por la izquierda
operador && , asociativo por la izquierda
operador !  , no asociativo
operadores relacionales, asociativos por la izquierda
operador asignación, asociativo por la derecha
operadores + y - , asociativos por la izquierda
operadores *, / y % , asociativos por la izquierda
operador ^ , asociativo por la derecha
operador unario - , no asociativo
operadores ++ y -- , no asociativo
.RE
.fi
.PP
Esta precedencia fue elegida para que los programas acordes con el \fBbc\fR 
de POSIX funcionaran correctamente. Esto hará que el uso de operadores 
relacionales y lógicos tenga un comportamiento inusual cuando se usen con 
expresiones de asignación. Considere la expresión:
.RS
a = 3 < 5
.RE
.PP
La mayoría de los programadores de C asumirían que se asignaría el 
resultado de "3 < 5" (el valor 1) a la variable "a". Lo que ocurre en 
\fBbc\fR es que se asigna el valor 3 a la variable "a" y entonces se 
compara 3 con 5. Es mejor usar paréntesis cuando se usan operadores 
relacionales y lógicos con operadores de asignación.
.PP
Hay algunas expresiones especiales más en \fBbc\fR. Estas están 
relacionadas con las funciones definidas por el usuario y las funciones 
estándar. Tienen la forma "\fInombre\fB(\fIparámetros\fB)\fR". Las 
funciones definidas por el usuario son tratadas en la sección FUNCIONES. 
Las funciones estándar son:
.IP "length ( expresión )"
EL valor de la función length es el número de dígitos significativos en la 
expresión.
.IP "read ( )"
La función read (una ampliación) leerá un número de la entrada estándar, 
independientemente del lugar dónde aparezca la función. Tenga cuidado pues 
esto puede causar problemas mezclando datos y programa en la entrada 
estándar. El mejor uso de esta función es ponerla en un programa 
previamente escrito que necesite la entrada del usuario, pero nunca 
permitiendo que el usuario introduzca código de programa. El valor de la 
función read es el número leído de la entrada estándar usando el valor de 
la variable \fBibase\fR para la base de conversión.
.IP "scale ( expresión )"
El valor de la función scale es el número de dígitos tras la coma decimal 
en la expresión.
.IP "sqrt ( expresión )"
El valor de la función sqrt es la raíz cuadrada de la expresión. Si la 
expresión es negativa, se genera un error en tiempo de ejecución.
.SS SENTENCIAS
Las sentencias (como en la mayoría de los lenguajes algebraicos) 
proporcionan la secuencia de las evaluación de las expresiones. En \fBbc\fR 
las sentencias son ejecutadas "tan pronto como es posible". La ejecución 
ocurre cuando se encuentra un cambio de línea y hay una o más sentencias 
completas. Debido a esta ejecución inmediata, los cambios de línea son muy 
importantes en \fBbc\fR. En realidad, tanto el punto y coma como el cambio 
de línea son usados como separadores de sentencias. Un cambio de línea en un 
lugar inapropiado provocará un error de sintaxis. Es posible ocultar el que 
un cambio de línea sea un separador de sentencias usando el carácter de 
contra-barra. \fBbc\fR toma la secuencia "\e<nl>", donde <nl> es el cambio de 
línea, como un espacio en blanco en lugar de como un cambio de línea. Una 
lista de sentencias es una serie de sentencias separadas por punto y coma y 
cambios de línea. Lo siguiente es un lista de sentencias y la descripción de 
lo que realizan: (Las partes entre corchetes de las sentencias son opcionales).
.IP "expresión"
Esta sentencia hace una de estas dos cosas. Si la expresión comienza con 
"<variable> <asignación> ...", es considerada como una sentencia de 
asignación. Si no es una sentencia de asignación, la expresión es evaluada 
e impresa en la salida. Tras el número viene un cambio de línea. Por 
ejemplo, "a=1" es una sentencia de asignación y "(a=1)" es una expresión 
que tiene una asignación incluida. Todos los números se imprimen en la base 
especificada por la variable \fBobase\fR. Los valores posibles para 
\fBobase\fR van desde 2 hasta BC_BASE_MAX. (Ver sección LÍMITES). Para las 
bases comprendidas entre 2 y 16, se usa el método usual de impresión. Para 
las bases mayores de 16, \fBbc\fR usa un método de impresión en el que 
utiliza dígitos multi-carácter para imprimir cada dígito mayor que la base 
como un número en base 10. Los dígitos multi-carácter son separados por 
espacios. Cada dígito emplea tantos caracteres como sean necesarios para 
representar "obase-1" en base diez. Como los números son de precisión 
arbitraria, puede que algunos números no se puedan imprimir en una sola 
línea. Estos números grandes serán repartidos en varias lineas con el 
carácter "\e" al final de cada línea. El número máximo de caracteres que se 
imprimen por línea es 70. Debido a la naturaleza interactiva de \fBbc\fR, 
la impresión de un número lleva consigo la asignación del valor impreso a 
la variable especial \fBlast\fR. Esto permite al usuario utilizar el último 
valor impreso sin tener que volver a teclear la expresión que causó su 
impresión. Está permitido asignar valores a \fBlast\fR y esto 
sobreescribirá el último valor impreso con el valor asignado. El nuevo 
valor permanecerá hasta que se imprima el siguiente número o se le asigne 
otro valor a \fBlast\fR. (Algunas instalaciones pueden permitir usar un 
punto (.) que no sea parte de un número como una notación más corta para 
\fBlast\fR).
.IP "cadena"
Se imprime la cadena en la salida. Las cadenas comienzan con una comilla 
doble y contienen todos los caracteres hasta la siguiente comilla doble. 
Todos los caracteres son tomados literalmente, incluidos los cambios de 
línea. Tras la cadena no se cambia de línea.
.IP "\fBprint\fR lista"
La sentencia print (una ampliación) proporciona otro método de impresión.
La "lista" es una lista de cadenas y expresiones separadas por comas. La 
lista se imprime en el orden en el que está. Tras la lista no se cambia de 
línea. Las expresiones son evaluadas y sus valores impresos y asignados 
a la variable \fBlast\fR. Las cadenas se imprimen en la salida y pueden 
contener caracteres especiales. Los caracteres especiales comienzan con el 
carácter de contra-barra (\e). \fBbc\fR reconoce los caracteres especiales 
"a" (alerta o campana), "b" (borrar carácter (backspace)), "f" (salto de 
línea), "n" (nueva linea), "r" (retorno de carro), "q" (comilla doble), "t" 
(tabulador), y "\e" (contra-barra). Cualquier otro carácter que siga a una 
contra-barra será ignorado.
.IP "{ lista_de_sentencias }"
Esta es la sentencia compuesta. Permite ejecutar varias sentencias 
agrupadas.
.IP "\fBif\fR ( expresión ) sentencia1 [\fBelse\fR sentencia2]"
Esta sentencia evalúa la expresión y ejecuta la sentencia1 o la sentencia2 
dependiendo del valor de la expresión. Si el valor es distinto de 0, se 
ejecuta la sentencia1. Si se da la sentencia2 y el valor de la expresión es 
0, entonces se ejecuta la sentencia2. (La cláusula else es una ampliación).
.IP "\fBwhile\fR ( expresión ) sentencia"
Se ejecuta la sentencia mientras la expresión sea distinta de 0. Se evalúa 
la expresión antes de cada ejecución de la sentencia. El bucle termina al 
tomar la expresión el valor 0 o ante una sentencia break.
.IP "\fBfor\fR ( [expresión1] ; [expresión2] ; [expresión3] ) sentencia"
La sentencia for controla la ejecución repetitiva de la sentencia. La 
expresión1 es evaluada antes del bucle. La expresión2 es evaluada antes de 
cada ejecución de la sentencia. Si es 0, el bucle termina. Después de cada 
ejecución de la sentencia, se evalúa la expresión3 antes de reevaluar la 
expresión2. Si la expresión1 o la expresión3 no se dan, no se evalúa nada 
en su lugar. Si la expresión2 no se da, es lo mismo que sustituirla por el 
valor 1. (El que las expresiones sean opcionales es una ampliación. El 
\fBbc\fR de POSIX requiere las tres expresiones).
Este es el código equivalente para la sentencia for:
.nf
.RS
expresión1;
while (expresión2) {
   sentencia;
   expresión3;
}
.RE
.fi
.IP "\fBbreak\fR"
Esta sentencia fuerza la salida de la sentencia while o for más reciente.
.IP "\fBcontinue\fR"
La sentencia continue (una ampliación) provoca que la sentencia for más 
reciente comience una nueva iteración.
.IP "\fBhalt\fR"
La sentencia halt (una ampliación) provoca que el procesador \fBbc\fR 
termine sólo cuando es ejecutada. Por ejemplo, "if (0 == 1) halt" no hará 
que \fBbc\fR termine porque no llega a ejecutarse la sentencia halt.
.IP "\fBreturn\fR"
Devuelve el valor 0 desde una función. (Ver sección sobre funciones).
.IP "\fBreturn\fR ( expresión )"
Devuelve el valor de la expresión desde una función.  (Ver sección sobre 
funciones).
.SS PSEUDO SENTENCIAS
Estas sentencias no son sentencias en el sentido tradicional. No son 
sentencias que se ejecuten. Su función se realiza en "tiempo de 
compilación".
.IP "\fBlimits\fR"
Imprime los límites locales forzados por la versión local de \fBbc\fR. Esto 
es una ampliación.
.IP "\fBquit\fR"
Cuando la sentencia quit se lee, el procesador \fBbc\fR termina, cualquiera 
que sea el lugar donde se encuentre la sentencia quit. Por ejemplo, "if (0 
== 1) quit" hará que \fBbc\fR termine.
.IP "\fBwarranty\fR"
Imprime un aviso largo sobre la garantía. Esto es una ampliación. 
.SS FUNCIONES
Las funciones proporcionan un método para definir un cálculo que será 
ejecutado más tarde. Las funciones en
.B bc
siempre calculan un valor que devuelven a quien la ha llamado. La 
definición de las funciones son "dinámicas" en el sentido de que una 
función está indefinida hasta que se encuentra una definición en la 
entrada. Se usa esa definición hasta que se encuentra otra definición de 
función con el mismo nombre. La nueva definición reemplaza a la anterior. 
Una función se define como sigue:
.nf
.RS
\fBdefine \fInombre \fB( \fIparámetros \fB) { \fInueva_línea
\fI    auto_lista   lista_de_sentencias \fB}\fR
.RE
.fi
La ejecución de una función es simplemente una expresión de la forma
"\fInombre\fB(\fIparámetros\fB)\fR".
.PP
Los parámetros son números o matrices (una ampliación). En la definición de 
la función, se definen cero o más parámetros listando sus nombres separados 
por comas. Los números son llamados por valor. Las matrices son llamadas 
por variable. Las matrices se especifican en la definición de parámetros 
mediante la notación "\fIname\fB[]\fR". En la llamada a la función, los 
parámetros son expresiones completas para los parámetros que son números. 
Se usa la misma notación para pasar matrices que para definirlas en los 
parámetros. El nombre de la matriz se pasa a la función por variable. Como 
las definiciones de las funciones son dinámicas, el número de parámetros y 
los tipos se comprueban en el momento de llamar a la función. Cualquier 
discrepancia en el número o en el tipo de los parámetros provocará un error 
en tiempo de ejecución. También se provocará un error al llamar a una 
función no definida.
.PP
La \fIauto_lista\fR es una lista opcional de variables para uso "local". La 
sintaxis de esta lista (si se da) es "\fBauto \fInombre\fR, ... ;". (El 
punto y coma es opcional). Cada \fInombre\fR es el nombre de una variable 
auto. Las matrices se pueden especificar con la misma notación que se usa 
en los parámetros. Los valores de estas variables se guardan en una pila al 
comienzo de la función. Entonces son inicializadas a cero y se usan en el
transcurso de la función. Al finalizar la función, se recuperan de la pila 
los valores originales (en el momento de la llamada a la función). Los 
parámetros son realmente variables auto que se inicializan al valor 
proporcionado en la llamada a la función. Las variables auto son diferentes 
de las tradicionales variables locales en que si la función A llama a la 
función B, B puede acceder a las variables auto de A simplemente usando sus 
nombres, a no ser que la función B tenga variables auto del mismo nombre. 
Como tanto las variables auto como los parámetros son guardados en una 
pila, \fBbc\fR admite funciones recursivas.
.PP
El cuerpo de la función es una lista de sentencias de \fBbc\fR. De nuevo las 
sentencias van separadas por punto y coma o cambio de línea. La sentencia 
return hace que la función termine y devuelva un valor a la expresión que 
ha llamado a la función.. La primera forma, "\fBreturn\fR", devuelve el 
valor 0. La segunda forma "\fBreturn ( \fIexpresión \fB)\fR", calcula el 
valor de la expresión y lo devuelve a la expresión que ha llamado la 
función. Hay un "\fBreturn (0)\fR" implícito al final de cada función. Esto 
permite a una función terminar y devolver 0, sin necesidad de una sentencia 
return explícita.
.PP
Las funciones también cambian el uso de la variable \fBibase\fR. Todas las 
constantes en el cuerpo de la función son convertidas usando el valor de 
\fBibase\fR en el momento de llamar a la función. Los cambios de 
\fBibase\fR serán ignorados durante la ejecución de la función excepto para 
la función estándar \fBread\fR, que siempre usará el valor actual de 
\fBibase\fR para la conversión de los números.
.SS BIBLIOTECA MATEMÁTICA
Si se invoca \fBbc\fR con la opción \fB-l\fR, una biblioteca matemática es 
pre-cargada y la escala por defecto se pone a 20. Las funciones matemáticas 
calcularán sus resultados a la escala definida en el momento de su llamada.
La biblioteca matemática define las siguientes funciones:
.IP "s (\fIx\fR)"
El seno de x, con x en radianes.
.IP "c (\fIx\fR)"
El coseno de x, con x en radianes.
.IP "a (\fIx\fR)"
El arcotangente de x, con el resultado en radianes.
.IP "l (\fIx\fR)"
El logaritmo natural de x.
.IP "e (\fIx\fR)"
La función exponencial resultante de elevar e al valor de x.
.IP "j (\fIn,x\fR)"
La función bessel de orden entero n de x.
.SS EJEMPLOS
En /bin/sh, lo siguiente asignará el valor de "pi" a la variable shell 
\fBpi\fR.
.RS
\f(CW
pi=$(echo "scale=10; 4*a(1)" | bc -l)
\fR
.RE
.PP
Lo siguiente es la definición de la función exponencial usada en la 
biblioteca matemática. Esta función está escrita en \fBbc\fR de POSIX.
.nf
.RS
\f(CW
scale = 20

/* Usa el hecho de que  e^x = (e^(x/2))^2
   Si x es lo suficientemente pequeño, se usa la serie:
     e^x = 1 + x + x^2/2! + x^3/3! + ...
*/

define e(x) {
  auto  a, d, e, f, i, m, v, z

  /* Comprueba el signo de x. */
  if (x<0) {
    m = 1
    x = -x
  } 

  /* Precondición x. */
  z = scale;
  scale = 4 + z + .44*x;
  while (x > 1) {
    f += 1;
    x /= 2;
  }

  /* Inicialización de las variables. */
  v = 1+x
  a = x
  d = 1

  for (i=2; 1; i++) {
    e = (a *= x) / (d *= i)
    if (e == 0) {
      if (f>0) while (f--)  v = v*v;
      scale = z
      if (m) return (1/v);
      return (v/1);
    }
    v += e
  }
}
\fR
.RE
.fi
.PP
El siguiente código usa las características ampliadas de \fBbc\fR para 
implementar un simple programa para calcular balances. Es mejor guardar 
este programa en un fichero para poderlo usar varias veces sin tener que 
teclearlo cada vez.
.nf
.RS
\f(CW
scale=2
print "\en¡Programa de balances!\en"
print " Recuerde, los depósitos son transacciones negativas.\en"
print " Para salir introducir una transacción 0 .\en\en"

print "¿ Balance inicial ? "; bal = read()
bal /= 1
print "\en"
while (1) {
  "Balance actual = "; bal
  "¿ transacción ? "; trans = read()
  if (trans == 0) break;
  bal -= trans
  bal /= 1
}
quit
\fR
.RE
.fi
.PP
Lo siguiente es la definición de la función factorial recursiva.
.nf
.RS
\f(CW
define f (x) {
  if (x <= 1) return (1);
  return (f(x-1) * x);
}
\fR
.RE
.fi
.SS OPCIÓN READLINE
El \fBbc\fR de GNU se puede compilar (mediante una opción de configuración) 
para usar la biblioteca de entrada \fBreadline\fR de GNU. Esto permite al 
usuario mayor posibilidad de edición de las líneas antes de mandarlas a 
\fBbc\fR. También permite tener un histórico de las líneas previamente 
introducidas. Cuando se selecciona esta opción, \fBbc\fR tiene una variable 
especial más. Esta variable especial, \fBhistory\fR es el número de líneas 
que se guardan en el histórico. Un valor de -1 significa que este número es 
ilimitado. Este es el valor por defecto. Dando un valor positivo a 
\fBhistory\fR se restringe el número de líneas a este valor. El valor 0 
desactiva el histórico. Para más información, leer los manuales de usuario 
de las bibliotecas \fBreadline\fR y \fBhistory\fR de GNU.
.SS DIFERENCIAS
Esta versión de
.B bc
fue implementada a partir del borrador POSIX P1003.2/D11 y contiene varias 
diferencias y ampliaciones respecto a este borrador y las implementaciones 
tradicionales. No está implementada usando
.I dc(1)
como suele ser tradicional. Esta versión es un simple proceso que analiza 
el programa y ejecuta una traducción de este a un código de bytes (byte 
code). Hay una opción "indocumentada" (-c) que hace que el programa imprima 
en la salida estándar este código en lugar de ejecutarlo. Fue usada 
principalmente para depurar el analizador y preparar la biblioteca 
matemática.
.PP
Una mayor fuente de diferencias son las ampliaciones, tanto cuando son 
añadidas para dar más funcionalidad como cuando añaden nuevas 
características.
Esta es la lista de las diferencias y ampliaciones.
.IP Entorno LANG
Esta versión no se ajusta al estándar POSIX sobre el proceso de la variable 
de entorno LANG y todas las variables de entorno que comienzan por LC_.
.IP nombres
El
.B bc
tradicional y el de POSIX usan nombres de una sola letra para funciones, 
variables y matrices. Han sido ampliados para ser nombres multi-carácter 
que comienzan por una letra y pueden contener letras, dígitos y caracteres de 
subrayado.
.IP Cadenas
No se permite que las cadenas contengan caracteres nulos (NUL). El estándar 
POSIX dice que todos los caracteres se deben incluir en las cadenas.
.IP last
En el \fBbc\fR de POSIX no existe la variable \fBlast\fR. Algunas 
implementaciones de \fBbc\fR usan el punto (.) de manera similar.
.IP comparaciones
El \fBbc\fR de POSIX permite las comparaciones sólo en la sentencia if, la 
sentencia while y la segunda expresión de la sentencia for. Además, sólo se 
permite una operación relacional en cada una de estas sentencias.
.IP "sentencia if, cláusula else"
El \fBbc\fR de POSIX no tiene la cláusula else.
.IP "sentencia for"
El \fBbc\fR de POSIX obliga a que estén todas las expresiones de la 
sentencia for.
.IP "&&, ||, !"
El \fBbc\fR de POSIX no tiene los operadores lógicos.
.IP "función read"
El \fBbc\fR de POSIX no tiene la función read.
.IP "sentencia print"
El \fBbc\fR de POSIX no tiene la sentencia print.
.IP "sentencia continue"
El \fBbc\fR de POSIX no tiene la sentencia continue.
.IP "parámetros de tipo matriz"
El \fBbc\fR de POSIX (actualmente) no admite totalmente las matrices como 
parámetros. La gramática POSIX permite incluir matrices en la definición de 
las funciones, pero no proporciona un método para especificar una matriz 
como parámetro en la llamada. (Se puede considerar esto como un error de la 
gramática). En las implementaciones tradicionales de \fBbc\fR sólo se pueden 
usar las matrices como parámetros por valor.
.IP "=+, =-, =*, =/, =%, =^"
El \fBbc\fR de POSIX no define estos operadores de asignación "al viejo 
estilo". Esta versión puede que las permita. Utilice la sentencia limits 
para ver si la versión instalada las admite. Si se admiten, la sentencia
"a =- 1" decrementará \fBa\fR en 1 en lugar de asignar a \fBa\fR el valor 
-1.
.IP "espacios en los números"
Otras implementaciones de \fBbc\fR permiten espacios en los números. Por 
ejemplo, "x=1 3" asignaría a la variable x el valor 13. La misma sentencia 
provocará un error de sintaxis en esta versión de \fBbc\fR.
.IP "errores y ejecución"
Esta implementación varia de otras implementaciones en el tema de qué 
código se ejecutará cuando en el programa se encuentren errores sintácticos 
o de otro tipo. Si en la definición de una función se encuentra un error 
sintáctico, se intenta recuperar el error encontrando el principio de la 
sentencia y continuando con el análisis de la función. Una vez que el error 
se encuentra en la función, la función no podrá usarse y queda indefinida.
Los errores sintácticos en la ejecución de código interactivo invalidarán 
el actual bloque en ejecución. El bloque en ejecución acaba con un salto de 
línea tras una secuencia completa de sentencias. Por ejemplo,
.nf
.RS
a = 1
b = 2
.RE
.fi
tiene dos bloques y
.nf
.RS
{ a = 1
  b = 2 }
.RE
.fi
tiene un bloque. Cualquier error en tiempo de ejecución terminará con el 
actual bloque en ejecución. Un mensaje de aviso (warning) en tiempo de 
ejecución no terminará con el actual bloque en ejecución.
.IP "Interrupciones"
Durante una sesión interactiva, la señal SIGINT (habitualmente generada por 
el carácter control-C desde el terminal) provocará la interrupción del 
actual bloque en ejecución. Se mostrará un error en tiempo de ejecución 
indicando que función fue interrumpida. Después de limpiar todas las 
estructuras, se muestra un mensaje al usuario para indicarle que \fBbc\fR 
esta listo para aceptar más entrada. Todas las funciones definidas 
previamente permanecen definidas y las variables que no sean del tipo auto 
conservan el valor que tenían en el momento de la interrupción. Durante una 
sesión no-interactiva, la señal SIGINT interrumpirá la ejecución de 
\fBbc\fR por completo.
.SS LÍMITES
Los límites actualmente en vigor para este procesador
.B bc
son los siguientes. Algunos de ellos pueden haber cambiado en el proceso de 
instalación. Utilice la sentencia limits para ver sus valores actuales.
.IP BC_BASE_MAX
La máxima base de salida se inicializa actualmente a 999. La base máxima de 
entrada es 16.
.IP BC_DIM_MAX
Tal y como se distribuye, este límite se inicializa arbitrariamente a 
65535. En su instalación puede ser diferente.
.IP BC_SCALE_MAX
El número de dígitos tras la coma decimal se limita a INT_MAX dígitos. De 
igual manera, el número de dígitos delante de la coma decimal se limita a 
INT_MAX dígitos
.IP BC_STRING_MAX
El límite para el número de caracteres de una cadena es INT_MAX caracteres.
.IP exponente
El valor del exponente en la operación potencia (^) esta limitado a 
LONG_MAX.
.IP multiplicación
La rutina de multiplicación puede dar resultados incorrectos si uno de los 
números tiene más de LONG_MAX / 90 dígitos en total. Para enteros largos 
(longs) de 32 bits, este número es 23.860.929 dígitos.
.IP "tamaño del código"
Cada función y el programa principal ("main") están limitados a 16384 bytes 
de código de bytes (byte code) cada uno. Este límite (BC_MAX_SEGS) puede 
ser fácilmente cambiado para tener más de 16 segmentos de 1024 bytes.
.IP "nombres de variables"
El límite actual para el número de nombres únicos de variables simples, 
matrices y funciones es de 32767 para cada tipo.
.SH VARIABLES DE ENTORNO
Las siguientes variables de entorno son procesadas por \fBbc\fR:
.IP "POSIXLY_CORRECT"
Esto es lo mismo que la opción \fB-s\fR.
.IP "BC_ENV_ARGS"
Este es otra forma de pasar argumentos a \fBbc\fR. El formato es el mismo 
que los argumentos de la línea de comando. Estos argumentos se procesan 
primero, por lo que cualquier fichero presente en los argumentos de entorno 
es procesado antes que cualquiera que aparezca en la línea de comando. Esto 
permite al usuario establecer opciones "estándar" y los ficheros que serán 
procesados en todas las invocaciones de \fBbc\fR. Los ficheros listados en 
las variables de entorno generalmente contendrán definiciones de funciones 
que el usuario quiera tener definidas cada vez que ejecute \fBbc\fR.
.IP "BC_LINE_LENGTH"
Este es un número que especifica el número de caracteres utilizados por los 
números en una línea en la salida. Incluyendo los caracteres de 
contra-barra y de salto de línea para los números largos.
.SH FICHEROS
En la mayoría de las instalaciones, \fBbc\fR está completamente 
auto-contenido. Allí dónde el tamaño del ejecutable sea importante o el 
compilador de C no maneje las cadenas muy largas, \fBbc\fR leerá la 
biblioteca matemática estándar del fichero /usr/local/lib/libmath.b. (La 
situación real puede variar. Puede ser /lib/libmath.b ).
.SH DIAGNÓSTICOS
Si algún fichero dado en la línea de comando no se puede abrir, \fBbc\fR 
informará que el fichero no está disponible y terminará. Asimismo, hay 
errores en tiempo de compilación y de ejecución que deberían ser 
auto-explicativos.
.SH FALLOS (BUGS)
La recuperación de errores no es muy buena todavía.
.PP
Notifique cualquier error a
.BR bug-gnu-utils@prep.ai.mit.edu .
Compruebe que incluye la palabra ``bc'' dentro del campo ``Asunto:'' 
(``Subject:'').
.SH AUTOR
.nf
Philip A. Nelson
phil@cs.wwu.edu
.fi
.SH RECONOCIMIENTOS
El autor quisiera agradecer a Steve Sommars (Steve.Sommars@att.com) su 
gran ayuda probando la implementación. Me dio muchas sugerencias 
estupendas. Éste es un producto mejor gracias a su implicación.
