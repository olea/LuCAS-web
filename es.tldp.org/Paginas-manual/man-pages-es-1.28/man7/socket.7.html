<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  ><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org" /><link rel="stylesheet" type="text/css" href="../../tigris.css" /><title>Manpage of SOCKET</title></head><body><p>
  
</p><h1>SOCKET</h1><p>

Section: Manual del Programador de Linux (7)<br />
Updated: 7 mayo 1999<br /><a href="#index">Index</a> <a href="http://localhost/cgi-bin/man/man2html">Return to Main
Contents</a>
</p><hr /><a id="lbAB"> </a><h2>NOMBRE</h2><p>

socket - Interfaz de conectores (sockets) de Linux <a id="lbAC"> </a> 
</p><h2>SINOPSIS</h2><b>#include &lt;<a href="file:/usr/include/sys/socket.h">sys/socket.h</a>&gt;</b><br /><i>mysocket</i><b>= socket(int</b><i>socket_family</i><b>,
int</b><i>socket_type</i><b>, int</b><i>protocol</i><b>);</b><a id="lbAD"> </a><h2>DESCRIPCIÓN</h2><p>

Esta página de manual describe la interfaz de usuario de la capa de
conectores de red de Linux. Los conectores compatibles con BSD son
la interfaz uniforme entre el proceso de usuario y las pilas de
protocolos de red dentro del núcleo. Los módulos de protocolo se
agrupan en <i>familias de protocolos</i> como <b>PF_INET</b>,
<b>PF_IPX</b> y <b>PF_PACKET</b>, y <i>tipos de conectores</i> como
<b>SOCK_STREAM</b> o <b>SOCK_DGRAM</b>. Vea <b><a href="http://localhost/cgi-bin/man/man2html?2+socket">socket</a></b>(2)
para obtener más información sobre las familias y los tipos. 
</p><p><a id="lbAE"> </a></p><h2>FUNCIONES DE LA CAPA DE CONECTORES</h2><p>

Estas funciones las usa el proceso de usuario para enviar o recibir
paquetes y para realizar otras operaciones con conectores. Para más
información vea sus páginas de manual respectivas. 
</p><p><b><a href="http://localhost/cgi-bin/man/man2html?2+socket">socket</a></b>(2)
crea un conector, <b><a href="http://localhost/cgi-bin/man/man2html?2+connect">connect</a></b>(2)
conecta un conector a una dirección de conector remota, la función
<b><a href="http://localhost/cgi-bin/man/man2html?2+bind">bind</a></b>(2)
enlaza un conector a una dirección de conector local, <b><a href="http://localhost/cgi-bin/man/man2html?2+listen">listen</a></b>(2)
indica al conector que se aceptarán nuevas conexiones y <b><a href="http://localhost/cgi-bin/man/man2html?2+accept">accept</a></b>(2)
se usa para obtener un nuevo conector con una nueva conexión de
entrada. <b><a href="http://localhost/cgi-bin/man/man2html?2+socketpair">socketpair</a></b>(2)
devuelve dos conectores anónimos conectados (sólo implementado para
unas pocas familias locales como <b>PF_UNIX</b>)</p><p><b><a href="http://localhost/cgi-bin/man/man2html?2+send">send</a></b>(2),
<b><a href="http://localhost/cgi-bin/man/man2html?2+sendto">sendto</a></b>(2)
y <b><a href="http://localhost/cgi-bin/man/man2html?2+sendmsg">sendmsg</a></b>(2)
envían datos a través de un conector y <b><a href="http://localhost/cgi-bin/man/man2html?2+recv">recv</a></b>(2),
<b><a href="http://localhost/cgi-bin/man/man2html?2+recvfrom">recvfrom</a></b>(2)
y <b><a href="http://localhost/cgi-bin/man/man2html?2+recvmsg">recvmsg</a></b>(2)
reciben datos de un conector. <b><a href="http://localhost/cgi-bin/man/man2html?2+poll">poll</a></b>(2)
y <b><a href="http://localhost/cgi-bin/man/man2html?2+select">select</a></b>(2)
esperan la llegada de datos o la posibilidad de enviar datos.
Además, se pueden usar las operaciones estándares de E/S como <b><a href="http://localhost/cgi-bin/man/man2html?2+write">write</a></b>(2),
<b><a href="http://localhost/cgi-bin/man/man2html?2+writev">writev</a></b>(2),
<b><a href="http://localhost/cgi-bin/man/man2html?2+sendfile">sendfile</a></b>(2),
<b><a href="http://localhost/cgi-bin/man/man2html?2+read">read</a></b>(2)
y <b><a href="http://localhost/cgi-bin/man/man2html?2+readv">readv</a></b>(2)
para leer y escribir datos.</p><p><b><a href="http://localhost/cgi-bin/man/man2html?2+getsockname">getsockname</a></b>(2)
devuelve la dirección de un conector local y <b><a href="http://localhost/cgi-bin/man/man2html?2+getpeername">getpeername</a></b>(2)
devuelve la dirección de un conector remoto. <b><a href="http://localhost/cgi-bin/man/man2html?2+getsockopt">getsockopt</a></b>(2)
y <b><a href="http://localhost/cgi-bin/man/man2html?2+setsockopt">setsockopt</a></b>(2)
se usan para configurar o consultar opciones de los protocolos o
las capas. <b><a href="http://localhost/cgi-bin/man/man2html?2+ioctl">ioctl</a></b>(2)
se puede usar para configurar o consultar otras opciones
determinadas.</p><p><b><a href="http://localhost/cgi-bin/man/man2html?2+close">close</a></b>(2)
se usa para cerrar un conector. <b><a href="http://localhost/cgi-bin/man/man2html?2+shutdown">shutdown</a></b>(2)
cierra partes de una conexión bidireccional entre conectores.</p><p>Las búsquedas o las llamadas a <b><a href="http://localhost/cgi-bin/man/man2html?2+pread">pread</a></b>(2)
o <b><a href="http://localhost/cgi-bin/man/man2html?2+pwrite">pwrite</a></b>(2)
con una posición distinta de cero, no están soportadas en
conectores.</p><p>Es posible realizar E/S no bloqueante con conectores activando
la opción <b>O_NONBLOCK</b> sobre el descriptor de fichero de un
conector usando <b><a href="http://localhost/cgi-bin/man/man2html?2+fcntl">fcntl</a></b>(2).
<b>O_NONBLOCK</b> se hereda durante una llamada a accept. A
continuación, todas las operaciones que normalmente se bloquearían
devolverán (usualmente) el error <b>EAGAIN</b>. <b><a href="http://localhost/cgi-bin/man/man2html?2+connect">connect</a></b>(2)
devuelve un error <b>EINPROGRESS</b> en este caso. Más tarde, el
usuario puede esperar diferentes eventos mediante <b><a href="http://localhost/cgi-bin/man/man2html?2+poll">poll</a></b>(2)
o <b><a href="http://localhost/cgi-bin/man/man2html?2+select">select</a></b>(2).</p><table border="1"><tr valign="top"><td align="center" colspan="3">Eventos de E/S<br /></td>
</tr><tr valign="top"><td>Evento</td>
<td>Opción de <b>poll</b></td>
<td>Ocurrencia<br /></td>
</tr><tr valign="top"><td>Lectura</td>
<td>POLLIN</td>
<td>Han llegado nuevos datos.<br /></td>
</tr><tr valign="top"><td>Lectura</td>
<td>POLLIN</td>
<td>Se ha completado una nueva solicitud de conexión (para
conectores orientados a conexión).<br /></td>
</tr><tr valign="top"><td>Lectura</td>
<td>POLLHUP</td>
<td>El otro extremo ha iniciado una solicitud de desconexión.<br /></td>
</tr><tr valign="top"><td>Lectura</td>
<td>POLLHUP</td>
<td>Se ha roto una conexión (sólo para protocolos orientados a
conexión). Cuando se escribe en el conector, también se envía la
señal <b>SIGPIPE</b>.<br /></td>
</tr><tr valign="top"><td>Escritura</td>
<td>POLLOUT</td>
<td>El conector tiene suficente espacio en el buffer de envío para
escribir nuevos datos.<br /></td>
</tr><tr valign="top"><td>Lectura/Escritura</td>
<td>POLLIN|<br />
 POLLOUT</td>
<td>Ha finalizado un <b><a href="http://localhost/cgi-bin/man/man2html?2+connect">connect</a></b>(2)
de salida.<br /></td>
</tr><tr valign="top"><td>Lectura/Escritura</td>
<td>POLLERR</td>
<td>Se ha producido un error asíncrono.<br /></td>
</tr><tr valign="top"><td>Lectura/Escritura</td>
<td>POLLHUP</td>
<td>El otro extremo ha cerrado una dirección de la conexión.<br /></td>
</tr><tr valign="top"><td>Excepción</td>
<td>POLLPRI</td>
<td>Han llegado datos fuera de orden, lo que hace que se envíe la
señal <b>SIGURG</b>.<br /></td>
</tr></table><p>Una alternativa a poll/select es dejar que el núcleo informe de
los eventos a la aplicación mediante una señal <b>SIGIO</b>. Para
ello, se debe activar la opción <b>FASYNC</b> en el descriptor de
fichero de un conector mediante <b><a href="http://localhost/cgi-bin/man/man2html?2+fcntl">fcntl</a></b>(2)
y se debe instalar un manejador de señales válido para <b>SIGIO</b>
mediante <b><a href="http://localhost/cgi-bin/man/man2html?2+sigaction">sigaction</a></b>(2).
Vea la discusión sobre <i>SEÑALES</i> más abajo. <a id="lbAF"> </a></p><h2>OPCIONES DE LOS CONECTORES</h2><p>

Estas opciones de conector se pueden configurar usando <b><a href="http://localhost/cgi-bin/man/man2html?2+setsockopt">setsockopt</a></b>(2)
y consultar con <b><a href="http://localhost/cgi-bin/man/man2html?2+getsockopt">getsockopt</a></b>(2)
con el nivel de conectores fijado a <b>SOL_SOCKET</b> para todos
los conectores: 
</p><dl compact="compact"><dt><b>SO_KEEPALIVE</b></dt>

<dd>Habilita el envío de mensajes "sigue vivo" (keep-alive) en
conectores orientados a conexión. Espera una opción booleana
entera.</dd>

<dt><b>SO_OOBINLINE</b></dt>

<dd>Si se habilita esta opción, los datos fuera de orden se colocan
directamente en el flujo de recepción de datos. En otro caso, los
datos fuera de orden sólo se pasan cuando se activa la opción
<b>MSG_OOB</b> durante la recepción.</dd>

<dt><b>SO_RCVLOWAT</b> y <b>SO_SNDLOWAT</b></dt>

<dd>Especifican el número mínimo de bytes en el buffer para que la
capa de conectores pase los datos al protocolo (<b>SO_SNDLOWAT</b>)
o al usuario durante la recepción (<b>SO_RCVLOWAT</b>). Estos dos
valores no se pueden cambiar en Linux y sus argumentos de tamaño
siempre tienen el valor de 1 byte. <b>getsockopt</b> es capaz de
leerlos. <b>setsockopt</b> siempre devolverá
<b>ENOPROTOOPT</b>.</dd>

<dt><b>SO_RCVTIMEO</b> y <b>SO_SNDTIMEO</b></dt>

<dd>Especifica los plazos de tiempo (timeouts) para enviar y
recibir antes de informar de un error. En Linux el valor de ambos
es fijo y viene dado por una configuración específica del protocolo
y no se pueden ni leer ni modificar. Su funcionalidad se puede
emular usando <b><a href="http://localhost/cgi-bin/man/man2html?2+alarm">alarm</a></b>(2)
o <b><a href="http://localhost/cgi-bin/man/man2html?2+setitimer">setitimer</a></b>(2).</dd>

<dt><b>SO_BSDCOMPAT</b></dt>

<dd>Habilita la compatibilidad fallo a fallo con BSD. Esto lo usa
sólo el módulo del protocolo UDP y está previsto que se elimine en
el futuro. Cuando está activa, los errores ICMP recibidos por un
conector UDP no se pasan al programa de usuario. Linux 2.0 también
habilitaba las opciones de compatibilidad fallo a fallo con BSD
(cambio aleatorio de las cabeceras, omisión de la opción de
difusión) para los conectores directos con esta opción, pero esto
se ha eliminado en la versión 2.2 de Linux. Es mejor corregir los
programas de usuario que habilitar esta opción.</dd>

<dt><b>SO_PASSCRED</b></dt>

<dd>Habilita o deshabilita la recepción del mensaje de control
<b>SCM_CREDENTIALS</b>. Para más información, vea <b><a href="http://localhost/cgi-bin/man/man2html?7+unix">unix</a></b>(7).</dd>

<dt><b>SO_PEERCRED</b></dt>

<dd>Devuelve las credenciales del proceso externo conectado a este
conector. Sólo útil para conectores <b>PF_UNIX</b>. Vea <b><a href="http://localhost/cgi-bin/man/man2html?7+unix">unix</a></b>(7).
El argumento es una estructura <b>ucred</b>. Esta opción sólo es
válida para <b>getsockopt</b>.</dd>

<dt><b>SO_BINDTODEVICE</b></dt>

<dd>Enlaza este conector a un dispositivo particular, como
lqeth0rq, especificado en el nombre de inferfaz pasado. Si el
nombre es una cadena vacía o la longitud de las opciones es cero,
se elimina el enlace entre el dispositivo y el conector. La opción
pasada es una cadena (terminada en \0) de longitud variable con el
nombre de la interfaz, con un tamaño máximo de <b>IFNAMSIZ</b>. Si
el conector está ligado a una interfaz, éste sólo procesará los
paquetes recibidos desde la interfaz particular.</dd>

<dt><b>SO_DEBUG</b></dt>

<dd>Activa la depuración de los conectores. Sólo permitida para los
procesos con la capacidad <b>CAP_NET_ADMIN</b> o un identificador
de usuario efectivo 0.</dd>

<dt><b>SO_REUSEADDR</b></dt>

<dd>Indica que las reglas usadas para validar las direcciones
proporcionadas en una llamada <b><a href="http://localhost/cgi-bin/man/man2html?2+bind">bind</a></b>(2)
deben permitir la reutilización de las direcciones locales. Para
los conectores <b>PF_INET</b> esto significa que un conector se
puede enlazar a una dirección, excepto cuando hay un conector
activo escuchando asociado a la dirección. Cuando el conector que
está escuchando está asociado a <b>INADDR_ANY</b> con un puerto
específico, entonces no es posible realizar enlaces a este puerto
para ninguna dirección local.</dd>

<dt><b>SO_TYPE</b></dt>

<dd>Obtiene el tipo de conector como un valor entero (como
<b>SOCK_STREAM</b>). Sólo puede ser leído con
<b>getsockopt</b>.</dd>

<dt><b>SO_DONTROUTE</b></dt>

<dd>No enviar a través de un enrutador, sólo enviar a ordenadores
directamente conectados. Se puede conseguir el mismo efecto
activando la opción <b>MSG_DONTROUTE</b> en una operación <b><a href="http://localhost/cgi-bin/man/man2html?2+send">send</a></b>(2)
sobre un conector. Espera una opción booleana entera.</dd>

<dt><b>SO_BROADCAST</b></dt>

<dd>Establece o consulta la opción de difusión. Cuando está activa,
los conectores de datagramas reciben los paquetes enviados a una
dirección de difusión y se les permite enviar paquetes a una
dirección de difusión. Esta opción no tiene efecto en conectores
orientados a conexión.</dd>

<dt><b>SO_SNDBUF</b></dt>

<dd>Establece u obtiene, en bytes, el máximo buffer de envío de un
conector. El valor por defecto se configura con la sysctl
<b>wmem_default</b> y el máximo valor permitido se establece con la
sysctl <b>wmem_max</b>.</dd>

<dt><b>SO_RCVBUF</b></dt>

<dd>Establece u obtiene, en bytes, el máximo buffer de recepción de
un conector. El valor por defecto se configura con la sysctl
<b>rmem_default</b> y el máximo valor permitido se establece con la
sysctl <b>rmem_max</b>.</dd>

<dt><b>SO_LINGER</b></dt>

<dd>Establece u obtiene la opción <b>SO_LINGER</b>. El argumento es
una estructura <b>linger</b>.</dd>
</dl><dl compact="compact"><dd>
<pre>
struct linger {
    int   l_onoff;    /* activar/desactivar demora */
    int   l_linger;   /* segundos de demora */
};

</pre>
</dd>
</dl><dl compact="compact"><dd>Cuando esta opción está activa, un <b><a href="http://localhost/cgi-bin/man/man2html?2+close">close</a></b>(2)
o <b><a href="http://localhost/cgi-bin/man/man2html?2+shutdown">shutdown</a></b>(2)
no regresarán hasta que todos los mensajes encolados para el
conector hayan sido enviados con éxito o se haya alcanzado el plazo
de tiempo de demora. En otro caso, la llamada regresa
inmediatamente y el cierre se realiza en segundo plano. Cuando el
conector se cierra como parte de una llamada <b><a href="http://localhost/cgi-bin/man/man2html?2+exit">exit</a></b>(2),
siempre se demora en segundo plano.</dd>

<dt><b>SO_PRIORITY</b></dt>

<dd>Asigna a todos los paquetes a enviar a través de este conector
la prioridad definida por el protocolo. Linux usa este valor para
ordenar las colas de red: los paquetes con una prioridad mayor se
pueden procesar primero dependiendo de la disciplina de
encolamiento del dispositivo seleccionado. Para <b><a href="http://localhost/cgi-bin/man/man2html?7+ip">ip</a></b>(7),
esto también establece el campo "tipo de servicio IP" (TOS) para
los paquetes de salida.</dd>

<dt><b>SO_ERROR</b></dt>

<dd>Obtiene y borra el error de conector pendiente. Sólo válida
para <b>getsockopt</b>. Espera un entero.</dd>
</dl><a id="lbAG"> </a><h2>SEÑALES</h2><p>

Cuando se escribe en un conector orientado a conexión que ha sido
cerrado (por el extremo local o remoto) se envía una señal
<b>SIGPIPE</b> al proceso escritor y se devuelve el valor de error
<b>EPIPE</b>. No se envía la señal cuando la llamada para escritura
especifica la opción <b>MSG_NOSIGNAL</b>. 
</p><p>Cuando se solicita con la fcntl <b>FIOCSETOWN</b> o la ioctl
<b>SIOCSPGRP</b>, la señal <b>SIGIO</b> se envía cuando se produce
un evento de E/S. Es posible usar <b><a href="http://localhost/cgi-bin/man/man2html?2+poll">poll</a></b>(2)
o <b><a href="http://localhost/cgi-bin/man/man2html?2+select">select</a></b>(2)
en el manejador de la señal para averigurar sobre qué conector se
produjo el evento. Una alternativa (en Linux 2.2) es configurar una
señal de tiempo real usando la fcntl <b>F_SETSIG</b>. Se llamará al
manejador de la señal de tiempo real con el descriptor de fichero
en el campo <i>si_fd</i> de su estructura <i>siginfo_t</i>. Vea
<b><a href="http://localhost/cgi-bin/man/man2html?2+fcntl">fcntl</a></b>(2)
para más información.</p><p>Bajo determinadas circunstancias (por ejemplo, varios procesos
accediendo a un único conector), la condición que ha provocado la
señal <b>SIGIO</b> puede haber desaparecido ya cuando el proceso
reaccione a la señal. Si esto ocurre, el proceso debería esperar de
nuevo ya que Linux reenviará la señal <b>SIGIO</b> más tarde. <a id="lbAH"> </a></p><h2>SYSCTLS</h2><p>

Se puede acceder a las sysctls fundamentales de red de los
conectores usando los ficheros <b>/proc/sys/net/core/*</b> o
mediante la interfaz <b><a href="http://localhost/cgi-bin/man/man2html?2+sysctl">sysctl</a></b>(2).

</p><dl compact="compact"><dt><b>rmem_default</b></dt>

<dd>contiene el valor por defecto, en bytes, del buffer de
recepción de un conector.</dd>

<dt><b>rmem_max</b></dt>

<dd>contiene el tamaño máximo, en bytes, del buffer de recepción de
un conector que el usuario puede establecer usando la opción de
conector <b>SO_RCVBUF</b>.</dd>

<dt><b>wmem_default</b></dt>

<dd>contiene el valor por defecto, en bytes, del buffer de envío de
un conector.</dd>

<dt><b>wmem_max</b></dt>

<dd>contiene el tamaño máximo, en bytes, del buffer de envío de un
conector que un usuario puede configurar usando la opción de
conector <b>SO_SNDBUF</b>.</dd>

<dt><b>message_cost</b> y <b>message_burst</b></dt>

<dd>configuran el filtro de cubetas de fichas usado to load limit
warning messages provocados por eventos de red externos.</dd>

<dt><b>netdev_max_backlog</b></dt>

<dd>Número máximo de paquetes en la cola de entrada global.</dd>

<dt><b>optmem_max</b></dt>

<dd>Longitud máxima de los datos auxiliares y de los datos de
control del usuario, como los iovecs por conector.</dd>
</dl><a id="lbAI"> </a><h2>IOCTLS</h2><p>

Se puede acceder a estas ioctls usando <b><a href="http://localhost/cgi-bin/man/man2html?2+ioctl">ioctl</a></b>(2):

</p><dl compact="compact"><dd>
<pre>
<i>error</i> <b>= ioctl(</b><i>ip_socket</i><b>,</b> <i>ioctl_type</i><b>,</b> <i>&amp;value_result</i><b>);</b>
</pre>
</dd>
</dl><dl compact="compact"><dt><b>SIOCGSTAMP</b></dt>

<dd>Devuelve una <b>struct timeval</b> con la marca de tiempo
recibida del último paquete pasado al usuario. Esto es útil para
realizar medidas exacta del tiempo de ida y vuelta o tiempo de
viaje. Vea <b><a href="http://localhost/cgi-bin/man/man2html?2+setitimer">setitimer</a></b>(2)
para una descripción de <b>struct timeval</b>.</dd>

<dt><b>SIOCSPGRP</b></dt>

<dd>Configura el proceso o grupo de procesos al que enviar la señal
<b>SIGIO</b> o <b>SIGURG</b> cuando termina una operación de E/S
asíncrona o hay disponibles datos urgentes. El argumento es un
puntero a un <b>pid_t</b>. Si el argumento es positivo, las señales
se envian a ese proceso. Si es negativo, las señales se envían al
grupo de procesos cuyo identificador es el valor absoluto del
argumento. El proceso sólo puede seleccionar a él mismo o a su
propio grupo de procesos para que reciban las señales, a menos que
posea la capacidad <b>CAP_KILL</b> o un identificador de usuario
efectivo 0.</dd>

<dt><b>FIOASYNC</b></dt>

<dd>Modifica la opción <b>O_ASYNC</b> para habilitar o deshabilitar
el modo de E/S asíncrona del conector. El modo de E/S asíncrona
significa que se producirá una señal <b>SIGIO</b>, o la señal
establecida mediante <b>F_SETSIG</b>, cuando se produzca un nuevo
evento de E/S.</dd>

<dd>El argumento es una opción booleana entera.</dd>

<dt><b>SIOCGPGRP</b></dt>

<dd>Obtiene el proceso o grupo de procesos actual que recibe las
señal <b>SIGIO</b> o <b>SIGURG</b>, o 0 cuando no hay ningúno.</dd>
</dl><p>Fcntls válidas:</p><dl compact="compact"><dt><b>FIOCGETOWN</b></dt>

<dd>Idéntica a la ioctl SIOCGPGRP.</dd>

<dt><b>FIOCSETOWN</b></dt>

<dd>Idéntica a la ioctl SIOCSPGRP.</dd>
</dl><a id="lbAJ"> </a><h2>OBSERVACIONES</h2><p>

Linux asume que se usa la mitad del buffer de envío/recepción para
estructuras internas del núcleo. Por tanto, las sysctls son el
doble de lo que se puede observar en última instancia. <a id="lbAK"> </a> 
</p><h2>FALLOS</h2><p>

No se han documentado las opciones de conector
<b>SO_ATTACH_FILTER</b> y <b>SO_DETACH_FILTER</b> de
<b>CONFIG_FILTER</b>. La interfaz sugerida para usarlas es la
biblioteca libpcap. <a id="lbAL"> </a> 
</p><h2>VERSIONES</h2><b>SO_BINDTODEVICE</b><p> se introdujo en la versión 2.0.30 de Linux.
<b>SO_PASSCRED</b> es nueva en la versión 2.2 del núcleo. Las
sysctls son nuevas en Linux 2.2. <a id="lbAM"> </a> 
</p><h2>AUTORES</h2><p>

Esta página de manual fue escrita por Andi Kleen. <a id="lbAN"> </a> 
</p><h2>VÉASE TAMBIÉN</h2><b><a href="http://localhost/cgi-bin/man/man2html?2+socket">socket</a></b><p>(2),
<b><a href="http://localhost/cgi-bin/man/man2html?7+ip">ip</a></b>(7),
<b><a href="http://localhost/cgi-bin/man/man2html?2+setsockopt">setsockopt</a></b>(2),
<b><a href="http://localhost/cgi-bin/man/man2html?2+getsockopt">getsockopt</a></b>(2),
<b><a href="http://localhost/cgi-bin/man/man2html?7+packet">packet</a></b>(7),
<b><a href="http://localhost/cgi-bin/man/man2html?7+ddp">ddp</a></b>(7) 
</p><hr /><a id="index"> </a><h2>Index</h2><dl><dt><a href="#lbAB">NOMBRE</a></dt>

<dt><a href="#lbAC">SINOPSIS</a></dt>

<dt><a href="#lbAD">DESCRIPCIÓN</a></dt>

<dt><a href="#lbAE">FUNCIONES DE LA CAPA DE CONECTORES</a></dt>

<dt><a href="#lbAF">OPCIONES DE LOS CONECTORES</a></dt>

<dt><a href="#lbAG">SEÑALES</a></dt>

<dt><a href="#lbAH">SYSCTLS</a></dt>

<dt><a href="#lbAI">IOCTLS</a></dt>

<dt><a href="#lbAJ">OBSERVACIONES</a></dt>

<dt><a href="#lbAK">FALLOS</a></dt>

<dt><a href="#lbAL">VERSIONES</a></dt>

<dt><a href="#lbAM">AUTORES</a></dt>

<dt><a href="#lbAN">VÉASE TAMBIÉN</a></dt>
</dl><hr /><p>
This document was created by <a href="http://localhost/cgi-bin/man/man2html">man2html</a>, using
the manual pages.<br />
Time: 06:16:28 GMT, January 22, 2005
</p></body></html>
