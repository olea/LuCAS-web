<!doctype linuxdoc system>

<article>
<!-- Notas: 
- 1 pagina de articulo, aprox. 6000 caracteres
- Un cuadro al menos cada dos paginas, o un cuadro y una captura
- Capturas con pie de foto
- Para incluir imagen ********* IMAGEN **********+
- 1 sumario por pagina 
-->


<title>Artículo para la revista Linux Actual número 17: Bases de datos en WWW con Perl embedido
<author>Miguel Angel Nacenta Sánchez y Javier Fernández-Sanguino Peña 
<date>9 noviembre 2000

<abstract> 
En este artículo veremos cómo se puede introducir Perl para la
creación, gestión y mantenimiento de bases de datos a través de la WWW.
</abstract>


<sect>Introducción
<p>

Antes de comenzar se van a repasar algunos de los conceptos vistos ya
en la serie, pero que refrescarán la memoria al lector además de
introducir algunos conceptos nuevos.

Desde que la la WWW decidió que quería ser más interactiva (hace ya
unos cuantos años) y dejar de limitarse a ofrecer contenidos
estáticos, han surgido muchas soluciones que permiten al usuario
interactuar con el sistema. Estas soluciones se pueden separar
claramente en dos tipos; soluciones ejecutadas en el cliente y
soluciones ejecutadas en el servidor. Las primeras (Javascript,
VBscript, applets etc.) fueron un avance considerable en la creación
de lugares Web; pero la mayoría de las aplicaciones serias donde hay
un flujo de información importante no se pueden gestionar de esta
manera.
      
Por eso hace mucho que existen los CGI scripts, de amplio uso sobre
todo en páginas de servidor que ofrecen algún tipo de servicio en el
que no se puede delegar el control al ordenador del cliente; bien por
motivos de seguridad, o bien por razones de eficiencia. Pongamos un
ejemplo: si queremos que un usuario extraiga una información de
nuestra base de datos no podemos pasarle la base de datos al usuario
para que el pueda hacer la consulta. Sería demasiado costoso en ancho
de banda, y es probable que no queramos que acceda a toda la
información (ni siquiera que la tenga).

<sect>CGI scripts.
<p>
La solución que surge entonces es utilizar un programa que puede
intercambiar datos con el usuario a través de la WWW, ejecutado en
nuestro servidor y que por lo tanto corre en un entorno seguro y que
conocemos. Esos programas podían estar escritos y funcionando en
prácticamente cualquier sistema o lenguaje de programación.
      
Nuestro script típico tomaría los datos que se le han proporcionado, y
realizaría alguna acción, devolviendo como resultado una página www
que podría ser distinta dependiendo de los datos o del resultado del
proceso en nuestra máquina. Esto significa interactividad con control
en el servidor. Lo único que controla el usuario son los datos que
manda (esto también puede resultar un agujero de seguridad, pero ya
hablaremos de ello más adelante).
      
Hasta hace relativamente poco, la solución más accesible (y la que
probablemente siga siendo la más adoptada) es usar Perl para procesar
los datos y construir una página que se le pueda devolver al usuario.
    

Perl es un lenguaje interpretado que posee unas características
particularmente beneficiosas a la hora de escribir programas de este
tipo, ya que fue inicialmente concebido como una herramienta de
proceso de informes y muestra un comportamiento excelente en el
proceso de datos de cualquier tipo. De hecho, PERL es el acrónimo de
<em>Practical Extraction and Report Language</em>, es decir, lenguaje
de programación práctico para extracción y generación de informes.
Además Perl es completamente libre y hay desarrolladas una cantidad
muy importante de librerías de funciones que implementan casi todas
las funciones que uno pueda necesitar.  Pero en este punto surgen
varios problemas:

<itemize>
<item>Cada vez que el script se tiene que ejecutar ha de iniciarse el
intérprete de Perl, lo cual resulta en una sobrecarga inicial no
despreciable. Esto limita nuestro uso del script: sólo podremos
utilizarlo en máquinas potentes o en sistemas que sepamos que van a
tener pocos usuarios simultáneos.

<item>El script que programemos ha de generar la página
íntegramente. Es decir, que tenemos que programar nuestro script para
que el documento resultante tenga etiquetas como &lt;html&gt;,
&lt;head&gt;, &lt;body&gt; etc, y en el orden adecuado. Esto tiene
repercusiones importantes a la hora del diseño de webs grandes, en los
que el mantenimiento del estilo y las plantillas no resulta un
problema trivial.
</itemize>

<sect1>Las alternativas.
<p>
    
Como respuesta a estos problemas han surgido varios sistemas, algunos
de ellos dependientes de plataforma, que alivian de algún modo las
pesadillas de los webmasters y de los administradores.
    
<itemize>

<item>PHP/ASP. 
Ahora mismo es el tipo de solución más popular. El concepto es
sencillo: dentro de las propias páginas html se incluyen unas
directivas escritas en un lenguaje especial que se ejecuta en el
servidor (accesos a bases de datos, bucles etc). PHP por supuesto
tiene la ventaja de que es libre
 y que está disponible para casi todas las
plataformas y sistemas operativos, a diferencia de las Active Server
Pages de Microsoft.

<item>Servlets.
Son programas ejecutados en el lado del servidor que pueden correr
scripts en lenguajes como Java (Java Servlets) aunque ahora es posible
utilizar otros lenguajes interpretados como Python etc...

</itemize>

<sect1>La solución elegida
<p>
	
Perl Embebido es un módulo de extensión de Perl que nos va a permitir
la máxima interactividad posible desde el servidor usando Perl como
lenguaje de programación.

	
Perl Embebido supera nuestras dos dificultades principales del
siguiente modo:

<itemize>

<item>En primer lugar se ejecuta bajo mod_perl (aunque también puede
ejecutarse al estilo de los antiguos CGI's). Mod_perl es un módulo de
Apache que introduce el intérprete de Perl dentro del mismo servidor
Web y que optimiza la ejecución de aplicaciones escritas en este
lenguaje, evitando la sobrecarga de inicialización antes mencionada y
logrando un rendimiento muy superior al de otras alternativas.

<item>En segundo lugar y tal como reza el nombre, Perl embebido permite
incluir código Perl directamente dentro de las páginas web. Esto no
sólo resulta cómodo para el programador sino que permite la
integración con otras herramientas que el estilo Perl-CGI antiguo no
nos permitía, como por ejemplo con Website Meta Language.

</itemize>
	
<sect2>Principales ventajas de Perl Embebido.
<p>

Es conveniente destacar algunas de las principales ventajas a la hora
de utilizar Perl como elemento de acceso a la base de datos, algunas
particulares del lenguaje de programación en sí y otras particulares
de la forma de introducir Perl en servidores WWW:


<itemize>
<item>Perl es un lenguaje flexible, potente, maduro y muy rápido a la hora
de escribir código.

	 
<item>Existe una tremenda cantidad de módulos bien documentados que podemos
usar dentro de nuestro código y que nos permiten construir de forma
sencilla aplicaciones web que hagan casi cualquier cosa (Ej: Acceso a
bases de datos independiente de la implementación de SQL, creación
automática de imágenes, operación sobre el sistema operativo...). Y
toda esta funcionalidad se puede explotar con Perl embebido desde una
página Web.

	 
<item>La ejecución sobre <em>mod_perl</em> es muy veloz. Varias
pruebas han revelado que es muchas veces más rápida que la de CGI's
convencionales.

	 
<item>Todo el software que es necesario para hacer funcionar
<em>mod_perl</em> es libre y está bien documentado. Además algunas
distribuciones lo incluyen empaquetado y prácticamente listo para
usar.

	 
<item><em>mod_perl</em> Incluye algunas facilidades propias para
manejar aspectos particulares de la programación web que resultan muy
útiles (datos de formularios, manejo de la sesión, etc).
</itemize>

Quizás la ventaja más importante es que no es necesario aprender un
lenguaje de programación que sirva para una única aplicación. Perl es
multipropósito y tremendamente útil en otros campos de
utilización. 


<sect2>Desventajas
<p>
	
Sin embargo Perl embedido no está exento de desventajas, puede
resultar, a priori, un poco más difícil de utilizar que sus
rivales. Además, el lenguaje de programación Perl puede ser bastante
difícil de leer (y por tanto mantener) si no se ha documentado lo
suficiente. La premisa de Perl de poder realizar la misma cosa de
muchas maneras distintas puede llevar a que el mantenimiento del
código por parte de otro programador sea dificultosa si las cosas no
se han hecho de manera ordenada.

<sect>Puesta en funcionamiento y configuración.
<p>
	
Antes de explicar cómo se instala y configura es necesario introducir
los elementos que van a entrar en juego para la instalación.

<itemize>
<item>Apache: Es el servidor web libre más avanzado y el más usado en
	Internet. Implementa un sistema de módulos con los cuales se
	pueden añadir funcionalidades al servidor.

<item>Mod_perl: Es un módulo de Apache que permite la ejecución
		eficiente de programas escritos en Perl.

<item>Perl: Es el intérprete de Perl, con el cual podemos ejecutar
	scripts escritos en el lenguaje del mismo nombre.

<item>DBI: Es un módulo (una biblioteca de funciones) de Perl que nos
permitirá el acceso a bases de datos de forma uniforme e independiente
de la base a la que estemos accediendo (Postgres, Oracle, Informix,
Interbase etc.)

<item>Postgresql: Es el sistema de base de datos libre más
	avanzado. La utilizaremos como ejemplo del acceso a bases de
	datos desde Perl Embebido.

<item>DBD::Pg: Es el módulo que usa DBI para acceder a funciones de
	Posgresql, que es la base de datos con la que implementamos
	nuestros ejemplos. En caso de utilizar otras bases de datos,
	tendremos que utilizar un &dquot;driver&dquot; distinto (Ej: DBD::Mysql).

</itemize>

<sect>Instalación
<p>
	
En primer lugar, para poder hacer nuestras pruebas necesitamos tener
un servidor Apache funcionando. La descripción de la instalación de
Apache queda fuera de la intención de este artículo, pero tampoco es
un tema excesivamente complicado, sobre todo si se usa alguna
distribución como Debian o Red Hat. Para saber si tenemos un servidor
Apache funcionando podemos probar en un navegador cualquiera que esté en
nuestra máquina a acceder a la dirección http://localhost/. Si no
habíamos introducido anteriormente ninguna página y tenemos nuestro
servidor activo, deberíamos ver una página de bienvenida de Apache.
	
Perl también debe estar instalado en nuestra máquina. Al igual que en
el caso de Apache, existe amplia documentación sobre este proceso, y
la mayoría de las veces es extremadamente sencillo.

	
Una vez que tenemos estos dos elementos instalados pasamos a la
instalación de <em>mod_perl</em>. Como siempre, si utilizamos una buena
distribución este proceso resultará sencillísimo, tanto como pedirle
al sistema que instale el paquete correspondiente a <em>mod-perl</em> (en
Debian se trata del paquete <em>libapache-mod-perl</em>).

	
Una vez que tenemos el fichero hay que decirle a Apache que lo
utilice.  El fichero de configuración de apache
&dquot;httpd.conf&dquot; contiene los módulos que se cargan al
arrancarlo. Lo normal es que este fichero contenga una linea
Loadmodule referente a mod perl, que tan sólo hemos de descomentar
(eliminar el &dquot;#&dquot; del principio). Si esta línea no existe,
debemos añadirla. La línea tendrá el siguiente aspecto:

<tscreen><verb>
   LoadModule perl_module /ruta/del/archivo/del/modulo/mod_perl.so
</verb></tscreen>

        
Ahora ya tenemos un servidor con la capacidad de ejecutar scripts a
través de <em>mod_perl</em>. Lo siguiente será hacer que el Perl embebido
funcione. De nuevo aparece la misma disyuntiva: si nuestro Linux está
instalado a partir de una distribución en la cual exista el paquete de
<em>emb-perl</em> (en Debian: <em>libhtml-embperl-perl</em>) bastará decirle al sistema
que lo instale. Si no, tendremos que bajarnos el archivo de
instalación (ver listado 1) y realizar los siguientes 
pasos:
<tscreen><verb>
	perl Makefile.PL 
	make 
	make test 
	make install 
</verb></tscreen>
	
	
El penúltimo de los pasos (<tt>make test</tt>) requiere que se hallen en su
sistema algunas bibliotecas instaladas de antemano.

Lo último que nos queda por hacer es configurar Apache para que
ciertos tipos de extensiones las procese con Embperl. En principio
nuestro servidor web puede tener gran variedad de tipos de ficheros
que procesar, y no queremos que procese todos a través de Embperl. Por
eso asignaremos a los documentos escritos con este propósito la
extensión de fichero .epl, aunque por supuesto esta configuración
puede (o debe) ser modificada según las necesidades concretas de
nuestro servidor o servicios web.

    
Para asignar la extensión .epl a los ficheros que deben ser procesados
por Embperl puede bastar con añadir las siguientes líneas a alguno de
los ficheros de configuración de Apache (srm.conf o httpd.conf),
aunque cualquier lector que haya trabajado con este servidor web es,
probablemente, capaz de sugerir varias alternativas.

<tscreen><verb>
    &lt;Files *.epl&gt;
    SetHandler  perl-script
    PerlHandler HTML::Embperl
    Options     ExecCGI
    &lt;/files&gt;

    AddType text/html .epl
</verb></tscreen>

	
<sect>¿Cómo se programa con Perl embebido?
<p>
	
El primer ejemplo que aquí se muestra, servirá para introducir la
sintaxis básica del lenguaje y al mismo tiempo para comprobar que
nuestro sistema está funcionando y procesa nuestros ficheros
.epl. Pero antes necesitamos tener el esqueleto de un archivo escrito
en HTML corriente en el que podamos empotrar nuestro código Perl.
	

<tscreen><verb>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Pruebas de Embperl&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Este es nuestro fichero de pruebas&lt;/H1&gt;

En este fichero todavía no hay nada que tenga que ver con Perl embebido.

&lt;/BODY&gt;
&lt;/HTML&gt;
</verb></tscreen>

	
El lector que todavía no tenga claro si su servidor web está
funcionando puede comprobarlo copiando este código en un fichero y
poniendo en las localizaciones típicas (pruebe a ponerlo en
<tt>/var/www/</tt> aunque debería mirar la variable DocumentRoot en su configuración de Apache).

	
Ahora comenzaremos a añadir capacidad de proceso a este archivo. En
primer lugar parece bastante lógico que cuando insertemos nuestro Perl
en el html tendremos que separarlo de alguna manera, para que el
intérprete reconozca lo que tiene que procesar y lo que no (el resto
del html). Esto en Perl embebido se hace con corchetes. Una sentencia
típica podría tener el siguiente aspecto.

<tscreen><verb>
	[- $variable1 = "Hola"; -]
</verb></tscreen>


El grupo de caracteres &dquot;[-&dquot; y &dquot;-]&dquot; delimitan
bloques de código perl dentro del HTML. Cualquier cosa que esté
incluida entre estos símbolos será interpretada como código Perl. Tan
sólo hay que preocuparse de terminar las sentencias con
&dquot;;&dquot; tal y cómo haríamos en un archivo de Perl corriente.
Lo que hemos hecho en la línea anterior es una simple asignación, la
variable &dquot;$variable1&dquot; contendrá ahora la cadena de texto
&dquot;Hola&dquot;. Al programador Perl que vea esto lo más probable
es que se le ocurra introducir sentencias con la instrucción
&dquot;print&dquot; dentro de los delimitadores que acabamos de
aprender. Sin embargo, Perl no sabría dónde tiene que imprimir el
resultado de la variable. El siguiente trozo de código es incorrecto
sólo por la declaración en la que aparece la instrucción
<em>print</em>:

<tscreen><verb>
	[- 
	   $variable1 = "Hola";
	   $suma = 1 + 2;
	   if ($suma > 0) {
	     $texto = "Mayor que cero";
	     print $texto; # Esta es la línea incorrecta
	   } 
	   $variable2 = $variable1
	 -] 
</verb></tscreen>

	 
Pero entonces ¿cómo imprimimos el resultado de nuestros cálculos (o de
nuestras operaciones interactivas) en la página web? Muy fácil,
usaremos otros delimitadores: &dquot;[+&dquot; y &dquot;+]&dquot;. El
siguiente listado muestra un ejemplo muy sencillo de cómo podemos
imprimir el resultado de una variable asignada previamente en nuestro
código, ya incluido dentro de nuestra página de prueba:

<tscreen><verb>	
  &lt;HTML&gt;
   &lt;HEAD&gt;
    &lt;TITLE&gt;Pruebas de Embperl&lt;/TITLE&gt;
   &lt;/HEAD&gt;
   &lt;BODY&gt;
    &lt;H1&gt;Este es nuestro fichero de pruebas&lt;/H1&gt;

     [- $variable1 = "hola";
        $variable2 = ", ¿qué tal?" -]

     [+ $variable1 +]

   &lt;/BODY&gt;
  &lt;/HTML&gt;
</verb></tscreen>
         
Con este ejemplo, ya podemos comprobar que Embperl está procesando
nuestro fichero. Si nombramos al archivo que contiene el código
anterior &dquot;prueba.epl&dquot;, lo situamos en el mismo lugar donde ya tengamos
páginas funcionando e intentamos acceder a él desde el exterior,
deberíamos ver algo como la figura nº 1.

****** IMAGEN 1 ****************************

        
En este punto hay que aclarar algunas cuestiones que se pueden
plantear habiendo visto los ejemplos anteriores. En primer lugar, como
ya aparece implícito en los ejemplos anteriores, dentro de los
delimitadores &dquot;[-&dquot; y &dquot;-]&dquot; podemos escribir
código en varias líneas, e incluso poner comentarios. El último
&dquot;;&dquot; que pongamos dentro de este código es opcional, ya que
Embperl lo cierra por nosotros en caso de que no nos demos cuenta.

	
Podemos incluir cuantos grupos de código queramos, y todos
<em>comparten el mismo espacio de variables dentro de una misma página
y una misma llamada</em>. Esto quiere decir por un lado que podemos
dotar a las variables de un valor en un grupo de código y luego usar
esa variable (que ya contiene el valor que le hemos asignado
previamente) en otro grupo, y por otra parte que si un usuario desde
Internet decide hacer una recarga de nuestra página, los valores de
las variables no se conservarán.

	
Dentro de los delimitadores de impresión en la página ([+ +]) podemos
poner cualquier cosa que pudiera ser argumento de la función
print. Por ejemplo, si queremos que la página descrita unos párrafos
más arriba sea un poco más educada, podemos sustituir la línea &dquot;[+
$variable1 +]&dquot; por esta otra &dquot;[+ &dquot;$variable1.$variable2&dquot; +]&dquot;

	
Cuando decimos que podemos incluir código dentro de nuestra página,
también quiere decir que puede haber bucles, condiciones y cualquiera
de las posibilidades de control de flujo de un programa que perl nos
brinda (que no son pocas). Pero el verdadero poder que nos brinda Perl
en una página web es la posibilidad de iterar y condicionar no sólo la
ejecución de una parte programada, sino <em>también las etiquetas HTML
y sus contenidos</em>. Para explicar mejor esto, ponemos un ejemplo:

	
Necesitamos que nuestra página enseñe una imagen si el resultado de un
cálculo anterior es mayor que 5, y en caso contrario, que muestre un
texto de cabecera de primer nivel (&lt;H1&gt;). Para hacer esto utilizaremos
lo que se denomina en Embperl <em>Meta-comandos</em>; aunque el nombre
asusta un poco, tan sólo se trata de separar las sentencias Perl de
bifurcación e iteración en bloques separados. Por ejemplo [$ if
(condición) $] que hay que terminar con [$ endif $]. A continuación
listamos el código que implementa el problema enunciado al principio
del párrafo.

<tscreen><verb>
  &lt;HTML&gt;
    &lt;HEAD&gt;
      &lt;TITLE&gt;Pruebas de Embperl&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;
      &lt;H1&gt;Este es nuestro fichero de pruebas&lt;/H1&gt;
       [- 
         $variable=7;	#aquí podría haber algo más complicado.
       -]
       [$ if ($condicion&gt;5) $]
         &lt;IMG SRC=imagen.gif&gt;
       [$ else $]
         &lt;H1&gt;La variable es menor o igual a 5, mis disculpas.&lt;/H1&gt;
       [$ endif $]
   &lt;/BODY&gt;
  &lt;/HTML&gt;
</verb></tscreen>
	
Desde el punto de vista de la programación Perl choca un poco el hecho
de que haya que cerrar cada una de las sentencias, pero con un poco de
detenimiento podrá el lector observar que si no se le indicara al
intérprete la finalización del bucle o la condición éste no podría
determinar sobre que trozo de código iterar o decidir.  Además del
meta-comando que acabamos de utilizar existe uno para cada sentencia
de control de flujo de Perl. A continuación listamos unos cuantos con
sus sentencias de cierre como referencia.


<tscreen><verb>
	[$ if (condicion) $]		
	[$ elseif (condicion) $]		
	    ...			       
	[$ else $]	
	[$ endif $]	
	
	[$ do $]
	[$ until $]

	[$ while (condicion) $]
	[$ endwhile $]         

	[$ foreach $var (lista) $]
	[$ endforeach $]
</verb></tscreen>

	
Pero el ejemplo descrito anteriormente no resulta de mucha utilidad,
en primer lugar porque siempre producirá la misma salida. Nuestra
próxima tarea será interactuar con el usuario.

	
La manera más directa y usual para interactuar con el usuario a través
de una página web es un formulario. Embperl nos permite acceder
fácilmente a la información proveniente de los formularios que se ha
enviado a nuestra pagina-Embperl_script. Para eso existe una
estructura de tipo &dquot;hash&dquot; (tambien llamada array
asociativo) con la cual podemos acceder directamente a estos
datos. Este &dquot;hash&dquot; se llama %fdat contiene la información
enviada de la siguiente forma:

<tscreen><verb>
	%fdat = (
		  nombre_del_campo  => información_del_campo,
		  nombre_otro_campo => información_del_otro_campo
		)
</verb></tscreen>
        
Para verlo más claro supongamos que una página web que hemos hecho de
antemano (que no tiene porqué tener nada que ver con Embperl) contiene
las siguientes líneas:

<tscreen><verb>
	&lt;FORM METHOD="POST" ACTION="prueba.epl"&gt;
	Ponga su comentario:&lt;INPUT TYPE="text" NAME="comentario"&gt;&lt;BR&gt;
	Y su nombre:    &lt;INPUT TYPE="text" NAME="nombre"&gt;&lt;BR&gt;
	&lt;INPUT TYPE="submit" NAME="enviar" VALUE="enviar"&gt;
	&lt;/FORM&gt;
</verb></tscreen>
	
Cuando el usuario de esta página pulsa el botón en el que pone
&dquot;enviar&dquot;, el navegador envía una petición http de la
página-script &dquot;prueba.epl&dquot; (la que ahora nos ocupa)
incluyendo la información del formulario que hemos descrito un poco
antes. Para saber si el usuario que lo ha mandado ha tecleado en el
campo de nombre la información &dquot;pepe&dquot;, y obrar en
consecuencia, podríamos incluir en nuestra página el siguiente código:

<tscreen><verb>
	[$ if ($fdat{nombre} eq "Pepe") $]
	[+ "¡Qué alegría Pepe, cuanto tiempo sin saber nada de tí!" +]
	[$ else $]
	Lo siento, [+ $fdat{nombre} +], pero no nos han presentado.&lt;br&gt;
	[$ endif $]
</verb></tscreen>

	
Ahora tenemos una visión más amplia de lo que puede hacer Embperl por
la interactividad de nuestras páginas. Pero todavía no hemos abierto
la caja de Pandora, o mejor dicho CPAN, el archivo de módulos Perl.


<sect>Programación en  Perl::DBI
<p>

DBI es el acrónimo de <em>Database Interface</em>, y es un módulo que
permite al programa abstraerse de la implementación específica del
acceso a la base de datos, que puede ser distinta en cada base de
datos, y le permite programar el acceso a una base de datos de manera
transparente. De esta forma se está facilitando la portabilidad de los
diversos programas ya que no están &dquot;atados&dquot; a ninguna base
de datos.

Como se muestra en la figura 2, Perl::DBI encaja entre los programas y
los interfaces particulares de cada base de datos, los llamados DBD
(de <em>Database Drivers</em>) que son los que implementan el acceso a
la base de datos en sí.

DBI tiene un interfaz muy sencillo que permitirá al programador
seleccionar la base de datos a utilizar y hacer consultas SQL,
devolviendo los resultados en tablas o arrays asociativos que puedan
ser fácilmente tratados en Perl.

El acceso a una base de datos con Perl::DBI se limita a:

<itemize>

<item>La conexión a la base de datos, que se realiza con la función <em>connect</em> y en la que se indica la base de datos a utilizar, así como el usuario y contraseña para realizar la conexión.

<item>La preparación de una llamada SQL con la función <em>prepare</em>, que se utilizará para que el motor de la base de datos con la que se ha realizado la conexión &dquot;compile&dquot; la instrucción SQL y se prepare a ejecutarla.

<item>La ejecución de la llamada SQL ya preparada con la función <em>execute</em>.

<item>La recuperación de los datos resultados de la ejecución de la orden SQL con las funciones <em>fetchrow_array</em>, <em>fetchrow_arrayref</em> o <em>fetchrow_hashref</em>.

<item>La finalización de la consulta con la función <em>finish</em>.

<item>La desconexión de la base de datos con la orden <em>disconnect</em>.

</itemize>


<sect>Migración de pgsql a Perl Embedido
<p>

En los artículos anteriores se ha desarrollado el acceso a una base de
datos utilizando un preprocesador específico para PostgreSQL que
permitía desarrollar intérpretes CGI rápidamente con los que acceder a
la base de datos. Sin embargo este acercamiento no esta exento de
problemas, algunos de los cuales ya se introdujeron en artículos
previos, y que pueden concretarse en:

<itemize>
<item>dificultada en la intercepción de errores.
<item>dificultad en la comprobación de datos recibidos.
<item>dificultad en la elaboración de interfaces complejos.
<item>necesidad de la separación de los formularios y el acceso a la base de datos.
</itemize>

Estos problemas van a poder ser solventados, pero no sin antes un
esfuerzo adicional de programación para contemplarlos y una
reimplementación haciendo uso de Perl embedido. Una vez hecha, sin
embargo, la reimplementación, la disponibilidad de un gran número de
módulos de Perl para las más diversas tareas (envío de correos
electrónicos, acceso a ficheros...) así como la integración con el
servidor de Apache para la gestión, por ejemplo, de cookies o de
sesiones, nos permitirán poder abrir nuevos campos de aplicación al
interfaz ya realizado.

Otra ventaja, además, es que podremos coger consultas implementadas en
Perl embedido y, con mínimos esfuerzo, convertirlas en programas
interpretados escritos en Perl que se ejecuten en el servidor. Esto va
a permitir, si fuera necesario, convertir el tratamiento dinámico de
la información en estático, si fuera necesario.


<sect1>Consulta de datos con Perl embedido
<p>

************** LISTADO 2 ****************************+


Como se puede ver en el listado 2, el acceso a las funciones de Perl
embedido permiten programa muchas características dentro de una
página. Vamos a tomar dicho listado como la base de un ejemplo para
ver cómo se haría la migración de las distintas consultas y
formularios de introducción de datos en este lenguaje, analizándolo
por completo.

En primer lugar se puede ver que el primer bloque hace que se carguen
los distintos módulos que van a ser utilizados por el intérprete, de
particular interés serán DBI, ya comentado, y CGI::Cookie, que
permitirá acceder a las cookies que el usuario envíe al
servidor. Estas cookies, como ya se comentó en artículos anteriores
son las que se van a utilizar para identificar si el usuario ha sido
autenticado.

Posteriormente, se hace la conexión con la base de datos, utilizando
la función correspondiente del módulo DBI, preservando en variables la
posibilidad o no de haber realizado la conexión. Esto va a permitir
que, a continuación se puedan tratar los casos de fallo de conexión a
la base de datos.

Como se puede ver en el bloque <em>if</em>
se pueden, dentro de una misma página introducir información que se va
a mostrar en función de las acciones tomadas anteriormente. Este
bloque permite mostrar una página determinada (en realidad va a
reenviar al usuario con un <em>refresh</em> a la página en cuestión)
en el caso de que no se haya podido establecer la conexión a la base
de datos. Los siguientes bloques se evaluarán sólo en el caso de que
la conexión haya sido exitosa, ya que, de no serlo, el intérprete
saltará al bloque <em>endif</em> correspondiente.

A continuación se evalúa si la <em>cookie</em> del usuario corresponde
con una válida, utilizando el valor de ésta para realizar una consulta
a la base de datos que nos indicará si está accediendo un usuario
autorizado.

En el caso de que no lo sea, hay un nuevo error que le indicará al
usuario que no pertenece a la base de datos y deberá autenticarse. Si
lo es, se llegará a la construcción de la consulta que será realizada
en la base de datos, en este caso un listado de Antiguos Alumnos.

Se utiliza Perl embedido para procesar la consulta a través del
interfaz DBI, y para mostrar la lista de columnas recibidas dentro de
una tabla. En el caso de que no haya datos se muestra un mensaje
explicativo indicando la razón.

Asimismo se pueden introducir en una misma página tres páginas
distintas que serán mostradas en función de las condiciones de
ejecución del programa.

<sect1>Autenticación de usuarios con Perl embedido
<p>

************** LISTADO 3 ***************************

Finalmente, como ejemplo más complejo se puede consultar el listado
3. Éste sería el correspondiente a la página de acceso al servidor,
que, como se puede ver es dinámica.

En dicha página está incluido el formulario de entrada de datos del
usuario, la comprobación de los datos en sí, y los mensajes de
aceptación y rechazo correspondientes. Como se puede ver se puede
hacer de golpe todas estas operaciones sin tener que necesitar
distintas páginas separadas que sí eran necesarias en el caso de
pgsql.

Se deja, por limitaciones de espacion, como ejercicio al lector el
determinar el exacto funcionamiento de este programa.



<sect>Resumen
<p>

Como se ha visto en éste artículo es posible hacer uso de toda la
potencia expresiva de Perl en la programación de páginas dentro de
servidores de WWW, esto, acompañado con la gran versatilidad del
módulo Perl::DBI permite a los programadores la definición de
interfaces desde WWW a servidores de bases de datos que sean
fácilmente portables entre servidores, sistemas operativos y sistemas
de gestión de bases de datos.

<sect>Sumarios
<p>
La solución más fácil para hacer CGIs es usar Perl.

Perl posee beneficiosas características a la hora de escribir programas.

Existen alternativas al uso de Perl embedido.

Perl emebedido permite una gran interactividad en el servidor.

Antes de nada es necesario introducir los elementos necesarios.

La configuración para Perl embedido no es complicada.

No es difícil introducir Perl embedido en páginas HTML.

DBI es un interfaz genérico de acceso a bases de datos.

Se reimplementarán los ejemplos anteriores con Perl embedido.

Es posible hacer uso de toda la potencia expresiva de Perl.

<sect>Listados
<p>
<!--LISTADO x

PIE LISTADO x-->

LISTADO 1

Algunos servidores de interés son:
<itemize>
<item>www.apache.org que contiene toda la información relativa al servidor Apache.
<item>www.perl.org, toda la información sobre el lenguaje de programación Perl.
<item>perl.apache.org, que contiene toda la información sobre la integración de Perl y Apache.
<item>www.cpan.org, servidor que ofrece todos los módulos disponibles para Perl.
<item>www.postgresql.org, el servidor principal del sistema de gestión de bases de datos PostgreSQL.

<item>Se puede encontrar gran información sobre DBI en la página de recursos
http://www.symbolstone.org/technology/perl/DBI/

<item>El proyecto WebDBI, www.wdbi.net, es también de gran interés en el sentido de que permite realizar rápidamente interfaces web a bases de datos con DBI y perl embedido. Merece la pena conocerlo.

<item>lucas.hispalinux.es, que contiene gran cantidad de documentación traducida al castellano incluyendo el proyecto de traducción de PostgreSQL al castellano. Otro servidor de gran interés para hispano parlantes es www.postgres.org.mx
</itemize>

El libro de O'reilly de Perl::DBI &dquot;Programming the Perl DBI&dquot; de
Alligator Descartes y Tim Bunce, los creadores del módulo es una
estupenda referencia sobre el tema (ISBN: 1565926994).

PIE LISTADO 1: Más información


LISTADO 2
<tscreen>
<verb>

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//ES"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
   &lt;TITLE&gt;Listado de antiguos alumnos por año de promoción&lt;/TITLE&gt;
   
 [- 
   use DBI;
   use POSIX qw/strftime/;
   use CGI::Cookie;
   %cookies = fetch CGI::Cookie;
   $db="alumni2k";
   $uslec="lectura";
  -]
 [-    
  $dbuser=$uslec;

  if (not(defined($dbhlectura))) {
   eval {$dbhlectura = DBI-&gt;connect("dbi:Pg:dbname=$db", "$dbuser", "") 
   or die "No puedo abrir la base de datos $dbname con el usuario $dbuser\n"; };

   $falloconex = "fallo" if ( ! defined($dbhlectura) );
  };
  -]

 [$ if ($falloconex) $]
 [- $udat{errores}="Sin conexión";  -]
           &lt;META http-equiv="refresh" content="1;URL=../error/fallo_conexion.epl"&gt;
           &lt;/HEAD&gt;
           &lt;BODY&gt;
           Ha habido un &lt;A HREF="../error/fallo_conexion.epl"&gt;error%lt;/A&gt;
           &lt;/BODY&gt;
           &lt;/HTML&gt;
 [$ else $]

 [-  if (exists($cookies{'codigo'}) && $cookies{'codigo'}-&gt;value != 0 ) 
      { 
        $codigo = $cookies{'codigo'}-&gt;value;
        @arraydatos = $dbhlectura-&gt;selectrow_array("SELECT DISTINCT codigo, nombre, apellido, id_persona FROM persona WHERE codigo = \'$codigo\'");
      }
      if (@arraydatos) 
      {
         $ref = \@arraydatos;
        ($bogus,$nombreusuario,$apellidousuario,$idpersona)=@$ref;
       }
      else {$ref=""}
  -]

  [$ if (not($ref)) $]
  [- $udat{errores}="No es miembro o no autentificado"; -]
&lt;META http-equiv="refresh" content="0;URL=../error/no_pertenece.epl"&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;STRONG&gt;
Ha habido algún error en el proceso, si su navegador no se lo muestra
automáticamente pulse &lt;a HREF="../error/no_pertenece.epl"&gt;aquí&lt;/A&gt;.
&lt;/STRONG&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;

 [$ else $] 

&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Listado de AAs por año de promoción&lt;/H1&gt;

[- 

   $consulta = "select nombre, apellido, graduacion  from persona, datos_academicos where persona.id_persona = datos_academicos.id_persona and autorizacion = 1 order by graduacion";
   $sth = $dbhlectura-&gt;prepare($consulta);
   $sth-&gt;execute or die "Lo siento, no puedo realizar la consulta en este momento"; 
   $head = $sth-&gt;{NAME};
   $data = $sth-&gt;fetchall_arrayref ;
   $rows = $sth-&gt;rows;
-]
[$ if $rows &gt; 0 $]
&lt;table border=0&gt;
&lt;tr&gt;&lt;th&gt;[+ $head-&gt;[$col] +]&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;[+ $data -&gt; [$row][$col] +]&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
[$ else $]
&lt;P&gt;Lo lamentamos, pero no hay datos en la base de datos en respuesta
a la consulta



&lt;/BODY&gt;
&lt;/HTML&gt;


[$ endif $]

[$ endif $] 
 
[- 
 if (defined($dbhlectura)) {
     eval{$dbhlectura-&gt;disconnect or warn "La desconexión de la base de datos falló: $DBI::errstr\n";}
   };
 -]

</verb></tscreen>


PIE LISTADO 2: Ejemplo de consulta con perl embedido

LISTADO 3
<tscreen>
<verb>


&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//ES"gt;
&lt;HTMLgt;
&lt;HEADgt;
   &lt;TITLEgt;Bienvenidos al sitio de la Asociación de Antiguos Alumnos&lt;/TITLEgt;
   
  [- 
   use DBI;
   use POSIX qw/strftime/;
   use CGI::Cookie;
   %cookies = fetch CGI::Cookie;
   $db="alumni2k";
   $uslec="lectura";
   $usesc="escritura";
   $uspub="sincompletar";
   $usadm="sincompletar";
   $passadm="sincompletar";
  -]

    
  [-    
  $dbuser=$uslec;
if (not(defined($dbhlectura))) {
eval {$dbhlectura = DBI-gt;connect("dbi:Pg:dbname=$db", "$dbuser", "") or die "No puedo abrir la base de datos $dbname con el usuario $dbuser\n"; };
if (not(defined($dbhlectura))) {$falloconex="fallo";}
};
  -]


 [-  if (exists($cookies{'codigo'}) && $cookies{'codigo'}-gt;value != 0 ) 
      { 
	$codigo = $cookies{'codigo'}-gt;value;
        @arraydatos = $dbhlectura-gt;selectrow_array("SELECT DISTINCT codigo, nombre, apellido, id_persona FROM persona WHERE codigo = \'$codigo\'");
      }
      if (@arraydatos) 
      {
	 $ref = \@arraydatos;
        ($bogus,$nombreusuario,$apellidousuario,$idpersona)=@$ref;
       }
      else {$ref=""}
 -]

   
   
[-
$dni=$fdat{donaid};
$fecha=$fdat{fecha};
-]

[$ if ($dni && $fecha ) $] 

[-  sub compruebadate {
    use POSIX qw/strftime/;
    my $anno = strftime "%Y", localtime;
    $_=shift;
    if (not(m/(\d\d)-(\d\d)-(\d\d\d\d)/)) {push @erroresdate, "La fecha no cumple el formato, revísela. (DD-MM-AAAA)\n";}
    return @erroresdate;
}
-]
[- sub compruebadni {
my $dnip=shift;
$_=$dnip;
if (not(m/^(\d+)$/)) {push @erroresdni, "El dni que ha introducido no es válido, por favor, asegúrese de que no incluye espacios ni caracteres que no sean dígitos.\n";}
return @erroresdni;
}
-]
[- 
   @edate= compruebadate($fecha);
   @edni = compruebadni($dni);
-]
[$ if (not(@edate||@edni)) $]

[-
$autentificable = "SELECT DISTINCT id_persona, nombre, apellido FROM persona WHERE fecha_nacimiento = \'$fecha\' and dni = \'$dni\'";
$sthautentificable = $dbhlectura-gt;prepare($autentificable);
$sthautentificable-gt;execute;
@arrayautent = $sthautentificable-gt;fetchrow_array;
-]
[$ if (not(@arrayautent)) $]
[- 
$autentificable = "SELECT DISTINCT id_persona, nombre, apellido FROM persona_sin_verif WHERE fecha_nacimiento = \'$fecha\' and dni = \'$dni\'";
$sthautentificable = $dbhlectura-gt;prepare($autentificable);
$sthautentificable-gt;execute;
@arrayautent = $sthautentificable-gt;fetchrow_array;
-]
[$ if (not(@arrayautent)) $]
[- push @egeneral,('Vd. no ha introducido aún sus datos para solicitar ser miembro de la asociación o ha cometido algun error en sus datos; si tiene algun problema, por favor &lt;A HREF="mailto:alumni-admin@dat.etsit.upm.es"gt;contacte con el administrador&lt;/Agt;.'); -]
[$ else $]
[- push @egeneral,('Ya hemos recibido sus datos pero lamentamos decirle que aún no hemos podido verificarlos. No podrá acceder, aún, a las consultas de la base de datos pero sí podra &lt;A HREF="datos/modificadatos.epl"gt;modificar&lt;/Agt; sus datos si lo desea. '); -]
[- ($aid,$anom,$aape) = @arrayautent; -]

 
[-
$sec = strftime "%S", localtime;
$criptado = crypt $anom, "$sec";
$metecodigo="UPDATE persona_sin_verif SET codigo=\'$criptado\' WHERE id_persona=\'$aid\'";
$sthcodigo=$dbhescritura-gt;prepare($metecodigo);
$sthcodigo-gt;execute();
-]


&lt;META HTTP-EQUIV="Set-Cookie" CONTENT="codigo =[+ $criptado +]"gt;


[-
$aumentaacceso="UPDATE accesos SET num_accesos = num_accesos + 1 WHERE persona_sin_verif.id_persona=\'$aid\'";
$aumentaaccesotemp="UPDATE accesos SET num_accesos_parcial = num_accesos_parcial +1 WHERE persona_sin_verif.id_persona=\'$aid\'";
$marcaultimoacceso="UPDATE accesos SET fecha_ultimo_acceso = \'now\' WHERE persona_sin_verif.id_persona=\'$aid\'";
$sthaumenta=$dbhescritura-gt;prepare($aumentaacceso);
$sthaumenta-gt;execute();
$sthaumentatemp=$dbhescritura-gt;prepare($aumentaaccesotemp);
$sthaumentatemp-gt;execute();
$sthmarca=$dbhescritura-gt;prepare($marcaultimoacceso);
$sthmarca-gt;execute();
-]


[$ endif $]
[$ else $]
[- ($aid,$anom,$aape) = @arrayautent; -]

 
[-
$sec = strftime "%S", localtime;
$criptado = crypt $anom, "$sec";
$metecodigo="UPDATE persona SET codigo=\'$criptado\' WHERE id_persona=\'$aid\'";
$sthcodigo=$dbhescritura-gt;prepare($metecodigo);
$sthcodigo-gt;execute();
-]


&lt;META HTTP-EQUIV="Set-Cookie" CONTENT="codigo =[+ $criptado +]"gt;


[-
$aumentaacceso="UPDATE accesos SET num_accesos = num_accesos + 1 WHERE persona.id_persona=\'$aid\'";
$aumentaaccesotemp="UPDATE accesos SET num_accesos_parcial = num_accesos_parcial +1 WHERE persona.id_persona=\'$aid\'";
$marcaultimoacceso="UPDATE accesos SET fecha_ultimo_acceso = \'now\' WHERE persona.id_persona=\'$aid\'";
$sthaumenta=$dbhescritura-gt;prepare($aumentaacceso);
$sthaumenta-gt;execute();
$sthaumentatemp=$dbhescritura-gt;prepare($aumentaaccesotemp);
$sthaumentatemp-gt;execute();
$sthmarca=$dbhescritura-gt;prepare($marcaultimoacceso);
$sthmarca-gt;execute();
-]

[$ endif $]


[$ endif $]

[$ endif $]

   	
    	  [$ if ($falloconex) $]
	   [- $udat{errores}="Sin conexión"; 
	   -]
           &lt;META http-equiv="refresh" content="1;URL=error/fallo_conexion.epl"gt;
	   &lt;/headgt;
	   &lt;bodygt;
	   &lt;/bodygt;
	   &lt;/htmlgt;
          [$ else $]
        	
    	  [$ if ($falloconex) $]
	   [- $udat{errores}="Sin conexión"; 
	   -]
           &lt;META http-equiv="refresh" content="1;URL=error/fallo_conexion.epl"gt;
	   &lt;/headgt;
	   &lt;bodygt;
	   &lt;/bodygt;
	   &lt;/htmlgt;
          [$ else $]
        
&lt;/HEADgt;
&lt;BODY BGCOLOR="white"gt;
&lt;H1gt;Bienvenido&lt;/H1gt;
&lt;Pgt;Bienvenido al servidor de la Asociación de Antiguos Alumnos.

&lt;table border="0" cellpadding="0" cellspacing="0"gt;
 &lt;trgt;
  &lt;td width="280" valign="top" align="left"gt;
[$ if not($aid) $]
    
[$ if (not($ref)) $]

&lt;FORM METHOD="POST" ACTION="index.epl"gt;
D.N.I.:&lt;INPUT TYPE="PASSWORD" NAME="donaid" TABINDEX="1" SIZE="10"gt;
Fecha de Nacimiento:
(DD-MM-AAAA) &lt;INPUT TYPE="TEXT" NAME="fecha" TABINDEX="2" SIZE="10"gt;
&lt;input type="submit" name="autent" value="Autentifícame"gt;
&lt;/FORMgt;

[$ endif $]
[$ if ($ref) $]

[+ $nombreusuario +]&nbsp;[+ $apellidousuario +]&lt;brgt;
Conectado al servidor, con los correspondientes permisos de usuario.

[$ endif $]

[$ endif $]
[$ if ($aid) $]
Ud. acaba de ser reconocido como&lt;brgt;
[+ $anom +]&nbsp;[+ $aape +],&lt;brgt;
Bienvenido al servidor.
[$ endif $]

[$ if ($dni) $]
[$ if (@edate||@edni||@egeneral) $]

[$ foreach $msg (@edni) $]
[+ $msg +]&lt;HRgt;
[$ endforeach $]
[$ foreach $msg (@edate) $]
[+ $msg +]&lt;HRgt;
[$ endforeach $]
[$ foreach $msg (@egeneral) $]
[+ $msg +]&lt;HRgt;
[$ endforeach $]

[$ else $]

No olvide que una vez su acceso al servidor ha sido reconocido, ya puede
acceder tanto a las &lt;a href="consultas/"gt;consultas&lt;/Agt; como a
la &lt;A HREF="datos/modificadatos.epl"gt;modificación o actualización&lt;/Agt; de sus datos guardados aquí.

[$ endif $]
[$ endif $]
[$ if (not($aid)) $]
    
[$ if (not($ref)) $]

&lt;FORM METHOD="POST" ACTION="datos/nuevosocio.epl"gt;
Nombre: &lt;INPUT TYPE="TEXT" NAME="nombre" TABINDEX="3" SIZE="20"gt;
Apellidos: &lt;INPUT TYPE="TEXT" NAME="apellidos" TABINDEX="4" SIZE="20"gt;
&lt;input type="submit" name="nuevosocio" value="Comenzar"gt;
&lt;/FORMgt;

[$ endif $]

[$ endif $]

&lt;/BODYgt;
&lt;/HTMLgt;
[$ endif $] 
[$ endif $]

  [- if (defined($dbhescritura)) {
     eval{$dbhescritura-gt;disconnect or warn "La desconexión de la base de datos falló: $DBI::errstr\n";}};
  -]

 
  [- if (defined($dbhlectura)) {
     eval{$dbhlectura-gt;disconnect or warn "La desconexión de la base de datos falló: $DBI::errstr\n";}};
  -]


</verb>
</tscreen>


PIE LISTADO 3: Entrada al servidor

<sect>Capturas
<p>

<itemize>
<item>Figura 1: (fig1.bmp) Primer ejemplo con Perl embedido
<item>Figura 2: (ambitodbi.png) Ambito del módulo Perl::DBI
<item>Figura 3: (entrada.png) Entrada al servidor
</itemize>



<sect>Notas de maquetación
<p>


<sect>Notas de coordinación
<p>

Es posible seguir con artículos de esta serie con los siguientes temas: 
<itemize>
<item>WDBI
<item>uso de WML para la creación de webs
<item>programación más detallada del uso de Perl::DBI
</itemize>

</article>
