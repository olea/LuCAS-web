<html>
<head>
<title>VideoForLinux: El canal del Pingüino</title>
</head>
<body>
<h1>VideoForLinux: "The Penguin Channel"</h1>
<p>
Autor: <a href="http://www.dit.upm.es/~jantonio">Juan Antonio Martínez</a><br>
E-mail: <a href="mailto:jantonio@dit.upm.es">jantonio@dit.upm.es</a>
</p>
<hr>
<h3>Copyright</h3>
Este artículo es Copyright 1998 de Juan Antonio Martínez Castaño y se 
distribuye bajo las siguientes condiciones:
<ul>
<li> Su distribución mediante medios electrónicos es libre, siempre y
cuando se conserve el texto íntegro y en su formato HTML original, haciendo
especial mención a la conservación del mensaje de copyright
<li> El autor y dueño del copyright cede los derechos de publicación impresa
a Prensa Técnica S.L., autorizando a ésta a realizar las modificaciones al
texto que considere oportunas para su publicación
<li> La distribución o copia, total o parcial, en cualquier medio impreso por 
parte ajena a Prensa Técnica S.L. Está expresamente prohibida
<li> Ningún particular podrá publicar este fichero en un servidor Web de acceso
público sin el consentimiento expreso del autor y de Prensa Técnica S.L.
</ul>

<hr>
<a name="indice"><h3>Indice:</h3></a>
<ol>
	<li><a href="#introduccion">Introducción</a>
	<li><a href="#conceptos">Conceptos</a>
	<li><a href="#requerimientos">Requerimientos</a>
	<li><a href="#instalacion">Instalación del driver</a>
	<li><a href="#aplicaciones">Instalación de las aplicaciones</a>
	<li><a href="#problemas">Problemas</a>
	<li><a href="#conclusion">Conclusiónes</a>
	<li><a href="#referencias">Referencias</a>
</ol>
<hr><h3><a name="entrada">Entradilla</h3></a>
<p>
	Se inicia aquí una serie sobre uno de los componentes más novedosos
del nuevo kernel de Linux, y que ya está disponible en la serie 2.0.XX: el 
soporte para dispositivos de vídeo, televisión y radio, conocido como 
VideoForLinux. En esta entrega se hace una introducción, se señalan los
requerimientos y se aprenderán a configurar e instalar los drivers y las
aplicaciones. En la segunda entrega se describirá el API y el modelo de
programación, así como la implementación VideoForLinux2 del nuevo kernel
2.2.X
</p>

<hr><h3><a name="introduccion">Introducción</h3></a>

<p>
	Un campo de actualidad e interés en el hardware es el mundo de la
multimedia: Tarjetas de videoconferencia, sintonizadores de televisión, 
procesado digital de la señal... de un tiempo a esta parte los fabricantes
de hardware han diseñado multitud de tarjetas para este propósito. Lejos
están ya los tiempos en que para poder ver la televisión en el ordenador, 
había que conectar la salida de la VGA a otra tarjeta especial, que mezclaba
la señal de la VGA con la que generaba un receptor de televisión. 
</p>
<p>
	Con el advenimiento del bus PCI, y las técnicas de DirectVideo y
DirectDraw, las tarjetas de videoconferencia/televisión para PC se han
vuelto mucho mas potentes. La calidad de señal es infinitamente mejor: ya
no se mezclan señales analógicas, sino que se escribe directamente en la
memoria de vídeo. Del mismo modo el procesado digital de la señal recibida se
hace posible: compresores/descompresores MPEG, visualizadores de Canal +,
posibilidad de grabar vídeo en tiempo real...
</p>
<p> 
	El mundo Linux no podía ser menos: En 1996 Ralp y Marcus Metzler
idearon una serie de drivers para poder utilizar una tarjeta capturadora
de vídeo desde Linux. El primitivo driver, se denominó "bttv" en relación
al chip de vídeo que llevaba dicha tarjeta ( el BookTree Bt848 ). 
Rápidamente, dicho driver evolucionó de manera que se empezaron a soportar 
diversas tarjetas de vídeo , e incluso sintonizadoras de radio y televisión. 
Del primitivo driver "bttv" surgió una pléyade de módulos y soporte para 
diversas tarjetas y combinaciones
</p>
<p>
	Otros autores, a partir del diseño original de "bttv" añadieron 
soporte a otros dispositivos de vídeo que no estaban basados en el Bt848:
cámaras QuickCam, tarjetas basadas en el chipset Zoran ZR36120 , codificadoras
MPEG, e incluso soporte de otras arquitecturas, como el Plan-B de Power 
MacIntosh. Era hora de definir un API estándar y unificado, y de ahí nació
el Proyecto VideoForLinux ( v4l en forma abrebiada )
</p>
<p>
	La evolución no se ha detenido. Alan Cox y Linus Torvalds han 
incluído VideoForLinux como parte integrante de los nuevos kernels 2.2.X, y
se ha definido un nuevo estándar: el VideoForLinux2, que incluye diversas
mejoras y cambios en el API para poder añadir prestaciones al subsistema de
vídeo, así como poder definir nuevos dispositivos multimedia
</p>

<p>
<table>
<tr><td width="40%"> 
<table border><tr><th>
<!-- texto del bocadillo -->
El nuevo núcleo de Linux incluye de serie el soportde de los dispositivos
de Video For Linux
</th></tr></table> 
</td><td> </td><td> </td></tr>
</table>
<p>                                                             
<p>
	En este artículo vamos a introducir al usuario en la versión 
VideoForLinux para kernels 2.0.3x, explicando como instalar los módulos,
compilar las aplicaciones, y disfrutar de la televisión en la pantalla de
nuestro ordenador. En el próximo número de Linux Actual, con el nuevo
kernel ya estable, describiremos VideoForLinux2, y se explicará con
detenimiento el API, y los drivers y dispositivos soportados.
</p>

<hr><h3><a name="conceptos">Conceptos</h3></a>
<p>
	Vamos a empezar con una descripción de los elementos integrantes del
módulo de v4l:
	<ul>Se definen una serie de nuevos dispositivos:
	<li>Dispositivos de vídeo ( /dev/videoXX ) que permiten la visualización
	    , proceso y captura de señales de vídeo ( sintonizadores, cámaras, 
	    e incluso dispositivos "dummy" para manejo de imágenes )
	<li>Dispositivos de audio ( /dev/radioXX ) que permiten el manejo de 
	    dispositivos "solo audio" ( tarjetas de radio, descompresores mp3,
	    sonido de videoconferencias, etc )
	<li>Dispositivos de información ( /dev/vtxXX ) , típicamente sistemas 
	    de videotexto y teletexto
	<li>Dispositivos de WebCast e InterCast ( /dev/vbiXX ), nueva tecnología
	    de distribución de páginas web a través de la señal de televisión
	</ul>
	<ul> Además VideoForLinux2 define otros dispositivos:
	<li> Generadores de efectos especiales de vídeo ( /dev/vfxXX )
	<li> Codecs, compresores/descompresores, etc ( /dev/codecXX )
	<li> Dispositivos de salida de vídeo ( /dev/voutXX )
	</ul>
</p>
La implementación actual de VideoForLinux consta de el módulo 
<b><i>videodev</i></b>, como corazón del sistema de vídeo. 
De éste dependen diversos módulos auxiliares:
	<ul>
	<li> <b><i>i2c</i></b> e <b><i>i2c_chardev</i></b> son dos módulos 
	genéricos que sirven para gestionar el bus I2C en el que se basan 
	la mayor parte de los chips de vídeo existentes en la actualidad. El 
	segundo de estos drivers permite el manejo en modo carácter de un
	bus i2c ( si existe el dispositivo /dev/i2cXX )
	<li> <b><i>bttv</i></b> es el módulo de control de las tarjetas de
	vídeo basadas en el chip Bt848.
	<li> <b><i>msp3400</i></b> controla el chip msp34XX que es un 
	decodificador estéreo incluído en muchas tarjetas de vídeo
	<li> El módulo <b><i>tuner</i></b> permite el manejo de dispositivos
	de vídeo o audio sintonizables, proporcionando datos que el módulo
	<i>bttv</i> puede manejar
	<li> Además de los descritos, cada dispositivo particular dispone de
	su propio módulo, que a su vez interacciona con éstos y que proporciona
	el acceso a cada tarjeta.
	</ul>
<p>
	la figura 1 ilustra las dependencias entre los diversos módulos
</p>

<p>
<table border>
<tr><td>
<!-- nombre de las imagenes a rellenar -->
<img src="modules.gif" alt="modulos de v4l y sus dependencias"> 
</td></tr>
<tr><th>Figura 1: Módulos del driver bttv y sus dependencias</th></tr>
</table>
<p>
<p>
Las aplicaciones interactuan con el módulo <i>videodev</i>, que les proporciona
información sobre los diversos dispositivos, y de las peculiaridades y 
posibilidades que ofrece cada uno. A grandes rasgos, se pueden especificar
operaciones de:
</p>
	<ul>	
	<li> Apertura/cierre de dispositivos
	<li> Identificación de prestaciones
	<li> Selección de modo de funcionamiento. Incluye especificación de
	formatos, selección de la ventana de captura, sintonización de canales,
	especificación de la fuente de señal, modo de vídeo, etc
	<li> Lectura de imágenes. Esta puede ser por "frames", ventanas de
	imagen ( si el dispositivo lo permite ), o bien continua, mendiante
	técnicas de "mmap()"
	</ul>
<p>

<p>
<table>
<tr><td width="40%"> 
<table border><tr><th>
<!-- texto del bocadillo -->
Las estructuras que definen el API de programación se encuentran en el
fichero <i>videodev.h</i>
</th></tr></table> 
</td><td> </td><td> </td></tr>
</table>
<p>                                                             
Como conclusión <i>videodev</i> nos proporciona un API unificado para todas las
tareas relacionadas con la selección, manejo y adquisición de señales de 
video, audio, teletexto, o Webcast
</p>
<hr><h3><a name="requerimientos">Requerimientos</h3></a>
<p>
	Ahora que ya sabemos qué es y qué hace VideoForLinux, vamos a ver los
requerimientos del sistema.
        <ul>
        <li> Pentium 120 o superior 
        <li> Algunas aplicaciones de procesado de señal de vídeo requieren
	     que el microprocesador soporte MMX. No es el caso de la
	     distribución "estándard", pero sí el de algunas específicas
	     ( compresor/descompresor MPEG, visualizador de Canal +, etc )
        <li> Tarjeta de vídeo PCI o AGP que soporte Direct-Video ( acceso
             directo al frame buffer), vía bus PCI. Estas tarjetas permiten
	     mapear la memoria de vídeo en memoria principal, de manera que
	     otros dispositivos puedan acceder a dicha memoria a través del
	     Bus PCI. ( eg. la Virge3D )
        <li> Tarjeta PCI sintonizadora de televisión, basada en el chip
             Booktree Bt848. No valen aquellas tarjetas que se comunican
             con la VGA a través de un conector externo. La página Web de
	     VideoForLinux lista gran cantidad de tarjetas soportadas. En
	     España, las más fácilmente localizables son la MiroPCTV, la
	     AverMedia, y la Zoltrix. Su precio oscila entre las 12.000 y
	     20.000 pesetas<br>
		Si en lugar de utilizar la señal de antena, disponemos de
	     un vídeo doméstico, y queremos que sea éste el que esté conectado
	     al ordenador, no necesitamos una sintonizadora, sino que con
	     una capturadora de vídeo nos basta. En este caso podemos utilizar
	     una tarjeta normal de videoconferencia ( por ejemplo la
	     VideoLogic Captivator ), que son mucho mas asequibles en precio
	     ( del orden de 5000-7000 pesetas.<br>
		Opcionalmente podemos enchufar a la tarjeta de vídeo una camara
	     de televisión. La experiencia recomienda huír de las cámaras
	     que se enchufan a puerto paralelo o a USB, por las evidentes
	     pérdidas de rendimiento del equipo
        <li> Kernel 2.0.34 o superior + modulos de v4l, o bien<br>
             Kernel 2.1.126 o superior, compilado con soporte de v4l<br>
	     Para Kernels de la serie 2.1.1XX, video4linux está ya incluído
	     dentro de los fuentes de la distribución. En el caso de la serie
	     2.0.XX, los drivers se adquieren de forma separada. En el CD-Rom
	     que acompaña a la revista se incluye el útimo driver existente
	     en el momemto de escribir este artículo
        <li> glibc ( ¿ alguien no la usa todavía ? )
        <li> En la BIOS, hay que deshabilitar la opción "VideoPallete Snoop".
	     Esto es debido a que es necesario que la tarjeta de vídeo pueda
	     generar y procesar interrupciones de barrido vertical, para poder
	     sincronizar los barridos de la tarjeta de vídeo y la sintonizadora
	     de televisión
	<li> La implementación actual del driver de v4l no permite compartir
	     las interrupciones de la tarjeta de vídeo y la sintonizadora con
	     otros dispositivos. Revisar los mensajes informativos de la BIOS
	     y los que aparecen en <i>/proc/interrupts</i>
        <li> Aseguráos que vuestro servidor X soporta la extension DGA
             ( XFree86-3.3.2 y superiores ). La tarjeta de vídeo debe poder
	     soportar una resolución de al menos 800x600 en 16bits 
	     ( 65536 colores)
	<li> Si no se quiere utilizar X-Windows, deberemos utilizar un kernel
	     de la serie 2.1.13X, con soporte de dispositivo frame-buffer
	     ( /dev/fbXX ) convenientemente compilado e instalado
        </ul>

<p>
<table>
<tr><td width="40%"> 
<table border><tr><th>
<!-- texto del bocadillo -->
Si no se quiere utilizar X-Windows, deberemos utilizar un kernel
de la serie 2.1.13X, con soporte de dispositivo frame-buffer
( /dev/fbXX ) convenientemente compilado e instalado
</th></tr></table> 
</td><td> </td><td> </td></tr>
</table>
<p>                                                             
<p>	
	En el CD-Rom se acompaña una copia de la Home Page de VideoForLinux y
	del proyecto Bttv. En ellos se detalla una lista completa de los 
	dispositivos soportados, lista que por motivos de espacio no podemos
	citar aquí.
</p>
<p>	
	Hay que hacer notar una excepción a la lista de tarjetas soportadas:
	las sintonizadoras basadas en el chipset ATI no están soportadas -ni
	se prevee que lo estén- en Linux, debido a la ceguera mental del
	fabricante que no publica las especificaciones técnicas de sus 
	productos. Existe una página Web, donde los interesados en que ATI
	cambie de actitud, pueden firmar
	
</p>
<hr><h3><a name="instalacion">Instalación del driver</h3></a>
	Nos remitimos a las páginas Web de cada dispositivo específico para un
	detalle completo de instalación. Vamos a describir aquí la instalación
	del driver más común: el <i>Bttv</i>. Para ello distinguiremos 
	dos casos:
<dl>
<dt>	<b> Caso 1: kernels superiores al 2.1.125</b>
<dd> En el menú de configuración del kernel, en el apartado "Character Devices"
	Buscaremos la opción "VideoForLinux". Activándola, aparecerán una serie
	de dispositivos, de entre los que escogemos "Bttv Video For Linux
	Support". La figura 2 ilustra un ejemplo.<br>
	Si vamos a usar v4l desde la consola, deberemos asegurarnos que los
	dispositivos /dev/fbXX correspondientes al framebuffer ( nuevo en 
	estas series de kernels ) funcionan y están correctamente instalados<p>
	
<p>
<table border>
<tr><td>
<!-- nombre de las imagenes a rellenar -->
<img src="kernel-2.1.conf.gif" alt="Configuración de v4l en kernel 2.1.125"> 
</td></tr>
<tr><th>Figura 2: Configuración  de VideoForlinux en kernel 2.1.125</th></tr>
</table>
<p>
<dt>	<b> Caso 2: kernels de la serie 2.0.3X</b>
<dd>	En este caso los módulos no son parte de la distribución estándard.
	Para instalarlo, deberemos seguir una serie de pasos:
	<ol>
	<li> Instalamos y descomprimimos el driver:
<pre>
root@cochito# cd /usr/src
root@cochito# tar zxvf &lt;path_al_fichero_en_cdrom&gt;/bttv-0.5.22.tgz
root@cochito# cd bttv-0.5.22/driver
</pre>
	<li> Editamos el makefile especificando las opciones de nuestra
	tarjeta, especialmente en lo referente al tipo de tarjeta y la
	frecuencia de oscilación del PLL. Leer la documentación que se 
	incluye en el driver sobre cada tarjeta específica
	<li> Mediante "make" compilamos los módulos
	<li> Copiamos los ficheros resultantes junto con los demás módulos
	del sistema, y creamos los ficheros especiales en <i>/dev</i>
<pre>
root@cochito# cp *.o /lib/modules/current/misc
root@cochito# ./MAKEDEV
</pre>
	<li> Creamos los ficheros de arranque. En el código fuente aparece
	un ejecutable <i>"update"</i>, que podemos usar. Alternativamente, en 
	el CD-Rom existe un fichero <i>"v4linux"</i> que está preparado
	para ser colocado en /etc/rc.d/init.d, y que podemos ver en el
	listado 1
<pre>
root@cochito# cp &lt;path_al_fichero_en_cdrom&gt;/v4linux /etc/rc.d/init.d
root@cochito# ln -s /etc/rc.d/init.d/v4linux /etc/rc.d/rc3.d/S99v4linux
</pre>
	<li> Editamos este fichero especificando los detalles de funcionamiento
	concretos de cada tarjeta. Nótese que estos módulos no se cargan
	bajo demanda a través de <i>kerneld</i>, sino que se insertan de manera
	permanente
	<li> Con <i>/etc/rc.d/init.d/v4linux start</i> los módulos quedan
	quedan instalados. mediante <i>lsmod</i> comprobaremos que están
	correctamente instalados. En caso de problemas consultar los logs 
	del sistema.
</dl>
<p>
Una vez instalado el driver llega momento de instalar y probar las aplicaciones
</p>
<p>
<table border>
<tr><td>
<!-- texto del listado entre los -pre- -->
<pre>
#!/bin/sh

if test "$UID" = "0"; then
	# running as root anyway, don't need sudo
	INSMOD="/sbin/insmod"
	RMMOD="/sbin/rmmod"
else
	INSMOD="sudo /sbin/insmod"
	RMMOD="sudo /sbin/rmmod"
fi

# handy functions for rmmod/insmod
function xrmmod () {
	grep -qe "^$1" /proc/modules || return
	echo rmmod $1
	$RMMOD $1 || exit 1
}
function xinsmod () {
	echo insmod $*
	$INSMOD -f $* || exit 1
	sleep 1
}

function remove_mods () {
xrmmod bttv
xrmmod msp3400
xrmmod tuner
xrmmod i2c_chardev
xrmmod i2c-dev
xrmmod algo-bit
xrmmod i2c
xrmmod videodev
}

function install_mods () {
#
# Modulo basico
xinsmod videodev

#
# Modulo de control de bus i2c
xinsmod i2c		verbose=1 scan=0 i2c_debug=0

#
# Este modulo es opcional. permite un control "tipo caracter" del driver
test -f /lib/modules/current/misc/i2c_chardev.o && xinsmod i2c_chardev

#
# dispositivo de sintonización. Es necesario a menos que se vaya a utilizar
# una entrada de video compuesto o de camara
# argumentos:
#        debug=1         Genera mediante syslog mensajes de depuracion
#        type=n          Especifica el tipo de sintonizador
#                0: Temic PAL tuner
#                1: Philips PAL_I tuner
#                2: Philips NTSC tuner
#                3: Philips SECAM tuner
#                4: no tuner
#                5: Philips PAL tuner
#                6: Temic NTSC tuner
#                7: Temic PAL tuner
xinsmod tuner		debug=0

#
# Modulo de control del chip de sonido MPS34XXX. 
# Es necesario en la mayor parte
# de las tarjetas que manejan stereo/Nicam
# debug puede valer 0, 1, o 2 
xinsmod msp3400		debug=0

#
# Finalmente el modulo bttv. 
#
#    insmod args:
#            remap=adr       remap Bt848 memory to adr<<20
#            vidmem=base     frame buffer address>>20 (of graphic card)
#            triton1=0/1     for Triton1 compatibility
#                            La placa triton 1 se detecta automaticamente
# 			     pero puede ser necesario fijar este valor
# 			     a cero en otras placas base
#            pll=0/1/2       Ajuste del oscilador a cristal del PLL
#	 		     0 -> bt848, los demás valores para otros
# 			     chipsets superiores de la familia
#                    0: no usar PLL
#                    1: oscilador de 28 MHz 
#                    2: oscilador de 35 MHz
#            radio=0/1       La tarjeta soporta receptor de radio
#            card=n          Tipo de tarjeta
#                    0:  Auto-Deteccion
#                    1:  Miro
#                    2:  Hauppauge
#                    3:  STB
#                    4:  Intel
#                    5:  Diamond
#                    6:  AVerMedia
#                    7:  MATRIX Vision MV-Delta
#                    8:  FlyVideo
#                    9:  TurboTV
#                    10: Hauppauge (usar este en las tarjetas modernas)
#
#    remap, card, radio and pll aceptan hasta 4 argumentos, separados por
#    comas, para poder poner mas de una tarjeta. Los valores por defecto
#    CARD y PLL son los que se definen en el Makefile
#        
xinsmod bttv		card=1 radio=0

}

case $1 in
	start ) install_mods
		;;
	stop ) remove_mods
		;;
	restart ) remove_mods
		install_mods
		;;
	status ) a=`cat /proc/modules | grep videodev`
		echo -n "Video For Linux modules are"
		if [ "$a" = "" ]; then echo -n " NOT"; fi
		echo " installed"
		;;
	* ) echo Usage: $0 [ start | stop | restart | status ]
		;;
esac
</pre>
</td></tr>
<tr><th>Listado 1: Programa de arranque de los modulos de VideoForLinux</th></tr>
</table>
<p>
<hr><h3><a name="aplicaciones">Instalación de las aplicaciones</h3></a>
<p>
	Existen multitud de aplicaciones que permiten el manejo de estos
módulos. A título de ejemplo se citan las siguientes:
<ul>
	<li> Kradio,KTuner: Diversas aplicaciones basadas en KDE y QT para
	gestión de tarejtas de radio
	<li>GnomoVision: Parte del escritorio del proyecto GNOME
	<li>VStream: Conjunto de bibliotecas y utilidades de captura de 
	audio y video
	<li>XTTV: Aplicación de Televisión basada en las XLib
	<li>XawTV: Visualizador de televisión basado en los athena Widgets
	<li> Existen muchas otras, unas derivadas de otras, siendo la mayor
	diferencia el <i>user interface</i> y las posibilidades de gestión
	de las imágenes ( captura, compresión MPEG, etc )
</ul>
<p>
	En el CD-Rom se incluyen algunas de estas aplicaciones. Las demás
-y otras muchas no mencionadas- se pueden encontrar siguiendo los enlaces 
indicados en las <a href="#referencias">referencias</a>.<br>
La figura 3 ilustra una simpática imagen capturada desde uno de estos programas

<p>
<table border>
<tr><td>
<!-- nombre de las imagenes a rellenar -->
<img src="supercoco.gif" alt="supercoco"> 
</td></tr>
<tr><th>Figura 3: Imagen capturada con XawTV</th></tr>
</table>
<p>
Vamos a describir aquí la que a juicio del autor es uno de los mejores
programas de visualización de televisión para Linux: el programa XawTV.
</p>
XawTV es un conjunto de aplicaciones destinadas a trabajar con 
sintonizadoras de televisión y de radio. Entre sus capacidades se incluyen:
<ul>
	<li> Trabajar a pantalla completa en resolución de televisión ( 768x576,
	resolución que ningún programa de MS-Windows es capaz de proporcionar:
	casi todos trabajan a 800x600, dejando huecos en "negro" )
	<li> Manejar resoluciones de 15,16, 24 o 32 bits 
	<li> Poder efectuar capturas de imágenes, tanto estáticas ( JPEG ) como
	dinámicas (AVI's)
	<li> Si se dispone de una conexión de red eficiente, se pueden 
	presentar imágenes en un terminal distinto a aquel en que reside la
	tarjeta
	<li> Si se usan kernels nuevos, existe un programa FbTV que permite las
	mismas prestaciones que XawTV, pero utilizando el framebuffer
	<li> Existe un fichero de configuración por usuario donde se especifican
	los canales, modos de video, frecuencias, etc
	<li> XawTV proporciona interfaces para mando a distancia, control 
	remoto desde otro terminal/consola, etc
</ul>

<p>
<table>
<tr><td width="40%"> 
<table border><tr><th>
<!-- texto del bocadillo -->
Con XawTV podemos capturar y almacenar tanto imágenes 
como secuencias de vídeo
</th></tr></table> 
</td><td> </td><td> </td></tr>
</table>
<p>                                                             
La instalación es realmente sencilla:
<ol>
	<li> Descomprimir el programa
	<li> Con <i>./configure</i> generamos los ficheros include y Makefile.
	     </i>./configure --help</i> nos proporciona la lista de opciones
	     de compilación
	<li> Ejecutamos <i>make</i>.
	<li> <i>make install</i> nos instala los programas y las páginas de 
	     manual en los destinos predefinidos
	<li> Ahora solo queda crear el fichero de configuración. El listado
	     2 ilustra el utilizado por el autor, donde se detallan los modos
	     de vídeo y los canales correspondientes a cada emisora<br>
	     En el caso de no crear un fichero de configuración, el programa
	     avisará al usuario, y le presentará directamente el menú de 
	     ajuste de emisoras
</ol>

<p>
<table border>
<tr><td>
<!-- texto del listado entre los -pre- -->
<pre>
# this is a comment
# empty lines are ignored too

source  = television
norm    = pal
# freqtab = pal-bcast-europe
# select one that makes it right from:
# "vol" "bass" "trebble" synth" "pcm" "speaker" "line"
mixer   = line
fullscreen = 768x576
wm-off-by = -4-24

# for /etc/XF86Config
# Modeline  "pal"  50.00  768 876 900 1000  576 590 595 630  -hsync -vsync

[TVE-1]
channel = 49
# key = 1

[TVE-2]
channel = 55
# key = 2

[Antena 3]
channel = 65
# key = 3

[TeleMadrid]
channel = 52
# key = 4

[Tele-5]
channel = 59
# key = 5

[Canal Plus]
channel = 62
# key = 6

[Canal-7 TV]
channel = 35
# key = 7

# more stations follow here

[Camera]
source = Composite1
# key = 8

</pre>
</td></tr>
<tr><th>Listado 2: Ejemplo de configuración de XawTV</th></tr>
</table>
<p>
	Ya tenemos el programa instalado y listo. <i>man xawtv</i> nos 
proporciona una lista de funciones, menús, y comandos del fichero de 
configuración. La figura 4 muestra el menú de opciones de XawTV
</p>

<p>
<table border>
<tr><td>
<!-- nombre de las imagenes a rellenar -->
<img src="options.gif" alt="menu de opciones de xawtv"> 
</td></tr>
<tr><th>Figura 4: Menú de opciones de XawTV</th></tr>
</table>
<p>
<p> 
	Un último retoque nos permitirá reconfigurar las X, para que XawTV
pueda funcionar a pantalla completa: Especificar un "ModeLine" para la
resolución de video PAL . Para ello, como root editamos el fichero
<i>/etc/X11/XF86Config</i> y en la seccion <i>Monitor</i> , antes de 
<i>EndSection</i> añadimos la linea:
<pre>
# For Pal TV decoder
Modeline  "768x576"  50.00  768 876 900 1000  576 590 595 630  -hsync -vsync
</pre>
<p> los valores anteriores se ajustan manualmente con <i>"xvidtune"</i> de 
manera que la pantalla quede centrada correctamente en pantalla. 
<p> Del mismo modo en la sección <i>Screen</i>, en el apartado correspondiente
a las resoluciones de 16 bits añadimos la opción "768x576"

<p>
<table>
<tr><td width="40%"> 
<table border><tr><th>
<!-- texto del bocadillo -->
El servidor X puede ser programado con la resolución correspondiente
a la señal de video PAL: 768x576 pixels
</th></tr></table> 
</td><td> </td><td> </td></tr>
</table>
<p>                                                             
<p>
No olvidemos que para poder ver correctamente la señal de tevisión, necesitamos
una resolucion de al menos 16 bits en el servidor X. Esto se consigue mediante
el comando <i>startx -- -bpp 16 </i>
<p> Rizando el rizo podemos crear un usuario "tele" que tenga como login shell
el programa "fbtv" ( en los nuevos kernels, o bien un script que arranque las
X y el programa xawtv, para los kernels 2.0.3X ), de manera que no haya que 
hacer login en la máquina para ver la televisión
<hr><h3><a name="problemas">Problemas</h3></a>
<p>
	En función de nuestra configuración, y sobre todo, de la tarjeta de
vídeo utilizada pueden presentarse diversos problemas:
<ul>
	<li> Los errores de compilación pueden deberse al uso de una versión
	incorrecta del kernel, o del compilador. hay que asegurarse de utilizar
	gcc version 2.7.2.3 o superior, o bien egcs. 
	<li> Del mismo modo, algunas de las aplicaciones que vienen con el 
	paquete bttv presentan errores de compilación del tipo "tipo xxxx no
	definido". Hay que revisar concienzudamente los includes, pues algunos
	de ellos dependen de la versión del kernel utilizada
	<li> Aunque la opción "Autodetect" funciona la mayor parte de las veces
	a la hora de insertar el módulo en el kernel, puede ocurrir que alguna
	tarjeta "no estandard" no se detecte. En este caso deberemos 
	especificarla en el script de carga
	<li> Del mismo modo, verificar que el módulo de gestión del chip de
	sonido estéreo/Nicam se carga e instala perfectamente
	<li> Todos los módulos disponen de una opción "debug" que genera
	mensajes de syslog en /var/log/messages. Estudiando detenidamente
	dichos mensajes podremos ver que es lo que está pasando
	<li> Mención especial merecen los parámetros "remap" y "vidmem" del
	modulo <i>bttv</i>. El primero indica donde va a guardar el chip los
	datos que lea de la entrada de vídeo. El segundo indica dónde está
	mapeado el framebuffer. Normalmente no es preciso especificarlo, pero
	en algunas ocasiones, al arrancar las X, el framebuffer es mapeado en
	otra dirección. Si bien la mayor parte de los programas utilizan las
	extensiones DGA para adivinar dónde está mapeado el frame buffer de las
	X's, no todos los servidores lo soportan. Si falla la autodetección
	el proceso a seguir es el siguiente:
	<ol>
		<li> Con los módulos de vídeo descargados arrancar las X
		<li> con &lt;Ctrl&gt;+&lt;Alt&gt;+&lt;F1&gt; volvemos a modo 
		texto y buscamos un texto similar a:<br>
		"Frame Buffer memory mapped at 0x0ff0xxxxxx"
		<li>Eliminamos cinco ceros y utilizamos dicho valor para 
		especificar la opción "vidmem"
	</ol>
	<li> Puede haber problemas en el funcionamiento normal del módulo en
	los casos de cambio de resolución de pantalla, utilización simultánea
	de otros programas que accedan a las extensiones DGA o al /dev/fbXX..
	en estos casos, con <i>/etc/rc.d/init.d/v4linux restart</i> deberemos
	reiniciar los módulos
</ul>
<p>
<hr><h3><a name="conclusion">Conclusiones</h3></a>
<p>
	En este artículo hemos hecho una presentación del subsistema de gestión
multimedia "Video For Linux", describiendo los módulos de que consta, su
instalación y alguna de sus aplicaciones. En el proximo número de Linux Actual
describiremos el API y el modelo de programación, indicando la interacción
con los dispositivos que el nuevo kernel 2.2 soporta, y analizando alguno de
los programas que utilizan dichos recursos.
</p>
<p>
	El modelo de programación unificado que nos propone el API de v4linux
es muy potente, y es capaz de efectuar una abstracción del hardware de manera
que se puede conseguir mucha mayor potencia y flexibilidad a la hora de
desarrollar software que con los drivers proporcionados para otros sistemas de
todos conocidos, tanto a nivel de control de hardware como de user iterface
<p>
<hr><h3><a name="referencias">Referencias</h3></a>
<ul>
<li> Video For Linux Home Page<br>
<a href="http://roadrunner.swansea.uk.linux.org/v4l.shtml"> http://roadrunner.swansea.uk.linux.org/v4l.shtml</a>
<li> Bttv Home Page<br>
<a href="http://www.thp.uni-koeln.de/~rjkm/linux/bttv.html"> http://www.thp.uni-koeln.de/~rjkm/linux/bttv.html</a>
<li> Información sobre el bus I2C<br>
<a href="http://www.tk.uni-linz.ac.at/~simon/private/i2c/"> http://www.tk.uni-linz.ac.at/~simon/private/i2c/</a>
<li> Información sobre el programa XawTV<br>
<a href="http://www.cs.tu-berlin.de/~kraxel/linux/#xawtv"> http://www.cs.tu-berlin.de/~kraxel/linux/#xawtv</a>
<li> Otras direcciones de interés<br>
<a href="http://www-nrg.ee.lbl.gov/vic/"> http://www-nrg.ee.lbl.gov/vic/</a><br>
<a href="http://www.kde.org "> http://www.kde.org </a><br>
<a href="http://FreeTV.Notrix.de"> http://FreeTV.Notrix.de</a><br>
</ul>
</body>
</html>
