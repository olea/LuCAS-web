<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>        psql
    </TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Manual del usuario de PostgreSQL"
HREF="user.html"><LINK
REL="UP"
TITLE="Aplicaciones"
HREF="applications.html"><LINK
REL="PREVIOUS"
TITLE="   pg_dumpall
  "
HREF="app-pgdumpall.html"><LINK
REL="NEXT"
TITLE="   pgtclsh
  "
HREF="app-pgtclsh.html"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Manual del usuario de PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="app-pgdumpall.html"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="app-pgtclsh.html"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="APP-PSQL"
><TT
CLASS="APPLICATION"
>psql</TT
></A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12454"
></A
><H2
>Nombre</H2
>      <TT
CLASS="APPLICATION"
>psql</TT
>
    &nbsp;--&nbsp;      <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> interactive terminal
    </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN12459"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>psql [ <TT
CLASS="REPLACEABLE"
><I
>options</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
> ] ]</PRE
></TD
></TR
></TABLE
><DIV
CLASS="REFSECT2"
><A
NAME="R2-APP-PSQL-1"
></A
><H3
>Summary</H3
><P
>     <TT
CLASS="APPLICATION"
>psql</TT
> is a terminal-based front-end to 
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. It enables you to type in queries
     interactively, issue them to <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, and see
     the query results. Alternatively, input can be from a file.
     In addition, it provides a number of meta-commands and
     various shell-like features to facilitate writing scripts and automating a wide
     variety of tasks.
    </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-APP-PSQL-1"
></A
><H2
>Description</H2
><DIV
CLASS="REFSECT2"
><A
NAME="R2-APP-PSQL-CONNECTING"
></A
><H3
>Connecting To A Database</H3
><P
>    <TT
CLASS="APPLICATION"
>psql</TT
> is a regular <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
    client application. In order to connect to a database you need to know the
    name of your target database, the hostname and port number of the server
    and what user name you want to connect as. <TT
CLASS="APPLICATION"
>psql</TT
> can be
    told about those parameters via command line options, namely <TT
CLASS="OPTION"
>-d</TT
>,
    <TT
CLASS="OPTION"
>-h</TT
>, <TT
CLASS="OPTION"
>-p</TT
>, and <TT
CLASS="OPTION"
>-U</TT
> respectively.
    If an argument is found that does not belong to any option it will be interpreted
    as database name as well. Not all these options are required, defaults do apply.
    If you omit the host name psql will connect via domain sockets to a server on the
    local host. The default port number is compile-time determined. Since the database
    server uses the same default, chances are you don't have to specify the port in most
    settings. The default user name is your Unix username, the same with the database.
    Note that you can't just connect to any database under any username. Your database
    administrator should have informed you about your access rights. To save you some typing
    you can also set the environment variables <TT
CLASS="ENVAR"
>PGDATABASE</TT
>,
    <TT
CLASS="ENVAR"
>PGHOST</TT
>, <TT
CLASS="ENVAR"
>PGPORT</TT
>, <TT
CLASS="ENVAR"
>PGUSER</TT
>,
    respectively to appropriate values.
    </P
><P
>    If the connection could not be made for any reason (e.g., insufficient
    privileges, postmaster is not running on the server, etc.),
    <TT
CLASS="APPLICATION"
>psql</TT
> will return an error and terminate.
    </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="R2-APP-PSQL-4"
></A
><H3
>Entering Queries</H3
><P
>    In normal operation, <TT
CLASS="APPLICATION"
>psql</TT
> provides a prompt with
    the name of the database that <TT
CLASS="APPLICATION"
>psql</TT
> is currently
    connected to followed by the string "=&#62;". For example,
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>$ <TT
CLASS="USERINPUT"
><B
>psql testdb</B
></TT
>
Welcome to psql, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help on internal slash commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=&#62;</PRE
></TD
></TR
></TABLE
>
    </P
><P
>    At the prompt, the user may type in <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> queries.  
    Ordinarily, input lines are sent to the backend when a query-terminating
    semicolon is reached. An end of line does not terminate a query! Thus queries
    can be spread over serveral lines for clarity. If the query was sent and without
    error, the query results are displayed on the screen.
    </P
><P
>    Whenever a query is executed, <TT
CLASS="APPLICATION"
>psql</TT
> also polls
    for asynchronous notification events generated by
    <A
HREF="sql-listen.html"
><I
>LISTEN</I
></A
> and
    <A
HREF="sql-notify.html"
><I
>NOTIFY</I
></A
>.
    </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-APP-PSQL-2"
></A
><H2
><TT
CLASS="APPLICATION"
>psql</TT
> Meta-Commands</H2
><P
>    Anything you enter in <TT
CLASS="APPLICATION"
>psql</TT
> that begins with an
    unquoted backslash is a <TT
CLASS="APPLICATION"
>psql</TT
> meta-command that is
    processes by <TT
CLASS="APPLICATION"
>psql</TT
> itself.
    These commands are what makes
    <TT
CLASS="APPLICATION"
>psql</TT
> interesting for administration or scripting.
    Meta-commands are more commonly called slash or backslash commands.
    </P
><P
>    The format of a <TT
CLASS="APPLICATION"
>psql</TT
> command is the backslash, 
    followed immediately by a command verb, then any arguments. The arguments
    are separated from the command verb and each other by any number of white
    space characters.
    </P
><P
>    To include whitespace into an argument you must quote it with a single
    quote. To include a single quote into such an argument, preceed it by
    a backslash. Anything contained in single quotes is furthermore subject to
    C-like substitutions for <TT
CLASS="LITERAL"
>\n</TT
> (new line), <TT
CLASS="LITERAL"
>\t</TT
>
     (tab), <TT
CLASS="LITERAL"
>\</TT
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>,
    <TT
CLASS="LITERAL"
>\0</TT
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>, and
    <TT
CLASS="LITERAL"
>\0x</TT
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>
    (the character with the given decimal, octal, or hexadecimal code).
    </P
><P
>    If an unquoted argument begins with a colon (<TT
CLASS="LITERAL"
>:</TT
>),
    it is taken as a variable and the value of the variable is taken as the
    argument instead.
    </P
><P
>    Arguments that are quoted in <SPAN
CLASS="QUOTE"
>"backticks"</SPAN
> (<TT
CLASS="LITERAL"
>`</TT
>)
    are taken as a command line that is passed to the shell. The output of the
    command (with a trailing newline removed) is taken as the argument value.
    The above escape sequences also apply in backticks.
    </P
><P
>    Some commands take the name of an <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> identifier (such as
    a table name) as argument. These arguments follow the syntax rules of
    <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> regarding double quotes: an identifier without
    double quotes is coerced to lower-case. For all other commands
    double quotes are not special and will become part of the argument.
    </P
><P
>    Parsing for arguments stops when another unquoted backslash occurs. This
    is taken as the beginning of a new meta-command. The special sequence
    <TT
CLASS="LITERAL"
>\\</TT
>
    (two backslashes) marks the end of arguments and continues parsing
    <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> queries, if any. That way <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> and
    <TT
CLASS="APPLICATION"
>psql</TT
> commands can be freely mixed on a line.
    But in any case, the arguments of a meta-command cannot continue beyond the end
    of the line. 
    </P
><P
>    The following meta-commands are defined:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>\a</TT
></DT
><DD
><P
>	If the current table output format is unaligned, switch to aligned.
	If it is not unaligned, set it to unaligned. This command is
	kept for backwards compatibility. See <B
CLASS="COMMAND"
>\pset</B
> for a
	general solution.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\C</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>title</I
></TT
> ]</DT
><DD
><P
>        Set the title of any tables being printed as the result of a query or
        unset any such title. This command is equivalent to
        <TT
CLASS="LITERAL"
>\pset title <TT
CLASS="REPLACEABLE"
><I
>title</I
></TT
></TT
>.
        (The name of this
        command derives from <SPAN
CLASS="QUOTE"
>"caption"</SPAN
>, as it was previously only
	used to set the caption in an <SPAN
CLASS="ACRONYM"
>HTML</SPAN
> table.)
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\connect</TT
> (or <TT
CLASS="LITERAL"
>\c</TT
>) [ <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
> ] ]</DT
><DD
><P
>	Establishes a connection to a new database and/or under a user name. The
	previous connection is closed.
	If <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> is <TT
CLASS="LITERAL"
>-</TT
>
	the current database name is assumed.
	</P
><P
>	If <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
> is omitted
        the current user name is assumed.
	</P
><P
>	As a special rule, <B
CLASS="COMMAND"
>\connect</B
> without any arguments will connect
	to the default database as the default user (as you would have gotten
	by starting <TT
CLASS="APPLICATION"
>psql</TT
> without any arguments).
	</P
><P
>	If the connection attempt failed (wrong username, access denied, etc.) the
	previous connection will be kept if and only if <TT
CLASS="APPLICATION"
>psql</TT
> is
	in interactive mode. When executing a non-interactive script, processing
	will immediately stop with an error. This distinction was chosen as a user
	convenience against typos on the one hand, and a safety mechanism that
	scripts are not accidentally acting on the wrong database on the other hand.
	</P
></DD
><DT
><TT
CLASS="LITERAL"
>\copy</TT
> <TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
>
        [ <TT
CLASS="LITERAL"
>with oids</TT
> ] { <TT
CLASS="LITERAL"
>from</TT
> | <TT
CLASS="LITERAL"
>to</TT
> }
	<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> | stdin | stdout
        [ <TT
CLASS="LITERAL"
>with delimiters</TT
> '<TT
CLASS="REPLACEABLE"
><I
>characters</I
></TT
>' ]
        [ <TT
CLASS="LITERAL"
>with null as</TT
> '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>' ]</DT
><DD
><P
>        Performs a frontend (client) copy. This is an operation that runs an
	<SPAN
CLASS="ACRONYM"
>SQL</SPAN
> <A
HREF="sql-copy.html"
><I
>COPY</I
></A
> command,
        but instead of the backend reading or writing the specified file, and 
        consequently requiring backend access and special user privilege, 
	as well as being bound to the file system accessible by the backend,
        <TT
CLASS="APPLICATION"
>psql</TT
> reads or writes the 
        file and routes the data to or from the backend onto the local file system.
	</P
><P
>	The syntax of the command is in analogy to the <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>
	<B
CLASS="COMMAND"
>COPY</B
> command, see its description for the details.
	Note that because of this, special parsing rules apply to the
	<B
CLASS="COMMAND"
>\copy</B
> command. In particular, the variable
	substitution rules and backslash escapes do not apply.
	</P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/tip.gif"
HSPACE="5"
ALT="Sugerencia"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	This operation is not as efficient as the <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> 
	<B
CLASS="COMMAND"
>COPY</B
> command because all data must pass through the
	client/server IP or socket connection. For large amounts of data the other
	technique may be preferable.
        </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>        Note the difference in interpretation of <TT
CLASS="LITERAL"
>stdin</TT
> and <TT
CLASS="LITERAL"
>stdout</TT
>
        between frontend and backend copies: In a frontend copy these always refer
        to <TT
CLASS="APPLICATION"
>psql</TT
>'s input and output stream. On a backend
        copy <TT
CLASS="LITERAL"
>stdin</TT
> comes from whereever the <B
CLASS="COMMAND"
>COPY</B
>
        itself came from (for example, a script ran with the <TT
CLASS="OPTION"
>-f</TT
>) option,
        and <TT
CLASS="LITERAL"
>stdout</TT
> refers to the query output stream (see
        <B
CLASS="COMMAND"
>\o</B
> meta-command below).
        </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\copyright</TT
></DT
><DD
><P
>        Shows the copyright and distribution terms of <TT
CLASS="APPLICATION"
>PostgreSQL</TT
>.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\d</TT
> <TT
CLASS="REPLACEABLE"
><I
>relation</I
></TT
></DT
><DD
><P
>	Shows all columns of <TT
CLASS="REPLACEABLE"
><I
>relation</I
></TT
>
	(which could be a table, view, index, or sequence),
	their types, and any special attributes such as <TT
CLASS="LITERAL"
>NOT NULL</TT
>
	or defaults, if any.
	If the relation is, in fact, a table, any defined indices are also listed.
	If the relation is a view, the view definition is also shown.
	</P
><P
>	The command form <TT
CLASS="LITERAL"
>\d+</TT
> is identical, but any comments
        associated with the table columns are shown as well.
	</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	If <B
CLASS="COMMAND"
>\d</B
> is called without any arguments, it is
	equivalent to <B
CLASS="COMMAND"
>\dtvs</B
> which will show a list
	of all tables, views, and sequences. This is purely a convenience
	measure.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\da</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> ]</DT
><DD
><P
>        Lists all available aggregate functions, together with the data type they operate on.
	If <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>
	(a regular expression) is specified, only matching aggregates are shown.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dd</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>object</I
></TT
> ]</DT
><DD
><P
>        Shows the descriptions of <TT
CLASS="REPLACEABLE"
><I
>object</I
></TT
>
        (which can be a regular expression), or of all objects if no argument is given.
        (<SPAN
CLASS="QUOTE"
>"Object"</SPAN
> covers aggregates, functions, operators, types, relations
        (tables, views, indices, sequences, large objects), rules, and triggers.) For example:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>=&#62; <TT
CLASS="USERINPUT"
><B
>\dd version</B
></TT
>
              Object descriptions
  Name   |   What   |        Description
---------+----------+---------------------------
 version | function | PostgreSQL version string
(1 row)</PRE
></TD
></TR
></TABLE
>
        </P
><P
>        Descriptions for objects can be generated with the <B
CLASS="COMMAND"
>COMMENT ON</B
>
        <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> command.
	</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> stores the object descriptions in the
        pg_description system table.
        </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\df [ <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> ]</TT
></DT
><DD
><P
>        Lists available functions, together with their argument and return types.
        If <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>
        (a regular expression) is specified, only matching functions are shown.
        If the form <TT
CLASS="LITERAL"
>\df+</TT
> is used, additional information about
        each function, including language and description is shown.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\distvS [ <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> ]</TT
></DT
><DD
><P
>	This is not the actual command name: The letters i, s, t, v, S stand for
	index, sequence, table, view, and system table, respectively. You can specify
	any or all of them in any order to obtain a listing of them, together with
	who the owner is.
	</P
><P
>	If <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> is specified,
	it is a regular expression restricts the listing to those objects
	whose name matches. If one appends a <SPAN
CLASS="QUOTE"
>"+"</SPAN
> to the command name,
	each object is listed with its associated description, if any.
	</P
></DD
><DT
><TT
CLASS="LITERAL"
>\dl</TT
></DT
><DD
><P
>	This is an alias for <B
CLASS="COMMAND"
>\lo_list</B
>, which shows a list of large objects.
	</P
></DD
><DT
><TT
CLASS="LITERAL"
>\do [ <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> ]</TT
></DT
><DD
><P
>        Lists available operators with their operand and return types.
        If <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>
        is specified, only operators with that name will be shown.
        (Since this is a regular expression, be sure to quote all special
        characters in you operator name with backslashes. To prevent
        interpretation of the backslash as a new command, you might also
        wish to quote the argument.)
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dp</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> ]</DT
><DD
><P
>	This is an alias for <B
CLASS="COMMAND"
>\z</B
> which was included for its
	greater mnemonic value (<SPAN
CLASS="QUOTE"
>"display permissions"</SPAN
>).
	</P
></DD
><DT
><TT
CLASS="LITERAL"
>\dT [ <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> ]</TT
></DT
><DD
><P
>        Lists all data types or only those that match <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>.
        The command form <TT
CLASS="LITERAL"
>\dT+</TT
> shows extra information.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\edit</TT
> (or <TT
CLASS="LITERAL"
>\e</TT
>) [ <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> ]</DT
><DD
><P
>        If <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> is specified,
        the file is edited and after the editor exit its content is copied
        back to the query buffer. If no argument is given, the current query
        buffer is copied to a temporary file which is then edited in the same
        fashion.
        </P
><P
>        The new query buffer is then re-parsed according to the normal rules of
        <TT
CLASS="APPLICATION"
>psql</TT
>, where the whole buffer is treated as
        a single line. (Thus you cannot make <SPAN
CLASS="QUOTE"
>"scripts"</SPAN
> this way,
        use <B
CLASS="COMMAND"
>\i</B
> for that.) This means also that
        if the query ends with (or rather contains) a semicolon, it is immediately
        executed. In other cases it will merely wait in the query buffer.
        </P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/tip.gif"
HSPACE="5"
ALT="Sugerencia"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>        <TT
CLASS="APPLICATION"
>psql</TT
> searches the environment variables
        <TT
CLASS="ENVAR"
>PSQL_EDITOR</TT
>, <TT
CLASS="ENVAR"
>EDITOR</TT
>, and <TT
CLASS="ENVAR"
>VISUAL</TT
>
        (in that order) for an editor to use. If all of them are unset,
        <TT
CLASS="FILENAME"
>/bin/vi</TT
> is run.
        </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\echo</TT
> <TT
CLASS="REPLACEABLE"
><I
>text</I
></TT
> [ ... ]</DT
><DD
><P
>        Prints the arguments to the standard output, separated by one space and
        followed by a newline. This can be useful to
        intersperse information in the output of scripts. For example:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>=&#62; <TT
CLASS="USERINPUT"
><B
>\echo `date`</B
></TT
>
Tue Oct 26 21:40:57 CEST 1999</PRE
></TD
></TR
></TABLE
>
        If the first argument is an unquoted <TT
CLASS="LITERAL"
>-n</TT
> the the trailing
        newline is not written.
	</P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/tip.gif"
HSPACE="5"
ALT="Sugerencia"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	If you use the <B
CLASS="COMMAND"
>\o</B
> command to redirect your query output
	you may wish to use <B
CLASS="COMMAND"
>\qecho</B
> instead of this command.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\encoding</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>encoding</I
></TT
> ]</DT
><DD
><P
>        Sets the client encoding, if you are using multibyte encodings.
        Without an argument, this command shows the current encoding.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\f</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
> ]</DT
><DD
><P
>        Sets the field separator for unaligned query output. The default is <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>|</TT
>"</SPAN
>
	(a <SPAN
CLASS="QUOTE"
>"pipe"</SPAN
> symbol). See also <B
CLASS="COMMAND"
>\pset</B
> for a generic way
	of setting output options.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\g</TT
> [ { <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> | <TT
CLASS="LITERAL"
>|</TT
><TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> } ]</DT
><DD
><P
>        Sends the current query input buffer to the backend and optionally
        saves the output in <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>
        or pipes the output into a separate Unix shell to execute
        <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>. A bare <TT
CLASS="LITERAL"
>\g</TT
>
	is virtually equivalent to a semicolon. A <TT
CLASS="LITERAL"
>\g</TT
> with argument
	is a <SPAN
CLASS="QUOTE"
>"one-shot"</SPAN
> alternative to the <B
CLASS="COMMAND"
>\o</B
> command.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\help</TT
> (or <TT
CLASS="LITERAL"
>\h</TT
>) [ <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> ]</DT
><DD
><P
>        Give syntax help on the specified <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> command.  
        If <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> is not specified,
        then <TT
CLASS="APPLICATION"
>psql</TT
> will 
        list all the commands for which syntax help is
        available.  If <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>
        is an asterisk (<SPAN
CLASS="QUOTE"
>"*"</SPAN
>), then
        syntax help on all <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> commands is shown.
        </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	To simplify typing, commands that consists of several words do not have to be quoted.
	Thus it is fine to type <TT
CLASS="USERINPUT"
><B
>\help alter table</B
></TT
>.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\H</TT
></DT
><DD
><P
>	Turns on <SPAN
CLASS="ACRONYM"
>HTML</SPAN
> query output format. If the <SPAN
CLASS="ACRONYM"
>HTML</SPAN
>
	format is already on, it is switched back to the default aligned text format. This
	command is for compatibility and convenience, but see <B
CLASS="COMMAND"
>\pset</B
> about
	setting other output options.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\i</TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></DT
><DD
><P
>        Reads input from the file <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>
	and executes it as though it had been typed on the keyboard.
        </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	If you want to see the lines on the screen as they are read you must set
	the variable <TT
CLASS="ENVAR"
>ECHO</TT
> to <TT
CLASS="LITERAL"
>all</TT
>.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\l</TT
> (or <TT
CLASS="LITERAL"
>\list</TT
>)</DT
><DD
><P
>        List all the databases in the server as well as their owners. Append a
        <SPAN
CLASS="QUOTE"
>"+"</SPAN
> to the command name to see any descriptions
        for the databases as well. If your <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
	installation was
	compiled with multibyte encoding support, the encoding scheme of each
	database is shown as well.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\lo_export</TT
> <TT
CLASS="REPLACEABLE"
><I
>loid</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></DT
><DD
><P
>	Reads the large object with <SPAN
CLASS="ACRONYM"
>OID</SPAN
> <TT
CLASS="REPLACEABLE"
><I
>loid</I
></TT
>
	from the database and writes it to <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>.
	Note that this is subtly different from the server function <TT
CLASS="FUNCTION"
>lo_export</TT
>,
	which acts with the permissions of the user that the database server runs as and
	on the server's file system.
	</P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/tip.gif"
HSPACE="5"
ALT="Sugerencia"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	Use <B
CLASS="COMMAND"
>\lo_list</B
> to find out the large object's <SPAN
CLASS="ACRONYM"
>OID</SPAN
>.
	</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	See the description of the <TT
CLASS="ENVAR"
>LO_TRANSACTION</TT
> variable for
	important information concerning all large object operations.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\lo_import</TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>comment</I
></TT
> ]</DT
><DD
><P
>	Stores the file into a <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> <SPAN
CLASS="QUOTE"
>"large object"</SPAN
>.
	Optionally, it associates the given comment with the object. Example:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>foo=&#62; <TT
CLASS="USERINPUT"
><B
>\lo_import '/home/peter/pictures/photo.xcf' 'a picture of me'</B
></TT
>
lo_import 152801</PRE
></TD
></TR
></TABLE
>
	The response indicates that the large object received object id 152801
	which one ought to remember if one wants to access the object ever again.
	For that reason it is recommended to always associate a human-readable
	comment with every object. Those can then be seen with the
	<B
CLASS="COMMAND"
>\lo_list</B
> command.
	</P
><P
>	Note that this command is subtly different from the server-side <TT
CLASS="FUNCTION"
>lo_import</TT
>
	because it acts as the local user on the local file system, rather than the server's
	user and file system.
	</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	See the description of the <TT
CLASS="ENVAR"
>LO_TRANSACTION</TT
> variable for
	important information concerning all large object operations.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\lo_list</TT
></DT
><DD
><P
>	Shows a list of all <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> <SPAN
CLASS="QUOTE"
>"large
	objects"</SPAN
> currently stored in the database along with their owners.
	</P
></DD
><DT
><TT
CLASS="LITERAL"
>\lo_unlink</TT
> <TT
CLASS="REPLACEABLE"
><I
>loid</I
></TT
></DT
><DD
><P
>	Deletes the large object with <SPAN
CLASS="ACRONYM"
>OID</SPAN
> <TT
CLASS="REPLACEABLE"
><I
>loid</I
></TT
>
	from the database.
	</P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/tip.gif"
HSPACE="5"
ALT="Sugerencia"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	Use <B
CLASS="COMMAND"
>\lo_list</B
> to find out the large object's <SPAN
CLASS="ACRONYM"
>OID</SPAN
>.
	</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	See the description of the <TT
CLASS="ENVAR"
>LO_TRANSACTION</TT
> variable for
	important information concerning all large object operations.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\o</TT
> [ {<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> | <TT
CLASS="LITERAL"
>|</TT
><TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>} ]</DT
><DD
><P
>        Saves future query results to the file
	<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> or pipe future
        results into a separate Unix shell to execute
	<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>.
        If no arguments are specified, the query output will be reset to
        <TT
CLASS="FILENAME"
>stdout</TT
>.
        </P
><P
>	<SPAN
CLASS="QUOTE"
>"Query results"</SPAN
> includes all tables, command responses,
        and notices obtained
	from the database server, as well as output of various backslash
	commands that query the database (such as <B
CLASS="COMMAND"
>\d</B
>),
        but not error messages.
	</P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/tip.gif"
HSPACE="5"
ALT="Sugerencia"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	To intersperse text output in between query results, use <B
CLASS="COMMAND"
>\qecho</B
>.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\p</TT
></DT
><DD
><P
>        Print the current query buffer to the standard output.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\pset</TT
> <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> ]</DT
><DD
><P
>	This command sets options affecting the output of query result tables.
	<TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
> describes which option
	is to be set. The semantics of <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>
	depend thereon.
	</P
><P
>	Adjustable printing options are:
	<P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>format</TT
></DT
><DD
><P
>	  Sets the output format to one of <TT
CLASS="LITERAL"
>unaligned</TT
>,
	  <TT
CLASS="LITERAL"
>aligned</TT
>, <TT
CLASS="LITERAL"
>html</TT
>, or <TT
CLASS="LITERAL"
>latex</TT
>.
	  Unique abbreviations are allowed. (That would mean one letter is enough.)
	  </P
><P
>	  <SPAN
CLASS="QUOTE"
>"Unaligned"</SPAN
> writes all fields of a tuple on a line, separated
	  by the currently active field separator. This is intended to create output
	  that might be intended to be read in by other programs (tab-separated,
	  comma-separated).
	  <SPAN
CLASS="QUOTE"
>"Aligned"</SPAN
> mode is the
	  standard, human-readable, nicely formatted text output that is default.
	  The <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="ACRONYM"
>HTML</SPAN
>"</SPAN
> and <SPAN
CLASS="QUOTE"
>"LaTeX"</SPAN
> modes
	  put out tables that are intended to be included in documents using the
	  respective mark-up language. They are not complete documents! (This might
	  not be so dramatic in <SPAN
CLASS="ACRONYM"
>HTML</SPAN
>, but in LaTeX you must
	  have a complete document wrapper.)
	  </P
></DD
><DT
><TT
CLASS="LITERAL"
>border</TT
></DT
><DD
><P
>	  The second argument must be a number. In general, the higher the number
	  the more borders and lines the tables will have, but this depends on
	  the particular format. In <SPAN
CLASS="ACRONYM"
>HTML</SPAN
> mode, this will
	  translate directly into the <TT
CLASS="LITERAL"
>border=...</TT
> attribute, in
	  the others only values 0 (no border), 1 (internal dividing lines), and 2
	  (table frame) make sense.
	  </P
></DD
><DT
><TT
CLASS="LITERAL"
>expanded</TT
> (or <TT
CLASS="LITERAL"
>x</TT
>)</DT
><DD
><P
>	  Toggles between regular and expanded format. When expanded format is
	  enabled, all output has two columns with the field name on the left
	  and the data on the right. This mode is useful if the data wouldn't
	  fit on the screen in the normal <SPAN
CLASS="QUOTE"
>"horizontal"</SPAN
> mode.
	  </P
><P
>	  Expanded mode is support by all four output modes.
	  </P
></DD
><DT
><TT
CLASS="LITERAL"
>null</TT
></DT
><DD
><P
>	  The second argument is a string that should be printed whenever a field
	  is null. The default is not to print anything, which can easily be mistaken
	  for, say, an empty string. Thus, one might choose to write
	  <TT
CLASS="LITERAL"
>\pset null "(null)"</TT
>.
	  </P
></DD
><DT
><TT
CLASS="LITERAL"
>fieldsep</TT
></DT
><DD
><P
>	  Specifies the field separator to be used in unaligned output mode. That way
	  one can create, for example, tab- or comma-separated output, which other
	  programs might prefer. To set a tab as field separator, type
	  <TT
CLASS="LITERAL"
>\pset fieldsep "\t"</TT
>. The default field separator is
	  <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>|</TT
>"</SPAN
> (a <SPAN
CLASS="QUOTE"
>"pipe"</SPAN
> symbol).
	  </P
></DD
><DT
><TT
CLASS="LITERAL"
>recordsep</TT
></DT
><DD
><P
>          Specifies the record (line) separator to use in unaligned output mode. The default
          is a newline character.
	  </P
></DD
><DT
><TT
CLASS="LITERAL"
>tuples_only</TT
> (or <TT
CLASS="LITERAL"
>t</TT
>)</DT
><DD
><P
>	  Toggles between tuples only and full display. Full display may show
	  extra information such as column headers, titles, and various footers.
	  In tuples only mode, only actual table data is shown.
	  </P
></DD
><DT
><TT
CLASS="LITERAL"
>title</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>text</I
></TT
> ]</DT
><DD
><P
>	  Sets the table title for any subsequently printed tables. This can be
	  used to give your output descriptive tags. If no argument is given,
	  the title is unset.
	  </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	  This formerly only affected <SPAN
CLASS="ACRONYM"
>HTML</SPAN
> mode. You can now
	  set titles in any output format.
	  </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>tableattr</TT
> (or <TT
CLASS="LITERAL"
>T</TT
>) [ <TT
CLASS="REPLACEABLE"
><I
>text</I
></TT
> ]</DT
><DD
><P
>	  Allows you to specify any attributes to be places inside the <SPAN
CLASS="ACRONYM"
>HTML</SPAN
>
	  <TT
CLASS="SGMLTAG"
>table</TT
> tag. This could for example be
	  <TT
CLASS="LITERAL"
>cellpadding</TT
> or <TT
CLASS="LITERAL"
>bgcolor</TT
>. Note that you
	  probably don't want to specify <TT
CLASS="LITERAL"
>border</TT
> here, as
	  that is already taken care of by <TT
CLASS="LITERAL"
>\pset border</TT
>.
	  </P
></DD
><DT
><TT
CLASS="LITERAL"
>pager</TT
></DT
><DD
><P
>	  Toggles the list of a pager to do table output. If the environment variable
	  <TT
CLASS="ENVAR"
>PAGER</TT
> is set, the output is piped to the specified program.
	  Otherwise <TT
CLASS="FILENAME"
>more</TT
> is used.
	  </P
><P
>	  In any case, <TT
CLASS="APPLICATION"
>psql</TT
> only uses the pager if it
	  seems appropriate. That means among other things that the output is to
	  a terminal and that the table would normally not fit on the screen.
	  Because of the modular nature of the printing routines it is not always
	  possible to predict the number of lines that will actually be printed.
	  For that reason <TT
CLASS="APPLICATION"
>psql</TT
> might not appear very
	  discriminating about when to use the pager and when not to.
	  </P
></DD
></DL
></DIV
>
	Illustrations on how these different formats look can be seen in
	the <A
HREF="app-psql.html#APP-PSQL-EXAMPLES"
><I
>Examples</I
></A
> section.
	</P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/tip.gif"
HSPACE="5"
ALT="Sugerencia"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	There are various shortcut commands for <B
CLASS="COMMAND"
>\pset</B
>. See
	<B
CLASS="COMMAND"
>\a</B
>, <B
CLASS="COMMAND"
>\C</B
>, <B
CLASS="COMMAND"
>\H</B
>,
	<B
CLASS="COMMAND"
>\t</B
>, <B
CLASS="COMMAND"
>\T</B
>, and <B
CLASS="COMMAND"
>\x</B
>.
	</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	It is an error to call <B
CLASS="COMMAND"
>\pset</B
> without arguments. In the future
	this call might show the current status of all printing options.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\q</TT
></DT
><DD
><P
>        Quit the <TT
CLASS="APPLICATION"
>psql</TT
> program.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\qecho</TT
> <TT
CLASS="REPLACEABLE"
><I
>text</I
></TT
> [ ... ]</DT
><DD
><P
>	This command is identical to <B
CLASS="COMMAND"
>\echo</B
> except that
	all output will be written to the query output channel, as set by
	<B
CLASS="COMMAND"
>\o</B
>.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\r</TT
></DT
><DD
><P
>        Resets (clears) the query buffer.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\s</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> ]</DT
><DD
><P
>        Print or save the command line history to 
        <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>.
        If <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> is omitted,
	the history is written to the standard output.
        This option is only available if <TT
CLASS="APPLICATION"
>psql</TT
> is
        configured to use the <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> history library.
        </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	As of <TT
CLASS="APPLICATION"
>psql</TT
> version 7.0 it is no longer
	necessary, in fact, to save the command history as that will be done
	automatically on program termination. The history is then
	also automatically loaded every time <TT
CLASS="APPLICATION"
>psql</TT
>
	starts up.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\set</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [ ... ]]]</DT
><DD
><P
>	Sets the internal variable <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>
	to <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> or, if more than one
        value is given, to the concatenation of all of them. If no second argument
	is given, the variable is just set with not value. To unset a variable, use
        the <B
CLASS="COMMAND"
>\unset</B
> command.
	</P
><P
>	Valid variable names can contain characters, digits, and underscores.
        See the section about <TT
CLASS="APPLICATION"
>psql</TT
> variables for details.
	</P
><P
>	Although you are welcome to set any variable to anything you want to,
	<TT
CLASS="APPLICATION"
>psql</TT
> treats several variables special.
	They are documented in the section about variables.
	</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	This command is totally separate from the <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> command
	<A
HREF="sql-set.html"
><I
>SET</I
></A
>.
	</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\t</TT
></DT
><DD
><P
>        Toggles the display of output column name headings and row count footer.
	This command is equivalent to <TT
CLASS="LITERAL"
>\pset tuples_only</TT
> and
	is provided for convenience.	
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\T</TT
> <TT
CLASS="REPLACEABLE"
><I
>table_options</I
></TT
></DT
><DD
><P
>        Allows you to specify options to be placed within the <TT
CLASS="SGMLTAG"
>table</TT
>
	tag in <SPAN
CLASS="ACRONYM"
>HTML</SPAN
> tabular output mode. This command is
	equivalent to <TT
CLASS="LITERAL"
>\pset tableattr <TT
CLASS="REPLACEABLE"
><I
>table_options</I
></TT
></TT
>.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\w</TT
> {<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>|command</I
></TT
>}</DT
><DD
><P
>        Outputs the current query buffer to the file <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>
	or pipes it to the Unix command <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\x</TT
></DT
><DD
><P
>        Toggles extended row format mode. As such it is equivalent to
	<TT
CLASS="LITERAL"
>\pset expanded</TT
>.
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>\z</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> ]</DT
><DD
><P
>        Produces a list of all tables in the database with their appropriate
	access permissions listed. If an argument is given it is taken as a regular
	expression which limits the listing to those tables which match it.
        </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>test=&#62; <TT
CLASS="USERINPUT"
><B
>\z</B
></TT
>
Access permissions for database "test"
 Relation |           Access permissions
----------+-------------------------------------
 my_table | {"=r","joe=arwR", "group staff=ar"}
(1 row )</PRE
></TD
></TR
></TABLE
>
        Read this as follows:

	<P
></P
><UL
><LI
><P
>          <TT
CLASS="LITERAL"
>"=r"</TT
>: <TT
CLASS="LITERAL"
>PUBLIC</TT
> has read
	  (<B
CLASS="COMMAND"
>SELECT</B
>) permission on the table.
	  </P
></LI
><LI
><P
>	  <TT
CLASS="LITERAL"
>"joe=arwR"</TT
>: User <TT
CLASS="LITERAL"
>joe</TT
> has read,
	  write (<B
CLASS="COMMAND"
>UPDATE</B
>, <B
CLASS="COMMAND"
>DELETE</B
>),
	  <SPAN
CLASS="QUOTE"
>"append"</SPAN
> (<B
CLASS="COMMAND"
>INSERT</B
>) permissions,
	  and permission to create rules on the table.
	  </P
></LI
><LI
><P
>	  <TT
CLASS="LITERAL"
>"group staff=ar"</TT
>: Group <TT
CLASS="LITERAL"
>staff</TT
>
	  has <B
CLASS="COMMAND"
>SELECT</B
> and <B
CLASS="COMMAND"
>INSERT</B
> permission.
	  </P
></LI
></UL
>
	</P
><P
>	The commands <A
HREF="sql-grant.html"
><I
>GRANT</I
></A
> and
	<A
HREF="sql-revoke.html"
><I
>REVOKE</I
></A
>
	are used to set access permissions.
	</P
></DD
><DT
><TT
CLASS="LITERAL"
>\!</TT
> [ <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> ]</DT
><DD
><P
>        Escapes to a separate Unix shell or executes the Unix command
        <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>. The arguments
        are not further interpreted, the shell will see them as is.
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\?</TT
></DT
><DD
><P
>        Get help information about the slash (<SPAN
CLASS="QUOTE"
>"\"</SPAN
>) commands.
        </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-APP-PSQL-3"
></A
><H2
>Command-line Options</H2
><P
>  If so configured, <TT
CLASS="APPLICATION"
>psql</TT
> understands both standard
  Unix short options, and <SPAN
CLASS="ACRONYM"
>GNU</SPAN
>-style long options. The latter
  are not available on all systems.
  </P
><P
>  <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-a, --echo-all</DT
><DD
><P
>      Print all the lines to the screen as they are read. This is more useful for
      script processing rather than interactive mode.
      This is equivalent to setting the variable <TT
CLASS="ENVAR"
>ECHO</TT
> to <TT
CLASS="LITERAL"
>all</TT
>.
      </P
></DD
><DT
>-A, --no-align</DT
><DD
><P
>      Switches to unaligned output mode. (The default output mode is otherwise
      aligned.)
      </P
></DD
><DT
>-c, --command <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
></DT
><DD
><P
>      Specifies that <TT
CLASS="APPLICATION"
>psql</TT
>
      is to execute one query string, <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>,
      and then exit.  This is useful in shell scripts.
      </P
><P
>      <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
> must be either a query string
      that is completely parseable by the backend (i.e., it contains no <TT
CLASS="APPLICATION"
>psql</TT
>
      specific features), or it is a single backslash command. Thus
      you cannot mix <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> and <TT
CLASS="APPLICATION"
>psql</TT
>
      meta-commands. To achieve this you could pipe the string into
      <TT
CLASS="APPLICATION"
>psql</TT
>, like so:
      <TT
CLASS="LITERAL"
>echo "\x \\ select * from foo;" | psql</TT
>.
      </P
></DD
><DT
>-d, --dbname <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></DT
><DD
><P
>      Specifies the name of the database to connect to. This is equivalent to specifying
      <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> as the first non-option
      argument on the command line.
      </P
></DD
><DT
>-e, --echo-queries</DT
><DD
><P
>      Show all queries that are sent to the backend.
      This is equivalent to setting the variable <TT
CLASS="ENVAR"
>ECHO</TT
>
      to <TT
CLASS="LITERAL"
>queries</TT
>.
      </P
></DD
><DT
>-E, --echo-hidden</DT
><DD
><P
>      Echos the actual queries generated by \d and other backslash commands.
      You can use this if you wish to include similar functionality into
      your own programs. This is equivalent to setting the variable
      <TT
CLASS="ENVAR"
>ECHO_HIDDEN</TT
> from within <TT
CLASS="APPLICATION"
>psql</TT
>.
      </P
></DD
><DT
>-f, --file <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></DT
><DD
><P
>      Use the file <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>
      as the source of queries instead of reading queries interactively.
      After the file is processed, <TT
CLASS="APPLICATION"
>psql</TT
> terminates.
      This in many ways equivalent to the internal command <B
CLASS="COMMAND"
>\i</B
>.
      </P
><P
>      Using this option is subtly different from writing
      <TT
CLASS="LITERAL"
>psql &#60; <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></TT
>.
      In general, both will do what you expect, but using <TT
CLASS="LITERAL"
>-f</TT
>
      enables some nice features such as error messages with line numbers.
      There is also a slight chance that using this option will reduce
      the startup overhead. On the other hand, the variant using the shell's
      input redirection is (in theory) guaranteed to yield exactly the same
      output that you would have gotten had you entered everything by hand.
      </P
></DD
><DT
>-F, --field-separator <TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
></DT
><DD
><P
>      Use <TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
> as the field separator.
      This is equivalent to <B
CLASS="COMMAND"
>\pset fieldsep</B
> or <B
CLASS="COMMAND"
>\f</B
>.
      </P
></DD
><DT
>-h, --host <TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
></DT
><DD
><P
>      Specifies the host name of the machine on which the
      <TT
CLASS="APPLICATION"
>postmaster</TT
> is running.
      Without this option, communication is performed using
      local Unix domain sockets.
      </P
></DD
><DT
>-H, --html</DT
><DD
><P
>      Turns on <SPAN
CLASS="ACRONYM"
>HTML</SPAN
> tabular output. This is equivalent
      to <TT
CLASS="LITERAL"
>\pset format html</TT
> or the <B
CLASS="COMMAND"
>\H</B
>
      command.
      </P
></DD
><DT
>-l, --list</DT
><DD
><P
>      Lists all available databases, then exits. Other non-connection options
      are ignored. This is similar to the internal command <B
CLASS="COMMAND"
>\list</B
>.
      </P
></DD
><DT
>-o, --output <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></DT
><DD
><P
>      Put all query output into file <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>.
      This is equivalent to the command <B
CLASS="COMMAND"
>\o</B
>.
      </P
></DD
><DT
>-p, --port <TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
></DT
><DD
><P
>      Specifies the TCP/IP port or, by omission, the local Unix domain socket file
      extension on which the <TT
CLASS="APPLICATION"
>postmaster</TT
>
      is listening for connections.  Defaults to the value of the
      <TT
CLASS="ENVAR"
>PGPORT</TT
> environment variable or, if not set, to the port
      specified at compile time, usually 5432.
      </P
></DD
><DT
>-P, --pset <TT
CLASS="REPLACEABLE"
><I
>assignment</I
></TT
></DT
><DD
><P
>      Allows you to specify printing options in the style of <B
CLASS="COMMAND"
>\pset</B
>
      on the command line. Note that here you have to separate name and value with
      an equal sign instead of a space. Thus to set the output format to LaTeX, you
      could write <TT
CLASS="LITERAL"
>-P format=latex</TT
>.
      </P
></DD
><DT
>-q</DT
><DD
><P
>      Specifies that <TT
CLASS="APPLICATION"
>psql</TT
> should do its work quietly.
      By default, it prints welcome messages and various informational output.
      If this option is used, none of this happens. This is useful with the
      <TT
CLASS="OPTION"
>-c</TT
> option. Within <TT
CLASS="APPLICATION"
>psql</TT
> you can
      also set the <TT
CLASS="ENVAR"
>QUIET</TT
> variable to achieve the same effect.
      </P
></DD
><DT
>-R, --record-separator <TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
></DT
><DD
><P
>      Use <TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
> as the record separator.
      This is equivalent to the <B
CLASS="COMMAND"
>\pset recordsep</B
> command.
      </P
></DD
><DT
>-s, --single-step</DT
><DD
><P
>      Run in single-step mode. That means the user is prompted before each query
      is sent to the backend, with the option to cancel execution as well.
      Use this to debug scripts.
      </P
></DD
><DT
>-S, --single-line</DT
><DD
><P
>      Runs in single-line mode where a newline terminates a query, like a semicolon would do.
      </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>      This mode is provided for those who insist on it, but you are not necessarily
      encouraged to use it. In particular, if you mix <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> and
      meta-commands on a line the order of execution might not always be clear to
      the unexperienced user.
      </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
>-t, --tuples-only</DT
><DD
><P
>      Turn off printing of column names and result row count footers, etc.
      It is completely equivalent to the <B
CLASS="COMMAND"
>\t</B
>.
      </P
></DD
><DT
>-T, --table-attr <TT
CLASS="REPLACEABLE"
><I
>table_options</I
></TT
></DT
><DD
><P
>      Allows you to specify options to be placed within the <SPAN
CLASS="ACRONYM"
>HTML</SPAN
>
      <TT
CLASS="SGMLTAG"
>table</TT
> tag. See <B
CLASS="COMMAND"
>\pset</B
> for details.
      </P
></DD
><DT
>-u</DT
><DD
><P
>      Makes <TT
CLASS="APPLICATION"
>psql</TT
> prompt for the user name and password
      before connecting to the database.
      </P
><P
>      This option is deprecated, as it is conceptually flawed. (Prompting for
      a non-default user name and prompting for a password because the
      backend requires it are really two different things.) You are encouraged
      to look at the <TT
CLASS="OPTION"
>-U</TT
> and <TT
CLASS="OPTION"
>-W</TT
> options instead.
      </P
></DD
><DT
>-U, --username <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
></DT
><DD
><P
>      Connects to the database as the user <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
>
      instead of the default. (You must have permission to do so, of course.)
      </P
></DD
><DT
>-v, --variable, --set <TT
CLASS="REPLACEABLE"
><I
>assignment</I
></TT
></DT
><DD
><P
>      Performs a variable assignment, like the <B
CLASS="COMMAND"
>\set</B
> internal command.
      Note that you must separate name and value, if any, by an equal sign on the command
      line. To unset a variable, leave off the equal sign. These assignments are done
      during a very early state of startup, so variables reserved for internal purposes
      might get overwritten again.
      </P
></DD
><DT
>-V, --version</DT
><DD
><P
>      Shows the <TT
CLASS="APPLICATION"
>psql</TT
> version.
      </P
></DD
><DT
>-W, --password</DT
><DD
><P
>      Requests that <TT
CLASS="APPLICATION"
>psql</TT
> should prompt for a password
      before connecting to a database. This will remain set for the entire
      session, even if you change the database connection with the meta-command
      <B
CLASS="COMMAND"
>\connect</B
>.
      </P
><P
>      As of version 7.0, <TT
CLASS="APPLICATION"
>psql</TT
> automatically issues a
      password prompt whenever the backend requests password authentication.
      Because this is currently based on a <SPAN
CLASS="QUOTE"
>"hack"</SPAN
>, the automatic
      recognition might mysteriously fail, hence this option to force a prompt.
      If no password prompt is issued and the backend requires password authentication
      the connection attempt will fail.
      </P
></DD
><DT
>-x, --expanded</DT
><DD
><P
>      Turns on extended row format mode. This is equivalent to the command
      <B
CLASS="COMMAND"
>\x</B
>.
      </P
></DD
><DT
>-?, --help</DT
><DD
><P
>      Shows help about <TT
CLASS="APPLICATION"
>psql</TT
> command line arguments.
      </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-APP-PSQL-4"
></A
><H2
>Advanced features</H2
><DIV
CLASS="REFSECT2"
><A
NAME="APP-PSQL-VARIABLES"
></A
><H3
>Variables</H3
><P
>    <TT
CLASS="APPLICATION"
>psql</TT
> provides variable substitution features
    similar to common Unix command shells. This feature is new and not very
    sophisticated, yet, but there are plans to expand it in the future.
    Variables are simply name/value
    pairs, where the value can be any string of any length. To set variables,
    use the <TT
CLASS="APPLICATION"
>psql</TT
> meta-command <B
CLASS="COMMAND"
>\set</B
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\set foo bar</B
></TT
></PRE
></TD
></TR
></TABLE
>
    sets the variable <SPAN
CLASS="QUOTE"
>"foo"</SPAN
> to the value <SPAN
CLASS="QUOTE"
>"bar"</SPAN
>. To retrieve
    the content of the variable, precede the name with a colon and use it
    as the argument of any slash command:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\echo :foo</B
></TT
>
bar</PRE
></TD
></TR
></TABLE
>
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>    The arguments of <B
CLASS="COMMAND"
>\set</B
> are subject to the same substitution
    rules as with other commands. Thus you can construct interesting references
    such as <TT
CLASS="LITERAL"
>\set :foo 'something'</TT
> and get <SPAN
CLASS="QUOTE"
>"soft
    links"</SPAN
> or <SPAN
CLASS="QUOTE"
>"variable variables"</SPAN
> of <SPAN
CLASS="PRODUCTNAME"
>Perl</SPAN
>
    or <SPAN
CLASS="PRODUCTNAME"
><SPAN
CLASS="ACRONYM"
>PHP</SPAN
></SPAN
> fame, respectively.
    Unfortunately (or fortunately?), there is not way to do anything useful
    with these constructs. On the
    other hand, <TT
CLASS="LITERAL"
>\set bar :foo</TT
> is a perfectly valid way to copy
    a variable.
    </P
></TD
></TR
></TABLE
></DIV
><P
>    If you call <B
CLASS="COMMAND"
>\set</B
> without a second argument, the variable is simply
    set, but has no value. To unset (or delete) a variable, use the command
    <B
CLASS="COMMAND"
>\unset</B
>.
    </P
><P
>    <TT
CLASS="APPLICATION"
>psql</TT
>'s internal variable names can consist of
    letters, numbers, and underscores in any order and any number of them.
    A number of regular variables are treated specially by <TT
CLASS="APPLICATION"
>psql</TT
>.
    They indicate certain option settings that can be changed at runtime
    by altering the value of the variable or represent some state of the application.
    Although you can use these
    variables for any other purpose, this is not recommended, as the
    program behavior might grow really strange really quickly.
    By convention, all specially treated variables consist of all upper-case letters
    (and possibly numbers and underscores). To ensure maximum compatibility in the
    future, avoid such variables. 
    A list of all specially treated variables follows.
    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="ENVAR"
>DBNAME</TT
></DT
><DD
><P
>        The name of the database you are currently connected to. This is set everytime
        you connect to a database (including program startup), but can be unset.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>ECHO</TT
></DT
><DD
><P
>	If set to <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>all</TT
>"</SPAN
>, all lines entered or from a script
        are written to the standard output before they
	are parsed or executed. To specify this on program startup, use the switch
        <TT
CLASS="OPTION"
>-a</TT
>. If set to <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>queries</TT
>"</SPAN
>,
        <TT
CLASS="APPLICATION"
>psql</TT
> merely prints all queries as they are sent to the
        backend. The option for this is <TT
CLASS="OPTION"
>-e</TT
>.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>ECHO_HIDDEN</TT
></DT
><DD
><P
>	When this variable is set and a backslash command queries the database, the query
	is first shown. This way you can study the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
	internals and provide similar functionality in your own programs. If you set the
	variable to the value <SPAN
CLASS="QUOTE"
>"noexec"</SPAN
>, the queries are just shown but are
	not actually sent to the backend and executed.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>ENCODING</TT
></DT
><DD
><P
>        The current client multibyte encoding. If you are not set up to use
        multibyte characters, this variable will always contain
        <SPAN
CLASS="QUOTE"
>"SQL_ASCII"</SPAN
>.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>HISTCONTROL</TT
></DT
><DD
><P
>         If  this variable is set  to  <TT
CLASS="LITERAL"
>ignorespace</TT
>, lines which begin with a
         space are not entered into the history list. If set to a value of
         <TT
CLASS="LITERAL"
>ignoredups</TT
>, lines matching the previous history line are not
         entered. A value of <TT
CLASS="LITERAL"
>ignoreboth</TT
> combines the two
         options.  If unset, or if set to any other value than those above, all lines read
         in interactive mode are saved on the history list.
	</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>        This feature was shamelessly plagiarized from <TT
CLASS="APPLICATION"
>bash</TT
>.
        </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="ENVAR"
>HISTSIZE</TT
></DT
><DD
><P
>        The number of commands to store in the command history.
        The default value is 500.
	</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>        This feature was shamelessly plagiarized from <TT
CLASS="APPLICATION"
>bash</TT
>.
        </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="ENVAR"
>HOST</TT
></DT
><DD
><P
>        The database server host you are currently connected to. This is set everytime
        you connect to a database (including program startup), but can be unset.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>IGNOREEOF</TT
></DT
><DD
><P
>         If unset, sending an EOF character (usually Control-D) to an interactive session of
         <TT
CLASS="APPLICATION"
>psql</TT
> will terminate the application.
         If set to a numeric value, that many EOF characters are ignored before the application
         terminates. If the variable is set but has no numeric value, the default is 10.
	</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>        This feature was shamelessly plagiarized from <TT
CLASS="APPLICATION"
>bash</TT
>.
        </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="ENVAR"
>LASTOID</TT
></DT
><DD
><P
>        The value of the last affected oid, as returned from an <B
CLASS="COMMAND"
>INSERT</B
>
        or <B
CLASS="COMMAND"
>lo_insert</B
> commmand. This variable is only guaranteed to be
        valid until after the result of the next <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> command has been
        displayed.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>LO_TRANSACTION</TT
></DT
><DD
><P
>	If you use the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> large object
        interface to specially store data that does not fit into one tuple,
        all the operations must be contained in a transaction block. (See the
        documentation of the large object interface for more information.) Since
        <TT
CLASS="APPLICATION"
>psql</TT
> has no way to keep track if you already
        have a transaction in progress when you call one of its internal
        commands <B
CLASS="COMMAND"
>\lo_export</B
>, <B
CLASS="COMMAND"
>\lo_import</B
>,
        <B
CLASS="COMMAND"
>\lo_unlink</B
> it must take some arbitrary action. This
        action could either be to roll back any transaction that might already
        be in progress, or to commit any such transaction, or to do nothing at
        all. In the latter case you must provide you own
        <B
CLASS="COMMAND"
>BEGIN TRANSACTION</B
>/<B
CLASS="COMMAND"
>COMMIT</B
> block or
        the results will be unpredictable (usually resulting in the desired
        action not being performed in any case).
	</P
><P
>	To choose what you want to do you set this variable to one of
	<SPAN
CLASS="QUOTE"
>"rollback"</SPAN
>, <SPAN
CLASS="QUOTE"
>"commit"</SPAN
>, or <SPAN
CLASS="QUOTE"
>"nothing"</SPAN
>.
        The default is to roll back the transaction. If you just want to load one
        or a few objects this is fine. However, if you intend to transfer many
        large objects, it might be advisable to provide one explicit transaction
        block around all commands.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>ON_ERROR_STOP</TT
></DT
><DD
><P
>	By default, if non-interactive scripts encounter an error, such as a
	malformed <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> query or internal meta-command,
	processing continues. This is has been the traditional behaviour of
        <TT
CLASS="APPLICATION"
>psql</TT
> but it is sometimes not desirable. If this variable
	is set, script processing will immediately terminate. If the script was
	called from another script it will terminate in the same fashion.
	If the outermost script was not called from an interactive <TT
CLASS="APPLICATION"
>psql</TT
>
	session but rather using the <TT
CLASS="OPTION"
>-f</TT
> option, <TT
CLASS="APPLICATION"
>psql</TT
>
	will return error code 3, to distinguish this case from fatal
	error conditions (error code 1).
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>PORT</TT
></DT
><DD
><P
>        The database server port you are currently connected to. This is set everytime
        you connect to a database (including program startup), but can be unset.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>PROMPT1</TT
>, <TT
CLASS="ENVAR"
>PROMPT2</TT
>, <TT
CLASS="ENVAR"
>PROMPT3</TT
></DT
><DD
><P
>	These specify what the prompt <TT
CLASS="APPLICATION"
>psql</TT
> issues is
	supposed to look like. See
	<SPAN
CLASS="QUOTE"
>"<A
HREF="app-psql.html#APP-PSQL-PROMPTING"
><I
>Prompting</I
></A
>"</SPAN
>
	below.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>QUIET</TT
></DT
><DD
><P
>	This variable is equivalent to the command line option <TT
CLASS="OPTION"
>-q</TT
>.
	It is probably not too useful in interactive mode.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>SINGLELINE</TT
></DT
><DD
><P
>	This variable is set be the command line options <TT
CLASS="OPTION"
>-S</TT
>. You
	can unset or reset it at run time.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>SINGLESTEP</TT
></DT
><DD
><P
>	This variable is equivalent to the command line option <TT
CLASS="OPTION"
>-s</TT
>.
	</P
></DD
><DT
><TT
CLASS="ENVAR"
>USER</TT
></DT
><DD
><P
>        The database user you are currently connected as. This is set everytime
        you connect to a database (including program startup), but can be unset.
	</P
></DD
></DL
></DIV
>

    </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="APP-PSQL-SQL-INTERPOL"
></A
><H3
><SPAN
CLASS="ACRONYM"
>SQL</SPAN
> Interpolation</H3
><P
>    An additional useful feature of <TT
CLASS="APPLICATION"
>psql</TT
> variables
    is that you can substitute (<SPAN
CLASS="QUOTE"
>"interpolate"</SPAN
>) them into
    regular <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> statements. The syntax for this is again to prepend
    the variable name with a colon (<TT
CLASS="LITERAL"
>:</TT
>).
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\set foo 'my_table'</B
></TT
>
testdb=&#62; <TT
CLASS="USERINPUT"
><B
>SELECT * FROM :foo;</B
></TT
></PRE
></TD
></TR
></TABLE
>
    would then query the table <TT
CLASS="LITERAL"
>my_table</TT
>. The value of the
    variable is copied literally, so it can even contain unbalanced quotes or
    backslash commands. You must make sure that it makes sense where you put it.
    Variable interpolation will not be performed into quoted <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>
    entities.
    </P
><P
>    A popular application of this facility is to refer to the last inserted
    <SPAN
CLASS="ACRONYM"
>OID</SPAN
> in subsequent statement to build a foreign key
    scenario.
    Another possible use of this mechanism is to copy the contents of a file
    into a field. First load the file into a variable and then proceed as above.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\set content '\'' `cat my_file.txt` '\''</B
></TT
>
testdb=&#62; <TT
CLASS="USERINPUT"
><B
>INSERT INTO my_table VALUES (:content);</B
></TT
></PRE
></TD
></TR
></TABLE
>
    One possible problem with this approach is that <TT
CLASS="FILENAME"
>my_file.txt</TT
>
    might contain single quotes. These need to be escaped so that
    they don't cause a syntax error when the third line is processed. This
    could be done with the program <TT
CLASS="APPLICATION"
>sed</TT
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\set content `sed -e "s/'/\\\\\\'/g" &#60; my_file.txt`</B
></TT
></PRE
></TD
></TR
></TABLE
>
    Observe the correct number of backslashes (6)! You can resolve it this way: After
    <TT
CLASS="APPLICATION"
>psql</TT
> has parsed this line, it passes
    <TT
CLASS="LITERAL"
>sed -e "s/'/\\\'/g" &#60; my_file.txt</TT
> to the shell. The shell
    will do it's own thing inside the double quotes and execute <TT
CLASS="FILENAME"
>sed</TT
>
    with the arguments <TT
CLASS="LITERAL"
>-e</TT
> and <TT
CLASS="LITERAL"
>s/'/\\'/g</TT
>.
    When <TT
CLASS="APPLICATION"
>sed</TT
> parses this it will replace the two
    backslashes with a single one and then do the substitution. Perhaps at
    one point you thought it was great that all Unix commands use the same
    escape character. And this is ignoring the fact that you might have to
    escape all backslashes as well because <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> text constants
    are also subject to certain interpretations. In that case you might
    be better off preparing the file externally.
    </P
><P
>    Since colons may legally appear in queries, the following rule applies: If the variable
    is not set, the character sequence <SPAN
CLASS="QUOTE"
>"colon+name"</SPAN
> is not changed. In any
    case you can escape a colon with a backslash to protect it from interpretation.
    (The colon syntax for variables is standard <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> for embedded
    query languages, such as <TT
CLASS="APPLICATION"
>ecpg</TT
>. The colon syntax for
    array slices and type casts are <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> extensions,
    hence the conflict.)
    </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="APP-PSQL-PROMPTING"
></A
><H3
>Prompting</H3
><P
>    The prompts <TT
CLASS="APPLICATION"
>psql</TT
> issues can be customized to
    your preference. The three variables <TT
CLASS="ENVAR"
>PROMPT1</TT
>, <TT
CLASS="ENVAR"
>PROMPT2</TT
>,
    and <TT
CLASS="ENVAR"
>PROMPT3</TT
> contain strings and special escape sequences
    that describe the appearance of the prompt. Prompt 1 is the normal prompt
    that is issued when <TT
CLASS="APPLICATION"
>psql</TT
> requests a new query.
    Prompt 2 is issued when more input is expected during query input because
    the query was not terminated with a semicolon or a quote was not closed.
    Prompt 3 is issued when you run an <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> <B
CLASS="COMMAND"
>COPY</B
>
    command and you are expected to type in the tuples on the terminal.
    </P
><P
>    The value of the respective prompt variable is printed literally, except where
    a percent sign (<SPAN
CLASS="QUOTE"
>"%"</SPAN
>) is encountered. Depending on the next
    character, certain other text is substituted instead. Defined substitutions are:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>%M</TT
></DT
><DD
><P
>The hostname of the database server (or <SPAN
CLASS="QUOTE"
>"."</SPAN
>
         if Unix domain socket).</P
></DD
><DT
><TT
CLASS="LITERAL"
>%m</TT
></DT
><DD
><P
>The hostname of the database server truncated after the
         first dot.</P
></DD
><DT
><TT
CLASS="LITERAL"
>%&#62;</TT
></DT
><DD
><P
>The port number at which the database server is listening.</P
></DD
><DT
><TT
CLASS="LITERAL"
>%n</TT
></DT
><DD
><P
>The username you are connected as (not your local system
         user name).</P
></DD
><DT
><TT
CLASS="LITERAL"
>%/</TT
></DT
><DD
><P
>The name of the current database.</P
></DD
><DT
><TT
CLASS="LITERAL"
>%~</TT
></DT
><DD
><P
>Like <TT
CLASS="LITERAL"
>%/</TT
>, but the output is <SPAN
CLASS="QUOTE"
>"~"</SPAN
>
         (tilde) if the database is your default database.</P
></DD
><DT
><TT
CLASS="LITERAL"
>%#</TT
></DT
><DD
><P
>If the current user is a database superuser, then a
         <SPAN
CLASS="QUOTE"
>"#"</SPAN
>, otherwise a <SPAN
CLASS="QUOTE"
>"&#62;"</SPAN
>.</P
></DD
><DT
><TT
CLASS="LITERAL"
>%R</TT
></DT
><DD
><P
>	In prompt 1 normally <SPAN
CLASS="QUOTE"
>"="</SPAN
>, but <SPAN
CLASS="QUOTE"
>"^"</SPAN
> if in single-line
        mode, and <SPAN
CLASS="QUOTE"
>"!"</SPAN
> if the session is disconnected from the database
        (which can happen if <B
CLASS="COMMAND"
>\connect</B
> fails). In prompt 2 the
        sequence is replaced by <SPAN
CLASS="QUOTE"
>"-"</SPAN
>, <SPAN
CLASS="QUOTE"
>"*"</SPAN
>, a single quote,
	or a double quote, depending on whether <TT
CLASS="APPLICATION"
>psql</TT
>
        expects more input because the query wasn't terminated yet, because you are
        inside a <TT
CLASS="LITERAL"
>/* ... */</TT
> comment, or because you are inside
        a quote. In prompt 3 the sequence doesn't resolve to anything.</P
></DD
><DT
><TT
CLASS="LITERAL"
>%</TT
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></DT
><DD
><P
>	If <TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
> starts with
        <TT
CLASS="LITERAL"
>0x</TT
> the rest of the characters are interpreted at a
        hexadecimal digit and the character with the corresponding code is
        subsituted. If the first digit is <TT
CLASS="LITERAL"
>0</TT
> the characters are
        interpreted as on octal number and the corresponding character is
        substituted. Otherwise a decimal number is assumed.</P
></DD
><DT
><TT
CLASS="LITERAL"
>%:</TT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
><TT
CLASS="LITERAL"
>:</TT
></DT
><DD
><P
>	The value of the <TT
CLASS="APPLICATION"
>psql</TT
>, variable <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>. See the section
	<SPAN
CLASS="QUOTE"
>"<A
HREF="app-psql.html#APP-PSQL-VARIABLES"
><I
>Variables</I
></A
>"</SPAN
>
	for details.</P
></DD
><DT
><TT
CLASS="LITERAL"
>%`</TT
><TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
><TT
CLASS="LITERAL"
>`</TT
></DT
><DD
><P
>	The output of <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>, similar to
	ordinary <SPAN
CLASS="QUOTE"
>"back-tick"</SPAN
> substitution.</P
></DD
></DL
></DIV
>

    To insert a percent sign into your prompt, write <TT
CLASS="LITERAL"
>%%</TT
>. The
    default prompts are equivalent to <TT
CLASS="LITERAL"
>'%/%R%# '</TT
> for prompts 1
    and 2, and <TT
CLASS="LITERAL"
>'&#62;&#62; '</TT
> for prompt 3.
    </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>    This feature was shamelessly plagiarized from <TT
CLASS="APPLICATION"
>tcsh</TT
>.
    </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="APP-PSQL-MISC"
></A
><H3
>Miscellaneous</H3
><P
>    <TT
CLASS="APPLICATION"
>psql</TT
> returns 0 to the shell if it finished normally,
    1 if a fatal error of its own (out of memory, file not found) occurs, 2 if the
    connection to the backend went bad and the session is not interactive, and 3 if
    an error occurred in a script and the variable <TT
CLASS="ENVAR"
>ON_ERROR_STOP</TT
> was
    set.
    </P
><P
>    Before starting up in interactive mode, <TT
CLASS="APPLICATION"
>psql</TT
> attempts
    to read and execute commands from the file <TT
CLASS="FILENAME"
>$HOME/.psqlrc</TT
>. It
    could be used to set up the client or the server to taste (using the <B
CLASS="COMMAND"
>\set
    </B
> and <B
CLASS="COMMAND"
>SET</B
> commands).
    </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN13634"
></A
><H3
><SPAN
CLASS="ACRONYM"
>GNU</SPAN
> readline</H3
><P
>    <TT
CLASS="APPLICATION"
>psql</TT
> supports the readline and history libraries for
    convenient line editing and retrieval. The command history is stored in a file
    named <TT
CLASS="FILENAME"
>.psql_history</TT
> in your home directory and is reloaded when
    <TT
CLASS="APPLICATION"
>psql</TT
> starts up.
    Tab-completion is also supported, although
    the completion logic makes no claim to be an <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> parser.
    When available, <TT
CLASS="APPLICATION"
>psql</TT
> is automatically built to use these
    features. If for some reason you do not like the tab completion, you can turn if off
    by putting this in a file named <TT
CLASS="FILENAME"
>.inputrc</TT
> in your
    home directory:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>$if psql
set disable-completion on
$endif</PRE
></TD
></TR
></TABLE
>
    (This is not a <TT
CLASS="APPLICATION"
>psql</TT
> but a <TT
CLASS="APPLICATION"
>readline</TT
>
    feature. Read its documentation for further details.)
    </P
><P
>    If you have the readline library installed but <TT
CLASS="APPLICATION"
>psql</TT
>
    does not seem to use it, you must make sure that <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>'s
    top-level <TT
CLASS="FILENAME"
>configure</TT
> script finds it. <TT
CLASS="FILENAME"
>configure</TT
>
    needs to find both the library <TT
CLASS="FILENAME"
>libreadline.a</TT
>
    (or <TT
CLASS="FILENAME"
>libreadline.so</TT
> on systems with shared libraries)
    <I
CLASS="EMPHASIS"
>and</I
> the header files <TT
CLASS="FILENAME"
>readline.h</TT
> and
    <TT
CLASS="FILENAME"
>history.h</TT
> (or <TT
CLASS="FILENAME"
>readline/readline.h</TT
> and
    <TT
CLASS="FILENAME"
>readline/history.h</TT
>) in appropriate directories. If
    you have the library and header files installed in an obscure place you
    must tell <TT
CLASS="FILENAME"
>configure</TT
> about them, for example:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>$ ./configure --with-includes=/opt/gnu/include --with-libs=/opt/gnu/lib  ...</PRE
></TD
></TR
></TABLE
>
    Then you have to recompile <TT
CLASS="APPLICATION"
>psql</TT
> (not necessarily
    the entire code tree).
    </P
><P
>    The <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> readline library can be obtained from the <SPAN
CLASS="ACRONYM"
>GNU</SPAN
>
    project's <SPAN
CLASS="ACRONYM"
>FTP</SPAN
> server at <A
HREF="ftp://ftp.gnu.org"
TARGET="_top"
>ftp://ftp.gnu.org</A
>.
    </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="APP-PSQL-EXAMPLES"
></A
><H2
>Examples</H2
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>  This section only shows a few examples specific to <TT
CLASS="APPLICATION"
>psql</TT
>.
  If you want to learn <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> or get familiar with
  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, you might wish to read the Tutorial that
  is included in the distribution.
  </P
></TD
></TR
></TABLE
></DIV
><P
>  The first example shows how to spread a query over several lines of input.
  Notice the changing prompt.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>testdb=&#62; <TT
CLASS="USERINPUT"
><B
>CREATE TABLE my_table (</B
></TT
>
testdb-&#62; <TT
CLASS="USERINPUT"
><B
> first integer not null default 0,</B
></TT
>
testdb-&#62; <TT
CLASS="USERINPUT"
><B
> second text</B
></TT
>
testdb-&#62; <TT
CLASS="USERINPUT"
><B
>);</B
></TT
>
CREATE</PRE
></TD
></TR
></TABLE
>
  Now look at the table definition again:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\d my_table</B
></TT
>
             Table "my_table"
 Attribute |  Type   |      Modifier
-----------+---------+--------------------
 first     | integer | not null default 0
 second    | text    |&#13;</PRE
></TD
></TR
></TABLE
>
  At this point you decide to change the prompt to something more
  interesting:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\set PROMPT1 '%n@%m %~%R%# '</B
></TT
>
peter@localhost testdb=&#62;</PRE
></TD
></TR
></TABLE
>
  Let's assume you have filled the table with data and want to take a look at it:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>peter@localhost testdb=&#62; SELECT * FROM my_table;
 first | second
-------+--------
     1 | one
     2 | two
     3 | three
     4 | four
(4 rows)&#13;</PRE
></TD
></TR
></TABLE
>
  Notice how the int4 colums in right aligned while the text column in left aligned.
  You can make this table look differently by using the <B
CLASS="COMMAND"
>\pset</B
>
  command.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\pset border 2</B
></TT
>
Border style is 2.
peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>SELECT * FROM my_table;</B
></TT
>
+-------+--------+
| first | second |
+-------+--------+
|     1 | one    |
|     2 | two    |
|     3 | three  |
|     4 | four   |
+-------+--------+
(4 rows)

peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\pset border 0</B
></TT
>
Border style is 0.
peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>SELECT * FROM my_table;</B
></TT
>
first second
----- ------
    1 one
    2 two
    3 three
    4 four
(4 rows)

peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\pset border 1</B
></TT
>
Border style is 1.
peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\pset format unaligned</B
></TT
>
Output format is unaligned.
peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\pset fieldsep ","</B
></TT
>
Field separator is ",".
peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\pset tuples_only</B
></TT
>
Showing only tuples.
peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>SELECT second, first FROM my_table;</B
></TT
>
one,1
two,2
three,3
four,4</PRE
></TD
></TR
></TABLE
>
  Alternatively, use the short commands:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\a \t \x</B
></TT
>
Output format is aligned.
Tuples only is off.
Expanded display is on.
peter@localhost testdb=&#62; <TT
CLASS="USERINPUT"
><B
>SELECT * FROM my_table;</B
></TT
>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four</PRE
></TD
></TR
></TABLE
>
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN13699"
></A
><H2
>Appendix</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN13703"
></A
><H3
>Bugs and Issues</H3
><P
></P
><UL
><LI
><P
>      In some earlier life <TT
CLASS="APPLICATION"
>psql</TT
> allowed the first
      argument to start directly after the (single-letter) command. For
      compatibility this is still supported to some extent but I am not
      going to explain the details here as this use is discouraged. But
      if you get strange messages, keep this in mind. For example
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>testdb=&#62; <TT
CLASS="USERINPUT"
><B
>\foo</B
></TT
>
Field separator is "oo".</PRE
></TD
></TR
></TABLE
>
      is perhaps not what one would expect.
      </P
></LI
><LI
><P
>      <TT
CLASS="APPLICATION"
>psql</TT
> only works smootly with servers of the
      same version. That does not mean other combinations will fail outright,
      but subtle and not-so-subtle problems might come up.
      </P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="app-pgdumpall.html"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="user.html"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="app-pgtclsh.html"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><TT
CLASS="APPLICATION"
>pg_dumpall</TT
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="applications.html"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><TT
CLASS="APPLICATION"
>pgtclsh</TT
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>