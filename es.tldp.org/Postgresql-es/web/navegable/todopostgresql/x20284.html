<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Procesamiento Asíncrono de Consultas</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="PostgreSQL"
HREF="postgres.html"><LINK
REL="UP"
TITLE="libpq"
HREF="libpq-chapter.html"><LINK
REL="PREVIOUS"
TITLE="Funciones de Ejecución de Consultas"
HREF="x20131.html"><LINK
REL="NEXT"
TITLE="Ruta Rápida"
HREF="x20429.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x20131.html"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>libpq</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x20429.html"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN20284"
>Procesamiento Asíncrono de Consultas</A
></H1
><P
>La función <TT
CLASS="FUNCTION"
>PQexec</TT
> es adecuada para emitir consultas en
aplicaciones síncronas sencillas. Sin embargo, tiene una porción de definciencias
importantes:

<P
></P
><UL
><LI
><P
><TT
CLASS="FUNCTION"
>PQexec</TT
> espera hasta que se completa la consulta. La aplicación
puede tener otro trabajo para hacer (como por ejemplo mantener una interfaz de
usuario), en cuyo caso no se querrá bloquear esperando la respuesta.</P
></LI
><LI
><P
>Una vez que el control se pasa a <TT
CLASS="FUNCTION"
>PQexec</TT
>, la aplicación cliente
tiene muy dificil intentar cancelar la consulta en curso. (Se puede hacer con un
manipulador de señales, pero no de otra forma).</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQexec</TT
> sólo puede devolver una estructura PGresult. Si la
cadena de la consulta emitida contiene múltiples comands <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>, 
se perderán todos excepto el último.</P
></LI
></UL
></P
><P
>Las aplicaciones que no se quieren encontrar con estas limitaciones, pueden utilizar
en su lugar las funciones que subyacen bajo <TT
CLASS="FUNCTION"
>PQexec</TT
>:
<TT
CLASS="FUNCTION"
>PQsendQuery</TT
> y <TT
CLASS="FUNCTION"
>PQgetResult</TT
>.</P
><P
>Para los programas antiguos que utilizaban esta funcionalidad utilizando
<TT
CLASS="FUNCTION"
>PQputline</TT
> y <TT
CLASS="FUNCTION"
>PQputnbytes</TT
>
y esperaban bloqueados el envío de datos del servidor, se añadió la función
<TT
CLASS="FUNCTION"
>PQsetnonblocking</TT
>.</P
><P
>Las aplicaciones antíguas pueden rechazar el uso de 
<TT
CLASS="FUNCTION"
>PQsetnonblocking</TT
>
y mantener el comportamiento anterior
potencialmente bloquante. Los programas más nuevos pueden utilizar
<TT
CLASS="FUNCTION"
>PQsetnonblocking</TT
> para conseguir una conexión con el servidor
completamente no bloqueante.

<P
></P
><UL
><LI
><P
>    <TT
CLASS="FUNCTION"
>PQsetnonblocking</TT
> fija el estado de la conexión a
    no bloqueante.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQsetnonblocking(PGconn *conn)</PRE
></TD
></TR
></TABLE
>
    Esta función asegura que las llamadas a 
    <TT
CLASS="FUNCTION"
>PQputline</TT
>, <TT
CLASS="FUNCTION"
>PQputnbytes</TT
>,
    <TT
CLASS="FUNCTION"
>PQsendQuery</TT
> y <TT
CLASS="FUNCTION"
>PQendcopy</TT
>
    se ejecutarán sin bloquo, devolviendo en su lugar un error si necesitan ser
    llamadas de nuevo.
   </P
><P
>    Cuando una conexión a una base de datos se ha fijado como no bloqueante, y
    se llama a <TT
CLASS="FUNCTION"
>PQexec</TT
>, se cambiará el estado temporalmente
    a bloqueante, hasta que se completa la ejecución de <TT
CLASS="FUNCTION"
>PQexec</TT
>.
   </P
><P
>    Se espera que en el próximo futuro, la mayoría de libp se haga segura para 
    la funcionalida de <TT
CLASS="FUNCTION"
>PQsetnonblocking</TT
>.
  </P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQisnonblocking</TT
>
       Devuelve la situación de bloqueante o no de la conexión a la base de datos.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQisnonblocking(const PGconn *conn)</PRE
></TD
></TR
></TABLE
>
       Devuelve TRUE si la conexión está fijada a modo no bloqueante, y 
       FALSE si está fijada a bloqueante.</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQsendQuery</TT
>
          Envía una consulta a <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> sin
          esperar los resultados. Devuelve TRUE si la consulta se despachó
          correctamente, y FALSE si no fue así (en cuyo caso, utilice 
          PQerrorMessage para obtener más información sobre el fallo).
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQsendQuery(PGconn *conn,
                const char *query);</PRE
></TD
></TR
></TABLE
>
          Tras llamar correctamente a <TT
CLASS="FUNCTION"
>PQsendQuery</TT
>, llame a
          <TT
CLASS="FUNCTION"
>PQgetResult</TT
> una o más veces para obtener el resultado
          de la consulta. No se debe volver a llamar a 
          <TT
CLASS="FUNCTION"
>PQsendQuery</TT
> en la misma conexión hasta que
          <TT
CLASS="FUNCTION"
>PQgetResult</TT
> devuelva NULL, indicando que la consulta
          se ha realizado.</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQgetResult</TT
>
          Espera el siguiente resultado de una ejecución previa de 
          <TT
CLASS="FUNCTION"
>PQsendQuery</TT
>,
y lo devuelve. Se devuelve NULL cuando
          la consulta está completa y ya no habrá más resultados.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PGresult *PQgetResult(PGconn *conn);</PRE
></TD
></TR
></TABLE
>
	  Se debe llamar a <TT
CLASS="FUNCTION"
>PQgetResult</TT
> repetidamente hasta que
          devuelva NULL, indicando que la consulta se ha realizado. (Si se la llama
          cuando no hay ninguna consulta activa, simplemente devolverá NULL desde
          el principio). Cada uno de los resultados no nulos de 
          <TT
CLASS="FUNCTION"
>PQgetResult</TT
> debería procesarse utilizando las mismas
          funciones de acceso a PGresult previamente descritas.
          No olvide liberar cada objeto resultado con <TT
CLASS="FUNCTION"
>PQclear</TT
>
          cuando lo haya hecho. Nótese que <TT
CLASS="FUNCTION"
>PQgetResult</TT
> sólo
          bloqueará si hay una consulta activa y <TT
CLASS="FUNCTION"
>PQconsumeInput</TT
>
          aún no a leido los datos de respuesta necesarios.</P
></LI
></UL
></P
><P
>Utilizando <TT
CLASS="FUNCTION"
>PQsendQuery</TT
> y <TT
CLASS="FUNCTION"
>PQgetResult</TT
>
se resuelve uno de los problemas de <TT
CLASS="FUNCTION"
>PQexec</TT
>:
Si una cadena de consulta contiene múltiples comandos <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>,
los resultados de esos comandos se pueden obtener individualmente. (Esto permite
una forma sencilla de procesamiento paralelo: la aplicación cliente puede estar
manipulando los resultados de una consulta mientras el servidor sigue trabajando
sobre consultas posteriores de la misma cadena de consulta). Sin embargo, 
la llamada a <TT
CLASS="FUNCTION"
>PQgetResult</TT
> seguirá probocando que el cliente quede
bloqueado hasta que el servidor complete el siguiente comando <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>
de la cadena. Esto se puede impedir con el uso adecuado de tres funciones más:

<P
></P
><UL
><LI
><P
><TT
CLASS="FUNCTION"
>PQconsumeInput</TT
>
          Si hay una entrada disponible desde el servidor, la recoge.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQconsumeInput(PGconn *conn);</PRE
></TD
></TR
></TABLE
>
<TT
CLASS="FUNCTION"
>PQconsumeInput</TT
> normalmente devuelve 1 indicando "no hay error",
pero devuelve 0 s hay algún tipo de problema (en cuyo caso se fija
<TT
CLASS="FUNCTION"
>PQerrorMessage</TT
>).  Tengase en cuenta que el resultado no dice
si se ha recogido algún dato de entrada. Tras llamar a 
<TT
CLASS="FUNCTION"
>PQconsumeInput</TT
>, la aplicación deberá revisar
<TT
CLASS="FUNCTION"
>PQisBusy</TT
> y/o <TT
CLASS="FUNCTION"
>PQnotifies</TT
> para ver si sus 
estados han cambiado.</P
><P
><TT
CLASS="FUNCTION"
>PQconsumeInput</TT
> se puede llamar incluso si la aplicación aún no
está preparada para recibir un resultado o una notificación. La rutina leerá los 
datos disponibles y los situará en un almacenamiento intermedio, probocando así una
indicación de preparado para leer a la función <TT
CLASS="FUNCTION"
>select</TT
>(2) para
que continúe. La aplicación puede por ello utilizar 
<TT
CLASS="FUNCTION"
>PQconsumeInput</TT
> para limpiar la condición 
<TT
CLASS="FUNCTION"
>select</TT
> inmediatamente, y examinar después los resultado
tranquilamente.</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQisBusy</TT
>
Devuelve 1 si una consulta está ocupada, es decir, si 
<TT
CLASS="FUNCTION"
>PQgetResult</TT
> se quedaría bloqueada esperando una entrada.
Un 0 indica que se puede llamar a <TT
CLASS="FUNCTION"
>PQgetResult</TT
> con la
seguridad de no bloquear.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQisBusy(PGconn *conn);</PRE
></TD
></TR
></TABLE
>
<TT
CLASS="FUNCTION"
>PQisBusy</TT
> no intentará por sí mismo leer los datos del servidor;
por ello, se debe llamar primero a <TT
CLASS="FUNCTION"
>PQconsumeInput</TT
>, o el estado
ocupado no terminará nunca.</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQflush</TT
> Intenta lanzar cualquier dato encolado al servidor,
y devuelve 0 si lo consigue (o si la cola de envío está vacía) y EOF si ha fallado
por algún motivo.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQflush(PGconn *conn);</PRE
></TD
></TR
></TABLE
>
Es necesario llamar a <TT
CLASS="FUNCTION"
>PQflush</TT
> en una conexión no bloqueante
antes de llamar a <TT
CLASS="FUNCTION"
>select</TT
> para determinar si ha llegado 
una respuesta. Una respuesta de 0 asegura que no hay datos encolados al servidor
que no se hayan enviado todavía. Solo las aplicaciones que han usado 
<TT
CLASS="FUNCTION"
>PQsetnonblocking</TT
> necesitan esto.</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQsocket</TT
>
          Obtiene el número descriptor de fichero para el socket de conexión
          con el servidor. Un descriptor válido sera &#62;= 0; un resultado de
          indica que no hay actualmente ninguna conexión con el servidor abierta.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQsocket(const PGconn *conn);</PRE
></TD
></TR
></TABLE
>
Se debería utilizar <TT
CLASS="FUNCTION"
>PQsocket</TT
> para obtener el descriptor del
socket del servidor para preparar la ejecución de <TT
CLASS="FUNCTION"
>select</TT
>(2).
 Esto permite a una aplicación que utiliza conexión bloqueante esperar las respuestas
u otras condiciones del servidor. Si el resultado de <TT
CLASS="FUNCTION"
>select</TT
>(2)
indica que los datos se pueden leer desde el socket del servidor, debería llamarse a
<TT
CLASS="FUNCTION"
>PQconsumeInput</TT
> para leer los datos; tras ello, se pueden 
utilizar <TT
CLASS="FUNCTION"
>PQisBusy</TT
>, <TT
CLASS="FUNCTION"
>PQgetResult</TT
>,
y/o <TT
CLASS="FUNCTION"
>PQnotifies</TT
> para procesar la respuesta.</P
><P
>Las conexiónes no bloqueantes (que han utilizado 
<TT
CLASS="FUNCTION"
>PQsetnonblocking</TT
>)
no deberían utilizar 
<TT
CLASS="FUNCTION"
>select</TT
> hasta que <TT
CLASS="FUNCTION"
>PQflush</TT
>
haya devuelto 0
indicando que no quedan datos almacenados esperando ser enviados al servidor.</P
></LI
></UL
></P
><P
>Una aplicación cliente típica que utilice estas funciones tendrá un bucle principal
que utiliza <TT
CLASS="FUNCTION"
>select</TT
>(2) para esperar todas las condiciones a las
que debe responder. Una de estas condiciones será la entrada disponible desde el
servidor, lo que en terminos de <TT
CLASS="FUNCTION"
>select</TT
> son datos legibles en 
el descriptor de fichero identificado por <TT
CLASS="FUNCTION"
>PQsocket</TT
>.
Cuando el bucle principal detecta que hay preparada una entrada, debería llamar a
<TT
CLASS="FUNCTION"
>PQconsumeInput</TT
> para leer la entrada. Puede después llamar a 
<TT
CLASS="FUNCTION"
>PQisBusy</TT
>, seguido de <TT
CLASS="FUNCTION"
>PQgetResult</TT
>
si 
<TT
CLASS="FUNCTION"
>PQisBusy</TT
> devuelve falso (0). Puede llamar también a 
<TT
CLASS="FUNCTION"
>PQnotifies</TT
> para detectar mensajes NOTIFY 
(ver "Notificación Asíncrona", más abajo).</P
><P
>Una aplicación cliente que utilice <TT
CLASS="FUNCTION"
>PQsendQuery</TT
>/<TT
CLASS="FUNCTION"
>PQgetResult</TT
>
también puede intentar cancelar una consulta que aún se esté procesando en el 
servidor.</P
><P
><P
></P
><UL
><LI
><P
><TT
CLASS="FUNCTION"
>PQrequestCancel</TT
>
          Requiere de <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> que abandone el 
          procesado de la consulta actual.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQrequestCancel(PGconn *conn);</PRE
></TD
></TR
></TABLE
>
Devuelve un valor 1 si la cancelación se ha despachado correctamente,
y 0 si no (y si no, <TT
CLASS="FUNCTION"
>PQerrorMessage</TT
> dirá porqué).
Que se despache correctamente no garantiza que el requerimiento vaya a tener ningún
efecto, sin embargo. Sin mirar el valor de retorno de <TT
CLASS="FUNCTION"
>PQrequestCancel</TT
>,
la aplicación debe continuar con la secuencia de lectura de resultados normal, 
utilizando <TT
CLASS="FUNCTION"
>PQgetResult</TT
>.  Si la cancelación ha sido efectiva,
la consulta actual terminará rápidamente y devolverá un resultado de error. Si falló
la cancelación (digamos que porque el servidor ya había procesado la consulta), 
no se verá ningún resultado.</P
></LI
></UL
></P
><P
>Nótese que si la consulta forma parte de una transacción, la cancelación abortará la
transacción completa.</P
><P
><TT
CLASS="FUNCTION"
>PQrequestCancel</TT
> se puede invocar de modo seguro desde un 
manipulador de señales. De esta forma, se puede utilizar en conjunción con
<TT
CLASS="FUNCTION"
>PQexec</TT
> plano, si la decisión de cancelar se puede tomar en un
manipulador de señales. Por ejemplo, <TT
CLASS="APPLICATION"
>psql</TT
> invoca a
<TT
CLASS="FUNCTION"
>PQrequestCancel</TT
> desde un manipulador de la señal SIGINT,
permitiendo de este modo la cancelación interactiva de consultas que él gestiona
a través de <TT
CLASS="FUNCTION"
>PQexec</TT
>.
Observese que 
<TT
CLASS="FUNCTION"
>PQrequestCancel</TT
> no tendrá efecto si la conexión no está
abierta en ese momento, o si el servidor no está procesando una consulta.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x20131.html"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="postgres.html"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x20429.html"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Funciones de Ejecución de Consultas</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq-chapter.html"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Ruta Rápida</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>