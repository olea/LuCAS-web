<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><title>
Manual de Allegro: 26 Rutinas de grabación de sonido
</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
<!--
A.xref:link    {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:visited {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:hover   {color: blue; text-decoration: underline; background: rgb(255, 224, 150);}
A.xref:active  {color: red; text-decoration: none; background: rgb(255, 204, 50);}
blockquote.xref {border: medium solid rgb(255, 204, 51); color: black; background: rgb(255, 204, 50);}
blockquote.code {border: medium solid rgb(255, 204, 50); color: black; background: rgb(255, 255, 155);}
blockquote.text {border: medium solid rgb(175, 235, 255); color: black; background: rgb(210, 244, 255);}
-->
</style>
</head><body bgcolor=white text=black link="#0000ee" alink="#ff0000" vlink="#551a8b">
<h1><a name="26 Rutinas de grabación de sonido">26 Rutinas de grabación de sonido</a></h1>

<ul>
<li><a href="#digi_recorder">digi_recorder</a>
<li><a href="#get_sound_input_cap_bits">get_sound_input_cap_bits</a>
<li><a href="#get_sound_input_cap_parm">get_sound_input_cap_parm</a>
<li><a href="#get_sound_input_cap_rate">get_sound_input_cap_rate</a>
<li><a href="#get_sound_input_cap_stereo">get_sound_input_cap_stereo</a>
<li><a href="#install_sound_input">install_sound_input</a>
<li><a href="#midi_recorder">midi_recorder</a>
<li><a href="#read_sound_input">read_sound_input</a>
<li><a href="#remove_sound_input">remove_sound_input</a>
<li><a href="#set_sound_input_source">set_sound_input_source</a>
<li><a href="#start_sound_input">start_sound_input</a>
<li><a href="#stop_sound_input">stop_sound_input</a>
</ul>

<p><br>
<b>int <a name="install_sound_input">install_sound_input</a>(int digi_card, int midi_card);</b><br>
   Inicializa el módulo de grabación de sonido, devolviendo cero si no hubo
   problemas. Debe instalar el sistema normal de reproducción de sonido
   antes de llamar esta rutina. Los dos parámetros de tarjetas deben ser los
   mismos que en install_sound(), incluyendo DIGI_NONE y MIDI_NONE para
   desactivar partes del módulo, o DIGI_AUTODETECT y MIDI_AUTODETECT para
   adivinar el hardware.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="alleg033.html#DIGI_*/DOS">DIGI_*/DOS</a>,
<a class="xref" href="alleg034.html#DIGI_*/Windows">DIGI_*/Windows</a>,
<a class="xref" href="alleg035.html#DIGI_*/Unix">DIGI_*/Unix</a>,
<a class="xref" href="alleg036.html#DIGI_*/BeOS">DIGI_*/BeOS</a>,
<a class="xref" href="alleg037.html#DIGI_*/QNX">DIGI_*/QNX</a>,
<a class="xref" href="alleg022.html#install_sound">install_sound</a>,
<a class="xref" href="#start_sound_input">start_sound_input</a>,
<a class="xref" href="#midi_recorder">midi_recorder</a>,
<a class="xref" href="alleg033.html#MIDI_*/DOS">MIDI_*/DOS</a>,
<a class="xref" href="alleg034.html#MIDI_*/Windows">MIDI_*/Windows</a>,
<a class="xref" href="alleg035.html#MIDI_*/Unix">MIDI_*/Unix</a>,
<a class="xref" href="alleg036.html#MIDI_*/BeOS">MIDI_*/BeOS</a>,
<a class="xref" href="alleg037.html#MIDI_*/QNX">MIDI_*/QNX</a>,
<a class="xref" href="alleg002.html#Variables de configuración estándar">Variables de configuración estándar</a>.</font></blockquote>
<b>void <a name="remove_sound_input">remove_sound_input</a>();</b><br>
   Desactiva el módulo cuando haya acabado de usarlo. Normalmente no debe
   llamar esta función, porque remove_sound() y/o allegro_exit() lo harán
   por usted.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#install_sound_input">install_sound_input</a>,
<a class="xref" href="alleg022.html#remove_sound">remove_sound</a>,
<a class="xref" href="alleg000.html#allegro_exit">allegro_exit</a>.</font></blockquote>
<b>int <a name="get_sound_input_cap_bits">get_sound_input_cap_bits</a>();</b><br>
   Comprueba qué formatos de sonido son soportados por el controlador de
   entrada de audio, devolviendo uno de los valores del campo de bits:
<blockquote class="text"><pre>
      0 = entrada de audio no soportada
      8 = entrada de audio de ocho bits soportada
      16 = entrada de audio de dieciséis bits soportada
      24 = entrada de audio de ocho y dieciséis bits soportada
</pre></blockquote>

<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_sound_input_cap_stereo">get_sound_input_cap_stereo</a>,
<a class="xref" href="#start_sound_input">start_sound_input</a>,
<a class="xref" href="#get_sound_input_cap_parm">get_sound_input_cap_parm</a>,
<a class="xref" href="#get_sound_input_cap_rate">get_sound_input_cap_rate</a>.</font></blockquote>
<b>int <a name="get_sound_input_cap_stereo">get_sound_input_cap_stereo</a>();</b><br>
   Comprueba si el controlador de entrada de audio actual es capaz de grabar
   en estéreo.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_sound_input_cap_rate">get_sound_input_cap_rate</a>,
<a class="xref" href="#start_sound_input">start_sound_input</a>,
<a class="xref" href="#get_sound_input_cap_parm">get_sound_input_cap_parm</a>,
<a class="xref" href="#get_sound_input_cap_bits">get_sound_input_cap_bits</a>.</font></blockquote>
<b>int <a name="get_sound_input_cap_rate">get_sound_input_cap_rate</a>(int bits, int stereo);</b><br>
   Devuelve la frecuencia de grabación de samples máxima posible en el
   formato especificado, o cero si los ajustes no son soportados.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_sound_input_cap_stereo">get_sound_input_cap_stereo</a>,
<a class="xref" href="#start_sound_input">start_sound_input</a>,
<a class="xref" href="#get_sound_input_cap_parm">get_sound_input_cap_parm</a>,
<a class="xref" href="#get_sound_input_cap_bits">get_sound_input_cap_bits</a>.</font></blockquote>
<b>int <a name="get_sound_input_cap_parm">get_sound_input_cap_parm</a>(int rate, int bits, int stereo);</b><br>
   Comprueba si la frecuencia de grabación especificada, número de bits y
   mono/estéreo es soportado por el controlador de audio actual, devolviendo
   uno de los siguientes valores:
<blockquote class="text"><pre>
      0 = es imposible grabar en este formato
      1 = grabar es posible, pero la salida de audio será suspendida
      2 = es posible grabar y reproducir sonidos a la vez
      -n = razón de muestreo no soportada, pero la razón 'n' puede funcionar
</pre></blockquote>

<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_sound_input_cap_stereo">get_sound_input_cap_stereo</a>,
<a class="xref" href="#start_sound_input">start_sound_input</a>,
<a class="xref" href="#get_sound_input_cap_bits">get_sound_input_cap_bits</a>,
<a class="xref" href="#get_sound_input_cap_rate">get_sound_input_cap_rate</a>.</font></blockquote>
<b>int <a name="set_sound_input_source">set_sound_input_source</a>(int source);</b><br>
   Selecciona la fuente de la entrada de audio, devolviendo cero si no hubo
   problemas o -1 si el hardware no proporciona un registro de selección de
   entrada. El parámetro debe ser uno de los valores:
<blockquote class="text"><pre>
      SOUND_INPUT_MIC
      SOUND_INPUT_LINE
      SOUND_INPUT_CD
</pre></blockquote>

<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#start_sound_input">start_sound_input</a>.</font></blockquote>
<b>int <a name="start_sound_input">start_sound_input</a>(int rate, int bits, int stereo);</b><br>
   Comienza a grabar en el formato especificado, suspendiendo la
   reproducción de sonidos si es necesario (esto sucederá siempre con los
   controladores actuales). Devuelve el tamaño del buffer en bytes si hubo
   éxito, o cero si hubo algún error.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#digi_recorder">digi_recorder</a>,
<a class="xref" href="#set_sound_input_source">set_sound_input_source</a>,
<a class="xref" href="#get_sound_input_cap_parm">get_sound_input_cap_parm</a>,
<a class="xref" href="#get_sound_input_cap_bits">get_sound_input_cap_bits</a>,
<a class="xref" href="#get_sound_input_cap_rate">get_sound_input_cap_rate</a>,
<a class="xref" href="#get_sound_input_cap_stereo">get_sound_input_cap_stereo</a>,
<a class="xref" href="#install_sound_input">install_sound_input</a>,
<a class="xref" href="#read_sound_input">read_sound_input</a>,
<a class="xref" href="#stop_sound_input">stop_sound_input</a>.</font></blockquote>
<b>void <a name="stop_sound_input">stop_sound_input</a>();</b><br>
   Para la grabación, ajustando la tarjeta de vuelta al modo normal de
   reproducción.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#start_sound_input">start_sound_input</a>.</font></blockquote>
<b>int <a name="read_sound_input">read_sound_input</a>(void *buffer);</b><br>
   Recupera el buffer de audio grabado más reciente en el lugar
   especificado, devolviendo no-cero si el buffer ha sido copiado, o cero si
   todavía no hay nuevos datos disponibles. El tamaño del buffer puede ser
   obtenido comprobando el valor de retorno de start_sound_input(). Debe
   llamar esta función a intervalos regulares durante la grabación
   (típicamente unas 100 veces por segundo), o podría perder datos. Si no
   puede hacer esto lo suficientemente rápido, use la función callback
   digi_recorder() para almacenar la onda de sonido en un buffer más grande
   que haya creado antes. Nota: muchas tarjetas de sonido reproducen un
   click o sonido raro cuando alternan entre los modos de grabación y
   reproducción, por lo que es buena idea descartar el primer buffer después
   de comenzar la grabación. La onda siempre se almacena en formato sin
   signo, con los datos estéreo siendo samples alternados izquierda/derecha.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#start_sound_input">start_sound_input</a>.</font></blockquote>
<b>extern void (*<a name="digi_recorder">digi_recorder</a>)();</b><br>
   Si está activada, esta función es llamada por el controlador de entrada
   de sonido siempre que un nuevo buffer de sonido está disponible, momento
   en el que puede usar read_sound_input() para copiar los datos a un lugar
   permanente. Esta rutina se ejecuta en contexto de interrupción, por lo
   que debe ejecutarse muy rápidamente, el código y la memoria que modifica
   debe estar bloqueada (locked), y no puede llamar desde ella rutinas de
   sistema o acceder a ficheros del disco.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#install_sound_input">install_sound_input</a>,
<a class="xref" href="#start_sound_input">start_sound_input</a>.</font></blockquote>
<b>extern void (*<a name="midi_recorder">midi_recorder</a>)(unsigned char data);</b><br>
   Si está activada, esta función es llamada por el controlador de entrada
   MIDI siempre que un nuevo byte de datos MIDI esté disponible. Se ejecuta
   en contexto de interrupción, por lo que debe ser muy rápida y su
   código/datos deben estar bloqueados (locked).




<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#install_sound_input">install_sound_input</a>,
<a class="xref" href="alleg024.html#midi_out">midi_out</a>.</font></blockquote>
<hr><a href="allegro.html">Volver al Indice</a>

</body>
</html>
