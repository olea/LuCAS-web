<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><title>
Manual de Allegro: 28 Rutinas de ficheros de datos
</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
<!--
A.xref:link    {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:visited {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:hover   {color: blue; text-decoration: underline; background: rgb(255, 224, 150);}
A.xref:active  {color: red; text-decoration: none; background: rgb(255, 204, 50);}
blockquote.xref {border: medium solid rgb(255, 204, 51); color: black; background: rgb(255, 204, 50);}
blockquote.code {border: medium solid rgb(255, 204, 50); color: black; background: rgb(255, 255, 155);}
blockquote.text {border: medium solid rgb(175, 235, 255); color: black; background: rgb(210, 244, 255);}
-->
</style>
</head><body bgcolor=white text=black link="#0000ee" alink="#ff0000" vlink="#551a8b">
<h1><a name="28 Rutinas de ficheros de datos">28 Rutinas de ficheros de datos</a></h1>

<ul>
<li><a href="#find_datafile_object">find_datafile_object</a>
<li><a href="#fixup_datafile">fixup_datafile</a>
<li><a href="#get_datafile_property">get_datafile_property</a>
<li><a href="#load_datafile">load_datafile</a>
<li><a href="#load_datafile_callback">load_datafile_callback</a>
<li><a href="#load_datafile_object">load_datafile_object</a>
<li><a href="#register_datafile_object">register_datafile_object</a>
<li><a href="#unload_datafile">unload_datafile</a>
<li><a href="#unload_datafile_object">unload_datafile_object</a>
</ul>

<p>
Los ficheros de datos son creados por la utilidad grabber, y tienen la
extensión .dat. Pueden contener bitmaps, paletas de color, fuentes, sonidos,
música MIDI, animaciones FLI/FLC y cualquier otro tipo binario de datos que
importe.

<p>
Atención: cuando use imágenes truecolor, debería activar el modo gráfico
antes de cargar ningún bitmap! Si no, el formato (RGB o BGR) será
desconocido, y el fichero probablemente será convertido erróneamente.

<p>
Mire la documentación en pack_fopen() para obtener información sobre como
leer directamente de un fichero de datos.

<p><br>
<b>DATAFILE *<a name="load_datafile">load_datafile</a>(const char *filename);</b><br>
   Carga un fichero de datos en memora, devolviendo un puntero hacia él, o
   NULL si ha habido un error. Si el fichero de datos ha sido encriptado,
   primero tiene que usar la función packfile_password() para introducir la
   clave correcta. Mire grabber.txt para mas información. Si el fichero de
   datos contiene gráficos truecolor, debe entrar en modo gráfico o llamar
   set_color_conversion() antes de cargarlo.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#find_datafile_object">find_datafile_object</a>,
<a class="xref" href="#register_datafile_object">register_datafile_object</a>,
<a class="xref" href="#load_datafile_callback">load_datafile_callback</a>,
<a class="xref" href="#unload_datafile">unload_datafile</a>,
<a class="xref" href="#load_datafile_object">load_datafile_object</a>,
<a class="xref" href="alleg009.html#set_color_conversion">set_color_conversion</a>,
<a class="xref" href="#fixup_datafile">fixup_datafile</a>,
<a class="xref" href="alleg027.html#packfile_password">packfile_password</a>.</font></blockquote>
<b>DATAFILE *<a name="load_datafile_callback">load_datafile_callback</a>(const char *filename,</b>
<b>                                 void (*callback)(DATAFILE *d));</b><br>
   Carga el datafile en memoria, llamando a la función de enganche (hook)
   especificada una vez por cada objeto en el fichero, pasándole un puntero
   al objeto leído recientemente.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#find_datafile_object">find_datafile_object</a>,
<a class="xref" href="#register_datafile_object">register_datafile_object</a>,
<a class="xref" href="#load_datafile">load_datafile</a>,
<a class="xref" href="#unload_datafile">unload_datafile</a>,
<a class="xref" href="#load_datafile_object">load_datafile_object</a>,
<a class="xref" href="alleg009.html#set_color_conversion">set_color_conversion</a>,
<a class="xref" href="#fixup_datafile">fixup_datafile</a>,
<a class="xref" href="alleg027.html#packfile_password">packfile_password</a>.</font></blockquote>
<b>void <a name="unload_datafile">unload_datafile</a>(DATAFILE *dat);</b><br>
   Libera todos los objetos de un fichero de datos.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#load_datafile">load_datafile</a>.</font></blockquote>
<b>DATAFILE *<a name="load_datafile_object">load_datafile_object</a>(const char *filename,</b>
<b>            const char *objectname);</b><br>
   Carga un objeto específico de un fichero dat. Esto no funcionará si
   elimina los nombres de los objetos del fichero, y será muy lento si salva
   el fichero de datos con compresión general. Mire grabber.txt para más
   información.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#register_datafile_object">register_datafile_object</a>,
<a class="xref" href="#unload_datafile_object">unload_datafile_object</a>,
<a class="xref" href="#load_datafile">load_datafile</a>,
<a class="xref" href="alleg009.html#set_color_conversion">set_color_conversion</a>.</font></blockquote>
<b>void <a name="unload_datafile_object">unload_datafile_object</a>(DATAFILE *dat);</b><br>
   Libera un objeto previamente cargado con load_datafile_object().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#load_datafile_object">load_datafile_object</a>.</font></blockquote>
<b>DATAFILE *<a name="find_datafile_object">find_datafile_object</a>(DATAFILE *dat, const char *objectname);</b><br>
   Busca en un fichero de datos que esté cargado un objeto con el nombre
   especificado, devolviendo un puntero a él, o NULL si el objeto no fue
   encontrado. Entiende '/' y '#' como separadores para paths de ficheros de
   datos anidados.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#load_datafile">load_datafile</a>,
<a class="xref" href="#load_datafile_object">load_datafile_object</a>.</font></blockquote>
<b>char *<a name="get_datafile_property">get_datafile_property</a>(DATAFILE *dat, int type);</b><br>
   Retorna la propiedad especifica de un objeto, o una cadena vacía si la
   propiedad no esta presente. Mire grabber.txt para mas información.

<p><br>
<b>void <a name="register_datafile_object">register_datafile_object</a>(int id, void *(*load)(PACKFILE *f, long size),</b>
<b>                                      void (*destroy)(void *data));</b><br>
   Usado para añadir tipos de objetos propios, especificando las funciones
   de carga y destrucción de este tipo. Mire grabber.txt para mas
   información.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#load_datafile">load_datafile</a>,
<a class="xref" href="#load_datafile_object">load_datafile_object</a>.</font></blockquote>
<b>void <a name="fixup_datafile">fixup_datafile</a>(DATAFILE *data);</b><br>
   Si está usando ficheros de datos compilados (producidos por la utilidad
   dat2s) que contienen imágenes truecolor, tiene que llamar esta función
   una vez haya puesto el modo de vídeo que vaya a usar, para convertir
   los valores de los colores al formato apropiado. Puede intercambiar los
   formatos RGB y BGR, y convertirlos a diferentes profundidades de color
   siempre que sea posible sin cambiar el tamaño de la imagen (por ejemplo:
   cambiando entre 15 y 16 bits de color para bitmaps y sprites RLE, y entre
   24 y 32 bits de color para sprites RLE).


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="alleg007.html#set_gfx_mode">set_gfx_mode</a>,
<a class="xref" href="alleg009.html#set_color_conversion">set_color_conversion</a>.</font></blockquote>
<br><center><h2><a name="Usando ficheros de datos">Usando ficheros de datos</a></h2></center><p>
Cuando cargue un fichero de datos, obtendrá un puntero a un array de
estructuras DATAFILE:
<blockquote class="code"><pre>
   typedef struct DATAFILE
   {
      void *dat;     - puntero a los datos
      int type;      - tipo del dato
      long size;     - tamaño de los datos en bytes
      void *prop;    - propiedades de los objetos
   } DATAFILE;
</pre></blockquote>
El campo type puede tener uno de los siguientes valores:
<blockquote class="text"><pre>
   DAT_FILE       - dat apunta a un fichero de datos anidado
   DAT_DATA       - dat apunta a un bloque ordinario de datos
   DAT_FONT       - dat apunta a una fuente
   DAT_SAMPLE     - dat apunta a un fichero de sonido
   DAT_MIDI       - dat apunta a un fichero MIDI
   DAT_PATCH      - dat apunta a un 'patch' para la GUS
   DAT_FLI        - dat apunta a una animación FLI/FLC
   DAT_BITMAP     - dat apunta a una estructura BITMAP
   DAT_RLE_SPRITE - dat apunta a una estructura RLE_SPRITE
   DAT_C_SPRITE   - dat apunta a un sprite compilado linearmente
   DAT_XC_SPRITE  - dat apunta a un sprite de modo-X
   DAT_PALETTE    - dat apunta a un array de 256 estructuras RGB
   DAT_END        - bit especial que marca el final de una lista de datos
</pre></blockquote>
El programa grabber también puede producir un fichero de cabecera que define
el índice de los objetos dentro de un fichero de datos como una serie de
constantes definidas, usando los nombres que les dio en el grabber. Por
ejemplo, si creó un fichero de datos llamado foo.dat que contiene el bitmap
llamado LA_IMAGEN, puede enseñarlo con el siguiente fragmento de código:
<blockquote class="code"><pre>
   #include "foo.h"

   DATAFILE *data = load_datafile("foo.dat");
   draw_sprite(screen, data[LA_IMAGEN].dat, x, y);
</pre></blockquote>
Si está programando en C++. obtendrá un error porque el campo dat es un
puntero void y draw_sprite espera un puntero BITMAP. Puede solucionarlo con
una conversión de puntero. Ejemplo:
<blockquote class="code"><pre>
   draw_sprite(screen, (BITMAP *)data[LA_IMAGEN].dat, x, y);
</pre></blockquote>
Cuando carge un sólo objeto de un fichero de datos, obtendrá un puntero a
una estructura DATAFILE única. Esto significa que no puede acceder a él como
un array, y no contiene el objeto DAT_END. Ejemplo:
<blockquote class="code"><pre>
   objeto_musica = load_datafile_object("datos.dat", "MUSICA");
   play_midi(objeto_musica-&gt;;dat);
</pre></blockquote>



<p><br>
<hr><a href="allegro.html">Volver al Indice</a>

</body>
</html>
