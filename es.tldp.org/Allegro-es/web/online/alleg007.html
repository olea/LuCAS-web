<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><title>
Manual de Allegro: 07 Modos gráficos
</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
<!--
A.xref:link    {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:visited {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:hover   {color: blue; text-decoration: underline; background: rgb(255, 224, 150);}
A.xref:active  {color: red; text-decoration: none; background: rgb(255, 204, 50);}
blockquote.xref {border: medium solid rgb(255, 204, 51); color: black; background: rgb(255, 204, 50);}
blockquote.code {border: medium solid rgb(255, 204, 50); color: black; background: rgb(255, 255, 155);}
blockquote.text {border: medium solid rgb(175, 235, 255); color: black; background: rgb(210, 244, 255);}
-->
</style>
</head><body bgcolor=white text=black link="#0000ee" alink="#ff0000" vlink="#551a8b">
<h1><a name="07 Modos gráficos">07 Modos gráficos</a></h1>

<ul>
<li><a href="#destroy_gfx_mode_list">destroy_gfx_mode_list</a>
<li><a href="#enable_triple_buffer">enable_triple_buffer</a>
<li><a href="#get_display_switch_mode">get_display_switch_mode</a>
<li><a href="#get_gfx_mode_list">get_gfx_mode_list</a>
<li><a href="#get_refresh_rate">get_refresh_rate</a>
<li><a href="#gfx_capabilities">gfx_capabilities</a>
<li><a href="#poll_scroll">poll_scroll</a>
<li><a href="#remove_display_switch_callback">remove_display_switch_callback</a>
<li><a href="#request_refresh_rate">request_refresh_rate</a>
<li><a href="#request_scroll">request_scroll</a>
<li><a href="#request_video_bitmap">request_video_bitmap</a>
<li><a href="#scroll_screen">scroll_screen</a>
<li><a href="#set_color_depth">set_color_depth</a>
<li><a href="#set_display_switch_callback">set_display_switch_callback</a>
<li><a href="#set_display_switch_mode">set_display_switch_mode</a>
<li><a href="#set_gfx_mode">set_gfx_mode</a>
<li><a href="#show_video_bitmap">show_video_bitmap</a>
</ul>

<p><br>
<b>void <a name="set_color_depth">set_color_depth</a>(int depth);</b><br>
   Especifica el formato gráfico que será usado en las siguientes llamadas a
   set_gfx_mode() y create_bitmap(). Las profundidades válidas son 8 (por
   defecto), 15, 16, 24 y 32 bits.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_gfx_mode">set_gfx_mode</a>,
<a class="xref" href="alleg009.html#set_color_conversion">set_color_conversion</a>,
<a class="xref" href="alleg011.html#makecol">makecol</a>,
<a class="xref" href="alleg011.html#getr">getr</a>.</font></blockquote>
<b>void <a name="request_refresh_rate">request_refresh_rate</a>(int rate);</b><br>
   Solicita que en la siguiente llamada a set_gfx_mode() se intente usar la
   velocidad de refresco especificada, si es posible. No todos los
   controladores son capaces de esto, e incluso cuando pueden, no todas las
   velocidades serán posibles en cualquier hardware, por lo que el resultado
   puede diferir de lo que haya pedido. Tras la llamada a set_gfx_mode(),
   puede usar get_refresh_rate() para saber qué velocidad de refresco fue
   seleccionada. Por el momento, sólo el driver DOS VESA 3.0, X DGA 2.0 y
   algunos drivers de DirectX soportan esta función. La velocidad es
   especificada en Hz, ej: 60, 70. Para volver a la velocidad por defecto,
   pase el valor cero.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_gfx_mode">set_gfx_mode</a>,
<a class="xref" href="#get_refresh_rate">get_refresh_rate</a>.</font></blockquote>
<b>int <a name="get_refresh_rate">get_refresh_rate</a>(void);</b><br>
   Devuelve la velocidad de refresco actual, si es conocida (no todos los
   controladores pueden devolver esta información). Devuelve cero si la
   velocidad de refresco actual es desconocida.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#request_refresh_rate">request_refresh_rate</a>.</font></blockquote>
<b>GFX_MODE_LIST *<a name="get_gfx_mode_list">get_gfx_mode_list</a>(int card);</b><br>
   Intenta crear una lista de todos los modos de vídeo soportados por un
   driver gráfico GFX determinado. Esta función devuelve un puntero a una
   lista de estructuras del tipo GFX_MODE_LIST que estan definidas como:
<blockquote class="code"><pre>
      typedef struct GFX_MODE_LIST {
         int num_modes;
         GFX_MODE *mode;
      } GFX_MODE_LIST;
</pre></blockquote>
   Si esta función devuelve NULL, significa que la llamada no tuvo éxito. El
   puntero mode apunta a la verdadera lista de modos de vídeo.
<blockquote class="code"><pre>
      typedef struct GFX_MODE {
         int width, height, bpp;
      } GFX_MODE;
</pre></blockquote>
   Esta lista termina con un elemento { 0, 0, 0 }.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#destroy_gfx_mode_list">destroy_gfx_mode_list</a>,
<a class="xref" href="#set_gfx_mode">set_gfx_mode</a>,
<a class="xref" href="#set_color_depth">set_color_depth</a>.</font></blockquote>
<b>void <a name="destroy_gfx_mode_list">destroy_gfx_mode_list</a>(GFX_MODE_LIST *mode_list);</b><br>
   Borra de la memoria la lista de modos creada por get_gfx_mode_list().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_gfx_mode_list">get_gfx_mode_list</a>,
<a class="xref" href="#set_gfx_mode">set_gfx_mode</a>,
<a class="xref" href="#set_color_depth">set_color_depth</a>.</font></blockquote>
<b>int <a name="set_gfx_mode">set_gfx_mode</a>(int card, int w, int h, int v_w, int v_h);</b><br>
   Cambia a modo gráfico. El parámetro card normalmente debería ser
   GFX_AUTODETECT, GFX_AUTODETECT_FULLSCREEN o GFX_AUTODETECT_WINDOWED, o
   puede mirar la documentación específica de su plataforma para tener una
   lista los drivers disponibles. Los parámetros w y h especifican que
   resolución de pantalla quiere.

<p>
   Los parámetros v_w y v_h especifican el tamaño mínimo de la pantalla
   virtual, en caso de que necesite una pantalla virtual grande para hacer
   scroll por hardware o intercambio de páginas. Debería ponerlos a cero si
   no le importa la pantalla virtual. Las pantallas virtuales crean mucha
   confusión, pero en realidad son muy simples. Aviso: ahora viene una
   explicación condescendiente, por lo que quizás quiera saltarse el resto
   del párrafo :-) Imagínese la memoria de vídeo como una pieza rectangular
   de papel que es vista a través de un pequeño agujero (su monitor) hecho
   sobre cartón. Ya que el papel es más grande que el agujero, sólo puede
   ver una parte de él cada vez, pero moviendo el cartón puede alterar qué
   porción está visualizando. Puede dejar el agujero en una posición e
   ignorar el resto de la memoria de vídeo no visible, pero puede conseguir
   una gran variedad de útiles efectos desplazando la ventana de
   visualización, o dibujando en una parte de la memoria de vídeo no
   visible, y entonces intercambiar páginas para visualizar la nueva
   pantalla.

<p>
   Por ejemplo, puede seleccionar el modo 640x480 en el cual el monitor
   actúa como una ventana sobre la pantalla virtual de 1024x1024, y
   entonces mover la pantalla visible dentro del área grande. Inicialmente,
   la parte visible está posicionada en la parte superior izquierda de la
   memoria de vídeo. Esta configuración sería así:
<blockquote class="text"><pre>
      (0,0)------------(640,0)----(1024,0)
      |                  |           |
      | pantalla visible |           |
      |                  |           |
      (0,480)----------(640,480)     |
      |                              |
      | resto de la memoria de vídeo |
      |                              |
      (0,1024)--------------------(1024,1024)
</pre></blockquote>
   ¿Qué es eso? ¿Está viendo esto con una fuente proporcional? Jejeje.

<p>
   Cuando llama set_gfx_mode(), los parámetros v_w y v_h representan el
   tamaño mínimo de la pantalla virtual que es aceptable para su programa.
   El rango de tamaños posibles es normalmente muy restringido, y es posible
   que Allegro acabe creando una pantalla virtual más grande que la que
   solicitó. En una SVGA con una mega de vram cuente con conseguir una
   pantalla virtual de 1024x1024 (256 colores) o 1024x512 (15 o 16 bpp), y
   con 512k de ram puede conseguir 1024x512 (256 colores). Otros tamaños
   pueden ser y no ser posibles: no asuma que vayan a funcionar. En modo-X
   la anchura virtual puede ser cualquier múltiplo de 8 mayor o igual a la
   anchura de la pantalla, y la altura virtual se ajustará de la misma forma
   (la VGA tiene 256k de vram, por lo que la altura virtual será
   256*1024/virtual_width).

<p>
   Después de seleccionar el modo gráfico, los tamaños físicos y virtuales de
   la pantalla pueden obtenerse mediante las macros SCREEN_W, SCREEN_H,
   VIRTUAL_W, y VIRTUAL_H.

<p>
   Si Allegro no es capaz de seleccionar un modo apropiado, set_gfx_mode()
   devuelve un modo negativo y almacena la descripción del problema en
   allegro_error. De otro modo devuelve cero.

<p>
   Como caso especial, si usa el código de driver mágico GFX_SAFE, Allegro
   garantizará que el modo siempre será establecido correctamente. Intentará
   seleccionar la resolución que pidió, y si falla, usará aquella resolución
   que sea fiable en la plataforma actual (esto es modo VGA a 320x200 bajo
   DOS, una resolución de 640x480 bajo Windows, la resolución actual del
   framebuffer bajo Linux si está soportada, etc). Si no puede establecer
   ningún modo gráfico de ninguna manera, devolverá un valor negativo
   indicando que debería abortar inmediatamente su programa, posiblemente
   tras informar al usuario de este hecho mediante allegro_message. Este
   driver falso es útil para situaciones en las que quiere establecer un modo
   gráfico que funcione, y no puede perder el tiempo probando diferentes
   resoluciones y haciendo la comprobación de errores. Tenga en cuenta, que
   tras una llamada con éxito a set_gfx_mode con este driver, no puede hacer
   ninguna asunción sobre el ancho o alto de la pantalla o su profundidad de
   color: su código deberá tratar con este pequeño detalle.

<p>
   Finalmente, GFX_TEXT es otro driver mágico que normalmente cierra
   cualquier modo gráfico abierto anteriormente, impidiendo que pueda usar
   la variable global screen, y en aquellos entornos que tienen modos de
   texto, vuelve a ajustar aquél más parecido al activo antes de Allegro
   (normalmente 80x25). Con este driver los parámetros de tamaño de
   set_gfx_mode no significan nada en absoluto, así que puede dejarlos a cero
   o cualquier otro número que prefiera.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="alleg000.html#allegro_error">allegro_error</a>,
<a class="xref" href="alleg002.html#Variables de configuración estándar">Variables de configuración estándar</a>,
<a class="xref" href="alleg033.html#GFX_*/DOS">GFX_*/DOS</a>,
<a class="xref" href="alleg034.html#GFX_*/Windows">GFX_*/Windows</a>,
<a class="xref" href="alleg035.html#GFX_*/X">GFX_*/X</a>,
<a class="xref" href="alleg035.html#GFX_*/Linux">GFX_*/Linux</a>,
<a class="xref" href="alleg036.html#GFX_*/BeOS">GFX_*/BeOS</a>,
<a class="xref" href="#set_color_depth">set_color_depth</a>,
<a class="xref" href="#request_refresh_rate">request_refresh_rate</a>,
<a class="xref" href="alleg008.html#screen">screen</a>,
<a class="xref" href="#gfx_capabilities">gfx_capabilities</a>.</font></blockquote>
<b>int <a name="set_display_switch_mode">set_display_switch_mode</a>(int mode);</b><br>
   Establece de qué forma el programa debe manejar el hecho de ser enviado a
   un segundo plano si el usuario cambia a otro programa. No todos los modos
   posibles serán soportados por cada driver gráfico en cada plataforma:
   debe llamar a esta rutina tras iniciar el modo gráfico y si pide un modo
   que no es posible, esta rutina devolverá -1. Los modos disponibles son:
<ul><li>
   SWITCH_NONE<br>
      Desactiva el cambio de modo. Este modo está por defecto en sistemas
      monotarea como el DOS. Puede ser soportado en otras plataformas, pero
      debería usarlo con cuidado, porque sus usuarios no se impresionarán si
      quieren cambiar de programa, ¡pero usted no les deja!
<li>
   SWITCH_PAUSE<br>
      Pone en pausa el programa mientras esté en segundo plano. La ejecución
      se restablecerá tan pronto como el usuario vuelva al programa. Este
      modo está por defecto en la mayoría de los entornos multitarea a
      pantalla completa, por ejemplo la consola de Linux.
<li>
   SWITCH_AMNESIA<br>
      Como SWITCH_PAUSE, pero este modo no se preocupa en recordar el
      contenido de la memoria de vídeo, por lo tanto de la pantalla, y
      los bitmaps de vídeo que haya creado se eliminarán después de que el
      usuario cambie de programa y vuelva otra vez. Este no es un modo
      terriblemente útil pero es el modo por defecto para los modos a
      pantalla completa bajo Windows porque DirectDraw es demasiado inútil
      para implementar algo mejor.
<li>
   SWITCH_BACKGROUND<br>
      El programa seguirá ejecutándose en background, con la variable screen
      apuntando temporalmente a un buffer de memoria en los modos de vídeo a
      pantalla completa. Debe tener especial cuidado cuando use este modo,
      porque ocurrirán cosas malas si el bitmap  de pantalla cambia cuando su
      programa no lo espera (lea más abajo).
<li>
   SWITCH_BACKAMNESIA<br>
      Como SWITCH_BACKGROUND, pero este modo no se preocupa por acordarse
      del contenido de la memoria de vídeo (vea SWITCH_AMNESIA). De nuevo,
      es el único modo soportado por los drivers a pantalla completa de
      Windows que permite que su programa siga ejecutándose en segundo
      plano.
</ul>
   Acuérdese de tener mucho cuidado cuando use rutinas gráficas durante un
   contexto de cambio: siempre deberá llamar acquire_screen() antes de
   comenzar a dibujar en la pantalla y no la libere hasta que no haya acabado
   completamente, porque el mecanismo de fijado automático puede no ser
   suficientemente bueno que funcione mientras el programa se ejecuta en
   segundo plano o acaba de de pasar al primer plano.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_display_switch_callback">set_display_switch_callback</a>,
<a class="xref" href="#get_display_switch_mode">get_display_switch_mode</a>.</font></blockquote>
<b>int <a name="set_display_switch_callback">set_display_switch_callback</a>(int dir, void (*cb)());</b><br>
   Instala una función de notificación para el cambio de modo que fue
   previamente seleccionado por set_display_switch_mode(). El parámetro
   direction puede ser SWITCH_IN o SWITCH_OUT, dependiendo de si quiere ser
   avisado cuando se deje su programa o cuando se vuelva a él. A veces puede
   instalar funciones para las dos direcciones, pero no todas las plataformas
   las soportan, así esta función puede devolver -1 si su petición es
   imposible. Puede instalar diferentes funciones de cambio de modo al mismo
   tiempo.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#remove_display_switch_callback">remove_display_switch_callback</a>,
<a class="xref" href="#set_display_switch_mode">set_display_switch_mode</a>.</font></blockquote>
<b>void <a name="remove_display_switch_callback">remove_display_switch_callback</a>(void (*cb)());</b><br>
   Elimina una función de notificación que fue previamente instalada mediante
   set_display_switch_callback(). Todas las funciones serán eliminadas
   automáticamente cuando llame a set_display_switch_mode().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_display_switch_callback">set_display_switch_callback</a>.</font></blockquote>
<b>int <a name="get_display_switch_mode">get_display_switch_mode</a>();</b><br>
   Devuelve el modo de cambio de pantalla, en el mismo formato que se pasa a
   set_display_switch_mode().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_display_switch_mode">set_display_switch_mode</a>.</font></blockquote>
<b>extern int <a name="gfx_capabilities">gfx_capabilities</a>;</b><br>
   Campo de bits describiendo las capacidades del controlador gráfico y el
   hardware de video actuales. Puede contener cualquiera de los siguientes
   bits:

<p>
   <b>GFX_CAN_SCROLL:</b><br>
      Indica que la función scroll_screen() puede ser usada con este
      controlador.

<p>
   <b>GFX_CAN_TRIPLE_BUFFER:</b><br>
      Indica que las funciones request_scroll() y poll_scroll() se pueden
      usar con este driver. Si este bit no está activado es posible que la
      función enable_triple_buffer() sea capaz de activarlo.

<p>
  <b>GFX_HW_CURSOR:</b><br>
      Indica que un puntero de ratón por hardware está siendo usado. Cuando
      este bit esté activado, puede dibujar sin problemas en la pantalla sin
      tener que ocultar antes el puntero del ratón. Tenga en cuenta que no
      todo cursor gráfico puede ser implementado via hardware: en particular,
      VBE/AF sólo soporta imágenes de 2 colores y de hasta 32x32 pixels,
      donde el segundo color es un inverso exacto del primero. Esto significa
      que Allegro puede necesitar alternar entre cursores por hardware o
      software en cualquier punto durante la ejecución de su programa, por lo
      que no debe asumir que este bit será constante durante largos periodos
      de tiempo. Sólo le dice si un cursor hardware está siendo usado ahora,
      y puede cambiar cuando oculte/enseñe el puntero.

<p>
<b>GFX_HW_HLINE:</b><br>
      Indica que la versión opaca normal de la función hline() está
      implementada usando aceleración por hardware. Esto incrementará el
      rendimiento, no sólo de hline(), sino también de otras funciones que
      la usen internamente, por ejemplo circlefill(), triangle(), y
      floodfill().

<p>
   <b>GFX_HW_HLINE_XOR:</b><br>
      Indica que la versión XOR de la función hline(), y cualquier otra que
      la use, estan implementadas usando aceleración por hardware.

<p>
   <b>GFX_HW_HLINE_SOLID_PATTERN:</b><br>
      Indica que los modos sólidos y con patrones de la función hline(), y
      cualquier otra función que la use, estan implementadas usando
      aceleración por hardware (lea nota abajo).

<p>
   <b>GFX_HW_HLINE_COPY_PATTERN:</b><br>
      Indica que el modo copia de patrón de la función hline(), y cualquier
      otra función que la use, estan implementadas usando aceleración por
      hardware (lea nota abajo).

<p>
   <b>GFX_HW_FILL:</b><br>
      Indica que la versión opaca de las funciones rectfill(), clear_bitmap()
      y clear_to_color(), están implementadas usando aceleración por
      hardware.

<p>
   <b>GFX_HW_FILL_XOR:</b><br>
      Indica que la versión XOR de la función rectfill() está implementada
      usando aceleración por hardware.

<p>
   <b>GFX_HW_FILL_SOLID_PATTERN:</b><br>
      Indica que los modos sólidos y con patrones de la función rectfill()
      están implementados usando aceleración por hardware (lea nota abajo).

<p>
   <b>GFX_HW_FILL_COPY_PATTERN:</b><br>
      Indica que el modo copia de patrón de la función rectill() está
      implementado usando aceleración por hardware (lea nota abajo).

<p>
   <b>GFX_HW_LINE:</b><br>
      Indica que la versión opaca de las funciones line() y vline() está
      implementada usando aceleración por hardware.

<p>
   <b>GFX_HW_LINE_XOR:</b><br>
      Indica que la versión XOR de las funciónes line() y vline() está
      implementada usando aceleración por hardware.

<p>
   <b>GFX_HW_TRIANGLE:</b><br>
      Indica que la versión opaca de la función triangle() está implementada
      usando aceleración por hardware.

<p>
   <b>GFX_HW_TRIANGLE_XOR:</b><br>
      Indica que la versión XOR de la función triangle() está implementada
      usando aceleración por hardware.

<p>
   <b>GFX_HW_GLYPH:</b><br>
      Indica que la expansión de carácter monocromo (para dibujo de texto)
      está implementada usando aceleración hardware.

<p>
   <b>GFX_HW_VRAM_BLIT:</b><br>
      Indica que hacer un blit desde una parte de la pantalla a otra está
      implementado usando aceleración por hardware. Si este bit está
      activado, hacer blits dentro de la memoria de vídeo será ciertamente
      el modo más rápido para enseñar una imagen, por lo que sería útil
      almacenar parte de sus gráficos más usados en una posición oculta de
      la memoria de vídeo.

<p>
   <b>GFX_HW_VRAM_BLIT_MASKED:</b><br>
      Indica que la rutina masked_blit() es capaz de hacer una copia de una
      parte de vídeo a otra usando aceleración por hardware, y que
      draw_sprite() usará copia por hardware cuando un sub-bitmap de la
      pantalla o un bitmap de memoria de vídeo sea la imagen origen. Si este
      bit está activado, el copiar desde la memoria de vídeo será casi
      seguramente el modo más rápido para visualizar una imagen, por lo que
      podría ser rentable almacenar algunos de sus sprites más usados en una
      porción no visible de la memoria de vídeo.

<p>
      Aviso: ¡si esta bit no está activado, masked_blit() y draw_sprite() no
      funcionarán correctamente cuando los use con la memoria de vídeo como
      bitmap origen! Sólo puede usar estas funciones para copiar memoria de
      vídeo si están soportadas por el hardware.

<p>
   <b>GFX_HW_MEM_BLIT:</b><br>
      Indica que hacer un blit desde un bitmap de memoria a la pantalla usa
      aceleración por hardware.

<p>
   <b>GFX_HW_MEM_BLIT_MASKED:</b><br>
      Indica que masked_blit() y draw_sprite() usan aceleración por hardware
      cuando la imagen fuente es un bitmap de memoria, y la imagen destino
      es la pantalla física.

<p>
   <b>GFX_HW_SYS_TO_VRAM_BLIT:</b><br>
      Indica que hacer un blit desde un bitmap de sistema a la pantalla está
      acelerado por hardware. Note que puede haber alguna aceleración incluso
      si este bit no está activado, porque los bitmaps de sistema también se
      pueden beneficiar del blit de memoria normal a la pantalla. Este bit
      sólo estará activado si los bitmaps de sistema una aceleración mayor
      que la proporcionada por GFX_HW_MEM_BLIT.

<p>
   <b>GFX_HW_SYS_TO_VRAM_BLIT_MASKED:</b><br>
      Indica que las funciones masked_blit() y draw_sprite() están siendo
      aceleradas por hardware cuando la imagen fuente es un bitmap de sistema
      y el destino es la pantalla física. Note que puede haber alguna
      aceleración incluso si este bit no está activado, porque los bitmaps de
      sistema también se pueden beneficiar del blit de memoria normal a la
      pantalla. Este bit sólo estará activado si los bitmaps de sistema
      una aceleración mayor que la proporcionada por GFX_HW_MEM_BLIT_MASKED.

<p>
   Nota: incluso cuando la información diga que el dibujo con patrón está
   soportado usando aceleración por hardware, no será posible para cualquier
   tamaño de patrón. El controlador VBE/AF sólo soporta patrones de hasta
   8x8 pixels, y usará la versión original no acelerada por hardware de las
   rutinas de dibujo siempre que use patrones más grandes.

<p>
   Nota2: estas características de aceleración por hardware sólo surtirán
   efecto cuando dibuje directamente sobre la pantalla física, o un
   sub-bitmap de ésta. La aceleración por hardware es útil sobre todo con
   una configuración de cambio de páginas o triple buffer, y probablemente no
   habrá diferencia de rendimiento con el sistema "dibuja en un bitmap de
   memoria, entonces cópialo a la pantalla".


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#enable_triple_buffer">enable_triple_buffer</a>,
<a class="xref" href="alleg008.html#screen">screen</a>,
<a class="xref" href="alleg008.html#create_video_bitmap">create_video_bitmap</a>,
<a class="xref" href="#scroll_screen">scroll_screen</a>,
<a class="xref" href="#request_scroll">request_scroll</a>,
<a class="xref" href="alleg003.html#show_mouse">show_mouse</a>.</font></blockquote>
<b>int <a name="enable_triple_buffer">enable_triple_buffer</a>();</b><br>
   Si el bit GFX_CAN_TRIPLE_BUFFER de la variable gfx_capabilities no está
   activado, puede intentar activarlo llamando esta función. En particular,
   si está trabajando en modo-X bajo DOS puro, esta rutina activará el
   simulador de retrazo temporizado, el cual entonces activará las funciones
   de triple buffering. Devuelve cero si el triple buffering está activado.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#gfx_capabilities">gfx_capabilities</a>,
<a class="xref" href="alleg004.html#timer_simulate_retrace">timer_simulate_retrace</a>,
<a class="xref" href="#request_scroll">request_scroll</a>,
<a class="xref" href="#request_video_bitmap">request_video_bitmap</a>.</font></blockquote>
<b>int <a name="scroll_screen">scroll_screen</a>(int x, int y);</b><br>
   Intenta hacer un scroll de la pantalla para mostrar una parte diferente de
   la pantalla virtual (que inicialmente se posicionará en 0,0, que es la
   esquina superior izquierda). Devuelve cero si ha tenido éxito: puede
   fallar si el controlador gráfico no soporta scroll por hardware o la
   pantalla virtual no es lo suficientemente grande. Puede usar esta función
   para mover la pantalla por un espacio de pantalla virtual grande, o para
   hacer un intercambio de páginas entre dos áreas de pantalla virtual que
   no estén solapadas. Tenga en cuenta que para dibujar fuera de la posición
   original de la pantalla deberá alterar el área de recorte: mire abajo.

<p>
   El scroll en Modo-X es de fiar y funcionará en cualquier tarjeta.
   Desafortunadamente la mayoría de las implementaciones VESA sólo pueden
   hacer scroll horizontal en incrementos de cuatro pixels, así que hacer
   un scroll suave en modos SVGA es imposible. Es vergonzoso, pero no veo
   forma de solucionarlo. Un numero significativo de implementaciones VESA
   parecen tener muchos fallos cuando hay que hacer scroll en modos
   truecolor, por lo que recomiendo no usar esta rutina en modos truecolor a
   menos que esté seguro de que Scitech Display Doctor está instalado.

<p>
   Allegro se ocupará de cualquier sincronización del retrazo vertical cuando
   hago un scroll de pantalla, así que no necesita llamar a vsync() antes.
   Esto significa que scroll_screen() tiene los mismos efectos de retraso que
   vsync().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_gfx_mode">set_gfx_mode</a>,
<a class="xref" href="#show_video_bitmap">show_video_bitmap</a>,
<a class="xref" href="#request_scroll">request_scroll</a>,
<a class="xref" href="#request_video_bitmap">request_video_bitmap</a>.</font></blockquote>
<b>int <a name="request_scroll">request_scroll</a>(int x, int y);</b><br>
   Esta función es usada para el triple buffering. Hace una petición de
   scroll por hardware a la posición especificada, pero vuelve inmediatamente
   en vez de esperar un retrazo. El scroll tendrá lugar durante el siguiente
   retrazo vertical, pero puede seguir ejecutando su código mientras y usar
   la rutina poll_scroll() para detectar cuando ha ocurrido el cambio por
   scroll (vea examples/ex3buf.c). El triple buffering sólo es posible en
   cierto hardware: funcionará en cualquier resolución de modo-X si el
   simulador de retrazo esta activo(pero no funciona bien bajo win95), y está
   suportado por los controladores VBE 3.0 y VBE/AF para un número limitado
   de tarjetas gráficas de alto nivel. Puede mirar el bit
   GFX_CAN_TRIPLE_BUFFER del campo de bits gfx_capabilities para ver si
   funcionará con el controlador actual. Esta función devuelve cero si no
   hubo problemas.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#poll_scroll">poll_scroll</a>,
<a class="xref" href="#request_video_bitmap">request_video_bitmap</a>,
<a class="xref" href="#gfx_capabilities">gfx_capabilities</a>,
<a class="xref" href="alleg004.html#timer_simulate_retrace">timer_simulate_retrace</a>,
<a class="xref" href="#scroll_screen">scroll_screen</a>.</font></blockquote>
<b>int <a name="poll_scroll">poll_scroll</a>();</b><br>
   Esta función es usada con triple buffering. Comprueba el estado de un
   scroll por hardware iniciado previamente por la rutina request_scroll(),
   devolviendo no-cero si todavía está esperando a que ocurra, y cero si ya
   ha ocurrido.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#request_scroll">request_scroll</a>,
<a class="xref" href="#request_video_bitmap">request_video_bitmap</a>.</font></blockquote>
<b>int <a name="show_video_bitmap">show_video_bitmap</a>(BITMAP *bitmap);</b><br>
   Solicita intercambiar la página de pantalla hardware para visualizar el
   objeto bitmap de vídeo especificado, que debe tener el mismo tamaño que
   la pantalla física, y debe haber sido obtenido usando la función
   create_video_bitmap(). Devuelve cero si no hubo problemas. Esta función
   esperará un retrazo vertical si su tarjeta de vídeo lo requiere, por lo
   que no hace falta que llame vsync() manualmente.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#scroll_screen">scroll_screen</a>,
<a class="xref" href="alleg008.html#create_video_bitmap">create_video_bitmap</a>.</font></blockquote>
<b>int <a name="request_video_bitmap">request_video_bitmap</a>(BITMAP *bitmap);</b><br>
   Esta función se usa con triple buffering. Solicita intercambiar la página
   de pantalla al objeto bitmap de vídeo especificado, pero retorna
   inmediatamente en vez de esperar el retrazo. El intercambio tendrá lugar
   con el siguiente retrazo vertical, pero puede mientras puede seguir
   ejecutando su código y usar la rutina poll_scroll() para detectar cuándo
   ocurre el intercambio realmente. Triple buffering sólo es posible en
   determinado hardware: mire los comentarios de request_scroll(). Devuelve
   cero si no hubo problemas.




<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="alleg008.html#create_video_bitmap">create_video_bitmap</a>,
<a class="xref" href="#scroll_screen">scroll_screen</a>,
<a class="xref" href="#poll_scroll">poll_scroll</a>,
<a class="xref" href="#request_scroll">request_scroll</a>,
<a class="xref" href="#gfx_capabilities">gfx_capabilities</a>,
<a class="xref" href="alleg004.html#timer_simulate_retrace">timer_simulate_retrace</a>.</font></blockquote>
<hr><a href="allegro.html">Volver al Indice</a>

</body>
</html>
