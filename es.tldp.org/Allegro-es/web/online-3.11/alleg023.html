<html><head><title>23 Rutinas de m£sica MIDI</title><body>
<h1><a name="23 Rutinas de música MIDI">23 Rutinas de música MIDI</a></h1>
<p>
<ul><h4>
<li><a href="#load_midi">load_midi</a>
<li><a href="#destroy_midi">destroy_midi</a>
<li><a href="#play_midi">play_midi</a>
<li><a href="#play_looped_midi">play_looped_midi</a>
<li><a href="#stop_midi">stop_midi</a>
<li><a href="#midi_pause">midi_pause</a>
<li><a href="#midi_resume">midi_resume</a>
<li><a href="#midi_seek">midi_seek</a>
<li><a href="#midi_out">midi_out</a>
<li><a href="#load_midi_patches">load_midi_patches</a>
<li><a href="#midi_pos">midi_pos</a>
<li><a href="#midi_loop_start">midi_loop_start</a>
<li><a href="#midi_loop_end">midi_loop_end</a>
<li><a href="#midi_msg_callback">midi_msg_callback</a>
<li><a href="#midi_meta_callback">midi_meta_callback</a>
<li><a href="#midi_sysex_callback">midi_sysex_callback</a>
<li><a href="#load_ibk">load_ibk</a>
</h4></ul>
<p><br><br>
<p>
<b>MIDI *<a name="load_midi">load_midi</a>(char *filename);</b><br>
   Carga un fichero MIDI (maneja ambos formatos 0 y 1), devolviendo un
   puntero a la estructura MIDI, o NULL si hubo problemas.
<p>
<b>void <a name="destroy_midi">destroy_midi</a>(MIDI *midi);</b><br>
   Destruye una estructura MIDI cuando ya no la necesite. Es seguro llamar
   esto incluso cuando el fichero MIDI está siendo reproducido, porque lo
   comprueba y para en caso de que esté activo.
<p>
<b>int <a name="play_midi">play_midi</a>(MIDI *midi, int loop);</b><br>
   Reproduce el fichero MIDI especificado, deteniendo cualquier música
   anterior. Si el biestable loop está activado, los datos serán repetidos
   hasta que los sustituya con otra cosa, de otro modo se parará la música
   al final del fichero. Pasando un puntero NULL parará cualquier música que
   esté siendo reproducida. Devuelve no-cero si hubo problemas (esto puede
   ocurrir si un controlador wavetable cacheable no consigue cargar los
   samples requeridos, o al menos ocurrirá en el futuro cuando alguien
   escriba algunos controladores wavetable cacheables :-)
<p>
<b>int <a name="play_looped_midi">play_looped_midi</a>(MIDI *midi, int loop_start, int loop_end);</b><br>
   Reproduce un fichero MIDI con una posición de loop definida por el
   usuario. Cuando el reproductor llega al final del loop o al final del
   fichero (loop_end puede ser -1 para repetir en EOF), volverá al principio
   del comienzo del loop. Ambas posiciones son especificadas en el mismo
   formato de golpes de ritmo que la variable midi_pos.
<p>
<b>void <a name="stop_midi">stop_midi</a>();</b><br>
   Para la música que esté siendo reproducida. Esto es lo mismo que llamar
   play_midi(NULL, FALSE).
<p>
<b>void <a name="midi_pause">midi_pause</a>();</b><br>
   Pone el reproductor MIDI en pausa.
<p>
<b>void <a name="midi_resume">midi_resume</a>();</b><br>
   Continua la reproducción de un MIDI pausado.
<p>
<b>int <a name="midi_seek">midi_seek</a>(int target);</b><br>
   Avanza hasta la posición especificada (midi_pos) en el fichero MIDI
   usado. Si el objetivo está antes en el fichero que el midi_pos actual,
   avanza desde el principio; de otro modo busca desde la posición actual.
   Devuelve cero si no lo ha conseguido, no-cero si llega al final del
   fichero (1 significa que paró la reproducción, 2 significa que volvió a
   reproducir desde el principio).
<p>
<b>void <a name="midi_out">midi_out</a>(unsigned char *data, int length);</b><br>
   Introduce un bloque de comandos MIDI en el reproductor en tiempo real,
   permitiéndole activar notas, tocar campanas, etc, sobre el fichero MIDI
   que esté siendo reproducido.
<p>
<b>int <a name="load_midi_patches">load_midi_patches</a>();</b><br>
   Fuerza al controlador MIDI a cargar un conjunto de patches completo para
   ser usados. Normalmente no deberá llamar esto, porque Allegro
   automáticamente carga todos los datos requeridos por el fichero MIDI
   seleccionado, pero debe llamar esto antes de mandar mensajes de cambio de
   programa vía comando midi_out(). Devuelve no-cero si ocurrió un fallo.
<p>
<b>extern volatile long <a name="midi_pos">midi_pos</a>;</b><br>
   Contiene la posición actual (número de beat) del fichero MIDI, o un
   número negativo si no se está reproduciendo ninguna música. Util para
   sincronizar animaciones con la música, y para chequear si un fichero MIDI
   se ha acabado de reproducir.
<p>
<b>extern long <a name="midi_loop_start">midi_loop_start</a>;</b><br>
<b>extern long <a name="midi_loop_end">midi_loop_end</a>;</b><br>
   Los puntos de comienzo y final del loop, ajustados por la función
   play_looped_midi(). Estos pueden ser alterados mientras suena la música,
   pero debería estar seguro de ponerlos a valores sensatos (comienzo &lt;
   final). Si está cambiando ambos al mismo tiempo, asegúrese de alterarlos
   en el mismo orden en caso de que una interrupción midi ocurra entre sus
   dos cambios. Si los valores están a -1, representan el comienzo y final
   del fichero respectivamente.
<p>
<b>extern void (*<a name="midi_msg_callback">midi_msg_callback</a>)(int msg, int byte1, int byte2);</b><br>
<b>extern void (*<a name="midi_meta_callback">midi_meta_callback</a>)(int type, unsigned char *data, int length);</b><br>
<b>extern void (*<a name="midi_sysex_callback">midi_sysex_callback</a>)(unsigned char *data, int length);</b><br>
   Funciones de enganche que permiten interceptar eventos MIDI del
   reproductor. Si se activan a cualquier cosa menos NULL, estas rutinas
   serán llamadas por cada mensaje MIDI, meta-evento, y bloque de datos
   exclusivo del sistema respectivamente. Estas funciones serán ejecutadas
   en un contexto de control de interrupción, por lo que todo el código y
   datos que usen debería estar fijado (locked), y no deben llamar funciones
   del sistema operativo. En general, simplemente use estas rutinas para
   activar algunos biestables y para responder a ellos más tarde en su
   código principal.
<p>
<b>int <a name="load_ibk">load_ibk</a>(char *filename, int drums);</b><br>
   Lee una definición de un fichero de patch .IBK usado por el controlador
   Adlib. Si los tambores están activados, lo cargará como un patch de
   percusión, de otro modo reemplazará el conjunto de instrumentos MIDI
   General. Puede llamar esto antes o después de iniciar el código de
   sonido, o simplemente puede activar las variables ibk_file e
   ibk_drum_file en el fichero de configuración para cargar los datos
   automáticamente. ¡Fíjese que esta función no tiene ningún efecto en otros
   controladores que no sean Adlib!
<p>
<br>
<br>
<p><hr><p><a href="allegro.html">Volver al Indice</a><p>
