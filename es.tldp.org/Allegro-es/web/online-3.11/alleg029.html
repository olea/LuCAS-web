<html><head><title>29 Rutinas matem ticas 3D</title><body>
<h1><a name="29 Rutinas matemáticas 3D">29 Rutinas matemáticas 3D</a></h1>
<p>
<ul><h4>
<li><a href="#identity_matrix">identity_matrix</a>
<li><a href="#identity_matrix_f">identity_matrix_f</a>
<li><a href="#get_translation_matrix">get_translation_matrix</a>
<li><a href="#get_translation_matrix_f">get_translation_matrix_f</a>
<li><a href="#get_scaling_matrix">get_scaling_matrix</a>
<li><a href="#get_scaling_matrix_f">get_scaling_matrix_f</a>
<li><a href="#get_x_rotate_matrix">get_x_rotate_matrix</a>
<li><a href="#get_x_rotate_matrix_f">get_x_rotate_matrix_f</a>
<li><a href="#get_y_rotate_matrix">get_y_rotate_matrix</a>
<li><a href="#get_y_rotate_matrix_f">get_y_rotate_matrix_f</a>
<li><a href="#get_z_rotate_matrix">get_z_rotate_matrix</a>
<li><a href="#get_z_rotate_matrix_f">get_z_rotate_matrix_f</a>
<li><a href="#get_rotation_matrix">get_rotation_matrix</a>
<li><a href="#get_rotation_matrix_f">get_rotation_matrix_f</a>
<li><a href="#get_align_matrix">get_align_matrix</a>
<li><a href="#get_align_matrix_f">get_align_matrix_f</a>
<li><a href="#get_vector_rotation_matrix">get_vector_rotation_matrix</a>
<li><a href="#get_vector_rotation_matrix_f">get_vector_rotation_matrix_f</a>
<li><a href="#get_transformation_matrix">get_transformation_matrix</a>
<li><a href="#get_transformation_matrix_f">get_transformation_matrix_f</a>
<li><a href="#get_camera_matrix">get_camera_matrix</a>
<li><a href="#get_camera_matrix_f">get_camera_matrix_f</a>
<li><a href="#qtranslate_matrix">qtranslate_matrix</a>
<li><a href="#qtranslate_matrix_f">qtranslate_matrix_f</a>
<li><a href="#qscale_matrix">qscale_matrix</a>
<li><a href="#qscale_matrix_f">qscale_matrix_f</a>
<li><a href="#matrix_mul">matrix_mul</a>
<li><a href="#matrix_mul_f">matrix_mul_f</a>
<li><a href="#vector_length">vector_length</a>
<li><a href="#vector_length_f">vector_length_f</a>
<li><a href="#normalize_vector">normalize_vector</a>
<li><a href="#normalize_vector_f">normalize_vector_f</a>
<li><a href="#dot_product">dot_product</a>
<li><a href="#dot_product_f">dot_product_f</a>
<li><a href="#cross_product">cross_product</a>
<li><a href="#cross_product_f">cross_product_f</a>
<li><a href="#polygon_z_normal">polygon_z_normal</a>
<li><a href="#polygon_z_normal_f">polygon_z_normal_f</a>
<li><a href="#apply_matrix">apply_matrix</a>
<li><a href="#apply_matrix_f">apply_matrix_f</a>
<li><a href="#set_projection_viewport">set_projection_viewport</a>
<li><a href="#persp_project">persp_project</a>
<li><a href="#persp_project_f">persp_project_f</a>
</h4></ul>
<p><br><br>
<p>
Allegro también contiene algunas funciones de ayuda de 3d para manipular
vectores, construir o usar matrices de transformación, y hacer proyecciones
de perspectiva de un espacio 3d en la pantalla. Estas funciones no son, y
nunca serán, una librería 3d total (mi objetivo es dar rutinas de soporte
genéricas, y no código gráfico muy especializado :-) pero estas funciones
pueden serle útiles para desarrollar su propio código 3d.
<p>
Hay dos versiones de todas las funciones matemáticas de 3d: una usando
aritmética de punto fijo, y la otra usando coma flotante. La sintaxis para
ambas es idéntica, pero las funciones y estructuras de coma flotante tienen
el sufijo '_f'. Ejemplo: la función cross_product() de punto fijo tiene el
equivalente de coma flotante en cross_product_f(). Si está programando en
C++, Allegro también sobrecarga estas funciones para que las use con la
clase "fija".
<p>
La transformación 3d se realiza modelando una matriz. Esta es un array de
4x4 números que pueden ser multiplicados con un punto 3d para producir otro
punto 3d. Si ponemos los valores correctos en la matriz, podemos usarla para
varias operaciones como translación, rotación y escalado. El truco consiste
en que puede multiplicar dos matrices para producir una tercera, y esta
tendrá el mismo efecto en los puntos 3d que aplicando las dos matrices
originales una después de la otra. Por ejemplo, si tiene una matriz que
rota un punto, y otra que lo mueve en una dirección, puede combinarlas para
producir una matriz que realizara la rotación y translación en un paso.
Puede crear transformaciones extremadamente complejas de este modo,
teniendo que multiplicar cada punto 3d por solo una matriz.
<p>
Allegro hace trampa al implementar la estructura de la matriz. La rotación y
el escalado de un punto 3d puede ser realizado con una matriz simple de 3x3,
pero para trasladar el punto y proyectarlo en la pantalla, la matriz tiene
que ser extendida a 4x4, y el punto extendido a una cuarta dimensión, al
añadir una coordenada extra: w=1. Esto es algo malo en términos de
eficiencia, pero afortunadamente, es posible realizar una optimización. Dada
la siguiente matriz 4x4:
<p><pre>
   ( a, b, c, d )
   ( e, f, g, h )
   ( i, j, k, l )
   ( m, n, o, p )
<p></pre>
se puede observar un patrón de qué partes hacen qué. La rejilla 3x3 de
arriba a la izquierda implementa la rotación y el escalado. Los tres valores
de arriba de la cuarta columna (d, h y l) implementan la translación, y
siempre y cuando la matriz sea usada sólo para transformaciones afines, m, n
y o serán siempre cero y p siempre será 1. Si no sabe que significa 'afín',
lea a Foley & Van Damme: básicamente cubre el escalado, la translación y
rotación del objeto pero no la proyección. Ya que Allegro usa una función
aparte para la proyección, las funciones de matriz sólo tienen que servir
para la transformación afín, lo que significa que no hay que guardar la fila
inferior de la matriz. Allegro asume que esta contiene (0,0,0,1), y por eso
optimiza las funciones de manipulación de matrices.
<p>
Las matrices se almacenan en estructuras:
<p><pre>
typedef struct MATRIX            - matriz de punto fijo
{
   fixed v[3][3];                - componente 3x3 de escalado y rotación
   fixed t[3];                   - componente x/y/z de translación
} MATRIX;
<p>
typedef struct MATRIX_f          - matriz de coma flotante
{
   float v[3][3];                - componente 3x3 de escalado y rotación
   float t[3];                   - componente x/y/z de translación
} MATRIX_f
<p></pre>
<b>extern MATRIX <a name="identity_matrix">identity_matrix</a>;</b><br>
<b>extern MATRIX_f <a name="identity_matrix_f">identity_matrix_f</a>;</b><br>
   Variable global que contiene la matriz con identidad 'vacía'. Multiplicar
   por la matriz de identidad no tiene ningún efecto.
<p>
<b>void <a name="get_translation_matrix">get_translation_matrix</a>(MATRIX *m, fixed x, fixed y, fixed z);</b><br>
<b>void <a name="get_translation_matrix_f">get_translation_matrix_f</a>(MATRIX_f *m, float x, float y, float z);</b><br>
   Construye una matriz de translación, guardándola en m. Si se aplica a un
   punto (px, py, pz), esta matriz producirá el punto (px+x, py+y, pz+z). En
   otras palabras: mueve las cosas.
<p>
<b>void <a name="get_scaling_matrix">get_scaling_matrix</a>(MATRIX *m, fixed x, fixed y, fixed z);</b><br>
<b>void <a name="get_scaling_matrix_f">get_scaling_matrix_f</a>(MATRIX_f *m, float x, float y, float z);</b><br>
   Construye una matriz de escalado, almacenándola en m. Cuando se aplica a
   un punto (px, py, pz), esta matriz produce un punto (px*x, py*y, pz*z).
   En otras palabras, agranda o empequeñece las cosas.
<p>
<b>void <a name="get_x_rotate_matrix">get_x_rotate_matrix</a>(MATRIX *m, fixed r);</b><br>
<b>void <a name="get_x_rotate_matrix_f">get_x_rotate_matrix_f</a>(MATRIX_f *m, float r);</b><br>
   Construye las matrices de rotación del eje X, almacenándolas en m. Cuando
   se aplican a un punto, estas matrices lo rotarán sobre el eje X el ángulo
   especificado (en binario, 256 grados hacen un círculo).
<p>
<b>void <a name="get_y_rotate_matrix">get_y_rotate_matrix</a>(MATRIX *m, fixed r);</b><br>
<b>void <a name="get_y_rotate_matrix_f">get_y_rotate_matrix_f</a>(MATRIX_f *m, float r);</b><br>
   Construye las matrices de rotación del eje Y, almacenándolas en m. Cuando
   se aplican a un punto, estas matrices lo rotarán sobre el eje Y el ángulo
   especificado (en binario, 256 grados hacen un círculo).
<p>
<b>void <a name="get_z_rotate_matrix">get_z_rotate_matrix</a>(MATRIX *m, fixed r);</b><br>
<b>void <a name="get_z_rotate_matrix_f">get_z_rotate_matrix_f</a>(MATRIX_f *m, float r);</b><br>
   Construye las matrices de rotación del eje Z, almacenándolas en m. Cuando
   se aplican a un punto, estas matrices lo rotarán sobre el eje Z el ángulo
   especificado (en binario, 256 grados hacen un círculo).
<p>
<b>void <a name="get_rotation_matrix">get_rotation_matrix</a>(MATRIX *m, fixed x, fixed y, fixed z);</b><br>
<b>void <a name="get_rotation_matrix_f">get_rotation_matrix_f</a>(MATRIX_f *m, float x, float y, float z);</b><br>
   Construye una matriz de transformación que rotará puntos en todos los
   ejes los grados especificados. (en binario, 256 grados hacen un círculo).
<p>
<b>void <a name="get_align_matrix">get_align_matrix</a>(MATRIX *m, fixed xfront, yfront, zfront,</b>
<b>                                 fixed xup, fixed yup, fixed zup);</b><br>
   Rota la matriz de tal forma que la alinea sobre las coordenadas de los
   vectores especificados (estos no tienen que ser normalizados o
   perpendiculares, pero up y front no pueden ser iguales). Un vector front
   de 1,0,0 y un vector up de 0,1,0 retornarán la matriz de identidad.
<p>
<b>void <a name="get_align_matrix_f">get_align_matrix_f</a>(MATRIX *m, float xfront, yfront, zfront,</b>
<b>                                   float xup, yup, zup);</b><br>
   Versión en coma flotante de get_align_matrix().
<p>
<b>void <a name="get_vector_rotation_matrix">get_vector_rotation_matrix</a>(MATRIX *m, fixed x, y, z, fixed a);</b><br>
<b>void <a name="get_vector_rotation_matrix_f">get_vector_rotation_matrix_f</a>(MATRIX_f *m, float x, y, z, float a);</b><br>
   Construye una matriz de transformación que rotará puntos sobre todos los
   vectores x,y,z un ángulo especificado (en binario, 256 grados hacen un
   círculo).
<p>
<b>void <a name="get_transformation_matrix">get_transformation_matrix</a>(MATRIX *m, fixed scale,</b>
<b>                               fixed xrot, yrot, zrot, x, y, z);</b><br>
   Construye una matriz de transformación que rotará puntos en todos los
   ejes los ángulos especificados (en binario, 256 grados hacen un círculo),
   escalará el resultado (pasa el valor 1 si no quiere cambiar la escala),
   y entonces los trasladará a la posición x, y, z requerida.
<p>
<b>void <a name="get_transformation_matrix_f">get_transformation_matrix_f</a>(MATRIX_f *m, float scale,</b>
<b>                                 float xrot, yrot, zrot, x, y, z);</b><br>
   Versión en coma flotante de get_transformation_matrix().
<p>
<b>void <a name="get_camera_matrix">get_camera_matrix</a>(MATRIX *m, fixed x, y, z, xfront, yfront, zfront,</b>
<b>                       fixed xup, yup, zup, fov, aspect);</b><br>
   Construye la matriz de cámara para trasladar objetos del espacio a una
   vista normalizada del espacio, preparada para la proyección de
   perspectiva. Los parámetros x, y, z especifican la posición de la cámara,
   xfront, yfront y zfront son los vectores 'de frente' que especifican
   hacia adonde apunta la cámara (estos pueden ser de cualquier tamaño, no
   es necesaria la normalización), y xup, yup y zup son los vectores de la
   dirección 'arriba'. El parámetro fov especifica el campo de visión (el
   ancho del foco de la cámara) en binario, haciendo 256 grados un círculo.
   Para proyecciones típicas, un campo de visión de entre 32 a 48 trabajara
   bien. Finalmente, la razón de aspecto es usada para el escalado en la
   dimensión Y relativamente al eje X, para que pueda ajustar las
   proporciones de la imagen final (ponga a uno para no escalar).
<p>
<b>void <a name="get_camera_matrix_f">get_camera_matrix_f</a>(MATRIX_f *m, float x, y, z, xfront, yfront,zfront,</b>
<b>                         float xup, yup, zup, fov, aspect);</b><br>
   Versión en coma flotante de get_camera_matrix().
<p>
<b>void <a name="qtranslate_matrix">qtranslate_matrix</a>(MATRIX *m, fixed x, fixed y, fixed z);</b><br>
<b>void <a name="qtranslate_matrix_f">qtranslate_matrix_f</a>(MATRIX_f *m, float x, float y, float z);</b><br>
   Rutina optimizada para trasladar una matriz ya generada: esto
   simplemente añade el 'offset' de translación, por lo que no hay que crear
   dos matrices temporales y multiplicarlas.
<p>
<b>void <a name="qscale_matrix">qscale_matrix</a>(MATRIX *m, fixed scale);</b><br>
<b>void <a name="qscale_matrix_f">qscale_matrix_f</a>(MATRIX_f *m, float scale);</b><br>
   Rutina optimizada para escalar una matriz ya generada: esto simplemente
   añade el factor de escalación, por lo que no hay que crear dos matrices
   temporales y multiplicarlas.
<p>
<b>void <a name="matrix_mul">matrix_mul</a>(MATRIX *m1, MATRIX *m2, MATRIX *out);</b><br>
<b>void <a name="matrix_mul_f">matrix_mul_f</a>(MATRIX_f *m1, MATRIX_f *m2, MATRIX_f *out);</b><br>
   Multiplica dos matrices, almacenando el resultado en out (esto tiene que
   ser diferente de las matrices de entrada). La matriz resultante creará el
   mismo efecto que la combinación de m1 y m2. Esto es, si se aplica a un
   punto p, (p * out) = ((p * m1) * m2). Cualquier número de
   transformaciones puede ser concatenado de este modo. Fíjese que la matriz
   de multiplicación no es conmutativa, es decir: matrix_mul(m1, m2) !=
   matrix_mul(m2, m1).
<p>
<b>fixed <a name="vector_length">vector_length</a>(fixed x, fixed y, fixed z);</b><br>
<b>float <a name="vector_length_f">vector_length_f</a>(float x, float y, float z);</b><br>
   Calcula la longitud del vector (x, y, z), usando ese buen teorema de
   Pitágoras.
<p>
<b>void <a name="normalize_vector">normalize_vector</a>(fixed *x, fixed *y, fixed *z);</b><br>
<b>void <a name="normalize_vector_f">normalize_vector_f</a>(float *x, float *y, float *z);</b><br>
   Convierte un vector (*x, *y, *z) a un vector normalizado. Este apunta en
   la misma dirección que el vector original, pero tiene una longitud de
   uno.
<p>
<b>fixed <a name="dot_product">dot_product</a>(fixed x1, y1, z1, x2, y2, z2);</b><br>
<b>float <a name="dot_product_f">dot_product_f</a>(float x1, y1, z1, x2, y2, z2);</b><br>
   <i>*** Esto no lo he sabido traducir bien. ***</i><br>
   Calcula el producto (x1, y1, z1) . (x2, y2, z2), devolviendo el
   resultado.
   Calculates the dot product (x1, y1, z1) . (x2, y2, z2), returning the
   result.
<p>
<b>void <a name="cross_product">cross_product</a>(fixed x1, y1, z1, x2, y2, z2, *xout, *yout, *zout);</b><br>
<b>void <a name="cross_product_f">cross_product_f</a>(float x1, y1, z1, x2, y2, z2, *xout, *yout, *zout);</b><br>
   Calcula el cruce de producto (x1, y1, z1) x (x2, y2, z2), almacenando el
   resultado en (*xout, *yout, *zout). El resultado del producto es
   perpendicular a los dos vectores de entrada, para que pueda ser usado
   para generar las normales de los polígonos.
<p>
<b>fixed <a name="polygon_z_normal">polygon_z_normal</a>(V3D *v1, V3D *v2, V3D *v3);</b><br>
<b>float <a name="polygon_z_normal_f">polygon_z_normal_f</a>(V3D_f *v1, V3D_f *v2, V3D_f *v3);</b><br>
   Encuentra la componente Z de la normal de un vector de tres vértices
   especificados (que deben ser parte de un polígono convexo). Esto es usado
   principalmente en la ocultación de caras. Las caras traseras de un
   poliedro cerrado nunca son visibles al espectador, y por tanto no
   necesitan ser dibujadas. Esto puede ocultar aproximadamente la mitad de
   los polígonos de una escena. Si la normal es negativa, el polígono se
   puede eliminar, si es cero, el polígono está perpendicular a la pantalla.
<p>
<b>void <a name="apply_matrix">apply_matrix</a>(MATRIX *m, fixed x, y, z, *xout, *yout, *zout);</b><br>
<b>void <a name="apply_matrix_f">apply_matrix_f</a>(MATRIX_f *m, float x, y, z, *xout, *yout, *zout);</b><br>
   Multiplica el punto (x, y, z) por la transformación de la matriz m,
   almacenando el resultado en el punto (*xout, *yout, *zout).
<p>
<b>void <a name="set_projection_viewport">set_projection_viewport</a>(int x, int y, int w, int h);</b><br>
   Ajusta el punto de visión usado para escalar la salida de la función
   persp_project(). Pase las dimensiones de la pantalla y el área donde la
   quiere dibujar, que típicamente será 0, 0, SCREEN_W, SCREEN_H.
<p>
<b>void <a name="persp_project">persp_project</a>(fixed x, y, z, *xout, *yout);</b><br>
<b>void <a name="persp_project_f">persp_project_f</a>(float x, y, z, *xout, *yout);</b><br>
   Proyecta el punto 3d (x, y, z) del espacio sobre una pantalla 2d,
   almacenando el resultado en (*xout, *yout) usando los parámetros
   anteriormente ajustados por set_projection_viewport(). Esta función
   proyecta desde la pirámide de vista normalizada, que tiene una cámara en
   el origen apuntando al eje z positivo. El eje x va de izquierda a
   derecha, y va de arriba a abajo, y z se incrementa con la profundidad de
   la pantalla. La cámara tiene un ángulo de visión de 90 grados, es
   decir, los planos x=z y -x=z serán los bordes izquierdo y derecho de la
   pantalla, y los planos y=z y -y=z serán la parte superior e inferior de
   la pantalla. Si quiere un campo de visión diferente a la posición de la
   cámara, debería transformar todos sus objetos con la matriz de visión
   apropiada. Ejemplo, para obtener el efecto de haber girado la cámara 10
   grados a la izquierda, rote todos sus objetos 10 grados a la derecha.
<p>
<br>
<br>
<p><hr><p><a href="allegro.html">Volver al Indice</a><p>
