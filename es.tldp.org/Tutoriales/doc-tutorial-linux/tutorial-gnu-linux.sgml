<!doctype linuxdoc system>

<article>
	<title>Tutorial básico de GNU/Linux</title>
	<author>Javier Smaldone - <tt>http://www.smaldone.com.ar</tt></author>
	<date>v1.0, junio de 2006</date>
 <abstract>
El presente tutorial es una guía de aprendizaje de la operación básica del sistema operativo <em>GNU/Linux</em> y los entornos <em>Unix</em> en general.
</abstract>

<toc>

<sect>
Introducción

<sect1>
Objetivo

<p>En los últimos años, la gran evolución de las interfaces gráficas para <em>GNU/Linux</em> y sus herramientas asociadas, han permitido a los usuarios prescindir de los conocimientos sobre comandos y herramientas tradicionales de <em>Unix</em> para su operación. Lamentablemente, esto conlleva el sacrificio de uno de los mayores poderes de este entorno, sobre todo para quienes desean utilizar el sistema para ser algo más que una herramienta de oficina o de diversión.</p>
<p>Es entonces el principal objetivo de este tutorial, introducir de forma breve al usuario novato en el poderoso mundo de las herramientas del entorno <em>Unix</em> de la mano del sistema operativo <em>GNU/Linux</em>.</p>
<p>
El autor recomienda ampliamente seguir el tutorial probando, en la medida de lo posible, cada comando en un sistema real; como así también la visita de los distintos enlaces incluidos en el texto.
</p>


<sect1>
Créditos

<p>
Este tutorial está basado, fundamentalmente, en el capítulo 3 de la primera edición del libro <em>&ldquo;Linux: Installation and Getting Started</em>&rdquo; (Copyright &copy; 1992-1996  Matt Welsh).<footnote>Dicho libro, además de abundante material sobre <em>GNU/Linux</em> y otros temas relacionados puede ser obtenido desde el sitio del <em>Linux Documentation Project</em> (<htmlurl url="http://www.tldp.org/" name="http://www.tldp.org/">).
</footnote> 
</p>

<p>
El autor agradecerá comentarios, críticas, correcciones o cualquier tipo de aporte a este breve tutorial. Si desea comunicarse con él, puede hacerlo escribiéndole a <tt>javier .ARROBA. smaldone.com.ar</tt>.
</p>

</sect1>

<sect1>
Licencia

<p>
Este es un documento libre; puede reproducirlo o modificarlo bajo los términos de la versión 2 (o posteriores, si lo prefiere) de la <em>GNU General Public License</em> (Licencia Pública general de la GNU, GNU GPL), tal y como ha sido publicada por la <em>Free Software Foundation</em> (FSF).<footnote>El texto completo de la licencia (en inglés) puede verse en <htmlurl url="http://www.gnu.org/copyleft/gpl.html" name="http://www.gnu.org/copyleft/gpl.html">.</footnote>
</p><p>
Este texto se distribuye esperando que sea útil, pero SIN GARANTÍA ALGUNA; e incluso sin la garantía implícita de SER COMERCIALIZABLE o de VALIDEZ PARA UN PROPÓSITO CONCRETO.
</p>

</sect1>

<sect1>
Notación y convenciones

<p>En el presente tutorial usaremos las siguientes convenciones tipográficas:</p>

<p>
<itemize>
<item>Tanto el texto mostrado por el sistema, como los nombres de comandos y las órdenes aparecerán en fuente <tt>typewriter</tt>. Ejemplo: <tt>ls /etc</tt>
<item>Las órdenes que el usuario ejecutará en el sistema aparecerán en fuente <tt>typewriter</tt> resaltada en <em>itálica</em>. Ejemplo: <tt><em>ls /etc</em></tt>
<item>Las teclas aparecerán entre corchetes y en fuente <tt>typewriter</tt>. Ejemplo: <tt>&lsqb;Enter&rsqb;</tt>
<item>Las combinaciones de teclas serán denotadas con un signo &ldquo;<tt>+</tt>&rdquo;. Ejemplo: 
<tt>&lsqb;Ctrl&rsqb;+&lsqb;D&rsqb;</tt>
</itemize>

</sect1>

</sect>

<sect>
&iquest;Qué son <em>Unix</em> y <em>GNU/Linux</em>? 

<sect1>
<em>Unix</em>, <em>Linux</em> y <em>GNU</em>

<p>
<em>Unix</em> es uno de los sistemas operativos más populares del mundo debido a su extenso soporte y distribución.<footnote>Ver <htmlurl url="http://es.wikipedia.org/wiki/Unix" name="http://es.wikipedia.org/wiki/Unix"></footnote> Originalmente fue desarrollado como sistema multitarea de tiempo compartido para mini-computadoras y mainframes a mediados de los 70 en los laboratorios de <em>AT&amp;T</em>, y desde entonces se ha convertido en uno de los sistemas más utilizados.
  </p>
  <p>
&iquest;Cuál es la verdadera razón de la popularidad de <em>Unix</em>? Muchos &ldquo;<em>hackers</em>&rdquo;<footnote>El término &ldquo;<em>hacker&rdquo;</em> es comúnmente utilizado para referirse a los fanáticos de la programación y las computadoras. Muchas veces se comete el error de llamar hackers a los piratas informáticos. Ver <htmlurl url="http://es.wikipedia.org/wiki/Hacker" name="http://es.wikipedia.org/wiki/Hacker"></footnote> consideran que es el auténtico y único sistema operativo. El desarrollo de <em>GNU/Linux</em> parte de un grupo en expansión de hackers que quisieron hacer un sistema operativo libre con sus propias manos.
  </p>
  <p>
Existen numerosas versiones de <em>Unix</em> para muchos sistemas, desde computadoras personales hasta supercomputadoras como la Cray Y-MP. La mayoría de las versiones de <em>Unix</em> son muy costosas.
  </p>
  <p>
<em>Linux</em> es una versión del &ldquo;<em>kernel</em>&rdquo; (núcleo) de <em>Unix</em> de libre distribución<footnote>Para mayor información sobre el software libre, visite <htmlurl url="http://www.gnu.org/philosophy/free-sw.es.html" name="http://www.gnu.org/philosophy/free-sw.es.html"></footnote>, inicialmente desarrollado de forma independiente por Linus Torvalds en Finlandia.<footnote>Ver <htmlurl url="http://es.wikipedia.org/wiki/Linux">
</footnote> Luego fue y es desarrollado con la ayuda de muchos programadores y expertos de todo el mundo, comunicados a través de Internet. Cualquiera puede acceder a <em>Linux</em> y desarrollar nuevos módulos o cambiarlo a su antojo, ya que es libre (esto es mucho más importante aún que su gratuidad). El kernel <em>Linux</em> no utiliza ni una sola línea del código original del <em>Unix</em> de <em>AT&amp;T</em> o de cualquier otro software privativo, y se distribuye bajo la licencia <em>GNU GPL</em>.<footnote>
Básicamente, esta licencia establece que el software en cuestión debe ser distribuído incluyendo todo el código fuente y la documentación. Establece además que cualquier persona puede modificar el software de acuerdo a sus necesidades e inclusive puede redistribuirlo, siempre y cuando lo haga bajo la misma licencia. Para mayor información, vea <htmlurl url="http://www.gnu.org/licenses/licenses.es.html#TOCGPL" name="http://www.gnu.org/licenses/licenses.es.html#TOCGPL">
</footnote> de la <em>Free Software Foundation</em><footnote>
<htmlurl url="http://www.fsf.org/" name="http://www.fsf.org/">
</footnote>
  </p>
  <p>
En Marzo de 1992 apareció la primera versión &ldquo;oficial&rdquo; de <em>Linux</em>. Hoy es ya un kernel completo, capaz de ejecutar las herramientas de <em>GNU</em> y muchos otros programas. Mucho software libre y no libre ha sido ya portado a <em>Linux</em>, y el hardware soportado es mucho mayor que en las primeras versiones (se han desarrollado versiones de <em>Linux</em> para más de 15 plataformas, entre las cuales se encuentran Macintosh, SGI, Sparc, Alpha, MIPS, entre otras). 
  </p>
  <p>
El <em>Proyecto GNU<footnote><htmlurl url="http://www.gnu.org/" name="http://www.gnu.org/">
</footnote></em> fue iniciado en 1984 por Richard M. Stallman (RMS) con el propósito de desarrollar un sistema operativo compatible con <em>Unix</em> que fuera software libre. Aunque en la actualidad no ha logrado producir un kernel estable, sus numerosas herramientas se utilizan con el kernel <em>Linux</em>. Existen varias distribuciones de <em>GNU</em> con <em>Linux</em> (usualmente mal llamadas &ldquo;<em>distribuciones de Linux</em>&rdquo;) que ofrecen distintos mecanismos de instalación, colecciones de aplicaciones y herramientas de administración del sistema (Debian, Red Hat, SuSE, etc.).
  </p>

<sect1>
Características de <em>GNU/Linux</em>

<p>
<em>GNU/Linux</em> es un sistema operativo completo con multitarea y multiusuario (como cualquier otra versión de <em>Unix</em>). Esto significa que pueden trabajar varios usuarios simultáneamente en él, y que cada uno de ellos puede tener varios programas en ejecución.
   </p>
   <p>
Fue desarrollado buscando la portabilidad del código fuente: Encontrará que casi todo el software desarrollado para <em>Unix</em> se compila en <em>GNU/Linux</em> sin problemas. Y todo lo que se hace para <em>GNU/Linux</em> (código del kernel, drivers, librerías y programas de usuario) puede correr sin grandes modificaciones en otros sistemas <em>Unix</em>.
   </p>
   <p>
<em>GNU/Linux</em> ofrece todo lo necesario para trabajar en red con TCP/IP (el protocolo de Internet). Desde manejadores para las tarjetas de red más populares, PPP (que permite acceder a una red TCP/IP utilizando un módem y la línea telefónica), PPPoE (acceso TCP/IP mediante ADSL), etc. Y también existen gran cantidad de aplicaciones relacionadas con Internet, como navegadores, clientes de correo, clientes de mensajería instantánea, etc.
   </p>

</sect1>

<sect1>
La filosofía de <em>Unix</em>

<p>En un sistema <em>Unix</em> casi todo es un archivo: dispositivos (placa de sonido, discos, impresoras, mouse, teclado, monitor) es un archivo. De esta manera, los programas pueden diseñarse abstrayéndose de las particularidades de los distintos dispositivos, asumiendo que leen y escriben datos en archivos.</p>

<p><em>Unix</em> incluye una gran cantidad de pequeñas herramientas (programas) capaces de hacer tareas simples y provee mecanismos para combinarlas (sumando además cualquier programa desarrollado por terceros, hasta por usted mismo), logrando realizar tareas realmente complejas sin mayor esfuerzo (sin requerir, por ejemplo, un programa especializado para tal fin).</p>

<p>Otra característica distintiva de <em>Unix</em> es su gran coherencia: el comportamiento y las opciones de los distintos programas son similares. Esta homogeneidad permite transferir fácilmente el conocimiento adquirido respecto de una herramienta a las otras, acelerando notablemente la velocidad de aprendizaje y la productividad.</p>

<p>Una advertencia: Un sistema <em>Unix</em> &ldquo;asumirá&rdquo; que el usuario sabe lo que hace, y que quiere hacer exactamente lo que ordena. Por lo tanto, no pedirá confirmación a la hora de borrar archivos o realizar alguna otra tarea destructiva o peligrosa. &iexcl;Tenga mucho cuidado a la hora de escribir órdenes peligrosas! En general, los programas de <em>Unix</em> son bastante &ldquo;silenciosos&rdquo;, esto significa que si un programa se ejecuta con éxito (por ejemplo, un comando en donde se especifique el borrado de 200 archivos), finalizará sin mostrar ningún mensaje al usuario.</p>
</sect1>

</sect>

<sect>
Conceptos básicos de <em>GNU/Linux</em>
  <p>
Bajo <em>GNU/Linux</em>, para que los usuarios puedan identificarse en el sistema, deben presentarse (&ldquo;<em>log in</em>&rdquo;) mediante un proceso que consta de dos pasos: Introducir el nombre de usuario (&ldquo;<em>login</em>&rdquo;), y una contraseña (&ldquo;<em>password</em>&rdquo;), la cual es su llave personal secreta para entrar en la cuenta. En nuestros ejemplos supondremos que el nombre de usuario es <tt>diego</tt>.
  </p>
  <p>
En los sistemas <em>Unix</em> tradicionales, el administrador del sistema asignará el nombre de usuario y una contraseña inicial en el momento de crear la cuenta de usuario. Además, cada sistema tiene un nombre (&ldquo;<em>hostname</em>&rdquo;) asignado, que le da nombre a la máquina. El nombre del sistema es usado para identificar computadoras en una red, pero incluso aunque la máquina no esté en red, debería tener su nombre. En nuestros ejemplos, el nombre del sistema será <tt>micasa</tt>.
  </p>

<sect1>
Ingresando al sistema
   <p>
En el momento de presentarse en el sistema, veremos el siguiente indicador en la pantalla:
   </p>
<p><quote>
  <p><tt>micasa login:</tt></p>
</quote></p>

   <p>
Ahora, introducimos nuestro nombre de usuario y presionamos <tt>&lsqb;Enter&rsqb;</tt>.<footnote>
En algunos teclados ésta tecla puede aparecer como <tt>&lsqb;Intro&rsqb;</tt> o <tt>&lsqb;Return&rsqb;</tt>.</footnote> En nuestro ejemplo, deberíamos teclear lo siguiente:
   </p>

<p>
<quote>  
<p><tt>micasa login: <em>diego</em></tt></p>
<p><tt>Password:</tt></p>
</quote>
</p>

   <p>
Ahora introducimos la contraseña. Esta no será mostrada en la pantalla conforme se va tecleando, por lo que debe hacer cuidadosamente. Si introducimos una contraseña incorrecta, se mostrará el siguiente mensaje:
   </p>

   <p>
<quote>
<p><tt>Login incorrect</tt></p>
</quote>
   </p>

   <p>
y deberemos intentarlo nuevamente.
   </p>

   <p>
Una vez que hemos introducido correctamente el nombre de usuario y la contraseña, estamos  &ldquo;presentados&rdquo; en el sistema y listo para iniciar una sesión interactiva y comenzar a trabajar, según los derechos de acceso que nos brinde nuestra cuenta, como veremos más adelante.
   </p>

   </sect1>

   <sect1>
Consolas virtuales
   <p>
La consola del sistema (o terminal) está formada por el monitor y teclado conectado directamente a la computadora. <em>GNU/Linux</em>, proporciona acceso a consolas virtuales (o VCs, por &ldquo;<em>Virtual Console</em>&rdquo;), las cuales nos permitirán tener mas de una sesión de trabajo activa a la vez desde una única consola física.
   </p>
   <p>
Para demostrar esto, ingresamos al sistema (como hemos visto antes). Luego presionamos <tt>&lsqb;ALT&rsqb;+&lsqb;F2&rsqb;</tt>. Deberíamos ver la línea <tt>micasa login:</tt> de nuevo. Estamos viendo la segunda consola virtual ya que hemos ingresado al sistema por la primera. Para volver a la primera VC, presionamos <tt>&lsqb;ALT&rsqb;+&lsqb;F1&rsqb;</tt>.
   </p>
   <p>
Un sistema <em>GNU/Linux</em> recién instalado probablemente nos permita acceder a las primeras seis VCs, usando <tt>&lsqb;ALT&rsqb;+&lsqb;F1&rsqb;</tt> a <tt>&lsqb;ALT&rsqb;+&lsqb;F6&rsqb;</tt>, pero es posible habilitar hasta 12 VCs, una por cada tecla de función del teclado.
   </p>
   <p>
Mientras que el uso de VC's es algo limitado (después de todo, sólo podemos mirar una por vez), esto debería dar una idea de las capacidades multiusuario del sistema. Mientras estamos trabajando en la VC N&ordm; 1, podemos conmutar a la VC N&ordm; 2 y comenzar a trabajar en otra tarea (inclusive, claro está, con un nombre de usuario diferente), mientras el sistema continúa ejecutando la tarea de la VC N&ordm; 1.
   </p>

   </sect1>

   <sect1>
Comandos e intérpretes de comandos

   <p>
Un intérprete de comandos (también conocido como &ldquo;shell&rdquo;) es un programa que toma la entrada del usuario (por ejemplo, las órdenes que teclea) y las traduce a instrucciones del sistema operativo. Esto puede ser comparado con el <tt>COMMAND.COM</tt> de <em>DOS</em>, el cual efectúa esencialmente la misma tarea. El intérprete de comandos es sólo una de las interfaces con <em>Unix</em>. Hay muchas interfaces posibles, como la interfaz gráfica <em>X Window</em>, la cual permite ejecutar comandos usando el ratón y el teclado.
   </p>
   <p>
Tan pronto como un usuario ingresa al sistema, se ejecuta un intérprete de comandos y éste ya puede teclear órdenes al sistema. Veamos un ejemplo. Aquí, <tt>diego</tt> entra en el sistema y es situado en el intérprete de comandos:
   </p>
<p><quote>
<p>
<tt>micasa login: <em>diego</em></tt>
   </p>
   <p>
<tt>Password: </tt>
   </p>
   <p>
<tt>Welcome to micasa!</tt>
   </p>
   <p>
<tt>/home/diego$</tt>
   </p>
</quote></p>

   <p>
&ldquo;<tt>/home/diego$</tt>&rdquo; es el <em>prompt</em> (o indicador) del intérprete de comandos, indicando que está listo para recibir órdenes. Tratemos de decirle al sistema que haga algo interesante:
   </p>
<p><quote>
   <p>
<tt>/home/diego$ <em>make love</em></tt>
   </p>
   <p>
<tt>make: *** No rule to make target `love'. Stop.</tt>
   </p>
   <p>
<tt>/home/diego$</tt>
   </p>
</quote></p>

   <p>
Bien, como resulta que <tt>make</tt> es el nombre de un programa ya existente en el sistema, el intérprete de comandos lo ejecuta (desafortunadamente, el sistema no está siendo muy amigable).
   </p>
   <p>
Esto nos lleva a una cuestión importante: &iquest;Qué es una orden? &iquest;Qué ocurre cuando tecleamos &ldquo;<tt>make love</tt>&rdquo;? La primera palabra de la orden, &ldquo;<tt>make</tt>&rdquo;, es el nombre del comando a ejecutar. El resto de la orden es tomado como argumentos (o parámetros) de la comando. Por ejemplo:
   </p>
   <p>
/home/diego$ cp hola mundo
   </p>
   <p>
Aquí, el nombre del comando es &ldquo;<tt>cp</tt>&rdquo;, y los argumentos son &ldquo;<tt>hola</tt>&rdquo; y &ldquo;<tt>mundo</tt>&rdquo;.
   </p>
   <p>
Cuando se teclea una orden, el intérprete de comandos hace varias cosas. Primero, busca el nombre del comando y comprueba si es un comando interno (es decir, una comando que el propio intérprete de comandos sabe ejecutar por si mismo). Hay bastantes comandos de ese tipo que veremos mas adelante. El intérprete de comandos también comprueba si el comando es un &ldquo;alias&rdquo; o nombre sustituto de otro comando. Si no se cumple ninguno de estos casos, el intérprete de comandos busca el programa y lo ejecuta pasándole los argumentos especificados en la línea de comandos.
   </p>
   <p>
En nuestro ejemplo, el intérprete de comandos busca el programa llamado <tt>make</tt> y lo ejecuta con el argumento <tt>love</tt>. <tt>make</tt> es un programa usado a menudo para compilar programas grandes, y toma como argumentos el nombre de un &ldquo;objetivo&rdquo; a compilar. En el caso de &ldquo;<tt>make love</tt>&rdquo;, ordenamos a <tt>make</tt> que compile el objetivo <tt>love</tt>. Como <tt>make</tt> no puede encontrar un objetivo de ese nombre, falla enviando un mensaje de error y volviendo al intérprete de comandos.
   </p>
   <p>
&iquest;Qué ocurre si tecleamos un comando y el intérprete de comandos no puede encontrar el programa de ese nombre? Bien, probémoslo:
   </p>
<p><quote>
   <p><tt>/home/diego$ <em>hacer nada</em></tt></p>
   <p><tt>hacer: command not found</tt>
   <p><tt>/home/diego$</tt></p>
</quote></p>

   <p>
Bastante simple, si no se puede encontrar el programa con el nombre dado en la orden (aquí &ldquo;<tt>hacer</tt>&rdquo;), se muestra un mensaje de error que debería de ser auto-explicativo. A menudo verá este mensaje de error si se equivoca al teclear un comando (por ejemplo, si hubiese tecleado &ldquo;<tt>mkae love</tt>&rdquo; en lugar de &ldquo;<tt>make love</tt>&rdquo;).
   </p>

   </sect1>

   <sect1>
Saliendo del sistema

   <p>
Antes de proseguir, deberíamos ver cómo salir del sistema. Desde la línea de comandos usaremos el comando para salir. Hay otras formas, pero esta es la más simple:
   </p>
<p><quote>
   <p><tt>/home/diego$ <em>exit</em></tt></p>
</quote></p>

   </sect1>

   <sect1>
Cambiando la contraseña

   <p>
La primera vez que un usuario ingresa al sistema lo hará utilizando la contraseña asignada por el administrador, pero es altamente recomendable que la cambie de inmediato (además, se recomienda realizar este procedimiento de vez en cuando). El comando <tt>passwd</tt> nos pedirá la  contraseña actual y luego la nueva (dos veces, para validarla). Debemos tener cuidado de no olvidar la contraseña, ya que si esto ocurre, el administrador del sistema deberá modificarla por nosotros.
   </p>

   </sect1>

   <sect1>
Archivos y directorios

   <p>
En la mayoría de los sistemas operativos (<em>Unix</em> incluido), existe el concepto de archivo, el cual es un conjunto de información al que se le ha asignado un nombre.
   </p>
   <p>
Ejemplos de archivo son un mensaje de correo, o un programa que puede ser ejecutado. Esencialmente, cualquier cosa almacenada en el disco es guardada en un archivo individual.
   </p>
   <p>
Los archivos son identificados por sus nombres. Por ejemplo, el archivo que contiene sus números telefónicos podría ser grabado con el nombre &ldquo;<tt>telefonos</tt>&rdquo;.<footnote>Generalmente trataremos de utilizar letras minúsculas y sin acentos en los nombres de archivos y directorios.</footnote> Estos nombres usualmente identifican el archivo y su contenido de alguna forma significativa para usted. No hay un formato estándar para los nombres de los archivos como lo hay en <em>DOS</em> y en otros sistemas operativos; en general estos pueden contener cualquier carácter (excepto &ldquo;<tt>/</tt>&rdquo;), y están limitados a 256 caracteres de longitud.
   </p>
   <p>
Con el concepto de archivo aparece el concepto de directorio. Un directorio es contenedor. Puede ser considerado como una &ldquo;carpeta&rdquo; que contiene muchos archivos diferentes. Tienen nombre con el que los podemos identificar y forman una estructura de árbol; es decir, pueden contener a otros directorios.
   </p>
   <p>
Un archivo puede ser referenciado por su nombre con camino, el cual esta constituido por su nombre, antecedido por el nombre del directorio que lo contiene. Por ejemplo, supongamos que <tt>diego</tt> tiene un directorio de nombre <tt>articulos</tt> que contiene tres archivos: <tt>historia</tt>, <tt>ingles</tt> y <tt>tesis</tt> (cada uno de los tres archivos contiene información sobre tres de los proyectos en los que está trabajando). Para referirse al archivo <tt>ingles</tt>, puede especificar su camino: <tt>articulos/ingles</tt>
   </p>
   <p>
Como podemos ver, el directorio y el nombre del archivo van separados por un carácter &ldquo;<tt>/</tt>&rdquo;. Por esta razón, los nombres de archivo no pueden contener este carácter. Los usuarios de <em>DOS</em> encontrarán esta convención familiar, aunque en ese sistema operativo se usa el carácter &ldquo;<tt>&bsol;</tt>&rdquo;.
   </p>
   <p>
Como hemos mencionado, los directorios pueden anidarse uno dentro de otro. Por ejemplo, supongamos que <tt>diego</tt> tiene otro directorio dentro de <tt>articulos</tt> llamado <tt>notas</tt>, y dentro de ese directorio, tiene un archivo llamado <tt>enlaces</tt>. El camino de este archivo sería: <tt>articulos/notas/enlaces</tt>
   </p>
   <p>
Por lo tanto, el camino realmente es la &ldquo;ruta&rdquo; (<em>path</em>) que se debe recorrer para localizar a un archivo. El directorio sobre un subdirectorio dado es conocido como el directorio padre. Aquí, el directorio <tt>articulos</tt> es el padre del directorio <tt>notas</tt>.
   </p>

   </sect1>

   <sect1>
El árbol de directorios

   <p>
La mayoría de los sistemas <em>Unix</em> tienen una distribución de archivos estándar, de forma que los recursos y archivos puedan ser fácilmente localizados. Esta distribución forma el árbol de directorios, el cual comienza en el directorio &ldquo;<tt>/</tt>&rdquo;, también conocido como &ldquo;raíz&rdquo; o &ldquo;<em>root</em>&rdquo;.<footnote>
No debemos confundir el directorio &ldquo;<em>root&rdquo;</em> o &ldquo;<em>raíz&rdquo;</em> con el usuario &ldquo;<tt>root</tt>&rdquo; que es el administrador del sistema, ni con el directorio &ldquo;<em>home</em>&rdquo; de éste último, ubicado en &ldquo;<tt>/root</tt>&rdquo;.
</footnote> Directamente por debajo (dentro) de <tt>/</tt> hay algunos subdirectorios importantes: <tt>/bin</tt>, <tt>/etc</tt>, <tt>/dev</tt> y <tt>/usr</tt>, entre otros. Estos a su vez contienen otros directorios con archivos de configuración del sistema, programas, etc.
   </p>
   <p>
En particular, cada usuario tiene un directorio &ldquo;<em>home</em>&rdquo;. Este es el directorio en el que el usuario guardará sus archivos. En los ejemplos anteriores, todos los archivos de <tt>diego</tt> (como <tt>enlaces</tt> y <tt>historia</tt>) estaban contenidos en su directorio &ldquo;<em>home</em>&rdquo;. Usualmente, los directorios &ldquo;<em>home</em>&rdquo; de los usuarios cuelgan de <tt>/home</tt> y son denominados con el nombre del usuario al que pertenecen. Por lo tanto, el directorio &ldquo;<em>home</em>&rdquo; de <tt>diego</tt> es <tt>/home/diego</tt>.
   </p>
   <p>
La siguiente figura muestra un árbol de directorio de ejemplo.
   </p>
<p>
<verb>/ ___ bin
|____ dev
|____ etc
|____ home ___ carlos
|        |____ diego ___ Mail 
|                  |____ articulos ___ notas
|                  |____ cartas
|____ lib
|____ proc
|____ tmp
|____ usr ___ X11R6
        |____ bin
        |____ lib
        |____ local ___ bin
        |         |____ etc
        |____ man
        |____ src ___ linux
        |____ tmp 
</verb>
</p>
   </sect1>

   <sect1>
Directorio de trabajo actual
   <p>
Las órdenes que teclee al intérprete de comandos son dadas en términos del directorio actual de trabajo, en donde estamos situados. Cuando un usuario entra al sistema, su directorio de trabajo se inicial es su directorio &ldquo;<em>home</em>&rdquo; (<tt>/home/diego</tt> en nuestro caso). Cuando referencie a un archivo puede hacerlo con relación a su directorio de trabajo actual, en lugar de especificar el camino completo del archivo.
   </p>
   <p>
Veamos un ejemplo: <tt>diego</tt> tiene el directorio <tt>articulos</tt>, y <tt>articulos</tt> contiene el archivo <tt>historia</tt>.
   </p>
   <p>
Si deseamos ver el contenido de ese archivo, podemos usar la orden:
   </p>
   <p>
<quote><p><tt>/home/diego$ <em>cat /home/diego/articulos/historia</em></tt></p></quote>
   </p>
   <p>
El comando <tt>cat</tt> muestra el contenido del archivo. Pero como el directorio de trabajo actual es <tt>/home/diego</tt>, podríamos habernos referido al archivo de forma relativa a su directorio de trabajo actual. La orden sería:
   </p>
   <p>
<quote><p><tt>/home/diego$ <em>cat articulos/historia</em></tt></p></quote>
   </p>
   <p>
Por lo tanto, si un camino comienza (como <tt>articulos/historia</tt>) con un carácter distinto a &ldquo;<tt>/</tt>&rdquo;, el sistema supone que se está refiriendo al archivo con su posición relativa a su directorio de trabajo. Esto es conocido como &ldquo;camino relativo&rdquo;.
   </p>
   <p>
Por otra parte, si un camino comienza con el carácter &ldquo;<tt>/</tt>&rdquo;, el sistema interpreta esto como el camino completo al archivo partiendo desde el directorio raíz (<tt>/</tt>). Esto es conocido como &ldquo;camino absoluto&rdquo;.
   </p>

   </sect1>

   <sect1>
Refiriéndose al directorio &ldquo;<em>home</em>&rdquo;
   <p>
Bajo <tt>bash</tt> y <tt>tcsh</tt>, dos de los intérpretes de comandos más utilizados, el directorio &ldquo;<em>home</em>&rdquo; puede ser referenciado usando el carácter de la tilde (&ldquo;<tt>&tilde;</tt>&rdquo;). Por ejemplo, la orden:
   </p>
   <p>
<quote><p><tt>/home/diego$ <em>cat &tilde;/articulos/historia</em></tt></p></quote>
   </p>
   <p>
es equivalente a:
   </p>
   <p>
<quote><p><tt>/home/diego$ <em>cat /home/diego/articulos/historia</em></tt></p></quote>
   </p>
   <p>
El carácter &ldquo;&tilde;&rdquo; es sustituido por el intérprete de comandos con el nombre del directorio &ldquo;<em>home</em>&ldquo;. El uso de la tilde es simplemente un atajo; no existe ningún directorio llamado &ldquo;&tilde;&rdquo;, sólo es una ayuda sintáctica proporcionada por el intérprete de comandos.
   </p>

   </sect1>


  </sect>

  <sect>
Primeros pasos en <em>GNU/Linux</em>
  <p>
Antes de comenzar es importante destacar que todos los nombres de archivos y comandos son &ldquo;<em>case-sensitive</em>&rdquo; (hacen diferencia entre mayúsculas y minúsculas, lo cual no ocurre en sistemas operativos como <em>DOS</em>). Por ejemplo, el comando &ldquo;<tt>make</tt>&rdquo; es diferente a &ldquo;<tt>Make</tt>&rdquo; o &ldquo;<tt>MAKE</tt>&rdquo;. Lo mismo ocurre en el caso de nombres de archivos o directorios.
  </p>
   <sect1>
Moviéndonos por el entorno
   <p>
Ahora que ya podemos presentarnos como usuarios y sabemos como indicar archivos con su camino completo, &iquest;cómo podemos cambiar nuestro directorio de trabajo?
   </p>
   <p>
El comando para movernos por la estructura de directorios es <tt>cd</tt>, abreviación de &ldquo;cambio de directorio&rdquo;. Hay que destacar, que la mayoría de los comandos <em>Unix</em> más usados son de dos o tres letras. La forma de uso del comando <tt>cd</tt> es:
   </p>
<p><quote><p><tt>cd &lt;directorio&gt;</tt></p></quote></p>
   <p>
donde <tt>&lt;directorio&gt;</tt> es el nombre del directorio al que queremos ingresar.
   </p>
   <p>
Como ya vimos, al entrar al sistema comenzamos en el directorio &ldquo;<em>home&rdquo;</em>. Si queremos ir al subdirectorio <tt>articulos</tt>, deberíamos usar la orden:
   </p>
<p><quote><p><tt>/home/diego$ <em>cd articulos</em></tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
   </p>
   <p>
Como podemos ver, el prompt cambia para mostrar el directorio actual de trabajo. Ahora que ya estamos en el directorio <tt>articulos</tt> podemos ver el contenido del archivo <tt>historia</tt> con el comando:
   </p>
   <p>
<quote><p><tt>/home/diego/articulos$ <em>cat historia</em></tt></p></quote>
   </p>
   <p>
Ahora estamos en el subdirectorio <tt>articulos</tt>. Para volver al directorio padre de éste, usamos la orden:
   </p>
   <p>
<quote><p><tt>/home/diego/articulos$ <em>cd ..</em></tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
   </p>
   <p>
(Nótese el espacio entre &ldquo;<tt>cd</tt>&rdquo; y &ldquo;<tt>..</tt>&rdquo;). Cada directorio tiene una entrada de nombre &ldquo;<tt>..</tt>&rdquo; la cual se refiere al directorio padre. De igual forma, existe en cada directorio la entrada &ldquo;<tt>.</tt>&rdquo; la cual se refiere a sí mismo. Así que el siguiente comando nos deja donde estamos:
   </p>
   <p>
<quote><p><tt>/home/diego/articulos$ <em>cd .</em></tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
   </p>
   <p>
También pueden usarse nombres con el camino absoluto en el comando <tt>cd</tt>. Para ir al directorio de <tt>carlos</tt> con <tt>cd</tt>, introduciremos la siguiente orden:<footnote>Siempre y cuando tengamos permiso para ingresar a dicho directorio, como veremos más adelante.</footnote>
   </p>
   <p>
<quote><p><tt>/home/diego/articulos$ <em>cd /home/carlos</em></tt></p>
<p><tt>/home/carlos$</tt></p>
</quote>
   </p>
   <p>
También, usando <tt>cd</tt> sin argumentos nos llevará a nuestro directorio &ldquo;<em>home</em>&rdquo;:
   </p>
   <p>
<quote><p><tt>/home/carlos$ <em>cd</em></tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
   </p>

   </sect1>

   <sect1>
Viendo el contenido de los directorios
   <p>
El simple movimiento por el árbol de directorios es poco útil, necesitamos un nuevo comando: <tt>ls</tt>. Este comando muestra en pantalla la lista de archivos y directorios, si no se indica otra cosa, del directorio activo. Por ejemplo:<footnote>Nótese que los listados aparecen ordenados alfabéticamente. Las letras mayúsculas son &ldquo;menores&rdquo; a las minúsculas.</footnote>
   </p>
   <p>
<quote><p><tt>/home/diego$ <em>ls</em></tt></p>
<p><tt>Mail</tt></p>
<p><tt>articulos</tt></p>
<p><tt>cartas</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
   </p>
   <p>
Aquí podemos ver que <tt>diego</tt> tiene tres entradas en su directorio actual: <tt>Mail</tt>, <tt>articulos</tt> y <tt>cartas</tt>. Esto no nos dice demasiado, &iquest;son archivos o directorios? Podemos usar la opción &ldquo;<tt>-F</tt>&rdquo; del comando <tt>ls</tt> para obtener mas información.
   </p>
   <p>
<quote>
<p><tt>/home/diego$ <em>ls -F</em></tt></p>
<p><tt>Mail/</tt></p>
<p><tt>articulos/</tt></p>
<p><tt>cartas/</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
   </p>
   <p>
Por el carácter &ldquo;<tt>/</tt>&rdquo; añadido al final de  cada nombre sabemos que las tres entradas son directorios. La orden &ldquo;<tt>ls -F</tt>&rdquo; puede también añadir al final un asterisco (&ldquo;<tt>*</tt>&rdquo;), esto indica que es un archivo ejecutable (programa). Si &ldquo;<tt>ls -F</tt>&rdquo; no añade nada, entonces es un archivo normal.
   </p>
   <p>
Por lo general cada comando <em>Unix</em> puede tomar una serie de opciones definidas en forma de argumentos. Estos usualmente comienzan con el carácter &ldquo;<tt>-</tt>&rdquo;<footnote>Similar al uso del carácter &ldquo;<tt>/</tt>&rdquo; en <em>DOS</em>.</footnote>, tal como vimos antes con <em>&ldquo;ls -F</em>&rdquo;. La opción &ldquo;<tt>-F</tt>&rdquo; le dice a <tt>ls</tt> que dé información sobre el tipo de cada entrada.
   </p>
   <p>
Si a <tt>ls</tt> le pasamos un nombre de directorio, mostrará su contenido:
   </p>
   <p>
<quote>
<p><tt>/home/diego$ <em>ls -F articulos</em></tt></p>
<p><tt>ingles</tt></p>
<p><tt>historia</tt></p>
<p><tt>tesis</tt></p>
<p><tt>notas/</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
  </p>
  <p>
Para ver un listado más interesante, veamos el contenido del directorio <tt>/etc</tt>.
   </p>
<p><quote>
   <p>
<tt>/home/diego$ <em>ls /etc</em></tt>
   </p>
   <p>
<verb>
Images		ftpusers	lpc		rc.new		shells
adm		getty		magic		rc0.d		startcons
bcheckrc	gettydefs	motd		rc1.d		swapoff
brc		group		mount		rc2.d		swapon
brc~		inet		mtab		rc3.d		syslog.conf
csh.cshrc	init		mtools		rc4.d		syslog.pid
csh.login	init.d		pac		rc5.d		syslogd.reload
default		initrunlvl 	passwd		rmt		termcap
disktab		inittab		printcap	rpc		umount
fdprm		inittab.old	profile		rpcinfo		update
fstab		issue		psdatabase	securetty	utmp
ftpaccess	lilo		rc		services	wtmp
</verb>
   </p>
   <p>
<tt>/home/diego$</tt>
   </p>
</quote></p>
   <p>
Los usuarios de <em>DOS</em> notarán que los nombres de los archivos pueden ser más largos que 11 caracteres (8 del nombre y 3 de la extensión) y pueden contener puntos en cualquier posición.<footnote>En <em>Unix</em> no existe el concepto de &ldquo;extensión&rdquo; de un archivo. Es solamente una convención que el nombre de algunos archivos termine con un punto y alguna secuencia de letras (no necesariamente tres) que denoten su tipo.</footnote> Incluso es posible que un archivo contenga más de un punto en su nombre.
   </p>
   <p>
Vayamos al directorio raíz con &ldquo;<tt>cd ..</tt>&rdquo; y desde allí vayamos al directorio <tt>/usr/bin</tt>:
   </p>
   <p>
<quote>
<p><tt>/home/diego$ <em>cd ..</em></tt></p>
<p><tt>/home$ <em>cd ..</em></tt></p>
<p><tt>/$ <em>cd usr</em></tt></p>
<p><tt>/usr$ <em>cd bin</em></tt></p>
<p><tt>/usr/bin$</tt></p>
</quote>
</p>
   <p>
También podemos movernos dentro de directorios en múltiples pasos, como en &ldquo;<tt>cd /usr/bin</tt>&rdquo;. Tratemos de movernos por varios directorios usando <tt>cd</tt> y de ver su contenido con <tt>ls</tt>. En algunos casos podremos encontrarnos con el desagradable mensaje de error &ldquo;Permission denied&rdquo; (permiso denegado). Esto se debe a cuestiones de seguridad del sistema. Para moverse o listar un directorio debemos de tener una serie de permisos. Hablaremos sobre ello más adelante.
   </p>

   </sect1>

   <sect1>
Creando directorios
   <p>
Es el momento de aprender a crear directorios. Para ello se usa el comando  <tt>mkdir</tt>. Probemos lo siguiente:
   </p>
   <p>
<quote>
<p><tt>/home/diego$ <em>mkdir nuevo</em></tt></p>
<p><tt>/home/diego$ <em>ls -F</em></tt></p>
<p><tt>Mail/</tt></p>
<p><tt>articulos/</tt></p>
<p><tt>cartas/</tt></p>
<p><tt>nuevo/</tt></p>
<p><tt>/home/diego$ <em>cd nuevo</em></tt></p>
<p><tt>/home/diego/nuevo$ <em>ls</em></tt></p>
<p><tt>/home/diego/nuevo$</tt></p>
</quote>
   </p>

   <p>
Acabamos de crear un directorio nuevo y movernos dentro de él. Como no contiene ningún archivo, veamos cómo copiar archivos desde un lugar a otro.
   </p>

   </sect1>

   <sect1>
Copiando archivos
   <p>
La copia de archivos es efectuada por el comando <tt>cp</tt>:
   </p>
   <p>
<quote>
<p><tt>/home/diego/nuevo$ <em>cp /etc/termcap .</em></tt></p>
<p><tt>/home/diego/nuevo$ <em>cp /etc/shells .</em></tt></p>
<p><tt>/home/diego/nuevo$ <em>ls -F</em></tt></p>
<p><tt>shells termcap</tt></p>
<p><tt>/home/diego/nuevo$ <em>cp shells bells</em></tt></p>
<p><tt>/home/diego/nuevo$ <em>ls -F</em></tt></p>
<p><tt>bells shells termcap</tt></p>
<p><tt>/home/diego/nuevo$</tt></p>
</quote>
</p>

   <p>
El comando <tt>cp</tt> copia los archivos listados en la línea de comandos al archivo o directorio pasado como último argumento. Nótese que usamos el directorio &ldquo;<tt>.</tt>&rdquo; para referirnos al directorio actual.
   </p>

   </sect1>

   <sect1>
Moviendo archivos
   <p>
El comando <tt>mv</tt> mueve archivos en lugar de copiarlos. La sintaxis es muy sencilla:
   </p>
   <p>
<quote>
<p><tt>/home/diego/nuevo$ <em>mv termcap sells</em></tt></p>
<p><tt>/home/diego/nuevo$ <em>ls -F</em></tt></p>
<p><tt>bells sells shells</tt></p>
<p><tt>/home/diego/nuevo$</tt></p>
</quote>
   <p>
Nótese como <tt>termcap</tt> ya no existe, y en su lugar está el archivo <tt>sells</tt>. Este comando puede usarse para renombrar archivos, como acabamos de hacer, pero también para mover archivos a directorios diferentes.
   </p>
   <p>
<bf>Nota:</bf> <tt>mv</tt> y <tt>cp</tt> sobreescribirán los archivos destino (si ya existen) sin consultar. Sea cuidadoso cuando mueva un archivo a otro directorio: puede haber ya un archivo con el mismo nombre que será sobreescrito y su contenido se perderá para siempre.
   </p>

   </sect1>

   <sect1>
Borrando archivos y directorios
   <p>
Para borrar un archivo, usamos el comando <tt>rm</tt>.
   </p>
   <p>
<quote>
<p><tt>/home/diego/nuevo$ <em>rm bells sells</em></tt></p>
<p><tt>/home/diego/nuevo$ <em>ls -F</em></tt></p>
<p><tt>shells</tt></p>
<p><tt>/home/diego/nuevo$</tt></p>
</quote>
  </p>
   <p>
En el directorio <tt>nuevo</tt> sólo ha quedado el archivo <tt>shells</tt>. Nótese que <tt>rm</tt> por defecto no preguntará antes de borrar un archivo, por lo tanto debemos ser muy cuidadosos.
   </p>
   <p>
Un comando relacionado con <tt>rm</tt> es <tt>rmdir</tt>. Éste borra un directorio, pero sólo si está vacío. Si el directorio contiene archivos o subdirectorios, nos informará del error.
   </p>

   </sect1>

   <sect1>
Viendo el contenido de archivos
   <p>
Los comandos <tt>cat</tt> y <tt>less</tt> son usados para ver el contenido de archivos. <tt>less</tt> muestra el archivo pantalla a pantalla, permitiéndonos movernos hacia adelante y atrás, mientras que <tt>cat</tt> lo muestra completo de una vez.
   </p>
   <p>
Para ver el contenido del archivo <tt>shells</tt> podemos usar la orden:
   </p>
   <p>
<quote><p><tt>/home/diego/nuevo$ <em>less shells</em></tt></p></quote>
   </p>
   <p>
Durante la ejecución de <tt>less</tt> podemos usar <tt>&lsqb;RePág&rsqb;</tt> y <tt>&lsqb;AvPág&rsqb;</tt><footnote><tt>&lsqb;PgUp&rsqb;</tt> y <tt>&lsqb;PgDown&rsqb;</tt> en los teclados en inglés</footnote> para retroceder y avanzar por páginas, y las teclas de cursor hacia arriba y abajo para retroceder y avanzar por líneas. <tt>&lsqb;Q&rsqb;</tt> finalizará la ejecución de <tt>less</tt>. Hay otros comandos disponibles, los citados son sólo los más básicos.
   </p>
   <p>
Salgamos de <tt>less</tt> y probemos &ldquo;<tt>cat /etc/termcap</tt>&rdquo;. El texto probablemente pasará demasiado rápido como para poder leerlo. El comando <tt>cat</tt>; viene de &ldquo;concatenar&rdquo;, que es para lo que realmente sirve, pero también puede ser usado para concatenar el contenido de varios archivos. Esto se verá mas adelante.
   </p>

   </sect1>

   <sect1>
Obteniendo ayuda en línea
   <p>
Prácticamente cada sistema <em>Unix</em> proporciona una utilidad conocida como &ldquo;páginas de manual&rdquo;. Estas páginas contienen documentación en línea para todos los comandos del sistema, recursos, archivos de configuración, etc. El comando usado para acceder a las páginas de manual es <tt>man</tt>. Por ejemplo, si estamos interesados en conocer otras opciones del comando <tt>ls</tt>, podemos escribir:
   </p>
   <p>
<quote><p><tt>/home/diego$ <em>man ls</em></tt></p></quote>
   </p>
   <p>
y veremos la página de manual para <tt>ls</tt>.
   </p>
   <p>
Desafortunadamente para los principiantes, la mayoría de las páginas de manual contienen detalles técnicos del comando sin ningún ejemplo ni explicación adicional acerca de su uso. Pese a esto, estas páginas son una gran fuente de información que permiten refrescar la memoria si olvidamos la sintaxis de un comando.<footnote>Una respuesta muy común a una pregunta de un principiante en un foro de <em>Unix</em> será &ldquo;RTFM&rdquo;, por &ldquo;<em>Read The F*****g Manual</em>&rdquo;.</footnote> Pruebe <tt>man</tt> con los comandos que ya hemos tratado y con los que vayamos introduciendo. Notará que alguno de los comandos no tiene página de manual. Esto puede deberse a diferentes motivos. El comando puede ser interna del intérprete de comandos (como el caso de <tt>cd</tt>), o un &quot;alias&quot; (renombre de otro comando), en cuyo caso no tendrán una página propia.
   </p>

   </sect1>


  </sect>

  <sect>
Sumario de comandos básicos
  <p>
Esta sección introduce algunas de los comandos básicas más útiles de un sistema <em>Unix</em>, incluidos los ya cubiertos en las secciones anteriores.
  </p>
  <p>
Nótese que las opciones usualmente comienzan con &ldquo;<tt>-</tt>&rdquo; y en la mayoría de los casos se pueden añadir múltiples opciones de una letra con un único &ldquo;<tt>-</tt>&rdquo;. Por ejemplo, en lugar de usar &ldquo;<tt>ls -l -F</tt>&rdquo; es posible usar &ldquo;<tt>ls -lF</tt>&rdquo;. En lugar de listar todas las opciones disponibles para cada uno de los comandos sólo hablaremos de aquellas más útiles o importantes. De hecho, la mayoría de los comandos tienen un gran número de opciones. Puede usar <tt>man</tt> para ver las páginas de manual de cada comando, la cual le mostrará la lista completa de opciones disponibles.
  </p>
  <p>
Nótese también, que la mayoría de los comandos toman una lista de archivos o directorios como argumentos, denotados como &ldquo;<tt>&lt;archivo1&gt; ... &lt;archivoN&gt;</tt>&rdquo;. Por ejemplo, el comando <tt>cp</tt> toma como argumentos la lista de archivos a copiar, seguidos del archivo o directorio destino. Cuando se copia o mueve más de un archivo, el destino <tt>&lt;archivoN&gt;</tt> debe ser un directorio.
  </p>
<sect1>
Operaciones sobre directorios

<p>
<descrip>
<tag><tt>cd</tt></tag><p>Cambia el directorio de trabajo actual.</p>
<p>Sintaxis: <tt>cd &lt;directorio&gt;</tt></p>
<p><tt>&lt;directorio&gt;</tt> es el directorio al que cambiamos. (&ldquo;<tt>.</tt>&rdquo; se refiere al directorio actual, &ldquo;<tt>..</tt>&rdquo; al directorio padre.)</p>
<p>Ejemplo: &ldquo;<tt>cd ../nuevo</tt>&rdquo; pone &ldquo;<tt>../nuevo</tt>&rdquo; como directorio actual.</p>

<tag><tt>ls</tt></tag><p>Muestra información sobre los archivos o directorios indicados.</p>
<p>Sintaxis: <tt>ls &lt;archivo1&gt; &lt;archivo2&gt; ... &lt;archivoN&gt;</tt></p>
<p>Donde <tt>&lt;archivo1&gt;</tt> a <tt>&lt;archivoN&gt;</tt> son los archivos o directorios a listar.</p>
<p>Opciones: Éste comando tiene gran cantidad de opciones. Las más usadas son: <tt>-F</tt> (muestra información sobre el tipo de archivo) y <tt>-l</tt> (da un listado &ldquo;largo&rdquo; incluyendo tamaño, propietario, permisos, etc.).</p>
<p>Ejemplo: &ldquo;<tt>ls -lF /home/diego</tt>&rdquo; mostrará el contenido del directorio &ldquo;<tt>/home/diego</tt>&rdquo;.</p>

<tag><tt>mkdir</tt><p>Crea directorios.</p>
<p>Sintaxis: <tt>mkdir &lt;dir1&gt; &lt;dir2&gt; ...&lt;dirN&gt;</tt></p>
<p>Donde <tt>&lt;dir1&gt;</tt> a <tt>&lt;dirN&gt;</tt> son los directorios a crear.</p>
<p>Ejemplo: &ldquo;<tt>mkdir /home/diego/prueba</tt>&rdquo; crea el directorio &ldquo;<tt>prueba</tt>&rdquo; dentro de &ldquo;<tt>/home/diego</tt>&rdquo;.</p>

<tag><tt>rmdir</tt><p>Borra directorios vacíos. El directorio de trabajo actual no debe de estar dentro del directorio a borrar.</p>
<p>Sintaxis: <tt>rmdir &lt;dir1&gt; &lt;dir2&gt; ... &lt;dirN&gt;</tt></p>
<p>Donde <tt>&lt;dir1&gt;</tt> a <tt>&lt;dirN&gt;</tt> son los directorios a borrar.</p>
<p>Ejemplo: &ldquo;<tt>rmdir /home/diego/articulos</tt>&rdquo; borra el directorio &ldquo;<tt>/home/diego/articulos</tt>&rdquo; si está vacío.</p>
</descrip>
</p>
</sect1>

<sect1>
Operaciones sobre archivos

<p>
<descrip>
<tag><tt>cp</tt></tag><p>Copia archivos.</p>
<p>Sintaxis: <tt>cp &lt;archivo1&gt; &lt;archivo2&gt; ... &lt;archivoN&gt; &lt;destino&gt;</tt></p>
<p>Donde <tt>&lt;archivo1&gt;</tt> a <tt>&lt;archivoN&gt;</tt> son los archivos a copiar y <tt>&lt;destino&gt;</tt> es el archivo o directorio destino.</p>
<p>Ejemplo: &ldquo;<tt>cp ../primero segundo</tt>&rdquo; copia el archivo &ldquo;<tt>../primero</tt>&rdquo; al archivo o directorio &ldquo;<tt>segundo</tt>&rdquo;.</p>

<tag><tt>mv</tt></tag><p>Mueve archivos. Es equivalente a una copia seguida del borrado del original.Puede ser usado para renombrar archivos.</p>
<p>Sintaxis: <tt>mv &lt;archivo1&gt; &lt;archivo2&gt; ... &lt;archivoN&gt; &lt;destino&gt;</tt></p>
<p>Donde <tt>&lt;archivo1&gt;</tt> a <tt>&lt;archivoN&gt;</tt> son los archivos a mover y <tt>&lt;destino&gt;</tt> es el archivo o directorio destino.</p>
<p>Ejemplo: &ldquo;<tt>mv ../primero segundo</tt>&rdquo; mueve el archivo &ldquo;<tt>../primero</tt>&rdquo; al archivo o directorio &ldquo;<tt>segundo</tt>&rdquo;.</p>

<tag><tt>rm</tt></tag><p>Borra archivos (de forma irrecuperable).</p>
<p>Sintaxis: <tt>rm &lt;archivo1&gt; &lt;archivo2&gt; ... &lt;archivoN&gt;</tt></p>
<p>Donde <tt>&lt;archivo1&gt;</tt> a <tt>&lt;archivoN&gt;</tt> son los nombres de los archivos a borrar.</p>
<p>Opciones: <tt>-i</tt> pedirá confirmación antes de borrar un archivo.</p>
<p>Ejemplo: &ldquo;<tt>rm -i /home/diego/primero /home/diego/segundo</tt>&rdquo; borra los archivos &ldquo;<tt>primero</tt>&rdquo; y &ldquo;<tt>segundo</tt>&rdquo; en &ldquo;<tt>/home/diego</tt>&rdquo;.</p>

<tag><tt>cat</tt><p>Concatena archivos. También es usado para mostrar el contenido completo de un archivo.</p>
<p>Sintaxis: <tt>cat &lt;archivo1&gt; &lt;archivo2&gt; ... &lt;archivoN&gt;</tt></p>
<p>Donde <tt>&lt;archivo1&gt;</tt> a <tt>&lt;archivoN&gt;</tt> son los archivos a mostrar.</p>
<p>Ejemplo: &ldquo;<tt>cat cartas/mi-novia</tt>&rdquo; muestra por la pantalla el contenido del archivo <tt>mi-novia</tt> que se encuentra en el directorio <tt>cartas</tt>.</p>
</descrip>
</p>
</sect1>

<sect1>
Otras utilidades

<p>
<descrip>


<tag><tt>less</tt><p>Muestra el contenido de los archivos indicados, una pantalla cada vez.</p>
<p>Sintaxis: <tt>less &lt;archivo1&gt; &lt;archivo2&gt; ... &lt;archivoN&gt;</tt></p>
<p>Donde <tt>&lt;archivo1&gt;</tt> a <tt>&lt;archivoN&gt;</tt> son los archivos a mostrar.</p>
<p>Ejemplo: &ldquo;<tt>less articulos/historia</tt>&rdquo; muestra por la pantalla el contenido del archivo &ldquo;<tt>historia</tt>&rdquo; dentro del directorio &ldquo;<tt>articulos</tt>&rdquo;.</p>


<tag><tt>man</tt><p>Muestra la página de manual del comando o recurso (función de librería, archivo de configuración) dado.</p>
<p>Sintaxis: <tt>man &lt;comando&gt;</tt></p>
<p>Donde <tt>&lt;comando&gt;</tt> es el nombre del comando o recurso sobre el que queremos obtener información.</p>
<p>Ejemplo: &ldquo;<tt>man ls</tt>&rdquo; muestra ayuda sobre el comando &ldquo;<tt>ls</tt>&rdquo;.</p>


<tag><tt>grep</tt><p>Muestra todas las líneas de un archivo dado que coinciden con un cierto patrón.</p>
<p>Sintaxis: <tt>grep &lt;patrón&gt; &lt;archivo1&gt; &lt;archivo2&gt; ... &lt;archivoN&gt;</tt></p>
<p>Donde <tt>&lt;patrón&gt;</tt> es una expresión regular<footnote>Las <em>expresiones regulares</em> son una forma de describir un conjunto de cadenas.</footnote> y <tt>&lt;archivo1&gt;</tt> a <tt>&lt;archivoN&gt;</tt> son los archivos donde buscar.</p>
<p>Ejemplo: &ldquo;<tt>grep micasa /etc/hosts</tt>&rdquo; mostrará todas las líneas en el archivo <tt>/etc/hosts</tt> que contienen la cadena &ldquo;micasa&rdquo;.</p>
</descrip>
</p>
</sect1>

  </sect>

  <sect>
Caracteres &ldquo;comodín&rdquo;
  <p>
Una característica importante de la mayoría de los intérpretes de comandos en <em>Unix</em> es la capacidad para referirse a más de un archivo usando <em>expresiones regulares</em>. En su forma más simple, esto consiste en la utilización de los llamados &ldquo;comodines&rdquo; que permiten referirse a, por ejemplo, todos los archivos cuyo nombre contiene una determinada secuencia de caracteres.
  </p>

<sect1>
Los comodines &ldquo;<tt>*</tt>&rdquo; y &ldquo;<tt>?</tt>&rdquo;

  <p>
El comodín &ldquo;<tt>*</tt>&rdquo; hace referencia cualquier cadena de caracteres en el nombre del archivo. Cuando se usa el carácter &ldquo;<tt>*</tt>&rdquo; para referirse al nombre de un archivo, el intérprete de comandos lo sustituye por todas las combinaciones posibles provenientes de los archivos en el directorio al cual nos estamos refiriendo.
  </p>
  <p>
Veamos un ejemplo rápido. Supongamos que <tt>diego</tt> tiene los archivos <tt>hugo</tt>, <tt>paco</tt> y <tt>luis</tt> en el directorio actual.
  </p>
  <p>
<quote>
<p><tt>/home/diego$ <em>ls</em></tt></p>
<p><tt>hugo luis paco</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
  </p>
<p>Para listar todos los archivos con la letra &ldquo;<tt>o</tt>&rdquo; en su nombre, usamos la orden:
  </p>
<p>
<quote>
<p><tt>/home/diego$ <em>ls *o*</em></tt></p>
<p><tt>hugo paco</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
  </p>
  <p>
Como podemos ver, el comodín &ldquo;<tt>*</tt>&rdquo; ha sido sustituido con todas las combinaciones posibles que coincidían de entre los archivos del directorio actual.
  </p>
  <p>
El uso de &ldquo;<tt>*</tt>&rdquo; solo, hace referencia a todos los archivos, puesto que todos los caracteres coinciden con el comodín.
  </p>
  <p>
<quote>
<p><tt>/home/diego$ <em>ls *</em></tt></p>
<p><tt>hugo luis paco</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
  </p>
  <p>
Veamos algunos otros ejemplos:
  </p>
  <p>
<quote>
<p><tt>/home/diego$ <em>ls h*</em></tt></p>
<p><tt>hugo</tt></p>
<p><tt>/home/diego$ <em>ls *is</em></tt></p>
<p><tt>luis</tt></p>
<p><tt>/home/diego$ <em>ls *u*</em></tt></p>
<p><tt>hugo luis</tt></p>
<p><tt>/home/diego$ <em>ls p*o</em></tt></p>
<p><tt>paco</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
  </p>
  <p>
El proceso de la sustitución de caracteres como &ldquo;<tt>*</tt>&rdquo; en nombres de archivos es llamado &ldquo;<em>expansión de comodines</em>&rdquo; y es efectuado por el intérprete de comandos. Esto es importante: los comandos, como <tt>ls</tt>, nunca ven el &ldquo;<tt>*</tt>&rdquo; en su lista de parámetros. Es el intérprete quien expande los comodines para incluir todos los nombres de archivos que se adaptan. Por lo tanto la orden:
  </p>
  <p>
<quote><p><tt>/home/diego$ <em>ls *o*</em></tt></p></quote>
  </p>
  <p>
es expandida para obtener
  </p>
  <p>
<quote><p><tt>/home/diego$ <em>ls hugo paco</em></tt></p></quote>
  </p>
  <p>
Otro carácter comodín es &ldquo;<tt>?</tt>&rdquo;. Este carácter comodín sólo expande un único carácter. Luego &ldquo;<tt>ls ?</tt>&rdquo; mostrará todos los nombres de archivos con un carácter de longitud, y &ldquo;<tt>ls termca?</tt>&rdquo;, por ejemplo, mostrará &ldquo;<tt>termcap</tt>&rdquo; pero no &ldquo;<tt>termcap.backup</tt>&rdquo;. Aquí tenemos otro ejemplo:
  </p>
  <p>
<quote>
<p><tt>/home/diego$ <em>ls hu?o</em></tt></p>
<p><tt>hugo</tt></p>
<p><tt>/home/diego$ <em>ls p??o</em></tt></p>
<p><tt>paco</tt></p>
<p><tt>/home/diego$ <em>ls ???s</em></tt></p>
<p><tt>luis</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
  </p>
  <p>
Como podemos ver, los caracteres comodín nos permiten referirse a más de un archivo a la vez. En el sumario de comandos básicos dijimos que <tt>cp</tt> y <tt>mv</tt> pueden copiar o mover múltiples archivos de una vez. Por ejemplo:
  </p>
  <p>
<quote><p><tt>/home/diego$ <em>cp /etc/s* /home/diego</em></tt></p></quote>
  </p>
  <p>
copiará todos los archivos de <tt>/etc</tt> que comiencen con &ldquo;<tt>s</tt>&rdquo; al directorio <tt>/home/diego</tt>.
  </p>
</sect1>

<sect1>
Los comodines y los archivos ocultos

<p>
Los comodines &ldquo;<tt>*</tt>&rdquo; y &ldquo;<tt>?</tt>&rdquo; no coincidirán con nombres de archivos que comiencen con un punto (&ldquo;<tt>.</tt>&rdquo;). Estos archivos son tratados como <em>ocultos</em>. Los archivos de este tipo no son mostrados en un listado normal de <tt>ls</tt> y no son afectados por el uso de &ldquo;<tt>*</tt>&rdquo; y &ldquo;<tt>?</tt>&rdquo;.
  </p>
  <p>
Por ejemplo, ya hemos mencionado que cada directorio tiene dos entradas especiales: &ldquo;<tt>.</tt>&rdquo;, que hace referencia al directorio actual, y &ldquo;<tt>..</tt>&rdquo;, que se refiere al directorio padre. Como ya hemos visto, al usar <tt>ls</tt> esas dos entradas no se muestran:
  </p>
  <p>
<quote>
<p><tt>/home/diego$ <em>ls</em></tt></p>
<p><tt>hugo luis paco</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
  </p>
  <p>
Si usamos el parámetro &ldquo;<tt>-a</tt>&rdquo; con <tt>ls</tt> podremos ver nombres de archivos que comienzan con &ldquo;<tt>.</tt>&rdquo;. Observemos:
  </p>
  <p>
<quote>
<p><tt>/home/diego$ <em>ls -a</em></tt></p>
<p><tt>.&nbsp;&nbsp;..&nbsp;&nbsp;.bash_profile .bashrc hugo luis paco</tt></p>
<p><tt>/home/diego$</tt></p>
</quote>
  </p>
  <p>
Ahora podemos ver las dos entradas especiales, &ldquo;<tt>.</tt>&rdquo; y &ldquo;<tt>..</tt>&rdquo;, así como otros dos archivos ocultos: &ldquo;<tt>.bash_profile</tt>&rdquo; y &ldquo;<tt>.bashrc</tt>&rdquo;.<footnote>Estos dos archivos son usados en el arranque por el intérprete de comandos <tt>bash</tt> cuando <tt>diego</tt> realiza el login.</footnote>
  </p>
</sect1>

  </sect>

  <sect>
Comunicación entre procesos

<p><em>Unix</em> provee una serie de mecanismos para poder intercomunicar procesos<footnote>Se denomina proceso a un programa en ejecución</footnote>, como parte de la estrategia de combinar el uso de herramientas simples para poder resolver problemas complejos.</p>

   <sect1>
Entrada y salida estándar
   <p>
La mayoría de los programas de <em>Unix</em> toman (leen) sus datos de entrada de la llamada &ldquo;entrada estándar&rdquo; y envían sus resultados (escriben) a la &ldquo;salida estándar&rdquo; (a menudo abreviadas como &ldquo;<tt>stdin</tt>&rdquo; y &ldquo;<tt>stdout</tt>&rdquo; respectivamente). Usualmente el sistema está configurado de forma que la entrada estándar es el teclado y la salida estándar la pantalla (recordemos que al teclado y la pantalla se los denomina comunmente &ldquo;consola&rdquo;).
   </p>
   <p>
Veamos un ejemplo con el comando <tt>cat</tt>. Normalmente <tt>cat</tt> lee datos de los archivos cuyos nombres se pasan como argumentos en la línea de comandos y envía estos datos directamente a la salida estándar. Luego, al ejecutar la orden:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>cat historia tesis</em></tt></p>
</quote>
   </p>
   <p>
se mostrará por pantalla el contenido del archivo <tt>historia</tt> seguido por el contenido del archivo <tt>tesis</tt>.
   </p>
   <p>
Si <tt>cat</tt> no recibe nombres de archivos como parámetros, leerá datos de <tt>stdin</tt> y los enviará a <tt>stdout</tt>. Veamos un ejemplo:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>cat</em></tt></p>
<p><tt><em>Hola !!!</em></tt></p>
<p><tt>Hola !!!</tt></p>
<p><tt><em>Adiós.</em></tt></p>
<p><tt>Adiós.</tt></p>
<p><tt><em>&lsqb;Ctrl&rsqb;+&lsqb;D&rsqb;</em></tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
   <p>
Como puede verse, cada línea que el usuario teclea (en letra itálica) es inmediatamente reenviada al monitor por <tt>cat</tt>. Cuando están leyendo datos, los procesos reconocen el fin de la entrada al recibir el carácter <tt>EOT</tt> (&ldquo;<em>end-of-text</em>&rdquo;, fin de texto). Normalmente es generado con la combinación de teclas <tt>&lsqb;Ctrl&rsqb;+&lsqb;D&rsqb;</tt>.
   </p>
   <p>
Veamos otro ejemplo. El comando <tt>sort</tt> toma como entrada líneas de texto (al igual que <tt>cat</tt>, leerá desde <tt>stdin</tt> si no se le proporcionan nombres de archivos en la línea de comandos), y devuelve la salida ordenada por <tt>stdout</tt>. Probemos lo siguiente:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>sort</em></tt></p>
<p><tt><em>bananas</em></tt></p>
<p><tt><em>manzanas</em></tt></p>
<p><tt><em>duraznos</em></tt></p>
<p><tt><em>&lsqb;Ctrl&rsqb;+&lsqb;D&rsqb;</em></tt></p>
<p><tt>bananas</tt></p>
<p><tt>duraznos</tt></p>
<p><tt>manzanas</tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
   </p>

   </sect1>

   <sect1>
Redirigiendo la entrada y salida
   <p>
Ahora, supongamos que queremos que la salida de <tt>sort</tt> vaya a un archivo llamado <tt>compras</tt> en vez de a la pantalla. El intérprete de comandos nos permite redirigir la salida estándar a un archivo usando el símbolo &ldquo;<tt>&gt;</tt>&rdquo;. Veamos como funciona:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>sort &gt; compras</em></tt></p>
<p><tt><em>bananas</em></tt></p>
<p><tt><em>manzanas</em></tt></p>
<p><tt><em>duraznos</em></tt></p>
<p><tt><em>&lsqb;Ctrl&rsqb;+&lsqb;D&rsqb;</em></tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
</p>
   <p>
Como podemos ver, el resultado de <tt>sort</tt> no se muestra por pantalla, en su lugar es escrito en el archivo <tt>compras</tt>. Veamos ahora su contenido:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>cat compras</em></tt></p>
<p><tt>bananas</tt></p>
<p><tt>duraznos</tt></p>
<p><tt>manzanas</tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
</p>

   <p>
Supongamos ahora que tenemos nuestra lista desordenada original en el archivo <tt>cosas</tt>. Una forma de ordenar la información y escribirla en un archivo podría ser darle a <tt>sort</tt> el nombre del archivo a leer en lugar de la entrada estándar y redirigir la salida estándar como acabamos de hacer:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>sort cosas &gt; compras</em></tt></p>
<p><tt>/home/diego/articulos$ <em>cat compras</em></tt></p>
<p><tt>bananas</tt></p>
<p><tt>duraznos</tt></p>
<p><tt>manzanas</tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
</p>

   <p>
Hay otra forma de hacer esto. No sólo puede ser redirigida la salida estándar, también puede ser redirigida la entrada estándar usando el símbolo &ldquo;<tt>&lt;</tt>&rdquo;.
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>sort &lt; cosas</em></tt></p>
<p><tt>bananas</tt></p>
<p><tt>duraznos</tt></p>
<p><tt>manzanas</tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
</p>

   <p>
Las órdenes &ldquo;<tt>sort &lt; cosas</tt>&rdquo; y &ldquo;<tt>sort cosas</tt>&rdquo; tienen el mismo efecto, pero esto nos permite ver que el intérprete de comandos es quien maneja las redirecciones. <tt>sort</tt> no recibe el nombre del archivo a leer, desde su punto de vista, está leyendo datos de la entrada estándar como si fueran ingresados desde el teclado.
   </p>
   <p>
Esto introduce el concepto de &ldquo;filtro&rdquo;. Un filtro es un programa que lee datos de la entrada estándar, los procesa de alguna forma y devuelve el resultado por la salida estándar. Usando la redirección, tanto la entrada estándar como la salida estándar pueden ser radirigidas a  archivos. <tt>sort</tt> es un filtro simple: ordena los datos de entrada y envía el resultado a la salida estándar. <tt>cat</tt> es incluso más simple, no hace nada con los datos de entrada, simplemente los envía a la salida tal como los recibe.
   </p>

   </sect1>

   <sect1>
Redirección no destructiva
   <p>
El uso de &ldquo;<tt>&gt;</tt>&rdquo; para redirigir la salida a un archivo es destructivo. En otras palabras, la orden:
   </p>
   <p>
<quote><p><tt>/home/diego/articulos$ <em>ls &gt; listado</em></tt></p></quote>
   </p>
   <p>
sobreescribe el contenido del archivo <tt>listado</tt>. Si en su lugar, usamos los símbolos &ldquo;<tt>&gt;&gt;</tt>&rdquo;, la salida será añadida al final del archivo nombrado, en lugar de ser sobrescrito (creándolo, si este no existiera). El comando:
   </p>
   <p>
<quote><p><tt>/home/diego/articulos$ <em>ls &gt;&gt; listado</em></tt></p></quote>
   </p>
   <p>
añadirá la salida de <tt>ls</tt> al final de <tt>listado</tt>.
   </p>

   </sect1>

   <sect1>
Uso de tuberías (pipes)
   <p>
Ya hemos visto como usar <tt>sort</tt> como un filtro, pero estos ejemplos suponen que tenemos los datos en un archivo o que los introducimos manualmente por la entrada estándar.
   </p>
   <p>
&iquest;Qué pasa si los datos que queremos ordenar provienen de la salida de otro comando, como <tt>ls</tt>? Por ejemplo, si el contenido de nuestro directorio actual fuese:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>ls</em></tt></p>
<p><tt>historia</tt></p>
<p><tt>ingles</tt></p>
<p><tt>notas</tt></p>
<p><tt>tesis</tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
   </p>
   <p>
Usando la opción &ldquo;<tt>-r</tt>&rdquo; con <tt>sort</tt> ordenaremos los datos en orden inverso. Una forma de hacer esto sería:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>ls &gt; listado</em></tt></p>
<p><tt>/home/diego/articulos$ <em>sort -r listado</em></tt></p>
<p><tt>tesis</tt></p>
<p><tt>notas</tt></p>
<p><tt>ingles</tt></p>
<p><tt>historia</tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
   </p>
   <p>
Aquí, escribimos la salida de <tt>ls</tt> en un archivo y luego ejecutamos &ldquo;<tt>sort -r</tt>&rdquo; sobre él. Pero de esta forma hemos creado un archivo solamente para que los datos generados por <tt>ls</tt> luego puedan ser leídos por <tt>sort</tt>. No parece tener demasiado sentido hacer esto.
   </p>
   <p>
La solución a este problema es usar los &ldquo;pipes&rdquo; (o &ldquo;tuberías&rdquo;). Los pipes son una poderosa herramienta provista por el sistema para conectar dos procesos, de manera que la <tt>stdout</tt> del primero es enviada directamente a la <tt>stdin</tt> del segundo (esto puede generalizarse para formar una cadena de procesos). Para crear un pipe se usa el símbolo &ldquo;<tt>|</tt>&rdquo;. En nuestro ejemplo, queremos conectar la salida de <tt>ls</tt> con la entrada de <tt>sort</tt>:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>ls | sort -r</em></tt></p>
<p><tt>tesis</tt></p>
<p><tt>notas</tt></p>
<p><tt>ingles</tt></p>
<p><tt>historia</tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
   </p>
   <p>
Esta forma es más corta, más eficiente y hasta más fácil de escribir.
   </p>
   <p>
Veamos otro ejemplo útil. Al usar el comando:
   </p>
   <p>
<quote><p><tt>/home/diego/articulos$ <em>ls /usr/bin</em></tt></p></quote>
   </p>
   <p>
se mostrará una lista de archivos demasiado extensa, parte de la cual pasará rápidamente por la pantalla ante nuestros ojos, sin que podamos leerla. En lugar de esto, usemos <tt>less</tt> para detener el listado cada vez que se complete la pantalla:<footnote>Recordemos que para salir de <tt>less</tt> hay que presionar <tt>&lsqb;Q&rsqb;</tt>.</footnote>
   </p>
   <p>
<quote><p><tt>/home/diego/articulos$ <em>ls /usr/bin | less</em></tt></p></quote
   </p>
   <p>
Ahora podemos ir avanzando o retrocediendo línea por línea o pantalla por pantalla, cómodamente.
   </p>
   <p>
Como dijimos anteriormente, podemos &ldquo;entubar&rdquo; más de dos procesos a la vez. <tt>head</tt> es un filtro que muestra las primeras líneas de la entrada. Si queremos ver el último archivo del directorio actual en orden alfabético, usaremos:
   </p>
   <p>
<quote>
<p><tt>/home/diego/articulos$ <em>ls | sort -r | head -1</em></tt></p>
<p><tt>tesis</tt></p>
<p><tt>/home/diego/articulos$</tt></p>
</quote>
   </p>
   <p>
Donde &ldquo;<tt>head -1</tt>&rdquo; muestra la primera línea de la entrada que recibe (en este caso, el flujo de datos ordenados inversamente, proveniente de &ldquo;<tt>sort -r</tt>&rdquo;, que es el listado que éste recibió de &ldquo;<tt>ls</tt>&rdquo;).
   </p>

   </sect1>


  </sect>

  <sect>
Permisos de archivos

   <p>
Al ser <em>Unix</em> un sistema multiusuario, los archivos de cada usuario deben ser protegidos del resto de los usuarios. Lo mismo ocurre con los archivos del sistema (programas, configuraciones, etc.). Esto tiene que ver no sólo con la confidencialidad de la información, sino también con la protección de errores involuntarios por parte de los usuarios. Para ello se utiliza un sistema de &ldquo;permisos de archivos&rdquo;. Este mecanismo permite que archivos y directorios &ldquo;pertenezcan&rdquo; a un usuario en particular. Por ejemplo, como <tt>diego</tt> creó archivos en su directorio &ldquo;home&rdquo;, diego es el propietario de esos archivos y tiene acceso total a ellos.
   </p>
   <p>
<em>Unix</em> también permite que los archivos sean compartidos entre usuarios y grupos de usuarios. Si <tt>diego</tt> lo desea, podría restringir el acceso a sus archivos de forma que ningún otro usuario pueda acceder a ellos. 
   </p>

<sect1>
Tipos de permisos

   <p>
Cada archivo pertenece a un usuario y a un grupo en particular. Un grupo es un conjunto de usuarios definido (cada usuario pertenece al menos a un grupo, pero puede pertenecer a varios). 
   </p>
   <p>
Los grupos usualmente son definidos por el tipo de usuarios que acceden al sistema. Por ejemplo, en un sistema <em>Unix</em> de una universidad, los usuarios pueden ser divididos en los grupos <tt>estudiantes</tt>, <tt>dirección</tt>, <tt>profesores</tt> e <tt>invitados</tt>. Hay también unos pocos grupos definidos por el sistema (como <tt>bin</tt> y <tt>daemon</tt>) que son usados por el propio sistema para controlar el acceso a los recursos. Normalmente los usuarios comunes no pertenecen a estos grupos.
   </p>
   <p>
Los permisos están divididos en tres tipos: lectura, escritura y ejecución. Estos permisos pueden ser fijados para tres clases de usuarios: el propietario del archivo o directorio, los integrantes del grupo al que pertenece y todos los demás usuarios.
   </p>
   <p>
El permiso de lectura permite a un usuario leer el contenido del archivo o en el caso de un directorio, listar el contenido del mismo (usando <tt>ls</tt>).
   </p>
   <p>
El permiso de escritura permite a un usuario escribir y modificar el archivo (inclusive, eliminarlo). Para directorios, el permiso de escritura permite crear nuevos archivos o borrar archivos ya existentes en el mismo.
   </p>
   <p>
Por último, el permiso de ejecución permite a un usuario ejecutar el archivo si es un programa. Para directorios, el permiso de ejecución permite al usuario ingresar al mismo (por ejemplo, con el comando <tt>cd</tt>).
   </p>

   </sect1>

   <sect1>
Interpretando los permisos de archivos
   <p>
Veamos un ejemplo del uso de permisos de archivos. Usando el comando <tt>ls</tt> con la opción &ldquo;<tt>-l</tt>&rdquo; se mostrara un listado &ldquo;largo&rdquo; de los archivos, el cual incluye los permisos.
   </p>
   <p>
<quote>
<p><tt>/home/diego/nuevo$ <em>ls -l cosas</em></tt></p>
<p><tt>-rw-r--r-- 1 diego users 505 Mar 13 19:05 paco</tt></p>
<p><tt>/home/diego/nuevo$</tt></p>
</quote>
   </p>
   <p>
El primer campo representa los permisos del archivo. El tercer campo es el propietario del mismo (<tt>diego</tt>), el cuarto es el grupo al cual pertenece el archivo (<tt>users</tt>) y el último campo es el nombre del archivo (<tt>paco</tt>).
   </p>
   <p>
La cadena &ldquo;<tt>-rw-r--r-</tt>&rdquo; nos informa, por orden, los permisos para el propietario, los usuarios del grupo y el resto de los usuarios.
   </p>
   <p>
El primer carácter de la cadena de permisos (&ldquo;<tt>-</tt>&rdquo;) representa el tipo de archivo. El &ldquo;<tt>-</tt>&rdquo; significa que es un archivo regular, &ldquo;<tt>d</tt>&rdquo; indicaría que se trata de un directorio. Los siguientes tres caracteres (&ldquo;<tt>rw-</tt>&rdquo;) representan los permisos para el propietario del archivo, <tt>diego</tt>. Éste tiene permisos para leer (<tt>r</tt>) y escribir (<tt>w</tt>) en el archivo <tt>paco</tt>.
   </p>
   <p>
Como ya mencionamos, además de los permisos de lectura y escritura existe el permiso de ejecución, representado por una &ldquo;<tt>x</tt>&rdquo;. Como hay un &ldquo;<tt>-</tt>&rdquo; en lugar de la &ldquo;<tt>x</tt>&rdquo;, significa que <tt>diego</tt> no tiene permiso para ejecutar ese archivo. Esto es correcto, puesto que <tt>paco</tt> no es un programa. Por supuesto, como el archivo es de <tt>diego</tt>, él puede cambiar los permisos, dándose a sí mismo permiso de ejecución, como veremos más adelante.
   </p>
   <p>
Los siguientes tres caracteres, &ldquo;<tt>r--</tt>&rdquo;, representan los permisos para los miembros del grupo al que pertenece el archivo (en este caso, <tt>users</tt>). Como sólo aparece una &ldquo;<tt>r</tt>&rdquo; cualquier usuario que pertenezca al grupo <tt>users</tt> puede leer este archivo, pero no modificarlo ni ejecutarlo.
   </p>
   <p>
Los últimos tres caracteres, &ldquo;<tt>r--</tt>&rdquo;, representan los permisos para cualquier otro usuario del sistema (que no sea <tt>diego</tt> ni pertenezca al grupo <tt>users</tt>). Nuevamente, como sólo está presente la &ldquo;<tt>r</tt>&rdquo;, los demás usuarios pueden leer el archivo, pero no escribir en él o ejecutarlo.
   </p>
   <p>
Aquí tenemos otros ejemplos de permisos de grupo.
   </p>
   <p>
<descrip>
<tag><tt>-rwxr-xr-x</tt></tag><p>El propietario del archivo puede leer, escribir y ejecutar el archivo. Los usuarios pertenecientes al grupo del archivo y todos los demás usuarios pueden leer y ejecutar el archivo.</p>
<tag><tt>-rw-------</tt></tag><p>El propietario del archivo puede leer y escribir. Nadie más puede acceder al archivo.</p>
<tag><tt>-rwxrwxrwx</tt></tag><p>Todos los usuarios pueden leer, escribir y ejecutar el archivo.</p>
<tag><tt>drwxr-xr-x</tt></tag><p>El propietario del directorio puede leer, escribir y entrar al mismo. Los usuarios pertenecientes al grupo del directorio y todos los demás usuarios pueden leer e ingresar al directorio.</p>
</descrip>
   </p>

   </sect1>

   <sect1>
Dependencias
   <p>
Es importante remarcar que los permisos de un archivo también dependen de los permisos del directorio en el que reside. Por ejemplo, aunque un archivo tenga los permisos &ldquo;<tt>-rwxrwxrwx</tt>&rdquo;, otros usuarios no podrán acceder a él a menos que también tengan permiso de lectura y ejecución para el directorio en el cual se encuentra el archivo. Si <tt>diego</tt> quiere restringir el acceso a todos sus archivos, podría simplemente poner los permisos de su directorio &ldquo;home&rdquo;, <tt>/home/diego</tt>, como &ldquo;<tt>drwx------</tt>&rdquo;. De esta forma ningún usuario podrá acceder a su directorio y, por lo tanto, tampoco a ninguno de sus archivos o subdirectorios. Así <tt>diego</tt> no necesita preocuparse de los permisos individuales de cada uno de sus archivos.
   </p>
   <p>
En otras palabras un usuario, para acceder a un archivo, debe de tener permiso de ejecución de todos los directorios a lo largo del camino de acceso al archivo, además de permiso de lectura  del archivo en particular.
   </p>
   <p>
La mayoría de los archivos usualmente tienen permisos &ldquo;<tt>-rw-r--r--</tt>&rdquo;, lo que permite a todos los usuarios leer los archivos, pero solamente a su propietario modificarlos. Los directorios usualmente tienen los permisos &ldquo;<tt>drwxr-xr-x</tt>&rdquo;, lo que permite a todos lo susuarios moverse y ver los directorios, pero solo permiten a su propietario poder crear o borrar archivos en ellos.
   </p>
   <p>
Si un usuario desea limitar el acceso de otros a un archivo en particular, puede asignarle los permisos &ldquo;<tt>-rw-------</tt>. De la misma manera, poniendo los permisos de un directorio como &ldquo;<tt>drwx------</tt>&rdquo; no se permitirá el acceso a los demás usuarios.
   </p>

   </sect1>

   <sect1>
Cambiando permisos
   <p>
El comando <tt>chmod</tt> se usa para establecer los permisos de un archivo. Sólo el propietario puede cambiar los permisos del archivo (además, claro está, del administrador del sistema, el usuario <tt>root</tt>). La sintaxis de <tt>chmod</tt> es:
   </p>
   <p>
<quote><p><tt>chmod &lsqb;a,u,g,o&rsqb;&lsqb;+,-&rsqb;&lsqb;r,w,x&rsqb; &lt;archivos&gt;</tt></p></quote>
   </p>
   <p>
El primer parámetro indica a qué usuarios afecta: <em>all</em>, <em>user</em>, <em>group</em> u <em>other</em> (todos, el propietario, el grupo u otros usuarios; respectivamente). Luego se especifica si se están añadiendo permisos (<tt>+</tt>) o quitándolos (<tt>-</tt>). El tercer parámetro especifica qué tipo de permiso estamos añadiendo o quitando: <em>read</em>, <em>write</em> o <em>execute</em>. Finalmente, se indican los nombres de los archivos a afectar. Algunos ejemplos de la utilización de <tt>chmod</tt> son:
   </p>
   <p>
<descrip>
<tag><tt>chmod a+r paco</tt><p>Da a todos los usuarios acceso de lectura al archivo <tt>paco</tt>.</p>
<tag><tt>chmod +r paco</tt><p>Igual al anterior. Si no se indica <tt>a</tt>, <tt>u</tt>, <tt>g</tt> u <tt>o</tt> por defecto se toma <tt>a</tt>.</p>
<tag><tt>chmod og-x paco</tt><p>Quita permisos de ejecución de <tt>paco</tt> a todos los usuarios excepto al propietario.</p>
<tag><tt>chmod u+rwx paco</tt><p>Permite al propietario leer, escribir y ejecutar el archivo <tt>paco</tt>.</p>
<tag><tt>chmod o-rwx paco</tt><p>Quita permisos de lectura, escritura y ejecución del archivo <tt>paco</tt> a todos los usuarios menos al propietario y a los usuarios del grupo.</p>
<tag><tt>chmod og-r paco luis</tt><p>Quita permisos de lectura de los archivos <tt>paco</tt> y <tt>luis</tt> a todos los usuarios excepto al propietario.</p>
</descrip>
</p>

   </sect1>


  </sect>

  <sect>
Próximos pasos
 
 <p>
Luego de recorrer en este breve tutorial los conceptos básicos del sistema <em>GNU/Linux</em> y habiendo adquirido las habilidades necesarias para comenzar a trabajar en él, usted se encuentra en condiciones de abordar otros temas. A modo de sugerencia, van los siguientes.</p>

<sect1>
Editores de textos

<p>En un entorno <em>Unix</em> se hace indispensable el uso de un editor de textos. La variedad de opciones disponibles es inmensa: desde editores extremadamente simples, hasta algunos muy completos y complejos.</p>
<p>La lista a continuación enumera algunos de los más conocidos:</p>

<p>
<descrip>
<tag>nano</tag><p>Editor muy fácil de usar. No posee capacidades avanzadas, pero es simple de usar sin conocimientos previos.</p>
<tag>joe</tag><p>Editor similar al <em>WordStar</em> de <em>DOS</em>. De dificultad y potencia medias.</p>
<tag>vim</tag>Versión mejorada del clásico de <em>Unix</em> <tt>vi</tt>. Requiere cierto entrenamiento inicial para su uso, pero posibilita lograr una gran productividad en la edición de textos. Viene acompañado de un tutorial interactivo llamado <tt>vimtutor</tt>.</p>
<tag>emacs</tag><p>El editor estrella del proyecto <em>GNU</em>. Ofrece una gran cantidad de herramientas y es mucho más que un editor de textos, aunque requiere cierto entrenamiento en su uso.</p>
</descrip>
</p>

<p>A modo de sugerencia, tenga en cuenta que todo el tiempo que invierta en el aprendizaje de un buen editor de textos (como <tt>emacs</tt> o <tt>vim</tt>) redundará en una mayor productividad en el uso del sistema.</p>
</sect1>

<sect1>
Programación del shell

<p>Los intérpretes de comando ofrecen potentes mecanismos para poder resolver problemas de gran complejidad. Entre ellos, <tt>bash</tt> es el más utilizado actualmente, existiendo una amplia documentación sobre su uso (desde &ldquo;<tt>man bash</tt>&rdquo; hasta los <em>HOWTO</em> disponibles en el &ldquo;<em>Linux Documentation Project</em>&rdquo;.<footnote><htmlurl url="http://www.tldp.org/" name="http://www.tldp.org/"></footnote>

<p>Se denomina &ldquo;<em>shell script</em>&rdquo; a un archivo que contenga comandos del shell. Mediante los shell scrips, podemos escribir verdaderos programas que automaticen tareas de mantenimiento del sistema o que realicen otras tareas comunes.</p>

</sect1>

<sect1>
Administración del sistema

<p>Una vez adquirido cierto dominio sobre el entorno <em>GNU/Linux</em> estará listo para adentrarse en las tareas reservadas al usuario <tt>root</tt>. Entre ellas se cuentan la administración de usuarios, la instalación de paquetes de software, la realización de copias de respaldo, entre tantas otras.</p>

<p>Nuevamente, en el &ldquo;<em>Linux Documentation Project</em>&rdquo; encontrará una amplia documentación sobre estos temas.</p>

</sect1>

<sect1>
Distribuciones de <em>GNU/Linux</em>

<p>Existen distintas distribuciones de <em>GNU/Linux</em>, orientadas a distinto tipo de usuarios o de sistemas, con herramientas de administración diferentes, o con distintas políticas. Algunas son comercializadas por empresas, en tanto que otras son mantenidas por comunidades de usuarios particulares. Algunas son gratuitas, son pagas. Unas requieren de horas (e incluso días) de instalación, en tanto que otras permiten tener un sistema 100% funcional en cuestión de minutos (&iexcl;hasta hay algunas que no requieren instalación en el disco duro!).</p>

<p>Sin duda encontrará la más apropiada para usted (o hasta pueden ser varias), luego de experimentar con varias de ellas, evaluando sus pro y sus contras. A modo de orientación, estas son las más populares en la actualidad:</p>

<p>
<descrip>
<tag>RedHat</tag><p>Es la distribución preferida por las empresas por su excelente soporte comercial. Existe una versión gratuita, orientada a la comunidad, llamada <em>Fedora</em>.</p>
<tag>Debian</tag><p>Es una distribución mantenida por un grupo de colaboradores que incluye principalmente <em>software libre</em>.</p>
<tag>Ubuntu</tag><p>Es una distribución derivada de <em>Debian</em>, con soporte comercial de la empresa que la produce. Puede ejecutarse sin necesidad de instalación en el disco duro.</p>
<tag>Gentoo</tag><p>Es una distribución de instalación lenta, pero que permite optimizar todo el software al hardware específico utilizado.</p>
<tag>Mandriva</tag><p>Distribución derivada de <em>RedHat</em> (antes llamada &ldquo;<em>Mandrake Linux</em>&rdquo;) que muchos usuarios prefieren por su simplicidad de instalación.</p>
<tag>SuSE</tag><p>Distribución de origen alemán, fácil de instalar y administrar, adquirida por la empresa <em>Novell</em>.</p>
</descrip>
</p>
</sect1>

</article>
