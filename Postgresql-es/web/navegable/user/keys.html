<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Índices y claves (keys)</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Manual del usuario de PostgreSQL"
HREF="user.html"><LINK
REL="PREVIOUS"
TITLE="Consultas UNION"
HREF="x3445.html"><LINK
REL="NEXT"
TITLE="Matrices"
HREF="arrays.html"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Manual del usuario de PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x3445.html"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="arrays.html"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="KEYS"
>Índices y claves (keys)</A
></H1
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Autor</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Escrito por
<A
HREF="herouth@oumail.openu.ac.il"
TARGET="_top"
>Herouth Maoz</A
></P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Nota del Editor</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Este artículo apareció originalmente en la lista de correo, como respuesta
a la pregunta: "¿Cual es la diferencia entre las restricciones PRIMARY
KEY y UNIQUE?".</P
></TD
></TR
></TABLE
></DIV
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>Asunto: Re: [PREGUNTAS] PRIMARY KEY | UNIQUE

        Cual es la diferencia entre:

              PRIMARY KEY(campos,...) y
              UNIQUE (campos,...)

       - ¿Son sinónimos?
       - Si PRIMARY KEY ya indica una clave (key) única, entonces ¿porqué
	 existe otra clase de clave llamada UNIQUE?</PRE
></TD
></TR
></TABLE
><P
>Una clave primaria es el campo (o los campos) usado para identificar una
fila. Por ejemplo, el número de identificación fiscal de una persona.</P
><P
>Una simple combinación única de campos (UNIQUE) no tiene nada que ver con
la identificación de la columna. Es simplemente una restricción de
integridad. Por ejemplo, yo tengo una colección de enlaces. Cada colección
se identifica por medio de un número único, que es la clave primaria. Esta
clave se usa en relaciones.</P
><P
>Sin embargo, mi aplicación exige que cada colección tenga también un
nombre único. ¿Porqué? Para que un ser humano que quiera modificar una
colección también sea capaz de identificarla. Es mucho mas difícil saber,
si se tienen dos colecciones llamadas "Ciencia de la Vida", que la que
tiene el número 24433 es la que usted necesita y no la que tiene el número
29882.</P
><P
>De esta forma, el usuario selecciona las colecciones por sus nombres. Por
lo tanto nos aseguramos que los nombres sean únicos dentro de la base de
datos. Sin embargo ninguna otra tabla en la base de datos se refiere a la
tabla de colecciones por su nombre. Eso sería bastante ineficiente.</P
><P
>¡Aún mas, a pesar de ser único, el nombre de la colección no define
realmente la colección! Por ejemplo, si alguien decidiera cambiar el
nombre de la colección de "Ciencia de la Vida" por "Biología", aún seguiría
siendo la misma colección, solo que con un nombre diferente. Mientras el
nombre sea único no hay problema.</P
><P
>Resumiendo:

<P
></P
><UL
><LI
><P
>Clave primaria:
<P
></P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
>Usada para identificar la fila y para referirse a ella.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Es imposible (o muy difícil) de actualizar.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>No debe aceptar valores NULL.</P
></LI
></UL
></P
></LI
><LI
><P
>Campos "unique":
<P
></P
><UL
COMPACT="COMPACT"
><LI
STYLE="list-style-type: disc"
><P
>Se usan como alternativa para acceder una fila.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Pueden ser actualizados siempre y cuando mantengan su valor único.</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>Aceptan valores NULL.</P
></LI
></UL
></P
></LI
></UL
></P
><P
>En cuanto a la pregunta de ¿por qué no se definen claves no-únicas
explícitamente en la sintaxis estándar de <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>?
Pues hay que entender que los índices dependen de la implementación
específica. <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> no define la implementación,
simplemente las relaciones entre los datos y la base de
datos. <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> acepta índices no-únicos, pero
los índices usados como claves <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> son siempre únicos.</P
><P
>De esta forma, puede efectuar búsquedas en una tabla por medio de
cualquier combinación de columnas, a pesar de que no tenga un índice en
esas columnas. Los no índices son sino una ayuda que cada implementación
de un <SPAN
CLASS="ACRONYM"
>RDBMS</SPAN
> le ofrece, para permitir que las búsquedas
usadas frecuentemente sean hechas de una forma más eficiente. Algunos
<SPAN
CLASS="ACRONYM"
>RDBMS</SPAN
> pueden proporcionarle mecanismos adicionales,
tales como el almacenamiento de una clave en la memoria principal. Esos
mecanismos tendrán una orden especial, por ejemplo
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CREATE MEMSTORE ON &#60;table&#62; COLUMNS &#60;cols&#62;</PRE
></TD
></TR
></TABLE
>
(ésta no es ninguna orden real, sino un ejemplo).</P
><P
>¡De hecho cuando usted crea una clave primaria o una combinación única de
campos, la especificación <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> no dice en ninguna parte
que sea creado un índice o que la obtención de los datos por medio de la
clave sea más eficiente que una búsqueda secuencial!</P
><P
>Así que si usted quiere usar como clave secundaria una combinación de
campos que no es única, no tiene que especificar nada - ¡simplemente
comience a obtener datos usando esa combinación! Sin embargo, si quiere
que la obtención de los datos sea más eficiente, tendrá que optar por los
medios que su <SPAN
CLASS="ACRONYM"
>RDBMS</SPAN
> le proporciona - ya sea un índice,
la orden MEMSTORE que inventé como ejemplo, o un <SPAN
CLASS="ACRONYM"
>RDBMS</SPAN
>
inteligente que cree índices, sin su conocimiento, basándose en el hecho
de que usted ha efectuado varias búsquedas con la misma combinación
específica de claves... (Aprende con la experiencia).</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x3445.html"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="user.html"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="arrays.html"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Consultas UNION</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Matrices</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>