<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Sobrecarga de funciones</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="PostgreSQL"
HREF="postgres.html"><LINK
REL="UP"
TITLE="Extendiendo SQL: Funciones"
HREF="xfunc.html"><LINK
REL="PREVIOUS"
TITLE="Funciones de Lenguaje Compilado (C) "
HREF="x16855.html"><LINK
REL="NEXT"
TITLE="Extendiendo SQL: Tipos"
HREF="xtypes.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x16855.html"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Extendiendo <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>: Funciones</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="xtypes.html"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN17086"
>Sobrecarga de funciones</A
></H1
><P
>    Se puede definir más de una función con el mismo nombre, siempre que
    los argumentos que tomen sean diferentes. En otras palabras, los nombres de las funciones
    se pueden <I
CLASS="FIRSTTERM"
>sobrecargar</I
>.
    Una función puede tener además el mismo nombre que un atributo. En el caso
    de que haya ambigüedad entre una función sobre un tipo complejo y
    un atributo del tipo complejo, se usará siempre el atributo.
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN17090"
>Conflictos en el Espacio de Nombres</A
></H2
><P
>     A partir de <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> v6.6, la forma
     alternativa de la cláusula AS para la orden 
     de SQL <B
CLASS="COMMAND"
>CREATE FUNCTION</B
>
     desempareja el nombre de la función SQL del nombre de función en el 
     código fuente C. Esta es ahora la técnica preferida para realizar
     la sobrecarga de funciones.
    </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN17095"
>Pre-v6.6</A
></H3
><P
>      Para funciones escritas en C, el nombre SQL declarado en 
      <B
CLASS="COMMAND"
>CREATE FUNCTION</B
>
      debe ser exactamente el mismo que el nombre real de la función en el
      código C (debido a esto debe ser un nombre de función de C legal).
     </P
><P
>      Hay una sutil consecuencia de este restricción: mientras las
      rutinas de carga dinámicas en la mayoría de los sistemas operativos están mas que
      felices de permitirle cargar cualquier número de librerías compartidas que
      contienen nombres de funciones conflictivos (con idénticos nombres), pueden,
      de hecho, chapucear la carga de formas interesantes. Por ejemplo, si usted
      define una función dinámicamente cargada que resulta tener el 
      mismo nombre que una función perteneciente a Postgres, el cargador DEC OSF/1
      dinámico hace que Postgres llame a la función dentro de él mismo preferiblemente a
      dejar que Postgres llame a su función. Por esto, si quiere que su función
      se use en diferentes arquitecturas, recomendamos que 
      no sobrecargue los nombres de las funciones C.
     </P
><P
>      Hay un truco ingenioso para resolver el problema que se acaba de describir.
      Dado que no hay problemas al sobrecargar funciones SQL, usted puede
      definir un conjunto de funciones C con nombres diferentes y entonces definir
      un conjunto de funciones SQL con idénticos nombres que tomen los 
      tipos de argumentos apropiados y llamen a la función C correspondiente. 
     </P
><P
>      Otra solución es no usar la carga dinámica, sino enlazar sus
      funciones al backend státicamente y declararlas como funciones 
      INTERNAL. Entonces, las funciones deben tener todas nombres C distintos pero
      se pueden declarar con los mismos nombres SQL (siempre que los tipos
      de sus argumentos difieran, por supuesto). Esta forma evita la sobrecarga de
      una función wrapper (o envolvente) SQL, con la desventaja de un mayor esfuerzo para preparar un 
      ejecutable del backend a medida. (Esta opción está disponible sólo en la versión 
      6.5 y posteriores, dado que las versiones anteriores requerían funciones internas para
      tener el mismo nombre en SQL que en el código C.)
     </P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x16855.html"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="postgres.html"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xtypes.html"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Funciones de Lenguaje Compilado (C)</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="xfunc.html"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Extendiendo <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>: Tipos</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>