<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Funciones de Lenguaje Compilado (C) </TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="PostgreSQL"
HREF="postgres.html"><LINK
REL="UP"
TITLE="Extendiendo SQL: Funciones"
HREF="xfunc.html"><LINK
REL="PREVIOUS"
TITLE="Funciones Internas"
HREF="x16850.html"><LINK
REL="NEXT"
TITLE="Sobrecarga de funciones"
HREF="x17086.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x16850.html"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Extendiendo <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>: Funciones</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x17086.html"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN16855"
>Funciones de Lenguaje Compilado (C)</A
></H1
><P
>    Las funciones escritas en C se pueden compilar en objetos que se pueden
    cargar de forma dinámica, y usar para implementar funciones SQL definidas 
    por el usuario. La primera vez que la función definida por el usuario es 
    llamada dentro del backend, el cargador dinámico carga el código objeto de 
    la función en memoria, y enlaza la función con el ejecutable en ejecución de
    <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>. La sintaxis SQL para <B
CLASS="COMMAND"
>CREATE FUNCTION</B
>
    enlaza la función SQL a la función en código C de una de dos formas.
    Si la función SQL tiene el mismo nombre que la función en código C se usa la 
    primera forma. El argumento cadena en la cláusula AS es el nombre de camino
    (pathname) completo del fichero que contiene el objeto compilado que se puede
    cargar de forma dinámica. Si el nombre de la función C es diferente del nombre
    deseado de la función SQL, entonces se usa la segunda forma. En esta forma la 
    cláusula AS toma dos argumentos cadena, el primero es el nombre del camino 
    completo del fichero objeto que se puede cargar de forma dinámica, y el segundo
    es el símbolo de enlace que el cargador dinámico debería buscar. Este símbolo   
    de enlace es solo el nombre de función en el código fuente C.

    <DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>      Después de que se use por primera vez, una función de usuario, dinámicamente
      cargada, se retiene en memoria, y futuras llamadas a la función solo incurren
      en la pequeña sobrecarga de una búsqueda de tabla de símbolos.
     </P
></TD
></TR
></TABLE
></DIV
>
   </P
><P
>    La cadena que especifica el fichero objeto (la cadena en la cláusula AS)
    debería ser el <I
CLASS="EMPHASIS"
>camino completo</I
> del fichero de código
    objeto para la función, unido por comillas simples. Si un símbolo de enlace
    se usa en la cláusula AS, el símbolo de enlace se debería unir por comillas
    simples también, y debería ser exactamente el mismo que el nombre de la función
    en el código fuente C. En sistemas Unix la orden <B
CLASS="COMMAND"
>nm</B
> imprimirá
    todos los símbolos de enlace de un objeto que se puede cargar de forma dinámica.
    (<SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> no compilará una función automáticamente; se
    debe compilar antes de que se use en una orden CREATE FUNCTION. Ver abajo para
    información adicional.)
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN16866"
>Funciones de Lenguaje C sobre Tipos Base</A
></H2
><P
>     La tabla siguiente da el tipo C requerido para los parámetros en las funciones
     C que se cargarán en Postgres. La columna "Defined In" da el fichero de 
     cabecera real (en el directorio  <TT
CLASS="FILENAME"
>.../src/backend/</TT
>) en el
     que el tipo C equivalente se define. Sin embargo, si incluye <TT
CLASS="FILENAME"
>utils/builtins.h</TT
>,
     estos ficheros se incluirán de forma automática.

     <DIV
CLASS="TABLE"
><A
NAME="AEN16871"
></A
><P
><B
>Tabla 1. Tipos de C equivalentes para los tipos internos de <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
></B
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
>	  Built-In Type
	 </TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>	  C Type
	 </TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>	  Defined In
	 </TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>abstime</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>AbsoluteTime</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>utils/nabstime.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>bool</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>bool</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/c.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>box</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(BOX *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>utils/geo-decls.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>bytea</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(bytea *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>char</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>char</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>N/A</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>cid</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>CID</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>datetime</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(DateTime *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/c.h or include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>int2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>int2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>int2vector</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(int2vector *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>int4</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>int4</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>float4</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>float32 or (float4 *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/c.h or include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>float8</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>float64 or (float8 *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/c.h or include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>lseg</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(LSEG *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/geo-decls.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>name</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(Name)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>oid</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>oid</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>oidvector</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(oidvector *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>path</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(PATH *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>utils/geo-decls.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>point</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(POINT *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>utils/geo-decls.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>regproc</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>regproc or REGPROC</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>reltime</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>RelativeTime</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>utils/nabstime.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>text</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(text *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>tid</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>ItemPointer</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>storage/itemptr.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>timespan</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(TimeSpan *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/c.h or include/postgres.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>tinterval</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>TimeInterval</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>utils/nabstime.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>uint2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>uint16</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/c.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>uint4</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>uint32</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/c.h</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>xid</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(XID *)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>include/postgres.h</TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
><P
>     Internamente, <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> considera un tipo base 
     como un "blob de memoria".
     Las funciones definidas por el usuario que usted define sobre un tipo
     en turn definen la forma en que <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> puede operar
     sobre él. Esto es, <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> solo almacenará y 
     recuperará los datos desde disco y solo usará sus funciones definidas por el
     usuario para introducir y procesar los datos, así como para obtener la salida
     de los datos. Los tipos base pueden tener uno de los tres formatos internos siguientes:

     <P
></P
><UL
><LI
><P
>	pass by value, fixed-length
       </P
></LI
><LI
><P
>	pass by reference, fixed-length
       </P
></LI
><LI
><P
>	pass by reference, variable-length
       </P
></LI
></UL
>
    </P
><P
>     Los tipos por valor solo pueden tener 1, 2 o 4 bytes de longitud
     (incluso si su computadora soporta tipos por valor de otros 
     tamaños). <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> mismo
     solo pasa los tipos entero por valor. Debería tener cuidado
     al definir sus tipos para que tengan el mismo tamaño (en bytes)
     en todas las arquitecturas. Por ejemplo, el tipo <TT
CLASS="LITERAL"
>long</TT
>
     es peligroso porque es de 4 bytes en algunas máquinas y de 8 bytes en otras,
     mientras que el tipo <TT
CLASS="LITERAL"
>int</TT
> es de 4 bytes en la mayoría de
     las máquinas Unix (aunque no en la mayoría de computadores personales). Una
     implementación razonable del tipo <TT
CLASS="LITERAL"
>int4</TT
> en las máquinas
     Unix podría ser:

     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>/* 4-byte integer, passed by value */
typedef int int4;
     </PRE
></TD
></TR
></TABLE
>
    </P
><P
>     En el otro lado, los tipos de longitud fija de cualquier tamaño se pueden
     pasar por referencia. Por ejemplo, aquí se presenta una implementación
     de ejemplo de un tipo de <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>:

     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>/* 16-byte structure, passed by reference */
typedef struct
{
    double  x, y;
} Point;
     </PRE
></TD
></TR
></TABLE
>
    </P
><P
>     Solo los punteros a tales tipos se pueden usar a la hora de pasarlos
     como argumentos de entrada o de retorno en las funciones de <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>. 
     Finalmente, todos los tipos de longitud variable se deben pasar también
     por referencia. Todos los tipos de longitud variable deben comenzar
     con un campo length de exactamente 4 bytes, y todos los datos
     que se tengan que almacenar dentro de ese tipo deben estar situados
     en la memoria inmediatamente a continuación de ese campo length.
     El campo length es la longitud total de la estructura (es decir,
     incluye el tamaño del campo length mismo). Podemos definir el tipo
     texto como sigue: 
 
     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
    int4 length;
    char data[1];
} text;
     </PRE
></TD
></TR
></TABLE
>
    </P
><P
>     Obviamente, el campo data no es suficientemente largo para almacenar
     todas las cadenas posibles; es imposible declarar tal estructura en <SPAN
CLASS="ACRONYM"
>C</SPAN
>.
     Al manipular tipos de longitud variable, debemos tener cuidado de
     reservar la cantidad de memoria correcta y de inicializar el campo length.
     Por ejemplo, si quisiéramos almacenar 40 bytes en una estructura text, 
     podríamos usar un fragmento de código como este:

     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
destination-&#62;length = VARHDRSZ + 40;
memmove(destination-&#62;data, buffer, 40);
...
     </PRE
></TD
></TR
></TABLE
>
    </P
><P
>     Ahora que hemos visto todas las estructuras posibles para los tipos base,
     podemos mostrar algunos ejemplos de funciones reales.
     Suponga que <TT
CLASS="FILENAME"
>funcs.c</TT
> es así:

     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>         #include &#60;string.h&#62;
         #include "postgres.h"

         /* By Value */
         
         int
         add_one(int arg)
         {
             return(arg + 1);
         }
         
         /* By Reference, Fixed Length */
         
         Point *
         makepoint(Point *pointx, Point *pointy )
         {
             Point     *new_point = (Point *) palloc(sizeof(Point));
        
             new_point-&#62;x = pointx-&#62;x;
             new_point-&#62;y = pointy-&#62;y;
                
             return new_point;
         }
        
         /* By Reference, Variable Length */
         
         text *
         copytext(text *t)
         {
             /*
              * VARSIZE is the total size of the struct in bytes.
              */
             text *new_t = (text *) palloc(VARSIZE(t));
             memset(new_t, 0, VARSIZE(t));
             VARSIZE(new_t) = VARSIZE(t);
             /*
              * VARDATA is a pointer to the data region of the struct.
              */
             memcpy((void *) VARDATA(new_t), /* destination */
                    (void *) VARDATA(t),     /* source */
                    VARSIZE(t)-VARHDRSZ);        /* how many bytes */
             return(new_t);
         }
         
         text *
         concat_text(text *arg1, text *arg2)
         {
             int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
             text *new_text = (text *) palloc(new_text_size);

             memset((void *) new_text, 0, new_text_size);
             VARSIZE(new_text) = new_text_size;
             strncpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1)-VARHDRSZ);
             strncat(VARDATA(new_text), VARDATA(arg2), VARSIZE(arg2)-VARHDRSZ);
             return (new_text);
         }
     </PRE
></TD
></TR
></TABLE
>
    </P
><P
>     On <SPAN
CLASS="ACRONYM"
>OSF/1</SPAN
> we would type:
     
     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>         CREATE FUNCTION add_one(int4) RETURNS int4
              AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs.so' LANGUAGE 'c';

         CREATE FUNCTION makepoint(point, point) RETURNS point
              AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs.so' LANGUAGE 'c';
    
         CREATE FUNCTION concat_text(text, text) RETURNS text
              AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs.so' LANGUAGE 'c';
                                  
         CREATE FUNCTION copytext(text) RETURNS text
              AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs.so' LANGUAGE 'c';
     </PRE
></TD
></TR
></TABLE
>
    </P
><P
>     En otros sistemas, podríamos tener que especificar la extensión del nombre
     del fichero como .sl (para indicar que es una librería (o biblioteca) compartida).
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN17027"
>Funciones del Lenguaje C sobre Tipos Compuestos</A
></H2
><P
>     Los tipos compuestos no tienen un formato fijo como las estructuras de C.
     Las instancias de un tipo compuesto pueden contener campos null. Además,
     los tipos compuestos que son parte de una jerarquía de herencia pueden 
     tener campos diferentes respecto a otros miembros de la misma jerarquía de herencia.
     Por ello, <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> proporciona una interfaz
     procedural para acceder a los campos de los tipos compuestos desde C.
     Cuando <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> procesa un conjunto de instancias,
     cada instancia se pasará a su función como una estructura opaca de tipo
     <TT
CLASS="LITERAL"
>TUPLE</TT
>. Suponga que queremos escribir una función para
     responder a la consulta

     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>         * SELECT name, c_overpaid(EMP, 1500) AS overpaid
           FROM EMP
           WHERE name = 'Bill' or name = 'Sam';
     </PRE
></TD
></TR
></TABLE
>

     En la consulta anterior, podemos definir c_overpaid como:
     
     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>         #include "postgres.h"
         #include "executor/executor.h"  /* for GetAttributeByName() */
         
         bool
         c_overpaid(TupleTableSlot *t, /* the current instance of EMP */
                    int4 limit)
         {
             bool isnull = false;
             int4 salary;
             salary = (int4) GetAttributeByName(t, "salary", &#38;isnull);
             if (isnull)
                 return (false);
             return(salary &#62; limit);
         }
     </PRE
></TD
></TR
></TABLE
>
    </P
><P
>     <TT
CLASS="FUNCTION"
>GetAttributeByName</TT
> es la función de sistema de
     <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> que devuelve los atributos fuera de
     la instancia actual. Tiene tres argumentos: el argumento de tipo TUPLE 
     pasado a la función, el nombre del atributo deseado, y un parámetro de retorno
     que describe si el atributo es null. <TT
CLASS="FUNCTION"
>GetAttributeByName</TT
> alineará
     los datos apropiadamente de forma que usted pueda convertir su valor de retorno
     al tipo deseado. Por ejemplo, si tiene un atributo name que es del tipo name,
     la llamada a <TT
CLASS="FUNCTION"
>GetAttributeByName</TT
> sería así:

     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>         char *str;
         ...
         str = (char *) GetAttributeByName(t, "name", &#38;isnull)
     </PRE
></TD
></TR
></TABLE
>
    </P
><P
>     La consulta siguiente permite que <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> conozca a la función c_overpaid:

     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>         * CREATE FUNCTION c_overpaid(EMP, int4) RETURNS bool
              AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/obj/funcs.so' LANGUAGE 'c';
     </PRE
></TD
></TR
></TABLE
>
    </P
><P
>     Aunque hay formas de construir nuevas instancias o de modificar las instancias
     existentes desde dentro de una función C, éstas son demasiado complejas
     para discutirlas en este manual.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN17046"
>Escribiendo código</A
></H2
><P
>     Ahora volvemos a la tarea más difícil de escribir funciones del lenguaje
     de programación. Aviso: esta sección del manual no le hará un programador.
     Debe tener un gran conocimiento de <SPAN
CLASS="ACRONYM"
>C</SPAN
> (incluyendo el uso
     de punteros y el administrador de memoria malloc) antes de intentar escribir
     funciones <SPAN
CLASS="ACRONYM"
>C</SPAN
> para usarlas con <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>.
     Aunque sería posible cargar funciones escritas en lenguajes distintos a <SPAN
CLASS="ACRONYM"
>C</SPAN
>
     en <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>, eso es a menudo difícil (cuando es
     posible hacerlo completamente) porque otros lenguajes, tales como <SPAN
CLASS="ACRONYM"
>FORTRAN</SPAN
>
     y <SPAN
CLASS="ACRONYM"
>Pascal</SPAN
> a menudo no siguen la misma <I
CLASS="FIRSTTERM"
>convención de 
     llamada</I
> que <SPAN
CLASS="ACRONYM"
>C</SPAN
>. Esto es, otros lenguajes no 
     pasan argumentos y devuelven valores entre funciones de la misma forma. Por
     esta razón, asumiremos que las funciones de su lenguaje de programación están
     escritas en <SPAN
CLASS="ACRONYM"
>C</SPAN
>.
    </P
><P
>     Las funciones C con tipos base como argumentos se pueden escribir de una
     forma sencilla. Los equivalentes C de los tipos internos de Postgres
     son accesibles en un fichero C si
     <TT
CLASS="FILENAME"
><TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/src/backend/utils/builtins.h</TT
>
     se incluye como un fichero de cabecera. Esto se puede conseguir escribiendo

     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &#60;utils/builtins.h&#62;
     </PRE
></TD
></TR
></TABLE
>

     al principio del fichero fuente C.
    </P
><P
>     Las reglas básicas para construir funciones <SPAN
CLASS="ACRONYM"
>C</SPAN
> son las siguientes:

     <P
></P
><UL
><LI
><P
>        La mayoría de los ficheros cabecera (include) para 
	<SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
	deberían      estar     ya     instalados     en
	<TT
CLASS="FILENAME"
><TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/include</TT
>  (ver  Figura  2).
	Debería incluir siempre

	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>-I$PGROOT/include
	</PRE
></TD
></TR
></TABLE
>

	en sus líneas de llamada a cc.  A veces, podría
        encontrar que necesita ficheros cabecera que están en
        el código fuente del servidor mismo (es decir, necesita un fichero
        que no hemos instalado en include). En esos
        casos puede necesitar añadir uno o más de

	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>-I$PGROOT/src/backend
-I$PGROOT/src/backend/include
-I$PGROOT/src/backend/port/&#60;PORTNAME&#62;
-I$PGROOT/src/backend/obj
	</PRE
></TD
></TR
></TABLE
>

	(donde &#60;PORTNAME&#62; es el nombre del puerto, por ejemplo,
	alpha or sparc).
       </P
></LI
><LI
><P
>        Al reservar memoria, use las rutinas de
	<SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
        palloc y pfree en vez de las
        rutinas de la librería de C correspondientes
        malloc y free.
        La memoria reservada por palloc se liberará
        automáticamente al final de cada transacción,
        previniendo fallos de memoria.	
       </P
></LI
><LI
><P
>        Siempre céntrese en los bytes de sus estructuras usando
        memset o bzero. Varias rutinas (tales como el 
        método de acceso hash, hash join y el algoritmo sort)
        computan funciones de los bits puros contenidos en
        su estructura. Incluso si usted inicializa todos los campos
        de su estructura, puede haber 
        varios bytes de relleno de alineación (agujeros en la 
        estructura) que pueden contener valores incorrectos o basura.
       </P
></LI
><LI
><P
>            La mayoría de los tipos internos de <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
        se declaran en <TT
CLASS="FILENAME"
>postgres.h</TT
>,
            por eso es una buena
        idea incluir siempre ese fichero también. Incluyendo 
        postgres.h incluirá también elog.h y palloc.h por usted.
       </P
></LI
><LI
><P
>        Compilar y cargar su código objeto para que
        se pueda cargar dinámicamente en
	<SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
	siempre requiere flags (o banderas) especiales.
	Ver <A
HREF="dfunc.html#DFUNC"
><I
>Enlazando funciones de carga dinámica</I
></A
>
	para una explicación detallada de cómo hacerlo para 
        su sistema operativo concreto.
       </P
></LI
></UL
>
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x16850.html"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="postgres.html"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x17086.html"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Funciones Internas</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="xfunc.html"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Sobrecarga de funciones</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>