<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Partial Indices</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="PostgreSQL"
HREF="postgres.html"><LINK
REL="UP"
TITLE="Indices and Keys"
HREF="indices.html"><LINK
REL="PREVIOUS"
TITLE="Indices and Keys"
HREF="indices.html"><LINK
REL="NEXT"
TITLE="Matrices"
HREF="arrays.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="indices.html"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Indices and Keys</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="arrays.html"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PARTIAL-INDEX"
>Partial Indices</A
></H1
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./stylesheet-images/note.gif"
HSPACE="5"
ALT="Nota"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Author</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>     This is from a reply to a question on the e-mail list
     by <A
HREF="aoki@CS.Berkeley.EDU"
TARGET="_top"
>Paul M. Aoki</A
>
     on 1998-08-11.
    </P
></TD
></TR
></TABLE
></DIV
><P
>    A <I
CLASS="FIRSTTERM"
>partial index</I
>
    is an index built over a subset of a table; the subset is defined by
    a predicate.  <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
    supported partial indices with arbitrary
    predicates.  I believe IBM's db2 for as/400 supports partial indices
    using single-clause predicates.
   </P
><P
>    The main motivation for partial indices is this:
    if all of the queries you ask that can
    profitably use an index fall into a certain range, why build an index
    over the whole table and suffer the associated space/time costs?

    (There are other reasons too; see 
    <A
HREF="part-appendix.html#AEN27311"
><I
>Stonebraker, M, 1989b</I
></A
> for details.)
   </P
><P
>    The machinery to build, update and query partial indices isn't too
    bad.  The hairy parts are index selection (which indices do I build?)
    and query optimization (which indices do I use?); i.e., the parts
    that involve deciding what predicate(s) match the workload/query in
    some useful way.  For those who are into database theory, the problems
    are basically analogous to the corresponding materialized view
    problems, albeit with different cost parameters and formulae.  These
    are, in the general case, hard problems for the standard ordinal 
    <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>
    types; they're super-hard problems with black-box extension types,
    because the selectivity estimation technology is so crude.
   </P
><P
>    Check <A
HREF="part-appendix.html#AEN27311"
><I
>Stonebraker, M, 1989b</I
></A
>,
    <A
HREF="part-appendix.html#AEN27187"
><I
>Olson, 1993</I
></A
>,
    and
    <A
HREF="part-appendix.html#AEN27227"
><I
></I
></A
>
    for more information.
   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="indices.html"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="postgres.html"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="arrays.html"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Indices and Keys</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="indices.html"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Matrices</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>