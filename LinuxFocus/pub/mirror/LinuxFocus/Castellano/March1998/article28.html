<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"> 
<HTML lang="en"> 
<HEAD><META http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
 <TITLE>LinuxFocus March 1998 --  Programando OpenGL: Mas Sobre Lineas</TITLE> 
 <META name="Author" CONTENT="Miguel Angel Sepulveda"> 
 <META name="Keywords" CONTENT=" "> 
 <META name="Description" CONTENT=" "> 
 <META name="Copyright" CONTENT="&copy; 1998 LinuxFocus"> 
 <META name="Translator" CONTENT="Hugo Lastras"> 
 <META name="Date" CONTENT="1998-02-91T00:00:00Z"> 
 
</HEAD> 
 
<BODY bgcolor="#FFFFFF"  text="#000000" link="#ff0033" vlink="#FF3333"> 
 
  <MAP name="navegator"> 
  <AREA shape="rect" coords="0, 0, 65, 28" alt="Home" href="../"> 
  <AREA shape="rect" coords="66, 0, 124, 28" alt="Index" href="../indice.html"> 
  <AREA shape="rect" coords="125, 0, 193, 28" alt="Search" href="../search.html"> 
  <AREA shape="rect" coords="194, 0, 260, 28" alt="Links" href="../links.html"> 
  <AREA shape="rect" coords="261, 0, 350, 28" alt="About Us" href="../aboutus.html"> 
  </MAP> 
 
 
 
 <TABLE border="0" width="100%" cellspacing="0" cellpadding="0"> 
 
 <THEAD> 
   <TR align="center"> 
      <TD colspan="2"><IMG src="../../common/March1998/border-short.jpg" alt="[LinuxFocus Image]" width="407" height="88"></TD> 
   </TR> 
 
   <TR align="center"> 
      <TD colspan="2" bgcolor="#660033"><IMG src="../../common/March1998/Navegator-bar.gif" ismap usemap="#navegator" border="0" width="351" height="28" alt="[Navegation Bar]"></TD> 
   </TR> 
 
   <TR align="center"> 
     <TD colspan="2">      
           <TABLE  border="0" width="75%" cellspacing="0" cellpadding="0"> 
		<TR bgcolor="#000000"> 
		   <TD align="center"> 
               <A href="../News/"><FONT face="Helvetica,Arial" color="#ffffff"><B>&nbsp; Noticias</B></FONT></A> 
               <A href="../Archives/"><FONT face="Helvetica,Arial" color="#ffffff"><B>&nbsp; Archivos</B></FONT></A> 
               <A href="../Companies/"><FONT face="Helvetica,Arial" color="#ffffff"><B>&nbsp; Compa&ntilde;&iacute;as</B></FONT></A> 
               <A href="../Tips/"><FONT face="Helvetica,Arial" color="#ffffff"><B>&nbsp; Consejos &nbsp;</B></FONT></A>  
               </TD> 
            </TR> 
             
		<TR> 
            <!--   Here goes the Title of the article, authors name and abstract --> 
		   <TD align="center"> 
 			<FONT face="Helvetica,Arial" color="#660066"><H1>Programando OpenGL: M&aacute;s sobre lineas</H1></FONT> 
 			<FONT face="Helvetica,Arial" color="#000000"><H3>por <A href="mailto:angel@mercury.chem.pitt.edu"><FONT color="#000000">Miguel Angel Sep&uacute;lveda</FONT></A></H3></FONT> 
                  <HR size="2" noshade> 
	         </TD> 
            </TR> 
 
           </TABLE> 
 
     </TD> 
   </TR> 
 
 </THEAD> 
 
 
 
 <TBODY> 
   
 <TR> 
    <TD valign="top" align="center"> 
           <H4><A href="../../common/March1998/example2.c">../../common/March1998/example2.c</A></H4> 
           <H4><A href="../../common/March1998/Makefile">../../common/March1998/Makefile</A></H4> 
           
    </TD> 
    
    <TD align="center"> 
       <TABLE border="0" width="80%" cellspacing="20" cellpadding="0"> 
	  <TR> 
          <TD> 
  


	     <A name="intro"></A>
           <H3><FONT face="Helvetica,Arial" color="#660033">Dibujando L&iacute;neas</FONT></H3>




	    <P>En el &uacute;ltimo n&uacute;mero hablamos sobre los
	    elementos b&aacute;sicos para la construcci&oacute;n de
	    pol&iacute;gonos bajo OpenGL. Éste sólo soporta unas pocas
	    primitivas de objetos grométricos: puntos, líneas,
	    polígonos y superfícies descritas por vectores de pequeños
	    trianguos o cuadrilateros.</p>

 
	    <P>La &iacute;dea principal tras la simplicidad de OpenGL
	    es que es responsabilidad del desarrollador implementar
	    modelos geom&eacute;tricos m&aacute;s complejos a partir
	    de estos objetos simples. OpenGL contiene una serie de
	    comandos para controlar los detalles de los puntos, las
	    l&iacute;neas y los pol&iacute;gonos.</P>
 
          <P>Por ejemplo el tamaño de los puntos se puede especificar
          en p&iacute;xels empleando la primitiva
          <tt>glPointSize</tt>:</P>
 
          <CENTER> 
          <BR> 
	    <i>void</i> <b>glPointSize</b>(GLfloat <em>tamaño</em>)<BR> 
          <BR> 
          </CENTER> 
 
          <P>Por defecto el tamaño de los puntos es de 1.0 pixels y
          <em>tamaño</em> ha de ser siempre mayor que cero. El tamaño
          del punto se especifica con un número en coma floatante;
          est&aacute;n permitidos tamaños fraccionarios de puntos y
          l&iacute;neas. OpenGL interpreta las fraccionarines de
          p&iacute;xel seg&uacute;n el contexto de trazado. Si el modo
          anti-aliasing est&aacute; activado, entonces OpenGL modifica
          los p&iacute;xels del entorno de la l&iacute;nea en
          cuesti&oacute;n para dar la sensaci&oacute;n de que tiene
          anchura fraccional. El anti-aliasing es una t&eacute;cnica
          que se usa tambi&eacute;n para eliminar las escaleras que
          tienen las l&iacute;neas inclinadas en las pantallas de baja
          resoluci&oacute;n. Si el modo anti-aliasing no est&aacute;
          activado entonces <b>glPointSize</b> redonderá el valor de
          <em>tamaño</em> al entero m&aacute;s próximo.</P>
 
          <P>El tamaño f&iacute;sico de un p&iacute;xel depende
          realmente del dispositivo. Por ejemplo, en resoluciones de
          monitor bajas, el p&iacute;xel parece m&aacute;s ancho. Del
          mismo modo, en dispositivos con resoluciones muy altas, como
          un plotter, el ancho de l&iacute;nea por defecto (1
          p&iacute;xel) puede aparecer casi invisible. Para estimar el
          ancho real de tus l&iacute;neas debes conocer las
          dimensiones f&iacute;sicas de los p&iacute;xels en el
          dispositivo de salida.</P>
 
          <P>El ancho de las l&iacute;neas se específica con la
          funci&oacute;n <tt>glLineWidth</tt>, que se debe invocar
          antes del par de funciones <tt>glBegin() - glEnd()</tt> que
          dibujan la l&iacute;nea. Ésta es la sintaxis completa del
          comando:</P>
 
          <CENTER> 
          <BR> 
	    <i>void</i> <b>glLineWidth</b>(GLfloat <em>ancho</em>)<BR> 
          <BR> 
          </CENTER> 
 
          <P>Las implementaciones de OpenGL pueden limitar el ancho de
          las l&iacute;neas sin anti-aliasing al ancho m&aacute;ximo
          de las l&iacute;neas con anti-aliasing, redondeado al valor
          entero m&aacute;s próximo. Ten en cuenta tambi&eacute;n que
          el ancho de las l&iacute;neas no se mide perpendicularmente
          a la l&iacute;nea, sino en la direcci&oacute;n del eje de
          las y si el valor absoluto de la pendiente de la curva es
          menor que 1; o en la direcci&oacute;n del eje de las x si es
          mayor que 1.</P>

          <P>Este mes hemos preparado otra animaci&oacute;n 2D, simple
          pero esperemos que &uacute;til, que muestra c&oacute;mo usar
          varios tipos de anchos de l&iacute;nea en las aplicaciones
          OpenGL (<A href="../../common/March1998/example2.c">../../common/March1998/example2.c</A>, <A
          href="../../common/March1998/Makefile">../../common/March1998/Makefile</A>).  He elegido un ejemplo de
          F&iacute;sica Cu&aacute;ntica: una part&iacute;cula
          cu&aacute;ntica atrapada en una pozo doble de
          potencial. ¿Por qu&eacute;? Humm... pues lo he olvidado. De
          cualquier modo, imagino que ser&aacute; &uacute;til para que
          estudiantes de f&iacute;sica e ingenier&iacute;a vean
          c&oacute;mo integrar la ecuaci&oacute;n de Schroedinger
          dependiente del tiempo, los dem&aacute;s se pueden divertir
          viendo la naturaleza no intuitiva de la mec&aacute;nica
          cu&aacute;ntica. En MC, una part&iacute;cula no se
          representa por una posici&oacute;n y una velocidad, sino por
          una onda cu&aacute;ntica (l&iacute;nea p&uacute;rpura
          s&oacute;lida en nuestra animaci&oacute;n) cuyo valor
          cuadrado absoluto representa la probabilidad de observar la
          part&iacute;cula en una posici&oacute;n dada (l&iacute;nea
          blanca discont&iacute;nua):</P>

	  <CENTER><A HREF="../../common/March1998/ogl.gif">
	  <IMG src="../../common/March1998/ogl-thumb.gif" width="201" height="207" border="1" alt="[Click here to see the image]"></A>
	  <BR><I>Figura 1. Simulaci&oacute;n Cu&aacute;ntica</I>
	  </CENTER>

	 <P>Para aquellos que tengan algunos conocimientos de
	 Ecuaciones Diferenciales Ordinarias, decir que la
	 ecuaci&oacute;n de onda se integra usando el m&eacute;todo de
	 FFT (Transformada R&aacute;pida de Fourier)
	 Split-Operator. Este m&eacute;todo es mucho m&aacute;s exacto
	 y r&aacute;pido que cualquier m&eacute;todo de diferencias
	 finitas. Es aplicable a la propagaci&oacute;n de ondas
	 no-lineales; el operador de evoluci&oacute;n del tiempo se
	 divide en dos operadores de segundo o mayor orden que sólo
	 dependen o de la posici&oacute;n o del momento (frecuencia),
	 entonces se hace evolucionar en el tiempo a la funci&oacute;n
	 de onda aplicando sucesivamente estos operadores cambiando
	 alternativamente entre el espacio de posiciones y el espacio
	 de momentos (frecuencias).</P>


	 <P>El cuerpo del c&oacute;digo fuente se puede usar para
	 muchas otras aplicaciones. Puedes cambiar mi
	 simulaci&oacute;n cu&aacute;ntica por tu funci&oacute;n
	 dependiente del tiempo y obtener una animaci&oacute;n maja de
	 tu sistema. Puedes probar tambi&eacute;n a escribir un
	 gnuplot simplificado basado en OpenGL para plotear funciones
	 y ficheros de datos.</P>


        <P>Si el lector ha seguido los art&iacute;culos previos sobre
        GLUT y OpenGL este c&oacute;digo fuente ser&aacute; muy
        sencillo y f&aacute;cil de entender (dejando a parte la
        mec&aacute;nica cu&aacute;ntica). No hay nada
        extraordinario. En la funci&oacute;n <tt>main()</tt> abrimos
        una sola ventana en modo buffer doble, entonces le pasamos
        unas funciones callback <tt>display()</tt> e <tt>idle()</tt>
        que se encargan de dibujar la funci&oacute;n de onda e
        integrar la ecuaci&oacute;n de onda, respectivamente. Entender
        lo que pasa en la funci&oacute;n <tt>idle()</tt>, aunque es un
        truco muy bonito, no es necesario para captar el contenido de
        este art&iacute;culo. Las cosas nuevas sobre OpenGL
        est&aacute;n en la funci&oacute;n callback
        <tt>display</tt>:</P>

<PRE>
void
display (void)
{
  static char label[100];
  float xtmp;

  /* Limpiar el espacio de dibujo */
  glClear (GL_COLOR_BUFFER_BIT);


  /* Escribir la nota al pie */
  glColor3f (0.0F, 1.0F, 1.0F);
  sprintf (label, "(c)Miguel Angel Sepulveda 1998");
  glRasterPos2f (-1.1, -1.1);
  drawString (label);


  /* Dibujar una rejilla fina */
  glLineWidth (0.5);
  glColor3f (0.5F, 0.5F, 0.5F);
  glBegin (GL_LINES);
  for (xtmp = -1.0F; xtmp < 1.0F; xtmp += 0.05)
    {
      glVertex2f (xtmp, -1.0);
      glVertex2f (xtmp, 1.0);
      glVertex2f (-1.0, xtmp);
      glVertex2f (1.0, xtmp);
    };
  glEnd ();

  /* Dibujar el cuadrado del borde */
  glColor3f (0.1F, 0.80F, 0.1F);
  glLineWidth (3);
  glBegin (GL_LINE_LOOP);
  glVertex2f (-1.0F, -1.0F);
  glVertex2f (1.0F, -1.0F);
  glVertex2f (1.0F, 1.0F);
  glVertex2f (-1.0F, 1.0F);
  glEnd ();

  /* Dibujar la rejilla */
  glLineWidth (1);
  glColor3f (1.0F, 1.0F, 1.0F);
  glBegin (GL_LINES);
  for (xtmp = -0.5; xtmp < 1.0; xtmp += 0.50)
    {
      glVertex2f (xtmp, -1.0);
      glVertex2f (xtmp, 1.0);
      glVertex2f (-1.0, xtmp);
      glVertex2f (1.0, xtmp);
    };
  glEnd ();

  /* Dibujar los ejes de coordenadas */
  glLineWidth (2);
  glBegin (GL_LINES);
  glVertex2f (-1.0, 0.0);
  glVertex2f (1.0, 0.0);
  glVertex2f (0.0, -1.0);
  glVertex2f (0.0, 1.0);
  glEnd ();

  /* Etiquetas de los ejes */
  glColor3f (1.0F, 1.0F, 1.0F);
  sprintf (label, "Position");
  glRasterPos2f (0.80F, 0.025F);
  drawString (label);
  glColor3f (1.0F, 0.0F, 1.0F);
  sprintf (label, " Quantum Probability ");
  glRasterPos2f (0.025F, 0.90F);
  drawString (label);
  glColor3f (1.0F, 1.0F, 1.0F);
  sprintf (label, " Real(Psi) ");
  glRasterPos2f (0.025F, 0.85F);
  drawString (label);

  /* Dibujar la funcion de onda */
  psiDraw (NR_POINTS, psi, x);

  /* Dibujar la funcion de potencial */
  potentialDraw (NR_POINTS, potential, x);

  glutSwapBuffers ();
};

</PRE>

        <P>Lo primero que se hace es borrar el bit del buffer de
        color, que nos da un espacio de dibujo limpio
        (negro). Añadimos una nota al pie usando <tt>glRasterPos</tt>
        y <tt>glutBitmapCharacter</tt> (drawstring no es nada
        m&aacute;s que una envoltura para la utilidad clut). En
        lecciones futuras <tt>glRasterPos</tt> aparecer&aacute; de
        nuevo como una funci&oacute;n auxiliar para el trazado de
        texturas. Ni OpenGL ni GLUT ofrecen una manera simple y
        potente de trazar texto en una ventana gr&aacute;fica.  La
        funci&oacute;n glutBitmapCharacter b&aacute;sicamente copia
        una fuente de mapas de bits en el buffer de color. </P>

        <P>Despu&eacute;s de la nota al pie vienen una serie de
        l&iacute;neas: el borde exterior, la rejilla de fondo, los
        ejes de coordenadas y, naturalmente, las curvas en
        cuesti&oacute;n, dibujadas con <tt>psiDraw</tt> y
        <tt>potentialDraw</tt>. Antes de trazar cada l&iacute;nea hay
        una instrucci&oacute;n <tt>glLineWidth</tt> que especifica el
        n&uacute;mero de p&iacute;xels de ancho que se debe dar a la
        l&iacute;nea. La Figura 1 muestra la salida en un X Window
        System (Linux Alpha). Por alguna raz&oacute;n que desconozco,
        la salida del mismo programa en Windows 95 sale bastante mal,
        parece que la capacidad de antialiasing no est&aacute; muy
        bien soportada en el driver de OpenGL de SGI; es
        dif&iacute;cil diferenciar l&iacute;neas que en principio
        deber&iacute;an tener anchura diferente, y la rejilla de
        l&iacute;neas de fondo tambi&eacute;n aparece muy
        uniforme. Estos defectos aparecen cuando el monitor
        est&aacute; puesto a alta resoluci&oacute;n, luego no es un
        defecto de una resoluci&oacute;n baja. Es para mi un placer
        decir que, una vez m&aacute;s, un X Window System en Linux
        sobrepasa por mucho a win95/NT.</P>

        <P>Hay dos tipos de trazado de l&iacute;neas en la
        funci&oacute;n <tt>display()</tt>, el modo GL_LINES, que une
        v&eacute;rtices con una l&iacute;nea continua abierta, y el
        modo GL_LINE_LOOP, que al final cierra el lazo. </P>



	     <A name="intro"></A>
           <H3><FONT face="Helvetica,Arial" color="#660033">L&iacute;neas con Antialiasing</FONT></H3>



        <P>He activado el antialiasing para las l&iacute;neas en la
        funci&oacute;n callback <tt>reshape()</tt>,</P>
   

<PRE>
void
reshape (int w, int h)
{
  glMatrixMode (GL_MODELVIEW);
  glLoadIdentity ();
  glViewport (0, 0, w, h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluOrtho2D (-1.2, 1.2, -1.2, 1.2);
  <B>glEnable (GL_LINE_SMOOTH);</B>     /* Activar lineas con Antialiasing */
  glEnable (GL_LINE_STIPPLE);
};
</PRE>
     
       
       <P>¿Para qu&eacute; sirve GL_LINE_STIPPLE? OpenGL nos deja
       controlar no sólo el ancho de una l&iacute;nea sino
       tambi&eacute;n su patr&oacute;n.  Activando GL_LINE_STIPPLE
       podremos dibujar l&iacute;neas ralladas, punteadas o con
       cualquier otro patr&oacute;n. La &uacute;nica l&iacute;nea que
       lo utiliza en nuestra animaci&oacute;n aparece en la
       funci&oacute;n <tt>psiDraw()</tt>:</P>

<PRE>
  glLineWidth (1);
  glPushAttrib (GL_LINE_BIT);
  <B>glLineStipple (3, 0xAAAA);</B>
  glBegin (GL_LINE_STRIP);
  for (i = 0; i < nx; i++)
    {
      xs = ratio1 * (x[i] - XMIN) - 1.0;
      ys = ratio2 * (psi[2 * i] - YMIN) - 1.0;
      glVertex2d (xs, ys);
    };
  glEnd ();
  glPopAttrib ();
</PRE>

	     <A name="intro"></A>
           <H3><FONT face="Helvetica,Arial" color="#660033">L&iacute;neas Punteadas</FONT></H3>


        <P>La funci&oacute;n <tt>glLineStipple</tt> específica el
        patr&oacute;n usado para el punteado, en nuestro ejemplo hemos
        usado el patr&oacute;n 0xAAAA. En binario este n&uacute;mero
        es 0000100010001000 y OpenGL interpreta esto dibujando 3 bits
        apagados, 1 bit encendido, 3 bits apagados, 1 bit encendido, 3
        bits apagados, 1 bit encendido y por &uacute;ltimo 4 bits
        apagados. La patr&oacute;n se lee hacia atr&aacute;s porque
        los bits de menor orden se usan
        primero. <tt>glLineStipple</tt> tiene dos par&aacute;metros,
        el patr&oacute;n de punteado que debe ser un n&uacute;mero
        hexadecimal y un factor entero que sirve para escalar este
        patr&oacute;n; con un factor de 3 nuestra l&iacute;nea
        punteada mostrar&aacute; 9 bits apagados, 3 bits encendidos, 9
        bits apagados, 3 bits encendidos, 9 bits apagados, 3 bits
        encendidos y por &uacute;ltimo 12 bits apagados. Jugando con
        factores y patrones binarios uno puede dibujar todo tipo de
        l&iacute;neas punteadas complicadas.</P>

        <P>Un detalle m&aacute;s: he puesto el trazado de la
        l&iacute;nea punteada entre dos sentencias de push y pop de
        atributos. ¿Record&aacute;is cuando en nuestro primer
        art&iacute;culo dijimos que OpenGL es una m&aacute;quina de
        estados? En futuros art&iacute;culos veremos con m&aacute;s
        detalle estas operaciones de push y pop, pero brevemente lo
        que estamos haciendo con la primera sentencia <tt>glPushAttrib
        (GL_LINE_BIT)</tt> es guardar en una pila el valor acutal de
        la variable de estado GL_LINE_BIT (esta variable decide el
        patr&oacute;n de punteado), entonces podemos modificar
        GL_LINE_BIT con nuestra sentencia <tt>glLineStipple</tt> y
        cuando hemos acabado llamamos a <tt>glPopAttrib</tt> que
        devuelve el valor antiguo de la variable GL_LINE_BIT. Este
        mecanismo es una manera efectiva de modificar las variables de
        estado de OpenGL localmente. Si no lo hacemos as&iacute;
        entonces todas las l&iacute;neas dibujadas despu&eacute;s de
        <tt>glLineStipple</tt> tendr&iacute;an el mismo patr&oacute;n
        de punteado y estar&iacute;amos forzados a declarar un
        patr&oacute;n con <tt>glLineStipple</tt> para cada
        l&iacute;nea que traz&aacute;semos en nuestra
        aplicaci&oacute;n. Push y pop nos evitan este molesto
        trabajo.</P>



	     <A name="intro"></A>
           <H3><FONT face="Helvetica,Arial" color="#660033">Pr&oacute;ximamente ....</FONT></H3>

         <P>OpenGL es famoso por su maravillosa API 3D. Hasta
         aqu&iacute; hemos explorado algunas posibilidades elementales
         de trazado 2D con OpenGL.  En el pr&oacute;ximo n&uacute;mero
         examinaremos el escenario de OpenGL 3D, c&oacute;mo poner una
         perspectiva, sistemas de coordenadas, planos de corte y
         matrices de proyecci&oacute;n.</P>

         <P>Hasta entonces, a divertirse con OpenGL.......</P>


          </TD> 
        </TR> 
	 </TABLE> 
 
     <HR size=2 noshade> 
        <P align="right"><I>Traducido por <A href="mailto:lastras@writeme.com"><FONT color="#000000">Hugo Lastras</FONT></A></I></P>

    </TD> 
 
 </TR> 
 
 </TBODY> 
 
<TBODY> 
  <TR> 
    <TD colspan="2"> 
    <B>Para m&aacute;s informaci&oacute;n</B>:<BR> 
    <UL> 
      <LI>Lee <A href="article29.html">Programando GLUT: Control de Ventanas</A>. </LI> 
      <LI>Mira en <A href="http://www.opengl.org">http://www.opengl.org</A>.</LI>  
      <LI>Lee otros art&iacute;culos del mismo autor:
       <A href="../January1998/article15.html">¿Qu&eacute; es OpenGL?</A>,
       <A href="../January1998/article17.html">Programando OpenGL: Trazado de Pol&iacute;gonos Simples</A>,
       <A href="../January1998/article16.html">Programando GLUT: Ventanas y Animaciones</A>
        </LI>  
     <UL><BR><BR> 
    <TD> 
  </TR> 
</TBODY> 
 
 <TR bgcolor="#660033"> 
   <TD colspan="2" align="center"><FONT face="Helvetica,Arial" color="#FFFFFF"><B> 
         &copy; 1998 Miguel Angel Sepulveda</B></FONT><BR> 
    <FONT color="#ffffff">P&aacute;ginas web mantenidas por  
    <A href="mailto:angel@mercury.chem.pitt.edu"><FONT color="#ffffff">Miguel A Sepulveda</FONT></A></FONT>. 
   </TD> 
 </TR> 
 
 
 
</TABLE> 
 
 
</BODY> 
</HTML> 
 
 
 
 
 
