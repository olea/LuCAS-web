<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.17">
 <META NAME="LFCATEGORY" CONTENT="UNIX Basics">
<!-- this is used be a number of tools:
 =LF=AUTHOR: Katja and Guido Socher
 =LF=CAT___: UNIX Basics
 =LF=TITLE_: Programaci&oacute;n en Shell
 =LF=NUMBER: 216
 =LF=ANAME_: article216.html
 -->
 <TITLE>lf216, UNIX Basics: Programaci&oacute;n en Shell</TITLE>
<!-- stylesheet added by lfparser: --> 
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-familiy:monospace,Courier }
 p.cl { color:#EE9500 }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; border-style:none; border-width:medium; border-color:#FFD700; padding:0.5cm ;  text-align:center }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; border-width:medium; border-color:#AAAAAA; padding:0.5cm ; margin-top:0.1cm; margin-right:1cm; margin-left:1cm; text-align:center }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://www.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar -->
 <!-- top navegation bar -->
 <TABLE cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="144"><IMG src="../../common/images/logolftop.gif"
           alt="[LinuxFocus-icon]" width="350" height="45" align="left" 
           border="0"></TD>

           <TD class="top">
             <TABLE width="100%">
               <TR align="right">
                 <TD class="top"><A class="nodec" href="../"><FONT color=
                 "#DDDDDD">Home</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../map.html"><FONT color=
                 "#DDDDDD">Map</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../indice.html"><FONT color=
                 "#DDDDDD">Index</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../Search/"><FONT color=
                 "#DDDDDD">Search</FONT></A> </TD>
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD><A class="nodec" href="../News/"><FONT color=
           "#FFFFFF">News</FONT></A> </TD>
           <TD><FONT color="#FFFFFF">|</FONT> </TD>
           <TD><A class="nodec" href="../Archives/"><FONT color=
           "#FFFFFF">Archives</FONT></A> </TD>
           <TD><FONT color="#FFFFFF">|</FONT> </TD>
           <TD><A class="nodec" href="../Links/"><FONT color=
           "#FFFFFF">Links</FONT></A> </TD>
           <TD><FONT color="#FFFFFF">|</FONT> </TD>
           <TD><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">About LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!--#include virtual="../../dynahead.shtml" -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT BIO ABOUT THE AUTHOR -->
<TABLE ALIGN=LEFT BORDER=0 hspace=4 vspace=4 WIDTH="30%" >
<TR>
<TD>

<!-- 2pdaIgnoreStart -->
<!-- PALM DOC -->
<TABLE BORDER=0 hspace=4 vspace=4> <TR> <TD>
<font size=1> <img src="../../common/images/2doc.gif" width=34 align=left border=0 height=22 alt="convert to palm"><a href="http://cgi.linuxfocus.org/cgi-bin/2ztxt">Convert to GutenPalm</a><br>or <a href="http://cgi.linuxfocus.org/cgi-bin/2pda">to PalmDoc</a></font>
</TD> </TR> </TABLE>
<!-- END PALM DOC -->
<!-- 2pdaIgnoreStop -->
<br>
<IMG src="../../common/images/KatjaAndGuido.jpg" alt=
    "[Photo of the Authors]" height="150" width="168">
<BR>by  <A href="mailto:katja&#64;linuxfocusorg, guido@linuxfocus.org">Katja and Guido Socher</A>
<BR><BR>
<I>About the author:</I><BR>
<P>Katja es la editora alemana de LinuxFocus. Le gusta Tux, las pel&iacute;culas
    &amp; la fotograf&iacute;a y el mar. Puedes visitar su p&aacute;gina personal <A href=
    "http://linuxfocus.org/~katja/">aqu&iacute;</A>.</P><P>Guido es un fan de Linux desde hace mucho tiempo y le gusta Linux porque
    est&aacute; dise&ntilde;ado por personas abiertas y honestas. Esta es una de las razones por la
    que lo llamamos c&oacute;digo abierto (open source). Su p&aacute;gina personal est&aacute; en <A href=
    "http://linuxfocus.org/~guido/">linuxfocus.org/~guido</A>.</P>
<BR><i>Content</i>:
<UL>
  <LI><A HREF="#216lfindex0">&iquest;Por qu&eacute; la programaci&oacute;n en shell?</A></LI>
  <LI><A HREF="#216lfindex1">Creando un script</A></LI>
  <LI><A HREF="#216lfindex2">Comentarios</A></LI>
  <LI><A HREF="#216lfindex3">Variables</A></LI>
  <LI><A HREF="#216lfindex4">Comandos de shell y estructuras de control</A></LI>
  <LI><A HREF="#216lfindex5">Ejemplos</A></LI>
  <LI><A HREF="#216lfindex6">Depuraci&oacute;n</A></LI>
  <LI><A HREF="#216lfindex7">Referencias</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=216&lang=en">Talkback form for this article</A></LI>
</UL>

</TD></TR></TABLE>
<!-- HEAD OF THE ARTICLE -->
<br>&nbsp;
<H2>Programaci&oacute;n en Shell</H2>
 <IMG src="../../common/images/illustration216.jpg" width="199"
    height="150" alt="[Illustration]" hspace="10">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Abstract</i>:
<P>

    En este art&iacute;culo se explica c&oacute;mo escribir peque&ntilde;os scripts de shell
    utilizando muchos ejemplos.

    </P>
<HR size="2" noshade align="right"><BR>
<!-- BODY OF THE ARTICLE -->


    <A NAME="216lfindex0">&nbsp;</A>
<H2>&iquest;Por qu&eacute; la programaci&oacute;n en shell?</H2>

    Incluso existiendo varios interfaces gr&aacute;ficos disponibles para Linux
    el shell sigue siendo una herramienta muy eficiente. El shell no es s&oacute;lo
    una colecci&oacute;n de comandos sino un buen lenguaje de programaci&oacute;n.
    Se pueden automatizar muchas tareas con &eacute;l, el shell es muy &uacute;til para
    tareas de administraci&oacute;n, puedes comprobar r&aacute;pidamente si tus ideas
    funcionan lo que lo hace muy &uacute;til cuando est&aacute;s creando un prototipo
    y es muy &uacute;til para peque&ntilde;as utilidades que realizan tareas relativamente
    simples donde la eficiencia importa menos que la facilidad de configuraci&oacute;n,
    mantenimiento y portabilidad.<BR>
     Por lo tanto veamos como funciona: <BR>


    <A NAME="216lfindex1">&nbsp;</A>
<H2>Creando un script</H2>

    Existen muchos shells disponibles para Linux pero habitualmente
    se utiliza el bash (bourne again shell) para la programaci&oacute;n en shell ya que
    est&aacute; disponible libremente y es f&aacute;cil de usar. Por lo tanto todos los scripts que
    escribamos en este art&iacute;culo usar&aacute;n el bash (aunque la mayor&iacute;a de veces tambi&eacute;n
    funcionar&aacute;n con su hermano mayor, el bourne shell).<BR>
     Para escribir nuestros programas en shell usaremos cualquier clase de editor de
    texto, p.ej. nedit, kedit, emacs, vi... como con otros lenguajes de programaci&oacute;n.<BR>
     El programa debe empezar con la siguiente l&iacute;nea (debe ser la primera l&iacute;nea
    del fichero):<BR>

<PRE>
    #!/bin/sh

</PRE>
    Lo caracteres #! indican al sistema que el primer argumento que
    sigue en la linea es el programa a utilizar para ejecutar este fichero.
    En este caso usamos el shell /bin/sh.<BR>
     Cuando hallas escrito y guardado tu script debes hacerlo
    ejecutable para poder usarlo.<BR>
     Para hacer el script ejecutable escribe<BR>
     chmod +x nombre-del-fichero <BR>
     Despu&eacute;s puedes ejecutar tu script escribiendo: <TT>./nombre-del-fichero</TT> <BR>


    <A NAME="216lfindex2">&nbsp;</A>
<H2>Comentarios</H2>

    Los comentarios en la programaci&oacute;n en shell comienzan con # se prolongan
    hasta el final de la l&iacute;nea. Te recomendamos que uses comentarios. Si tienes
    comentarios y no usas un cierto script durante alg&uacute;n tiempo inmediatamente
    sabr&aacute;s qu&eacute; hace y c&oacute;mo funciona. <BR>


    <A NAME="216lfindex3">&nbsp;</A>
<H2>Variables</H2>

    Como en otros lenguajes de programaci&oacute;n no se puede vivir sin variables.
    En la programaci&oacute;n en shell todas las variables son de tipo string y no
    es necesario declararlas. Para asignar un valor a una variable se escribe:
<PRE>
nombre_de_la_variable=valor
</PRE>
    Para obtener el valor de la variable simplemente hay que poner el signo del
    d&oacute;lar delante de la variable:
<PRE>
#!/bin/sh
# asignamos un valor:
a="hola mundo"
# ahora mostramos el contenido de  "a":
echo "A es:"
echo $a
</PRE>
    Escribe estas l&iacute;neas en tu editor de textos y guardalo p.ej. como primero.
    Despu&eacute;s haz ejecutable el script escribiendo chmod +x primero en el
    shell y despu&eacute;s ejec&uacute;talo escribiendo ./primero<BR>
    El script mostrar&aacute; lo siguiente:
<PRE>
A es:
hola mundo
</PRE>
    Algunas veces es posible confundir nombres de variables con el resto del texto:
<PRE>
num=2
echo "este es el $numº"
</PRE>
    Aqu&iacute; no se mostrar&aacute; "este es el 2º" si no "este es el " porque
    el shell busca una variable llamada numdo que no tiene valor.
    Para decirle al shell que queremos mostrar la variable num tenemos que usar
    llaves:
<PRE>
num=2
echo "este es el ${num}º"
</PRE>
    Con esto imprimiremos lo que queremos: este es el 2º <BR>
    <BR>
    Hay una serie de variables que se establecen automaticamente.
    Hablaremos sobre ellas m&aacute;s adelante cuando las usemos por
    primera vez.<BR>
    <BR>
     Si necesitas manejar expresiones matem&aacute;ticas entonces necesitas
    usar programas como expr (ver tabla abajo).<BR>
     Adem&aacute;s de las variables de shell normales que son &uacute;nicamente v&aacute;lidas
    dentro del programa en shell hay tambi&eacute;n variables de entorno. Una
    variable precedida de la palabra clave export es una variable de entorno.
    No vamos a comentar nada m&aacute;s sobre ellas ya que normalmente s&oacute;lo
    se utilizan en scripts de entrada al sistema.

    <A NAME="216lfindex4">&nbsp;</A>
<H2>Comandos de shell y estructuras de control</H2>

    Hay tres categor&iacute;as de comandos que pueden ser usados
    en scripts de shell:<BR>
     <BR>
     <B>1)Comandos Unix:</B><BR>
     Aunque un script de shell puede hacer uso de cualquier comando unix aqu&iacute;
    tienes varios comandos utilizados con m&aacute;s frecuencia que el resto. Estos comandos
    se decriben como comandos para la manipulaci&oacute;n de ficheros y texto.<BR>

    <TABLE bgcolor="#aaaaff" border="1" align="center">
      <TR>
        <TH width="30%">Sintaxis del comando</TH>

        <TH>Utilidad</TH>
      </TR>

      <TR>
        <TD>echo "texto cualquiera"</TD>

        <TD>escribir un texto cualquiera en tu pantalla</TD>
      </TR>

      <TR>
        <TD>ls</TD>

        <TD>listar ficheros</TD>
      </TR>

      <TR>
        <TD>wc -l fichero<BR>
        wc -w fichero<BR>
        wc -c fichero</TD>

        <TD>contar las l&iacute;neas de un fichero o<BR>
         contar las palabras de un fichero o<BR>
         contar el n&uacute;mero de car&aacute;cteres</TD>
      </TR>

      <TR>
        <TD>cp fichero_origen fichero_destino</TD>

        <TD>copiar el fichero_origen al fichero_destino</TD>
      </TR>

      <TR>
        <TD>mv nombre_antiguo nuevo_nombre</TD>

        <TD>renombrar o mover un fichero</TD>
      </TR>

      <TR>
        <TD>rm fichero</TD>

        <TD>borrar un fichero</TD>
      </TR>

      <TR>
        <TD>grep 'patr&oacute;n' fichero</TD>

        <TD>buscar cadenas en un fichero<BR>
        Ejemplo: grep 'cadena-a-buscar' fichero.txt</TD>
      </TR>

      <TR>
        <TD>cut -b num_de_columna fichero</TD>

        <TD>sacar datos de columnas de texto de ancho definido<BR>
        Ejemplo: sacar los caracteres de la posici&oacute;n 5 a la 9<BR>
        cut -b5-9 fichero.txt<BR>
        No confundais este comando con "cat" que es algo
        totalmente diferente</TD>
      </TR>

      <TR>
        <TD>cat fichero.txt</TD>

        <TD>mostrar un fichero.txt por stdout (tu pantalla)</TD>
      </TR>

      <TR>
        <TD>file un_fichero</TD>

        <TD>describir qu&eacute; tipo de fichero es un_fichero</TD>
      </TR>

      <TR>
        <TD>read var</TD>

        <TD>esperar a que el usuario introduzca algo y guardarlo
        en la variable (var)</TD>
      </TR>

      <TR>
        <TD>sort fichero.txt</TD>

        <TD>ordenar las l&iacute;neas del fichero fichero.txt</TD>
      </TR>

      <TR>
        <TD>uniq</TD>

        <TD>borrar las l&iacute;neas duplicadas, usado en combinaci&oacute;n con sort
        ya que uniq s&oacute;lo borra las l&iacute;neas duplicadas consecutivas<BR>
        Ejemplo: sort fichero.txt | uniq<BR>
        </TD>
      </TR>

      <TR>
        <TD>expr</TD>

        <TD>hacer operaciones matem&aacute;ticas en el shell<BR>
        Ejemplo: sumar 2 y 3<BR>
        expr 2 "+" 3</TD>
      </TR>

      <TR>
        <TD>find</TD>

        <TD>buscar ficheros<BR>
        Ejemplo: buscar por nombre:<BR>
        find . -name nombre_del_fichero -print<BR>
        Este comando tiene muchas posibilidades y opciones diferentes.
        Desafortunadamente son demasiadas para explicarlas todas
        en este art&iacute;culo.</TD>
      </TR>

      <TR>
        <TD>tee</TD>

        <TD>escribir datos por stdout (tu pantalla) y a un fichero<BR>
        Normalmente se usa as&iacute;:<BR>
        un-comando | tee fichero-de-salida<BR>
        Escribe la salida de un-comando por la pantalla y a
        el fichero de salida</TD>
      </TR>

      <TR>
        <TD>basename fichero</TD>

        <TD>devolver el nombre del fichero dado un nombre y
        quitarle la ruta al directorio<BR>
        Ejemplo: basename /bin/tux<BR>
        devuelve s&oacute;lo tux</TD>
      </TR>

      <TR>
        <TD>dirname fichero</TD>

        <TD>devolver el nombre del directorio dado un nombre y
        quit&aacute;ndole el nombre del fichero<BR>
        Ejemplo: dirname /bin/tux<BR>
        devuelve /bin</TD>
      </TR>

      <TR>
        <TD>head fichero</TD>

        <TD>mostrar algunas l&iacute;neas del principio de un fichero</TD>
      </TR>

      <TR>
        <TD>tail fichero</TD>

        <TD>mostrar algunas l&iacute;neas del final de un fichero</TD>
      </TR>

      <TR>
        <TD>sed</TD>

        <TD>sed es b&aacute;sicamente un programa para buscar y reemplazar. Lee el texto
        de la entrada est&aacute;ndar (p.ej. una tuber&iacute;a) y escribe el resultado por
        stdout (normalmente la pantalla). El patr&oacute;n de b&uacute;squeda es una expresi&oacute;n
        regular (ver referencias). Este patr&oacute;n de b&uacute;squeda de se debe
        confundir con la sintaxis de comodines (wildcard) del shell. Para reemplazar
        la cadena linuxfocus con LinuxFocus es un fichero de texto usa:<BR>
        cat texto.fichero | sed 's/linuxfocus/LinuxFocus/' &gt;
        nuevotexto.fichero<BR>
        Esto reemplaza la primera aparici&oacute;n de la cadena linuxfocus en
        cada l&iacute;nea por LinuxFocus. Si hay l&iacute;neas en que linuxfocus
        aparece varias veces y quieres reemplazarlas todas usa:<BR>
        cat texto.fichero | sed 's/linuxfocus/LinuxFocus/g' &gt;
        nuevotexto.fichero<BR>
        </TD>
      </TR>

      <TR>
        <TD>awk</TD>

        <TD>
          La mayor&iacute;a de las veces awk se utiliza para extraer campos de una
          l&iacute;nea de un texto.
          El campo separador por defecto es un espacio. Para especificar uno
          diferente se usa la opci&oacute;n -F.
<PRE>
 <SMALL>cat fichero.txt | awk -F, '{print $1 "," $3 }'
</SMALL>
</PRE>
          Aqu&iacute; hemos usado la coma (,) como separador de campos e imprimimos
          la columna primero y tercera ($1 $3). Si fichero.txt tiene l&iacute;neas como:
<PRE>
<SMALL>Adam Bor, 34, India
Kerry Miller, 22, USA
</SMALL>
</PRE>
          estonces mostrar&iacute;a lo siguiente:
<PRE>
<SMALL>Adam Bor, India
Kerry Miller, USA
</SMALL>
</PRE>
          Se pueden hacer muchas m&aacute;s cosas con awk pero este es
          su uso m&aacute;s com&uacute;n.
        </TD>
      </TR>
    </TABLE>
    <BR>
    <BR>
     <B>2) Conceptos: Tuber&iacute;as (pipes), redirecciones y comillas simples invertidas</B><BR>
     Realmente no son comando pero son conceptos muy importantes.<BR>
<BR>
     <B>tuber&iacute;as (pipes)</B> (|) envian la salida (stdout) de un programa a la
    entrada (stdin) de otro.<BR>
<PRE>
    grep "hola" fichero.txt | wc -l
</PRE>
    encuentra las l&iacute;neas con la cadena hola en fichero.txt y despu&eacute;s cuenta
    el n&uacute;mero de l&iacute;neas.<BR>
     La salida del comando grep se usa como entrada del comando wc.
    De esta manera se pueden contatenar tantos comandos como se quiera
    (dentro de unos l&iacute;mites razonables). <BR>
    <BR>
     <B>redirecciones</B>: escribe la salida de un comando a un fichero
    o a&ntilde;ade datos a un fichero<BR>
     &gt; escribe la salida a un fichero y sobreescribe el fichero antiguo
    en caso de existir<BR>
     &gt;&gt; a&ntilde;ade datos a un fichero (o crea uno nuevo si no exist&iacute;a
    previamente pero nunca sobreescribe nada).<BR>
    <BR>

     <B>Comillas simples invertidas (o tilde invertida)</B><BR>
     La salida de un comando se puede usar como argumento de l&iacute;nea de comandos (no
    stdin como anteriormente, los argumentos de l&iacute;nea de comando son cadenas que se
    especifican destr&aacute;s de un comando como con los nombres de ficheros y opciones) para
    otro comando. Tambi&eacute;n se pueden usar para asignar la salida de un
    comando a una variable. <BR>
     El comando
<PRE>
find . -mtime -1 -type f -print
</PRE>
    encuetra todos los ficheros que han sido modificados en las &uacute;ltimas 24 horas
    (-mtime -2 ser&iacute;an 48 horas). Si quisieramos empaquetar estos fichero
    en un archivo tar (fichero.tar) la sintaxis ser&iacute;a:
<PRE>
tar xvf fichero.tar fichero1 fichero2 ...
</PRE>
    En vez de escribirlo todo se pueden combinar los dos comandos (find
    y tar) usando comillas simples invertidas. Entonces tar empaquetar&aacute; todos los ficheros
    que muestre find:
<PRE>
#!/bin/sh
# Las comillas son comillas simples invertidas (`)  no comillas normales ('):
tar -zcvf ultimodific.tar.gz `find . -mtime -1 -type f -print`
</PRE>
    <BR>
     <B>3) Estructuras de control</B><BR>
    La <B>sentencia "if"</B> comprueba si una condici&oacute;n es verdadera  (con salida
    de estado 0, correcto). Si es correcto entonces se ejecuta la parte "then":
<PRE>
if ....; then
   ....
elif ....; then
   ....
else
   ....
fi
</PRE>
    La mayor&iacute;a de las veces se utiliza un comando muy especial dentro de las
    sentencias if. Se puede usar para comparar cadena o comprobar si un fichero
    existe, tiene permiso de lectura etc... <BR>
    El comando "test" se escribe como corchetes " [ ] ". Aqu&iacute; los espacios
    son muy importantes: Aseg&uacute;rate que siempre hay un espacio
    entre corchetes. Ejemplos:
<PRE>
[ -f "un-fichero" ]  : Comprueba si un-fichero es un fichero.
[ -x "/bin/ls" ]   : Comprueba si /bin/ls existe y es ejecutable.
[ -n "$var" ]      : Comprueba si la variable $var contiene algo
[ "$a" = "$b" ]    : Comprueba si las variables "$a" y  "$b" son iguales
</PRE>
    Ejecuta el comando "man test" y obtendr&aacute;s una larga lista con todo
    tipo de operadores test para comparaciones y ficheros. <BR>
    Usarlo en scripts de shell es bastante directo:
<PRE>
#!/bin/sh
if [ "$SHELL" = "/bin/bash" ]; then
  echo "tu shell es el bash (bourne again shell)"
else
  echo "tu shell no es bash sino $SHELL"
fi
</PRE>
    La variable $SHELL contiene el nombre de la shell donde est&aacute;s y esto
    es lo que estamos comprobando aqu&iacute; comparandola con la cadena
    "/bin/bash" <BR>
    <BR>
    <B>Operadores cortos</B><BR>
    A aquellos que conozcan C les gustar&aacute; la siguiente expresi&oacute;n:<BR>
<PRE>
[ -f "/etc/shadow" ] &amp;&amp; echo "Este ordenador usa shadow passwors"
</PRE>
    Los &amp;&amp; se pueden usar como una peque&ntilde;a sentencia if. Lo de la derecha
    se ejecuta si lo de la izquierda es verdadero. Podemos interpretarlo como un Y (AND). Por
    lo tanto el ejemplo quedar&iacute;a: "El fichero /etc/shadow existe Y (AND) se ejecuta
    el comando echo". Tambi&eacute;n est&aacute; disponible el operador O (OR) (||). Un ejemplo:
<PRE>
#!/bin/sh
mailfolder=/var/spool/mail/james
[ -r "$mailfolder" ] || { echo "No se ha podido leer $mailfolder" ; exit 1; }
echo "$mailfolder tiene mensajes de:"
grep "^From " $mailfolder
</PRE>
    El script comprueba primero si puede leer un buz&oacute;n de correo. Si puede
    entonces imprime las l&iacute;neas "From" del buz&oacute;n. Si no puede leer
    el fichero $mailfolder entonces se activa el operador O. Sencillamente
    este c&oacute;digo lo leer&iacute;amos como "Mailfolder legible o salir del
    programa". Aqu&iacute; el problema es que debemos tener exactamente un
    comando detr&aacute;s de O pero en este caso necesitamos dos: <BR>
    -mostrar un mensaje de error <BR>
    -salir del programa <BR>
    Para manejar ambos como un solo comando podemos agruparlos en una
    funci&oacute;n an&oacute;nima usando llaves. Las funciones en general se
    explican con m&aacute;s profundidad m&aacute;s abajo. <BR>
    Puedes hacerlo todo sin O e Ys usando simplemente
    sentencias if pero algunas veces los operadores O e Y son mucho
    m&aacute;s convenientes. <BR>
    <BR>
    La sentencia <B>case</B> se puede usar para comparar (usando comodines
    del shell como * y ?) una cadena dada con varias posibilidades.
<PRE>
case ... in
...) hacer algo aqu&iacute;;;
esac
</PRE>
    Veamos un ejemplo. El comando file comprueba que tipo de fichero es
    el fichero que le pasamos:
<PRE>
file lf.gz

devuelve:

lf.gz: gzip compressed data, deflated, original filename,
last modified: Mon Aug 27 23:09:18 2001, os: Unix
</PRE>
    Ahora vamos a usar esto para escribir un script llamado <A href=
    "../../common/src/article216/smartzip.txt">smartzip</A> que puede
    descomprimir ficheros comprimidos con bzip2, gzip y zip automaticamente :
<PRE>
#!/bin/sh
tipofichero=`file "$1"`
case "$tipofichero" in
"$1: Zip archive"*)
    unzip "$1" ;;
"$1: gzip compressed"*)
    gunzip "$1" ;;
"$1: bzip2 compressed"*)
    bunzip2 "$1" ;;
*) error "El fichero $1 no se puede descomprimir con smartzip";;
esac
</PRE>
    <BR>
    Te habr&aacute;s fijado que hemos usado una nueva variable especial llamada $1. Esta
    variable contiene el primer argumento pasado a un programa. Digamos que ejecutamos
    <BR>
    smartzip articles.zip <BR>
    entonces $1 contendr&iacute;a la cadena articles.zip <BR>
     <BR>
    La sentencia <B>select</B> es una extensi&oacute;n espec&iacute;fica del bash y es
    muy &uacute;til para usos interactivos. El usuario puede escoger una opci&oacute;n de una
    lista de difirentes valores:
<PRE>
select var in ... ; do
  break
done
.... ahora podemos usar $var ....
</PRE>
    Un ejemplo:
<PRE>
#!/bin/sh
echo "&iquest;Cu&aacute;l es tu sistema operativo favorito?"
select var in "Linux" "Gnu Hurd" "Free BSD" "Otros"; do
        break
done
echo "Has seleccionado $var"
</PRE>
    Aqu&iacute; tienes lo que har&iacute;a el programa:
<PRE>
&iquest;Cu&aacute;l es tu sistema operativo favorito?
1) Linux
2) Gnu Hurd
3) Free BSD
4) Otros
#? 1
Has seleccionado Linux
</PRE>
    En el shell tenemos est&aacute;n disponibles las siguientes <B>sentencias de bucle</B>:
<PRE>
while ...; do
 ....
done
</PRE>
    El <B>bucle while</B> se ejecutar&aacute; mientras la expresi&oacute;n que comprobamos
    sea verdadera. Se puede usar la palabra clave "break" para abandonar el bucle
    en cualquier punto de la ejecuci&oacute;n. Con la palabra clave "continue" el bucle
    continua con la siguiente iteraci&oacute;n y se salta el resto del cuerpo del bucle. <BR>
    <BR>
    El <B>bucle for</B> toma una lista de cadenas (separadas por espacios)
    y las asigna a una variable:
<PRE>
for var in ....; do
  ....
done
</PRE>
    El siguente ejemplo muestra por pantalla de la letra A a la C:
<PRE>
#!/bin/sh
for var in A B C ; do
  echo "var es $var"
done
</PRE>
    Un script de ejemplo m&aacute;s &uacute;til es este, llamado showrpm, que muestra un resumen
    del contenido de una serie de paquetes RPM:
<PRE>
#!/bin/sh
# listar un resumen del contenido de una serie de paquetes RPM
# USO: showrpm ficherorpm1 ficherorpm2 ...
# EJEMPLO: showrpm /cdrom/RedHat/RPMS/*.rpm
for rpmpackage in $*; do
  if [ -r "$rpmpackage" ];then
    echo "=============== $rpmpackage =============="
    rpm -qi -p $rpmpackage
  else
    echo "ERROR: no se pudo leer el fichero $rpmpackage"
  fi
done
</PRE>
    Como se puede ver hemos usado la siguente variable especial, $* que
    contiene todos los argumentos de la l&iacute;nea de comandos. Si ejecutas <BR>
    showrpm openssh.rpm w3m.rpm webgrep.rpm <BR>
    entonces $* contiene las tres cadenas openssh.rpm, w3m.rpm y
    webgrep.rpm. <BR>
    <BR>
     El bash GNU tambi&eacute;n entiende bucles until pero en general con los bucles
    while y for es suficiente. <BR>
    <BR>
     <B>Comillas</B><BR>
    Antes de pasarle cualquier argumento a un programa el shell intenta expandir
    los comodines y variables. Expandir significa que el comod&iacute;n (p.ej. *)
    se reemplaza por los nombres de fichero apropiados o que una variable se
    reemplaza por su valor. Para modificar este comportamiento se pueden usar las comillas:
    Pongamos que tenemos varios ficheros en el directorio actual. Dos
    de ellos son ficheros jpg, correo.jpg y tux.jpg.
<PRE>
#!/bin/sh
echo *.jpg
</PRE>
    Imprimir&aacute; "correo.jpg tux.jpg".<BR>
    Usar comillas (simples y dobles) evitar&aacute; esta expansi&oacute;n de comodines:
<PRE>
#!/bin/sh
echo "*.jpg"
echo '*.jpg'
</PRE>
    Esto mostrar&aacute; "*.jpg" dos veces. <BR>
    Las comillas simples son las m&aacute;s estrictas. Evitan incluso la expansi&oacute;n
    de variables. Las comillas dobles evitar&aacute;n la exprasi&oacute;n de comodines
    pero no as&iacute; la de variables:
<PRE>
#!/bin/sh
echo $SHELL
echo "$SHELL"
echo '$SHELL'
</PRE>
    Esto mostrar&aacute;:
<PRE>
/bin/bash
/bin/bash
$SHELL
</PRE>
    Finalmente existe la posibilidad de eliminar el significado especial de un &uacute;nico
    caracter anteponiendole una barra invertida:
<PRE>
echo \*.jpg
echo \$SHELL
</PRE>
    Esto mostrar&aacute;:
<PRE>
*.jpg
$SHELL
</PRE>
    <B>Documentaci&oacute;n aqu&iacute;</B><BR>
     Documentaci&oacute;n aqu&iacute; es una forma muy elegante de enviar varias l&iacute;neas de texto a un
    comando. Es bastante &uacute;til para escribir un texto de ayuda en un script
    sin tener que poner echo delante de cada l&iacute;nea. Un "Documentaci&oacute;n aqu&iacute;"
    comienza por &lt;&lt; seguido de una cadena que tambi&eacute;n debe aparecer
    al final del documentaci&oacute;n aqu&iacute;. Aqu&iacute; tenemos un <A href=
    "../../common/src/article216/ren.txt">script de ejemplo, llamado
    ren,</A> que renombra m&uacute;ltiples ficheros y usa documentaci&oacute;n aqu&iacute;
    para su texto de ayuda:
<PRE>
#!/bin/sh
# tenemos menos de 3 argumentos. Mostramos el texto de ayuda:
if [ $# -lt 3 ] ; then
cat &lt;&lt;AYUDA
ren -- renombra varios ficheros usando expresiones regulares de sed

USO: ren 'regexp' 'reemplazo' ficheros...

EJEMPLO: rename all *.HTM fles in *.html:
  ren 'HTM$' 'html' *.HTM

AYUDA
  exit 0
fi
VIEJO="$1"
NUEVO="$2"
# El comando shift elimina un argumento de la lista
# de argumentos de la linea de comandos.
shift
shift
# ahora $* contiene todos los ficheros:
for fichero in $*; do
    if [ -f "$fichero" ] ; then
      nuevofichero=`echo "$fichero" | sed "s/${VIEJO}/${NUEVO}/g"`
      if [ -f "$nuevofichero" ]; then
        echo "ERROR: $nuevofichero ya existe"
      else
        echo "renombrando $fichero como $nuevofichero ..."
        mv "$fichero" "$nuevofichero"
      fi
    fi
done
</PRE>
    Hasta ahora este es el script m&aacute;s complejo que hemos visto. Hablemos sobre &eacute;l
    un poco. La primera sentencia if comprueba si hemos introducido al menos 3
    par&aacute;metros de l&iacute;nea de comandos. (La variable especial $# contiene el
    n&uacute;mero de argumentos). Si no, se envia el texto de ayuda al comando
    cat que consecuentemente lo muestra por pantalla. Despu&eacute;s de mostrar el texto
    de ayuda salimos del programa. Si hay 3 o m&aacute;s argumentos asignamos
    el primer argumento a la variable VIEJO y el segundo a la
    variable NUEVO. Lo siguiente es cambiar la posici&oacute;n de los par&aacute;metros de la lista de comandos
    dos veces para poner el tercero en la primera posici&oacute;n de $*. Con $* entramos
    en el bucle for. Cada uno de los argumentos de $* se asigna uno a uno
    a la variable $fichero. Aqu&iacute; comprobamos primero que el fichero
    existe y despu&eacute;s creamos un nuevo fichero usando buscar
    y reemplazar con sed. Las comillas simples invertidas se usan para asignar el resultado
    a la variable nuevofichero. Ya tenemos todo lo que necesitamos: El nombre de
    fichero de viejo y el nuevo. Ahora s&oacute;lo tenemos que utilizarlos con el comando
    mv para renombrar los ficheros. <BR>
    <BR>
     <B>Funciones</B><BR>
    Tan pronto como tengamos un programa m&aacute;s complejo nos encontraremos con que
    estamos usando el mismo c&oacute;digo en varias partes y que ser&iacute;a de m&aacute;s ayuda el
    darle cierta estructura. Una funci&oacute;n es similar a esto:
<PRE>
nombredelafuncion()
{
 # dentro del cuerpo $1 es el primer argumento dado a la funci&oacute;n
 # $2 el segundo ...
 cuerpo
}
</PRE>
    Se necesita "declarar" las funciones al principio del script
    antes de usarlas. <BR>
    <BR>
    Aqu&iacute; tenemos un script llamado <A href=
    "../../common/src/article216/xtitlebar.txt">xtitlebar (t&iacute;tulo de la ventana)</A> que
    puedes usar para cambiar el nombre de una ventana de terminal. Si tienes
    varias abiertas es m&aacute;s f&aacute;cil encontrar una. El script envia una
    secuencia de escape que es interpretada por el terminal y hace que este
    cambie su nombre el la barra de t&iacute;tulo. El script usa una funci&oacute;n
    llamada ayuda. Como se puede ver la funci&oacute;n se define una vez y despu&eacute;s se
    utiliza dos veces:
<PRE>
#!/bin/sh
# vim: set sw=4 ts=4 et:

ayuda()
{
    cat &lt;&lt;AYUDA
xtitlebar -- cambiar el nombre de un xterm, gnome-terminal o konsole de kde

USO: xtitlebar [-h] "cadena_para_la_barra_de_titulo"

OPCIONES: -h texto de ayuda

EJEMPLO: xtitlebar "cvs"

AYUDA
    exit 0
}

# en caso de error o si le pasamos -h llamar a la funci&oacute;n ayuda:
[ -z "$1" ] &amp;&amp; ayuda
[ "$1" = "-h" ] &amp;&amp; ayuda

# enviamos la secuencia de escape para cambiar el t&iacute;tulo de la ventana:
echo -e "\033]0;$1\007"
#
</PRE>
    Se recomienda siempre documentar detalladamente el c&oacute;digo de los scripts.
    Con esto posibilitamos que otras personas (y t&uacute;) puedan usar y entender
    el script. <BR>
    <BR>
     <B>Argumentos de l&iacute;nea de comandos</B><BR>
    Hemos visto que $* y $1, $2 ... $9 contienen los argumentos que
    el usuario especific&oacute; en la l&iacute;nea de comandos (las cadenas escritas detr&aacute;s
    del nombre del programa). Hasta ahora s&oacute;lo hemos tratado con sintaxis de linea
    de comandos bastante sencilla y corta (un par de argumentos obligatorios
    y la opci&oacute;n -h para ayuda). Pero pronto descubrir&aacute;s que necesitas alg&uacute;n tipo de
    analizador para programas m&aacute;s complejos donde defines tus propias opciones.
    Por convenci&oacute;n se dice que los par&aacute;metros opcionales deben estar precedidos por
    un signo menos y deben ir antes de otros argumentos (como p.ej.
    nombres de ficheros). <BR>
    <BR>
    Hay muchas posibilidades para implementar un analizador (parser). El bucle
    while siguiente combiando con una sentencia case es una soluci&oacute;n muy buena
    para un <A href="../../common/src/article216/cmdparser.txt">analizador
    gen&eacute;rico</A>:
<PRE>
#!/bin/sh
ayuda()
{
  cat &lt;&lt;AYUDA
Esta es la demostraci&oacute;n de un analizador de l&iacute;nea de comandos gen&eacute;rico.
EJEMPLO DE USO: cmdparser -l hola -f -- -fichero1 fichero2
AYUDA
  exit 0
}
while [ -n "$1" ]; do
case $1 in
    -h) ayuda;shift 1;; # llamamos a la funci&oacute;n ayuda
    -f) opt_f=1;shift 1;; # la variable opt_f existe
    -l) opt_l=$2;shift 2;; # -l toma un argumento -&gt; cambiado 2 veces
    --) shift;break;; # end of options
    -*) echo "error: no existe la opci&oacute;n $1. -h para ayuda";exit 1;;
    *)  break;;
esac
done

echo "opt_f es $opt_f"
echo "opt_l es $opt_l"
echo "el primer argumento es $1"
echo "el 2º argumento es $2"
</PRE>
    &iexcl;Pru&eacute;balo! Puedes ejecutarlo con p.ej.:
<PRE>
cmdparser -l hola -f -- -fichero1 fichero2
</PRE>
    Produce
<PRE>
opt_f es 1
opt_l es hola
el primer argumento es -fichero1
el 2º argumento es fichero2
</PRE>
    &iquest;C&oacute;mo funciona? Basicamente se realiza un bucle a trav&eacute;s de todos los argumentos
    y los compara con la sentencia case. Si encuentra alguna coincidencia
    establece una variable y cambia la l&iacute;nea de comandos en uno. Por convenci&oacute;n
    en unix las opciones (lo que tiene delante un signo menos) deben estar
    primero. Puedes indicar que han finalizado las opciones escribiendo
    dos signos menos (--). Lo necesitar&aacute;s p.ej. con grep para buscar
    una cadena que comience con el signo menos:
<PRE>
Buscar la cadena -xx- en el fichero f.txt:
grep -- -xx- f.txt
</PRE>
    Nuestro analizador de opciones tambi&eacute;n puede manejar los -- como se puede comprobar
    en el listado superior.

    <A NAME="216lfindex5">&nbsp;</A>
<H2>Ejemplos</H2>

    <B>Un esqueleto de prop&oacute;sito general</B><BR>
    <BR>
    Hasta ahora hemos hablado de casi todos los componentes que se necesitan para
    escribir un script. Todos los buenos scripts deber&iacute;an tener ayuda y tambi&eacute;n un buen
    analizador gen&eacute;rico de opciones incluso aunque el script tenga una sola
    opci&oacute;n. Por lo tanto es un buena idea tener un script b&aacute;sico, llamado
    <A href=
    "../../common/src/article216/framework.sh.txt">framework.sh (framework = armaz&oacute;n)</A>,
    que se puede usar como esqueleto para otros scripts. Si se quiere escribir
    un nuevo script simplemente se tendr&iacute;a que hacer una copia:
<PRE>
cp framework.sh miscript
</PRE>
    y despu&eacute;s insertar las funcionalidades necesarias en "miscript". <BR>
    <BR>
    Veamos ahora dos ejemplos m&aacute;s: <BR>
    <BR>
    <B>Un conversor num&eacute;rico de binario a decimal</B><BR>
    <BR>
    El script <A href="../../common/src/article216/b2d.txt">b2d</A>
    convierte un n&uacute;mero binario (e.g 1101) a su equivalente en decimal. Es
    un ejemplo que muestra c&oacute;mo hacer sencillas operaciones matem&aacute;ticas
    con expr:
<PRE>
#!/bin/sh
# vim: set sw=4 ts=4 et:
ayuda()
{
  cat &lt;&lt;AYUDA
b2d -- conversor binario a decimal

USO: b2d [-h] numeroenbinario

OPCIONES: -h texto de ayuda

EJEMPLO: b2d 111010
devolver&aacute; 58
AYUDA
  exit 0
}

error()
{
    # mostrar un error y salir
    echo "$1"
    exit 1
}

ultimocarac()
{
    # devolver el &uacute;ltimo caracter de una cadena en $rval
    if [ -z "$1" ]; then
        # cadena vac&iacute;a
        rval=""
        return
    fi
    # wc deja espacio antes de su salida y por eso necesitamos usar sed:
    numdcarac=`echo -n "$1" | wc -c | sed 's/ //g' `
    # ahora cortamos el &uacute;ltimo caracter
    rval=`echo -n "$1" | cut -b $numdcarac`
}

chop()
{
    # borrar el &uacute;ltimo caracter de la cadena y retornarno como $rval
    if [ -z "$1" ]; then
        # cadena vac&iacute;a
        rval=""
        return
    fi
    # wc deja espacio antes de su salida y por eso necesitamos usar sed:
    numdcarac=`echo -n "$1" | wc -c | sed 's/ //g' `
    if [ "$numdcarac" = "1" ]; then
        # s&oacute;lo hay un car&aacute;cter en la cadena
        rval=""
        return
    fi
    numdcaracmenos1=`expr $numdcarac "-" 1`
    # ahora cortamos todos excepto el &uacute;ltimo:
    rval=`echo -n "$1" | cut -b 0-${numdcaracmenos1}`
}


while [ -n "$1" ]; do
case $1 in
    -h) ayuda;shift 1;; # llamamos a la funci&oacute;n ayuda
    --) shift;break;; # fin de las opciones
    -*) error "error: no existe la opci&oacute;n $1. -h para ayuda";;
    *)  break;;
esac
done

# El programa principal
suma=0
peso=1
# hay que pasar un argumento:
[ -z "$1" ] &amp;&amp; ayuda
numbin="$1"
numbinorig="$1"

while [ -n "$numbin" ]; do
    ultimocarac "$numbin"
    if [ "$rval" = "1" ]; then
        suma=`expr "$peso" "+" "$suma"`
    fi
    # borrar la &uacute;ltima posici&oacute;n en $numbin
    chop "$numbin"
    numbin="$rval"
    peso=`expr "$peso" "*" 2`
done

echo "el binario $numbinorig en decimal es $suma"
#
</PRE>
    El algoritmo usado en este script toma el peso decimal
    (1,2,4,8,16,..) de cada d&iacute;gito comenzando por el d&iacute;gito m&aacute;s a la derecha
    y lo a&ntilde;ade a la suma si el d&iacute;gito es un 1. De este modo "10" es: <BR>
    0 * 1 + 1 * 2 = 2 <BR>
    Para sacar lo d&iacute;gitos de la cadena usamos la funci&oacute;n ultimocarac.
    Esta usa wc -c para contar el n&uacute;mero de caracteres en la cadena y
    despu&eacute;s cut para cortar el &uacute;ltimo caracter. La funci&oacute;n chop sigue la
    misma l&oacute;gica pero borra el &uacute;ltimo caracter, es decir, corta todo
    desde el principio hasta el caracter anterior al &uacute;ltimo.
    <BR>
    <BR>
     <B>Un programa para rotar ficheros</B><BR>
    Quiz&aacute; eres uno de aquellos que guardan todo en correo enviado en un fichero.
    Despu&eacute;s de un par de meses este fichero se ha hecho bastante grande y si lo
    cargas en tu programa de correo el acceso a &eacute;l es muy lento. El
    siguiente script <A href=
    "../../common/src/article216/rotatefile.txt">rotatefile</A> puede
    ayudarte. Renombra el buz&oacute;n de correo, llam&eacute;moslo correoenviado, a
    correoenviado.1 si ya hab&iacute;an un correoenviado.1 entonces se convierte en
    correoenviado.2 etc...
<PRE>
#!/bin/sh
# vim: set sw=4 ts=4 et:
ver="0.1"
ayuda()
{
    cat &lt;&lt;AYUDA
rotatefile -- rotar el nombre de un fichero

USO: rotatefile [-h]  nombre_del_fichero

OPCIONES: -h texto de ayuda

EJEMPLO: rotatefile algo
Esto p. ej. renombrar&aacute; algo.2 a algo.3, algo.1 a algo.2, algo a algo.1
y crear&aacute; un fichero vac&iacute;o llamado algo.

El n&uacute;mero m&aacute;ximo es 10

version $ver
AYUDA
    exit 0
}

error()
{
    echo "$1"
    exit 1
}
while [ -n "$1" ]; do
case $1 in
    -h) ayuda;shift 1;;
    --) break;;
    -*) echo "error: no existe la opci&oacute;n $1. -h para ayuda";exit 1;;
    *)  break;;
esac
done

# comprobamos la entrada:
if [ -z "$1" ] ; then
 error "ERROR: debe especificar un fichero, use -h para obtener ayuda"
fi
nomfich="$1"
# renombrar cualquier fichero .1 , .2 etc:
for n in  9 8 7 6 5 4 3 2 1; do
    if [ -f "$nomfich.$n" ]; then
        p=`expr $n + 1`
        echo "mv $nomfich.$n $nomfich.$p"
        mv $nomfich.$n $nomfich.$p
    fi
done
# renombrar el fichero original:
if [ -f "$nomfich" ]; then
    echo "mv $nomfich $nomfich.1"
    mv $nomfich $nomfich.1
fi
echo touch $nomfich
touch $nomfich

</PRE>
    &iquest;C&oacute;mo funciona el programa? Despu&eacute;s de comprobar que el usuario ha proporcionado un
    nombre de fichero entramos en un bucle for desde 9 a 1. El fichero 9 se
    renombra como 10, el 8 como 9 as&iacute; con todos. Despu&eacute;s del bucle renombramos el
    fichero original como 1 y creamos un fichero vac&iacute;o con el nombre del
    fichero original.

    <A NAME="216lfindex6">&nbsp;</A>
<H2>Depuraci&oacute;n</H2>

    La ayuda para depurar m&aacute;s sencilla es por supuesto el comando echo. Lo
    puedes usar para imprimir variables espec&iacute;ficas en en lugar donde sospeches
    que est&aacute; el fallo. Esto es probablemente lo que usan la mayor&iacute;a de programadores
    de shell el 80% de las veces que intentan encontrar un error. La ventaja de la
    programaci&oacute;n en shell es que no requiere ninguna recompilaci&oacute;n e
    insertar una sentencia "echo" se hace r&aacute;pidamente. <BR>
     <BR>
     El shell tambi&eacute;n tiene un modo de depuraci&oacute;n real. Si hay un error en tu
     script "scriptconerror" entonces puedes depurarlo con:
<PRE>
sh -x scriptconerror
</PRE>
    Esto ejecutar&aacute; el script y mostrar&aacute; todas la sentencias que se ejecutan
    con las variables y comodines ya expandidos. <BR>
    <BR>
    El shell tambi&eacute;n tiene un modo para comprobar errores de sintaxis sin
    ejecutar el programa. Se usa as&iacute;:
<PRE>
sh -n tu_script
</PRE>
    Si no retorna nada entonces tu programa no tiene errores de sintaxis.
    <BR>
    <BR>
    Esperamos que ahora comiences a escribir tus propios scripts de shell. &iexcl;Divi&eacute;rtete! <BR>


    <A NAME="216lfindex7">&nbsp;</A>
<H2>Referencias</H2>


    <UL>
      <LI>Las p&aacute;ginas man e info de bash son muy buenas y descubrir&aacute;s
      muchos m&aacute;s trucos all&iacute;:<BR>
      man bash<BR>
      tkinfo bash<BR>
      (Odio el navegador est&aacute;ndar de info sin embargo <A href=
      "http://math-www.uni-paderborn.de/~axel/tkinfo/">tkinfo</A> o
      konqueror (la url es info:/bash/Top ) son bastante buenos)</LI>

      <LI>El art&iacute;culo de LinuxFocus sobre <A href=
      "../November2000/article131.shtml">Utilidades GNU (GNU file utilities)</A></LI>

      <LI>El art&iacute;culo de LinuxFocus sobre <A href=
      "../July1998/article53.html">Expresiones regulares (Regular expressions)</A></LI>

      <LI>El art&iacute;culo de LinuxFocus sobre <A href=
      "../September1999/article103.html">Ejemplos con awk: Una breve introducci&oacute;n</A></LI>

      <LI>El art&iacute;culo de LinuxFocus sobre <A href=
      "../November1998/article68.html">Ordenes b&aacute;sicas de la l&iacute;nea de comandos (Basic UNIX commands)</A></LI>

      <LI>Si no tienes bash instalado en tu sistema o quieres obtener la
      versi&oacute;n m&aacute;s reciente puedes descargarla del sitio web de GNU en
      http://www.gnu.org (para averiguar si el bash ya est&aacute; instalado en
      tu sistema simplemente escribe bash. Si no obtienes ning&uacute;n tipo de error
      entonces bash ya est&aacute; instalado)</LI>
    </UL>
    <!-- vim: set sw=2 ts=2 et: -->
  



<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback form for this article</h2>
Every article has its own talkback page. On this page you can submit a comment or look at comments from other readers:
<center>
<table border="0"  CELLSPACING="2" CELLPADDING="1">
 <tr BGCOLOR="#C2C2C2"><td align=center>
  <table border="3"  CELLSPACING="2" CELLPADDING="1">
   <tr BGCOLOR="#C2C2C2"><td align=center>
    <A href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=216&lang=en"><b>&nbsp;talkback page&nbsp;</b></a>
   </td></tr></table>
</td></tr></table>
</center>

<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="95%">
<TR><TD ALIGN=CENTER BGCOLOR="#9999AA">
<A HREF="../../common/lfteam.html">Webpages maintained by the LinuxFocus Editor team</A>
<BR><FONT COLOR="#FFFFFF">&copy; Katja and Guido Socher, <a href="../../common/copy.html">FDL</a> <BR><a href="http://www.linuxfocus.org">LinuxFocus.org</a></FONT>
<BR><a href="http://cgi.linuxfocus.org/cgi-bin/lfcomment?lang=en&article=article216.html" target="_TOP">Click here to report a fault or send a comment to LinuxFocus</A><BR></TD>
<TD BGCOLOR="#9999AA"><!-- TRANSLATION INFO -->
<font size=2>Translation information:</font><TABLE>
<tr><td><font size=2>en</font></td>
    <td><font size=2>-&gt;</font></td>
    <td><font size=2>--</font></td>
    <td><font size=2><a href="mailto:katja&#64;linuxfocusorg, guido@linuxfocus.org"><FONT COLOR="#FFFFFF">Katja and Guido Socher</FONT></a></font></td>
</tr>
<tr><td><font size=2>en</font></td>
    <td><font size=2>-&gt;</font></td>
    <td><font size=2>es</font></td>
    <td><font size=2><a href="mailto:jgomsi&#64;obelix.umh.es"><FONT COLOR="#FFFFFF">Javier G&oacute;mez Sierras</FONT></a></font></td>
</tr>
</TABLE></TD>
</TR></TABLE></CENTER>
<p><font size=1>2001-10-26, generated by lfparser version 2.17</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
