<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML lang="en">
<HEAD><META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <TITLE> SQL: Introducción al SQL. Instalación de PostgreSQL</TITLE>
 <META name="Author" CONTENT=" ">
 <META name="Keywords" CONTENT="SQL PostgreSQL ">
 <META name="Description" CONTENT=" Introducción al SQL">
 <META name="Copyright" CONTENT="&copy; 1998 LinuxFocus">
 <META name="Translator" CONTENT="Original en Castellano">
 <META name="Date" CONTENT="1998-02-91T00:00:00Z">

</HEAD>

<BODY bgcolor="#FFFFFF" text="#000000" link="#ff0033" vlink="#FF3333">

  <MAP name="navegator">
      <AREA shape="rect" coords="0, 0, 65, 28" alt="Ir al Hogar" href="../">
      <AREA shape="rect" coords="66, 0, 124, 28" alt="Ver &Iacute;ndice" href="../indice.html">
      <AREA shape="rect" coords="125, 0, 193, 28" alt="Buscar" href="../search.html"><AREA shape="rect" coords="194, 0, 260, 28" alt="Enlaces" href="../links.html">
      <AREA shape="rect" coords="261, 0, 350, 28" alt="Acerda de nosotros" href="../aboutus.html"></MAP>
  </MAP>



 <TABLE border="0" width="100%" cellspacing="0" cellpadding="0">

 <THEAD>
   <TR align="center">
      <TD colspan="2"><IMG src="../../common/May1998/border-short.jpg" alt="[LinuxFocus Image]" width="407" height="88"></TD>
   </TR>

   <TR align="center">
      <TD colspan="2" bgcolor="#660033"><IMG src="../../common/May1998/Navegator-bar.gif" ismap usemap="#navegator" border="0" width="351" height="28" alt="[Navegation Bar]"></TD>
   </TR>

   <TR align="center">
     <TD colspan="2">     
           <TABLE  border="0" width="75%" cellspacing="0" cellpadding="5">
		<TR bgcolor="#000000">
		   <TD align="center">
               <A href="../News/"><FONT face="Helvetica,Arial" color="#ffffff"><B>&nbsp; Noticias</B></FONT></A>
               <A href="../Archives/"><FONT face="Helvetica,Arial" color="#ffffff"><B>&nbsp; Archivos</B></FONT></A>
               <A href="../Companies/"><FONT face="Helvetica,Arial" color="#ffffff"><B>&nbsp; Compa&ntilde;&iacute;as</B></FONT></A>
               <A href="../Tips/"><FONT face="Helvetica,Arial" color="#ffffff"><B>&nbsp; Consejos&nbsp</B></FONT></A> 
               </TD>
            </TR>
            
		<TR>
            <!--   Here goes the Title of the article, authors name and abstract -->
		   <TD align="center">
 			<FONT face="Helvetica,Arial" color="#660066"><H1>SQL: Introducción al SQL. Instalación de PostgreSQL</H1></FONT>
 			<FONT face="Helvetica,Arial" color="#000000"><H3>por <A href="mailto:manu@europa3.com"><FONT color="#000000"> Manuel Soriano</FONT></A></H3></FONT>
                  <HR size="2" noshade>
	         </TD>
            </TR>

           </TABLE>

     </TD>
   </TR>

 </THEAD>



 <TBODY>
  
 <TR>
    <TD valign="top" align="center">
           <H4><A href="#section1">Introducción</A></H4>
           <H4><A href="#section2">Primer Paso</A></H4>
           <H4><A href="#section3">Funciones</A></H4>
           <H4><A href="#section4">Revisión de Conceptos</A></H4>
           <H4><A href="#section5">Resumen</A></H4>
    </TD>
   
    <TD align="center">
       <TABLE border="0" width="80%" cellspacing="0" cellpadding="0">
	  <TR>
          <TD>



<P align=left><I> &nbsp;&nbsp;&nbsp;&nbsp;Este cursillo de SQL se hará
en tres parte,  en la primera  nos  centraremos en la generalidad  del
SQL,  trataremos con postgreSQL que es  un  servidor de bases de datos
vía SQL de dominio público. La segunda parte estudiaremos los comandos
SQL con un  mayor detalle. En la  tercera parte trataremos comando SQL
con opciones avanzadas así como funciones del propio gestor PostgreSQL
que pueden  ser interesantes  para  nuestros desarrollos  y haremos un
pequeño programa en C.  </I><BR>
</P>


	     <A name="section1"></A>
           <H2><FONT face="Helvetica,Arial" color="#660033">Introducción</FONT></H2>


Durante esta rápida introducción sólo  hablaré de gestores de base  de
datos. Existen otras organizaciones de  datos, pero hablar de ellas se
saldría del objetivo del curso.

<p>
Hasta el momento,  el acceso a los  datos se hacía  mediante accesos a
entidades  que    se relacionaban  entre  sí mediante    una ligaduras
definidas en el  esquema de la base  de datos, eso  tenía una ventaja,
rapidez, pero una gran desventaja,   sólo podíamos acceder a los  datos
mediante una ligadura, ejemplo :
<pre>
&nbsp;&nbsp;&nbsp;&nbsp;país -> provincias -> municipios
</pre>
pero nunca :
<pre>
&nbsp;&nbsp;&nbsp;&nbsp;país -> municipios
</pre>
Siendo "->" la ligadura.

<p>
Si queríamos realizar esa segunda relación, debíamos redefinir el esquema y
recompilarlo...
<p>
En efecto, en una BD jerarquica, la relación entre las diversas entidades es estática y solo modificable mediante modificación del esquema de la base de datos y recompilacion de este ultimo.

<p>
La idea básica   de los gestores  de  bases de  datos relacionales  es
justamente ligar los datos en el momento de la petición de estos, pero
sin  necesitar  una ligadura   estática, sino  una  identificación que
permita ligar un registro con otro. 
<p>
Esto que acabo de escribir necesita una Aspirina :-)
<p>
Los gestores de base de datos relacionales no precisan unas ligaduras
estáticas para poder descender una jerarquia de entidades, sino que usan un
código único que les identifica para realizar una relación temporanea que es el
resultado de una pregunta al gestor.
<p>
Esta identificación no es más que el código. Ej: mi número de telefono 
no es el :

<p>
1234567

<p>
sino el :

<p>
34 6 1234567

<p>
En efecto mi numero de telefono esta identificado por el código país (34), 
el código de la provincia (6) y el propio número de aparato (1234567).
<UL>
<LI>En la entidad paises, el código 34 (España) es único.
<LI>En la entidad provincias, el código 34-6 (España/Valencia) es único.
<LI>En la entidad aparatos, el código 34-6-1234567 (España/Valencia/mi telefono) es único.
</UL>
<p>

Vamos a poner las bases del primer ejemplo que ilustrara lo que acabo de decir.

<p>
&nbsp;&nbsp;&nbsp;&nbsp;Todos los municipios tienen un código, pertenecen a una provincia y a un país<br>
&nbsp;&nbsp;&nbsp;&nbsp;Todas las provincias tienen un código y pertenecen a un país<br>
&nbsp;&nbsp;&nbsp;&nbsp;Todos los países tienen un código

<p>
Para conocer todos  los  municipios  de una  provincia,  relaciono  el
municipio con  la provincia por  el código  de  país y provincia; para
saber todos los  municipio de un  país, relaciono el municipio con  el
país por el código  de país.  Estas  relaciones son temporáneas y sólo
existen durante la realización de mi pregunta.

<p>
Es un poco duro, pero con los primeros ejemplos comprenderemos un poco mejor
este concepto de código y de pertenencia.

<p>
Al realizar mi pregunta el gestor me  entregara todos los datos que se
relacionen entre sí. Pero ¿qué  datos me va a  dar? Pues la conjunción
de los datos de  países y municipios,  para cada municipio me repetirá
los datos del país.

<p>
Durante  la realización de mi pregunta  se ha creado  un nueva entidad
que no  tiene    nombre y  que contiene   una   réplica  de países   y
municipios.  Esa nueva entidad,  y   me repito, desaparecerá una   vez
terminada mi lectura.

<p>
Antes llamábamos a los conjuntos de datos, ficheros. Estos se componen
de registros y estos últimos se componen  de campos. Bien, pues en una
base  de datos relacional, un "fichero"  se  llama tabla, una tabla se
compone de  tuplas  y una tupla contiene   columnas, no es más que  un
matiz... ;-)

<p>
Hay  que destacar que ciertos  gestores  de BD jerárquicos introducían
SQL como lenguaje de acceso, pero esto  es anecdótico. El lenguaje SQL
es casi una exclusividad de los gestores relacionales.

<p>
Para ilustrar el  curso utilizaremos el gestor  relacional PostgreSQL,
aunque no  cumple   con todas las normas    SQL,  sí que es   más  que
suficiente para nosotros, y para otros menesteres más duros también.

<p>
Voy a  explicar muy brevemente el proceso  de instalación, dado que el
objetivo de este artículo es SQL.

Primero        bajamos     los          fuentes                 de     <A
href="http://www.postgresql.org">www.postgresql.org</a>,  así como los
parches. Los extraemos      (tar   zxvf)    en   un   directorio,    <tt>cd
postgresql-6.3</tt>
<pre>
cd src
./configure --prefix=/el/path/deseado
make all >& make.log &
tail -f make.log

export PATH=$PATH:/el/path/deseado/pgsql/bin
export MANPATH=$MANPATH:/el/path/deseado/pgsql/man
export PGLIB=/el/path/deseado/pgsql/lib
export PGDATA=/el/path/deseado/pgsql/data

initdb
createdb prueba
psql prueba
Welcome to the POSTGRESQL interactive sql monitor:
  Please read the file COPYRIGHT for copyright terms of POSTGRESQL

   type \? for help on slash commands
   type \q to quit
   type \g or terminate with semicolon to execute query
 You are currently connected to the database: postgres

prueba=>
</pre>

Este es el prompt de postgres, ahora podemos ejecutar comandos.
<pre>
prueba=>create table prueba (campo1 varchar(10));
CREATE

prueba=>insert into prueba values ('hello');
INSERT numerito 1

prueba=>commit work;
NOTICE:EndTransactionBlock and not inprogress/abort state
END

prueba=>select * from prueba;
campo1
------
hello
(1 row)

prueba=>drop table prueba;
DROP

prueba=>Ctrl-d
</pre>

Ya estamos fuera del monitor SQL.

<p>
Si no habéis conseguido compilar  e instalar Postgres95 correctamente,
referiros al fichero  INSTALL que está  en el directorio de entrada de
la distribución.

<p>
Como comentario, vamos a ver como esta construido un servidor de bases de
datos relacional :
<OL>
<LI> La capa de acceso a los datos</li>
<li> La capa gestora SQL</li>
<li> La capa traductora SQL</li>
<li> La capa de comunicaciones</li>
</OL>

Como cliente nos conectaremos a la capa  4, le enviaremos los comandos
SQL a esta capa, que los pasará a la capa 3.   Ésta hace la traducción
del comando y, si  no hay errores,  envía el comando a  la capa 2.  La
capa 2 hace toda la gestión del comando con la colaboración de la capa
1: recoge los  datos y errores para  enviarlos al cliente, vía la capa
4;  y es capaz  de  mantener un diálogo   con el programa cliente para
coordinarse. La capa 1 es la  encargada de gestionar correctamente los
datos y controlar los bloqueos y transacciones.



<A       name="section2"></A>        <H2><FONT  face="Helvetica,Arial"
color="#660033">Primer Paso</FONT></H2>


Vamos a ilustrar con datos lo que antes he  explicado, así que vamos a
crear 3 tablas (o ficheros) :<p>

<pre>
<b><tt>Fichero: paises.sql</tt></b>
create table paises (cod_pais integer, nombre varchar(30));
insert into paises values (1, 'pais 1');
insert into paises values (2, 'pais 2');
insert into paises values (3, 'pais 3');
commit work;
</pre>


<pre>
<b><tt>Fichero: provincias.sql</tt></b>
create table provincias (cod_provincia int, 
			cod_pais int, 
			nom_provincia varchar(30));
insert into provincias values (1, 1, 'Provincia 1, Pais 1');
insert into provincias values (2, 1, 'Provincia 2, Pais 1');
insert into provincias values (1, 2, 'Provincia 1, Pais 2');
insert into provincias values (2, 2, 'Provincia 2, Pais 2');
insert into provincias values (1, 3, 'Provincia 1, Pais 3');
insert into provincias values (2, 3, 'Provincia 2, Pais 3');
commit work;
</pre>


<pre>
<b><tt>Fichero: municipios.sql</tt></b>
create table municipios (cod_pais int, 
			cod_provincia int, 
			cod_municipio int,
			nombre_municipio varchar(60));
insert into municipios values (1, 1, 1, 'Municipio 1, Provincia 1, Pais 1');
insert into municipios values (2, 1, 1, 'Municipio 2, Provincia 1, Pais 1');
insert into municipios values (3, 1, 1, 'Municipio 3, Provincia 1, Pais 1');
insert into municipios values (1, 2, 1, 'Municipio 1, Provincia 2, Pais 1');
insert into municipios values (2, 2, 1, 'Municipio 2, Provincia 2, Pais 1');
insert into municipios values (3, 2, 1, 'Municipio 3, Provincia 2, Pais 1');
insert into municipios values (1, 3, 1, 'Municipio 1, Provincia 3, Pais 1');
insert into municipios values (2, 3, 1, 'Municipio 2, Provincia 3, Pais 1');
insert into municipios values (3, 3, 1, 'Municipio 3, Provincia 3, Pais 1');
insert into municipios values (1, 1, 2, 'Municipio 1, Provincia 1, Pais 2');
insert into municipios values (2, 1, 2, 'Municipio 2, Provincia 1, Pais 2');
insert into municipios values (3, 1, 2, 'Municipio 3, Provincia 1, Pais 2');
insert into municipios values (1, 2, 2, 'Municipio 1, Provincia 2, Pais 2');
insert into municipios values (2, 2, 2, 'Municipio 2, Provincia 2, Pais 2');
insert into municipios values (3, 2, 2, 'Municipio 3, Provincia 2, Pais 2');
insert into municipios values (1, 3, 2, 'Municipio 1, Provincia 3, Pais 2');
insert into municipios values (2, 3, 2, 'Municipio 2, Provincia 3, Pais 2');
insert into municipios values (3, 3, 2, 'Municipio 3, Provincia 3, Pais 2');
insert into municipios values (1, 1, 3, 'Municipio 1, Provincia 1, Pais 3');
insert into municipios values (2, 1, 3, 'Municipio 2, Provincia 1, Pais 3');
insert into municipios values (3, 1, 3, 'Municipio 3, Provincia 1, Pais 3');
insert into municipios values (1, 2, 3, 'Municipio 1, Provincia 2, Pais 3');
insert into municipios values (2, 2, 3, 'Municipio 2, Provincia 2, Pais 3');
insert into municipios values (3, 2, 3, 'Municipio 3, Provincia 2, Pais 3');
insert into municipios values (1, 3, 3, 'Municipio 1, Provincia 3, Pais 3');
insert into municipios values (2, 3, 3, 'Municipio 2, Provincia 3, Pais 3');
insert into municipios values (3, 3, 3, 'Municipio 3, Provincia 3, Pais 3');
commit work;
</pre>
<p>
Para ejecutar dentro del psql unos comandos sql de un fichero, hacer :
<p>
\i nombre_del_fichero

<p>
Tambén podemos hacer un cortar y pegar desde estas páginas.

<p>
Vamos a ver qué municipios tenemos :

<pre>
select * from municipios;

cod_pais|cod_provincia|cod_municipio|nombre_municpio
--------+-------------+-------------+--------------------------------
       1|            1|            1|Municipio 1, Provincia 1, Pais 1
       2|            1|            1|Municipio 2, Provincia 1, Pais 1
       3|            1|            1|Municipio 3, Provincia 1, Pais 1
       1|            2|            1|Municipio 1, Provincia 2, Pais 1
       2|            2|            1|Municipio 2, Provincia 2, Pais 1
       3|            2|            1|Municipio 3, Provincia 2, Pais 1
       1|            3|            1|Municipio 1, Provincia 3, Pais 1
       2|            3|            1|Municipio 2, Provincia 3, Pais 1
       3|            3|            1|Municipio 3, Provincia 3, Pais 1
       1|            1|            2|Municipio 1, Provincia 1, Pais 2
       2|            1|            2|Municipio 2, Provincia 1, Pais 2
       3|            1|            2|Municipio 3, Provincia 1, Pais 2
       1|            2|            2|Municipio 1, Provincia 2, Pais 2
       2|            2|            2|Municipio 2, Provincia 2, Pais 2
       3|            2|            2|Municipio 3, Provincia 2, Pais 2
       1|            3|            2|Municipio 1, Provincia 3, Pais 2
       2|            3|            2|Municipio 2, Provincia 3, Pais 2
       3|            3|            2|Municipio 3, Provincia 3, Pais 2
       1|            1|            3|Municipio 1, Provincia 1, Pais 3
       2|            1|            3|Municipio 2, Provincia 1, Pais 3
       3|            1|            3|Municipio 3, Provincia 1, Pais 3
       1|            2|            3|Municipio 1, Provincia 2, Pais 3
       2|            2|            3|Municipio 2, Provincia 2, Pais 3
       3|            2|            3|Municipio 3, Provincia 2, Pais 3
       1|            3|            3|Municipio 1, Provincia 3, Pais 3
       2|            3|            3|Municipio 2, Provincia 3, Pais 3
       3|            3|            3|Municipio 3, Provincia 3, Pais 3
(27 rows)

prueba=>
</pre>


Bien tenemos 27 tuplas y el pgsql está esperando otro comando, 
vamos a ver este :

<pre>
select * from paises, municipios

cod_pais|nombre|cod_provincia|cod_pais|nom_provincia
--------+------+-------------+--------+-------------------
       1|pais 1|            1|       1|Provincia 1, Pais 1
       2|pais 2|            1|       1|Provincia 1, Pais 1
       3|pais 3|            1|       1|Provincia 1, Pais 1
       1|pais 1|            2|       1|Provincia 2, Pais 1
       2|pais 2|            2|       1|Provincia 2, Pais 1
       3|pais 3|            2|       1|Provincia 2, Pais 1
       1|pais 1|            1|       2|Provincia 1, Pais 2
       2|pais 2|            1|       2|Provincia 1, Pais 2
       3|pais 3|            1|       2|Provincia 1, Pais 2
       1|pais 1|            2|       2|Provincia 2, Pais 2
       2|pais 2|            2|       2|Provincia 2, Pais 2
       3|pais 3|            2|       2|Provincia 2, Pais 2
       1|pais 1|            1|       3|Provincia 1, Pais 3
       2|pais 2|            1|       3|Provincia 1, Pais 3
       3|pais 3|            1|       3|Provincia 1, Pais 3
       1|pais 1|            2|       3|Provincia 2, Pais 3
       2|pais 2|            2|       3|Provincia 2, Pais 3
       3|pais 3|            2|       3|Provincia 2, Pais 3
(18 rows)
</pre>

<b>¿¿¿18  tuplas ???</b> Vamos  a  ver, hemos insertado   3 países, y 6
provincias, todas ellas identificadas en  un  país. ¿Cómo es  posible
que nos saque 18 tuplas?

<p>
En este  último  comando hemos,  realizado una unión   de dos  tablas, hemos
relacionado la tabla  de países con la  de  municipios, como no le  hemos
dado ninguna regla de unión, nos ha devuelto TODAS las tuplas de países
relacionadas con TODAS las tuplas de provincias, es  decir 3 tuplas de
países   por  6 de  provincias   total 18 tuplas,    este resultado es
totalmente ilógico e inútil, ahora mejor hacer:

<pre>
select * from paises, provincias
where paises.cod_pais = provincias.cod_pais;

cod_pais|nombre|cod_provincia|cod_pais|nom_provincia
--------+------+-------------+--------+-------------------
       1|pais 1|            1|       1|Provincia 1, Pais 1
       1|pais 1|            2|       1|Provincia 2, Pais 1
       2|pais 2|            1|       2|Provincia 1, Pais 2
       2|pais 2|            2|       2|Provincia 2, Pais 2
       3|pais 3|            1|       3|Provincia 1, Pais 3
       3|pais 3|            2|       3|Provincia 2, Pais 3
(6 rows)
</pre>

Bueno, esto ya empieza a ser más razonable. ¿Seis tuplas, correcto?

<p>
Si tenemos seis  municipios y cada municipio  está en un país. Es  normal
que me dé un número de tuplas igual al  de municipios, dado que países
es un  calificativo  de municipios. Acabamos de  relacionar  la  tabla de
países  con la  tabla    de provincias  mediante el  código   de país.
Recordemos  que países tiene código y  que  provincias tiene el código
país al que pertenece.

<p>
¿Porqué <tt>paises.cod_pais = provincias.cod_pais</tt> ?

<p>
Código de país  en la tabla de países  se llama <tt>cod_pais</tt> y en
la tabla de provincias también, entonces:

<pre>
cod_pais = cod_pais
</pre>

es ilógico, el interprete nunca sabría como manejar eso y nos daría un
error:

<pre>
select * from paises, provincias
		where cod_pais = cod_pais;

ERROR:  Column cod_pais is ambiguous
</pre>

Esto ahora podemos dar alias a las columnas :

<pre>
select * from paises a, provincias b
	where a.cod_pais = b.cod_pais;    

cod_pais|nombre|cod_provincia|cod_pais|nom_provincia
--------+------+-------------+--------+-------------------
       1|pais 1|            1|       1|Provincia 1, Pais 1
       1|pais 1|            2|       1|Provincia 2, Pais 1
       2|pais 2|            1|       2|Provincia 1, Pais 2
       2|pais 2|            2|       2|Provincia 2, Pais 2
       3|pais 3|            1|       3|Provincia 1, Pais 3
       3|pais 3|            2|       3|Provincia 2, Pais 3
(6 rows)
</pre>

¿Qué   nos devuelve el   gestor?: <tt>cod_pais</tt>, <tt> nombre</tt>,
<tt>cod_provincia</tt>, <tt>cod_pais</tt> y <tt>nom_provincia</tt>.

<p>
Como hemos pedido    "<tt>select * from  países, provincias</tt>",  el
<tt>*</tt> es un  comodín que indica que  queremos  TODO, por eso  nos
devuelve las  dos  columnas de países  y las   3 de provincias,  ahora
queremos algo más explícito

<pre>
select a.cod_pais, cod_provincia, nombre, nom_provincia
	from paises a, provincias b
	where a.cod_pais = b.cod_pais;

cod_pais|cod_provincia|nombre|nom_provincia
--------+-------------+------+-------------------
       1|            1|pais 1|Provincia 1, Pais 1
       1|            2|pais 1|Provincia 2, Pais 1
       2|            1|pais 2|Provincia 1, Pais 2
       2|            2|pais 2|Provincia 2, Pais 2
       3|            1|pais 3|Provincia 1, Pais 3
       3|            2|pais 3|Provincia 2, Pais 3
(6 rows)
</pre>

En  este comando hemos   especificado que  queremos, concretamente  el
código  del país, el código  de la provincia, el  nombre del país y el
nombre de la  provincia. Fijaros que  ciertos nombres de columna están
cualificados (a.cod_pais)  mientras que otros no (nom_provincia), esto
es debido a  que cod_pais está repetido en  ambas  tablas mientras que
nom_provincia sólo se encuentra en provincias. Los nombres de columnas
únicos no hace falta cualificarlos.
<p>
Complicamos un poco más:

<pre>
select a.cod_pais, cod_provincia, nombre, nom_provincia
	from paises a, provincias b
	where a.cod_pais = b.cod_pais
		and a.cod_pais = 3;

cod_pais|cod_provincia|nombre|nom_provincia
--------+-------------+------+-------------------
       3|            1|pais 3|Provincia 1, Pais 3
       3|            2|pais 3|Provincia 2, Pais 3
(2 rows)
</pre>

Esta vez hemos limitado la busqueda a los que  sólo tienen como código
país el 3.


	     <A name="section3"></A>
           <H2><FONT face="Helvetica,Arial" color="#660033">Funciones</FONT></H2>




A tÍtulo  de ejemplo vamos   a ver la  función de  recuento de tuplas,
<TT>count()</tt>.

<pre>
select count(*) from municipios;

count
-----
   27
(1 row)
</pre>

Nos  devuelve el número  de tuplas  que tiene  la tabla de municipios,
ahora:

<pre>
select cod_pais, count(*) from municipios
	group by cod_pais;

cod_pais|count
--------+-----
       1|    9
       2|    9
       3|    9
(3 rows)
</pre>

Nos devuelve el número  de tuplas que tienen el  MISMO código de país,
por eso usamos el discriminante <tt>cod_pais</tt>.
<p>

Para ilustrarlo mejor:

<pre>
select nombre, count(*) from paises a, municipios b
	where a.cod_pais = b.cod_pais
	group by nombre;

nombre|count
------+-----
pais 1|    9
pais 2|    9
pais 3|    9
(3 rows)
</pre>

Continuamos teniendo nuestras tres tuplas pero un pelín más claras.

<p>
Bueno esto era una mera introducción, una forma de ponernos en calor :-)


<A          name="section4"></A>     <H2><FONT  face="Helvetica,Arial"
color="#660033">Revisión de Conceptos</FONT></H2>



Hemos visto unos conceptos muy básicos de SQL. Lo más importante es el
concepto básico  de SQL. Con  éste   se deja de trabajar  sobre  datos
concretos para hacerlo con entidades de datos. Una entidad de datos es
el concepto abstracto de la base de datos.  En resumen "DE TODO LO QUE
TIENES SÓLO QUIERO UNA PARTE".
<p>
Hemos visto varios comandos:
<TABLE border="0"  BGCOLOR="#FFDDAA"  COLS=2 WIDTH="100%">
<tr>

<td VALIGN=TOP NOSAVE WIDTH="100">
<tt><b>CREATE TABLE</b></tt>  </td><td> Este comando permite crear una
tabla con sus columnas.</td></tr>
<tr BGCOLOR="#EEFFFF">
<td VALIGN=TOP NOSAVE>
<tt><b>DROP TABLE</b></tt></td> <td>Borrará la tabla.</td></tr>
<tr>
<td VALIGN=TOP NOSAVE>
<tt><b>SELECT</b></tt></td> <td>

Este comando es la base   de SQL, es el que   permite crear una  tabla
temporal con los  datos que necesitamos.  Este  comando puede contener
funciones o predicados complejos, así como <tt>sub_selects</tt>:
<pre>
select count(*) from municipios
	where cod_pais in (select cod_pais from paises);

count
-----
   27
(1 row)
</pre>
</td></tr>
<tr BGCOLOR="#EEFFFF">
<td VALIGN=TOP>
<tt><b>COMMIT  WORK</b></tt>  </td><td>Este   es   otro   comando  muy
importante. Este comando indica al gestor que TODAS las modificaciones
desde  el BEGIN WORK pueden hacerse  definitivas. En nuestro gestor lo
que marca el  inicio de  una transacción  es  el BEGIN WORK,  en otros
gestores el inicio  de una transacción la marca  el primer comando que
modifica algo en  la base  de datos.  En  postgreSQL  todo comando que
modifique  datos lo  hará    directamente, si previamente  no   se  ha
realizado un BEGIN WORK.

<p>
NOTA: los   comandos que  modifican  el  esquema de  la base  de datos
realizan un COMMIT WORK,  como tal si  se ha abierto una transacción y
se realiza un comando que modifique el esquema, nuestra transacción se
vera cerrada, con la imposibilidad de realizar un ROLLBACK WORK.

<p>
Mientras un  usuario tenga una transacción  activa, este podrá decidir
como los demás usuarios tendrán acceso a sus datos :
<lu>
<li> Datos modificados
<li> Datos originales a la transacción
<li> Bloqueo de acceso 
</lu>
</td></tr>

<tr VALIGN=TOP >
<td>
<tt><b>COMMIT WORK</b></tt>  </td><td> Cierra  una transacción dejando
las modificaciones    como definitivas   mientras que    ROLLBACK WORK
devuelve los  datos     al     estado anterior al    inicio    de   la
transacción.</td></tr>
</table>


El  concepto  de transacción es  muy  importante, dado que  permite la
vuelta  al estado  anterior en  caso  de  haberse producido  un error.
Ahora  probemos ese concepto, empezamos  por un "<i>rollback work</i>"
para cerrar cualquier transacción abierta:

<pre>
select * from paises;
cod_pais|nombre
--------+------
       1|pais 1
       2|pais 2
       3|pais 3
(3 rows)
</pre>

Tenemos tres tuplas.

<pre>
begin work;
</pre>

Inicio la transacción
<pre>
insert into paises values (5, 'pais de mentira');
</pre>

Inserto una tupla.
<pre>
select * from paises;
cod_pais|nombre
--------+---------------
       1|pais 1
       2|pais 2
       3|pais 3
       5|pais de mentira
(4 rows)
</pre>

Verificamos que están todas y lo están.

<pre>
rollback work;
</pre>

Abandonamos la transacción.

<pre>
select * from paises;
cod_pais|nombre
--------+------
       1|pais 1
       2|pais 2
       3|pais 3
(3 rows)
</pre>

Todo está como antes.

<TABLE border="0"  BGCOLOR="#FFDDAA"  COLS=2 WIDTH="100%">
<tr>
<td VALIGN=TOP NOSAVE WIDTH="100">
<tt><b>INSERT</b></tt> </td><td>
 También lo hemos visto, este comando sirve para meter datos en una
tabla.</td></tr>
<tr BGCOLOR="#EEFFFF">
<td VALIGN=TOP NOSAVE>

<tt><b>CREATE TABLE</b></tt></td> <td> Otro comando muy importante, el
de creación de la tabla y sus columnas, vamos a ver que tipos de datos
podemos tratar :
<TABLE border="0"  BGCOLOR="#EECC99"  COLS=2 WIDTH="100%">
<tr>

<td  VALIGN=TOP   NOSAVE WIDTH="100"><tt><b>char(rango):</b></tt></td>
<td> Dato alfanumérico de longitud fija de 30 bytes.
</td>
<tr BGCOLOR="#DDEEEE">

<td VALIGN=TOP NOSAVE WIDTH="100"><tt><b>varchar(rango):</b></tt></td>
<td> Dato alfanumérico de longitud variable de hasta 30 bytes.</td>
<tr>

<td VALIGN=TOP NOSAVE WIDTH="100"><tt><b>int2:</b></tt></td> <td> Dato
numérico binario de 2 bytes : 2**-15 hasta 2**15
</td>
<tr BGCOLOR="#DDEEEE">

<td VALIGN=TOP NOSAVE WIDTH="100"><tt><b>int4:</b></tt></td> <td> Dato
numérico binario de 4 bytes : 2**-31 - 2**31
</td>
<tr>

<td   VALIGN=TOP NOSAVE  WIDTH="100"><tt><b>money:</b></tt></td>  <td>
Dato numérico de  coma fija,  ej: money(6,3),  dato numérico de   seis
dígitos de los cuales 3 son decimales (3 enteros y tres decimales).
</td>
<tr BGCOLOR="#DDEEEE">

<td VALIGN=TOP NOSAVE WIDTH="100"><tt><b>time:</b></tt></td> <td> Dato
de tiempo   que contendrá    horas,  minutos,   segundos,  centésimas,
HH:MM:SS:CCC
</td>
<tr>

<td VALIGN=TOP NOSAVE WIDTH="100"><tt><b>date:</b></tt></td> <td> Dato
de fecha que contendrá año, mes, día, AAAA/MM/DD
</td>
<tr BGCOLOR="#DDEEEE">

<td VALIGN=TOP NOSAVE WIDTH="100"><tt><b>timestamp:</b></tt></td> <td>
Dato fecha y hora, AAAA/MM/DD:HH:MM:SS:CCC
</td>
<tr>

<td VALIGN=TOP NOSAVE WIDTH="100"><tt><b>float(n):</b></tt></td>  <td>
Dato real de precisión
</td>
<tr BGCOLOR="#DDEEEE">

<td  VALIGN=TOP NOSAVE WIDTH="100"><tt><b>float3:</b></tt></td>   <td>
Dato real de doble precisión
</td>
<tr>
</table>
Las definiciones de   los tipos de datos   son propias a  cada gestor,
existe una normalización de SQL (la última es la  ANSI/92 o SQL/3) que
define unos tipos de  datos con sus  características, como tal en este
cursillo sólo veremos unos cuantos propios a PostgreSQL.

</tr>
</td>
<tr>
<td VALIGN=TOP NOSAVE WIDTH="100">
<tt><b>DELETE</b></tt> </td><td> Con este borraremos tuplas de una tabla
<tr  BGCOLOR="#EEFFFF">
<td VALIGN=TOP NOSAVE WIDTH="100">
<tt><b>UPDATE</b></tt> </td><td> Con este modificaremos columnas de tuplas de una tabla
</tr>
</td>
</table>
	     <A name="section5"></A>
           <H2><FONT face="Helvetica,Arial" color="#660033">Resumen</FONT></H2>



Aunque parezca un  tanto revuelto,  nos  hemos  introducido al SQL   y
tenemos instalado un gestor de bases de datos relacionales.

<p>
SQL nos  permite  construir  una capa de  abstracción   a los datos  y
manejar estos según lo necesitemos.

<p>
De la forma que hemos visto esto, cabe una pregunta :

¿Cómo aplico SQL a una aplicación?

<p>
La  respuesta vendrá poco a poco  y en la  tercera entrega haremos una
pequeña aplicación en C.


          </TD>
        </TR>
	 </TABLE>

     <HR size=2 noshade>
    <p align=right> <b>Artículo original en Castellano</b></p>
<BR><BR>    
    </TD>

 </TR>

 </TBODY>


 <TR bgcolor="#660033">
   <TD colspan="2" align="center"><FONT face="Helvetica,Arial" color="#FFFFFF"><B>
         &copy; 1998 Manuel Soriano</B></FONT><BR>
    <FONT color="#ffffff"> Páginas web mantenidas por
    <A href="mailto:angel@mercury.chem.pitt.edu"><FONT color="#ffffff">Miguel A Sepulveda</FONT></A></FONT>.
   </TD>
 </TR>



</TABLE>


</BODY>
</HTML>



