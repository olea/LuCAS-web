<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//ES">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.21">
 <META NAME="LFCATEGORY" CONTENT="Software Development">
<!-- this is used by a number of tools:
 =LF=AUTHOR:  Fr&eacute;d&eacute;ric Raynal, Christophe Blaess, Christophe Grenier
 =LF=CAT___: Software Development
 =LF=TITLE_: Evitando agujeros de seguridad al desarrollar una aplicaci&oacute;n - Parte 6: Scripts CGI
 =LF=NUMBER: 203
 =LF=ANAME_: article203.html
 -->
 <TITLE>lf203, Software Development: Evitando agujeros de seguridad al desarrollar una aplicaci&oacute;n - Parte 6: Scripts CGI</TITLE>
<!-- stylesheet added by lfparser: --> 
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-familiy:monospace,Courier }
 p.cl { color:#EE9500 }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; border-style:none; border-width:medium; border-color:#FFD700; padding:0.5cm ;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; border-style:none; border-width:medium; border-color:#aedbe8; padding:0.1cm ;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; border-width:medium; border-color:#AAAAAA; padding:0.5cm ; margin-top:0.1cm; margin-right:1cm; margin-left:1cm; text-align:center }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://www.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar -->
 <!-- top navegation bar -->
 <TABLE cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="144"><IMG src="../../common/images/logolftop.gif"
           alt="[LinuxFocus-icon]" width="350" height="45" align="left" 
           border="0"></TD>

           <TD class="top">
             <TABLE width="100%">
               <TR align="right">
                 <TD class="top"><A class="nodec" href="../"><FONT color=
                 "#DDDDDD" size="-1">Hogar</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="-1">Mapa</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="-1">Indice</FONT></A> &nbsp;|&nbsp; <A class=
                 "nodec" href="../Search/"><FONT color=
                 "#DDDDDD" size="-1">Busqueda</FONT></A> </TD>
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/"><FONT color=
           "#FFFFFF">Noticias</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/"><FONT color=
           "#FFFFFF">Arca</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/"><FONT color=
           "#FFFFFF">Enlaces</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">Sobre LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!--#include virtual="../../dynahead.shtml" -->

<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT BIO ABOUT THE AUTHOR -->
<TABLE ALIGN=LEFT BORDER=0  WIDTH="30%" >
<TR>
<TD>

<!-- 2pdaIgnoreStart -->
<!-- PALM DOC -->
<TABLE BORDER=0 hspace=4 vspace=4> <TR> <TD>
<font size=1> <img src="../../common/images/2doc.gif" width=34 align=left border=0 height=22 alt="convert to palm"><a href="http://cgi.linuxfocus.org/cgi-bin/2ztxt">Convert to GutenPalm</a><br>or <a href="http://cgi.linuxfocus.org/cgi-bin/2pda">to PalmDoc</a></font>
</TD> </TR> </TABLE>
<!-- END PALM DOC -->
<!-- 2pdaIgnoreStop -->
<br>
<IMG src="../../common/images/FredCrisBCrisG.jpg" alt=
    "[imagen de los autores]" width="200" height="150">
<BR>por   Fr&eacute;d&eacute;ric Raynal, Christophe Blaess, Christophe Grenier <br> <small>&lt;pappy(at)users.sourceforge.net, ccb(at)club-internet.fr, grenier(at)nef.esiea.fr&gt;</small>
<BR><BR>
<I>Sobre el autor:</I><BR>
<P>Christophe Blaess es un ingeniero aeron&aacute;utico independiente. Es un fan de Linux
 y realiza mucho de su trabajo con este sistema. Adem&aacute;s, coordina la traducci&oacute;n de las p&aacute;ginas del manual
	publicadas en <I>Linux Documentation Project</I>.</P><P>Christophe Grenier es un estudiante de 5º curso en ESIEA, donde
trabaja como administrador de sistemas. Siente pasi&oacute;n por la seguridad en computadoras.</P><P>Fr&eacute;d&eacute;ric Raynal ha estado utilizando Linux durante
	muchos a&ntilde;os ya que no contamina, no utiliza hormonas, ni
    GMO ni harina de engorde para animales... solamente contiene esfuerzo e ingenio.</P>
<!-- TRANSLATED TO es -->
<BR><BR><I>Taducido al espa&ntilde;ol por:</I><BR>
Gerard Farr&agrave;s Ballabriga <small>&lt;gerard.farras(at)campus.uab.es&gt;</small>
<br>
<!-- TRANSLATED TO STOP -->
<BR><i>Contenidos</i>:
<UL>
  <LI><A HREF="#203lfindex0">Servidor Web, URI y problemas de configuraci&oacute;n</A></LI>
  <LI><A HREF="#203lfindex1">Introducci&oacute;n (demasiado breve) sobre como trabaja un servidor web y como
 construir una URI</A></LI>
  <LI><A HREF="#203lfindex2">Configuraci&oacute;n de Apache con "SSI Server Side
    Include"</A></LI>
  <LI><A HREF="#203lfindex3">Scripts en Perl</A></LI>
  <LI><A HREF="#203lfindex4">El byte null</A></LI>
  <LI><A HREF="#203lfindex5">Utilizando pipes (tuber&iacute;as)</A></LI>
  <LI><A HREF="#203lfindex6">Salto de l&iacute;nea</A></LI>
  <LI><A HREF="#203lfindex7">La barra invertida y el punto y coma</A></LI>
  <LI><A HREF="#203lfindex8">Utilizando un car&aacute;cter " no protegido</A></LI>
  <LI><A HREF="#203lfindex9">Programando en Perl</A></LI>
  <LI><A HREF="#203lfindex10">Opciones de Warning y tainting</A></LI>
  <LI><A HREF="#203lfindex11">La llamada open()</A></LI>
  <LI><A HREF="#203lfindex12">Filtrando la entrada</A></LI>
  <LI><A HREF="#203lfindex13">Scripts PHP</A></LI>
  <LI><A HREF="#203lfindex14">Conclusi&oacute;n</A></LI>
  <LI><A HREF="#203lfindex15">Algunos caracteres unicode</A></LI>
  <LI><A HREF="#203lfindex16">Enlaces</A></LI>
  <LI><A HREF="#203lfindex17">El programa LibroDeInvitados.cgi defectuoso</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=203&amp;lang=es">Formulario de "talkback" para este art&iacute;culo</A></LI>
</UL>

</TD></TR></TABLE>
<!-- HEAD OF THE ARTICLE -->
<br>&nbsp;
<H2>Evitando agujeros de seguridad al desarrollar una aplicaci&oacute;n - Parte 6: Scripts CGI</H2>
 <IMG src="../../common/images/illustration183.gif" width="100"
    height="100" alt="[article illustration]" hspace="10">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Resumen</i>:
<P>

    Obteniendo un fichero, ejecutando un script en Perl mal programado
    ... "Hay m&aacute;s de un camino para hacer esto!" <BR><BR>
    Art&iacute;culos previos de esta serie :

    <UL><LI><A href="../January2001/article182.shtml">Evitando los
agujeros de seguridad durante el desarrollo de aplicaciones - Parte 1</A></LI><LI><A href="../March2001/article183.shtml">Evitando los
agujeros de seguridad durante el desarrollo de aplicaciones -
Parte 2 : Memoria, pila y funciones</A></LI>
      holes when developing an application - Part 2 : memory, stack and
      functions, shellcode</A></LI><LI><A href="../May2001/article190.shtml">Evitando los
agujeros de seguridad durante el desarrollo de aplicaciones -
Parte 3 : Desbordamiento de b&uacute;ffer</A></LI><LI><A href="../July2001/article191.shtml">Evitando los
agujeros de seguridad durante el desarrollo de aplicaciones -
Parte 4 : Cadenas de formato</A></LI><LI><A href="../September2001/article198.shtml">Evitando los
agujeros de seguridad durante el desarrollo de aplicaciones -
Parte 5 : Condiciones de carrera</A></LI></UL></P>
<HR size="2" noshade align="right"><BR>
<!-- BODY OF THE ARTICLE -->


    <A NAME="203lfindex0">&nbsp;</A>
<H2>Servidor Web, URI y problemas de configuraci&oacute;n</H2>


    <A NAME="203lfindex1">&nbsp;</A>
<H3>Introducci&oacute;n (demasiado breve) sobre como trabaja un servidor web y como
 construir una URI</H3>


    <P>Cuando un cliente pide un archivo HTML, el servidor env&iacute;a la p&aacute;gina pedida
(o un mensaje de error). El navegador interpreta el c&oacute;digo HTML para formatear y visualizar
el fichero. Para poner un ejemplo, escribiendo la URL (Uniform Request Locator)
    <CODE>http://www.linuxdoc.org/HOWTO/HOWTO-INDEX/howtos.html</CODE>,
 el cliente se conecta al servidor
    <CODE>www.linuxdoc.org</CODE> y pide la p&aacute;gina
    <CODE>/HOWTO/HOWTO-INDEX/howtos.html</CODE>, utilizando el protocolo HTTP.
    Si la p&aacute;gina existe, el servidor env&iacute;a el archivo pedido.
    Con este modelo <EM>est&aacute;tico</EM>, si el archivo est&aacute; presente en el servidor
    , &eacute;ste es enviado "tal y como es" al cliente, de otra forma un mensaje de error
    es enviado (el bien conocido <EM>404 - Not Found</EM>).</P>

    <P>Desgraciadamente, esto no permite la interactividad con el usuario.
    De este modo cosas como e-negocios, e-reservas para vacaciones o
    e-loquesea no es posible.</P>

    <P>Afortunadamente, hay soluciones para generar din&aacute;micamente p&aacute;ginas HTML.
 Los scripts CGI (Common Gateway Interface) son una de ellas. En este caso,
 la URL para acceder a estas p&aacute;ginas es construida de forma ligeramente diferente:</P>
<PRE>
http://&lt;servidor&gt;&lt;pathHaciaScript&gt;[?[param_1=val_1][...][&amp;param_n=val_n]]
</PRE>
    La lista de argumentos es guardada en la variable de entorno <CODE>QUERY_STRING</CODE>.
 En este contexto, un script CGI no es nada m&aacute;s que un archivo ejecutable.
 Utiliza <CODE>stdin</CODE> (standard input)
    o la variable de entorno <CODE>QUERY_STRING</CODE> para obtener
    los argumentos que le pasan. Despu&eacute;s de ejecutar el c&oacute;digo, el resultado es
    mostrado en <CODE>stdout</CODE> (standard output) y luego,
    redirigido al cliente web. Casi todos los lenguajes de programaci&oacute;n pueden ser usados
para escribir un script CGI (un programa compilado en C, Perl,
    shell-scripts...). <BR>
    <BR>

    <P>Por ejemplo, perm&iacute;tame buscar qu&eacute; es lo que los HOWTOs de
    <CODE>www.linuxdoc.org</CODE> conocen sobre ssh&nbsp;:</P>
<PRE>
http://www.linuxdoc.org/cgi-bin/ldpsrch.cgi?

svr=http%3A%2F%2Fwww.linuxdoc.org&amp;srch=ssh&amp;db=1&amp;scope=0&amp;rpt=20
</PRE>
    De hecho, esto es mucho m&aacute;s simple de lo que parece. Vamos a analizar esta URL
    :

    <UL>
      <LI>el servidor es a&uacute;n el mismo
      <CODE>www.linuxdoc.org</CODE>&nbsp;;</LI>

      <LI>el archivo pedido, el script CGI, es llamado
      <CODE>/cgi-bin/ldpsrch.cgi</CODE>&nbsp;;</LI>

      <LI>
        el car&aacute;cter <CODE>?</CODE> es el comienzo de una larga lista de argumentos
        :

        <OL>
          <LI><CODE>srv=http%3A%2F%2Fwww.linuxdoc.org</CODE> es el servidor
          de donde viene la petici&oacute;n;</LI>

          <LI><CODE>srch=ssh</CODE> contiene la petici&oacute;n en s&iacute;;</LI>

          <LI><CODE>db=1</CODE> significa que la petici&oacute;n solo se refiere a
          HOWTOs;</LI>

          <LI><CODE>scope=0</CODE> significa que la petici&oacute;n se refiere al contenido
del documento y no solo a su t&iacute;tulo;</LI>

          <LI><CODE>rpt=20</CODE> limita a 20 el n&uacute;mero de respuestas visualizadas.
          </LI>
        </OL>
      </LI>
    </UL>
    <BR>
    <BR>

    <P>Frecuentemente, los nombres de los argumentos y sus valores son suficientemente
expl&iacute;citos como para entender su significado. Adem&aacute;s, el contenido de la p&aacute;gina
    que muestra las respuestas puede ser significativas.</P>

    <P>Ahora sabemos que el lado brillante de los scripts CGI es la habilidad
    que tiene un usuario para pasar argumentos... pero el lado oscuro es que un script
mal programado abre un agujero de seguridad.</P>

    <P>Probablemente habr&aacute;s notado caracteres extra&ntilde;os en tu navegador
    o presentes dentro de la petici&oacute;n previa. Estos caracteres est&aacute;n en formato
    <EM>Unicode</EM>. La <A href=
    "#tab_unicode">tabla 1</A> muestra el significado de algunos de estos c&oacute;digos.
 Perm&iacute;teme mencionar que algunos servidores IIS4.0 y IIS5.0 tienen una vulnerabilidad
    basada en estos caracteres.</P>

    <A NAME="203lfindex2">&nbsp;</A>
<H3>Configuraci&oacute;n de Apache con "<CODE>SSI Server Side
    Include</CODE>"</H3>


    <P><CODE><EM>Server Side Include</EM></CODE> es una funci&oacute;n parte de los servidores web.
    Permite integrar instrucciones dentro de las p&aacute;ginas web, incluir un fichero "tal y como es", o ejecutar un comando
    (shell o script CGI).</P>

    <P>En el fichero de configuraci&oacute;n del Apache <CODE>httpd.conf</CODE>, la instrucci&oacute;n
    "<CODE>AddHandler server-parsed .shtml</CODE>" activa este mecanismo.
    Frecuentemente, para evitar la distinci&oacute;n entre <CODE>.html</CODE> and <CODE>.shtml</CODE>, uno puede a&ntilde;adir la
extensi&oacute;n <CODE>.html</CODE>. Evidentemente, esto ralentiza el servidor...
	Esto puede ser controlado a nivel de directorios con las instrucciones:</P>

    <UL>
      <LI><CODE>Options Includes</CODE> activa todos los SSI&nbsp;;</LI>

      <LI><CODE>OptionsIncludesNoExec</CODE> prohibe <CODE>exec
      cmd</CODE> y <CODE>exec cgi</CODE>.</LI>
    </UL>
    <BR>
    <BR>

    <P>En el script adjunto <CODE><A href=
    "#guestbook">LibroDeInvitados.cgi</A></CODE>, el texto proporcionado por el usuario
    es incluido en un archivo HTML, sin la conversi&oacute;n de caracteres de '&lt;' y '&gt;'
    hacia los c&oacute;digos HTML &amp;lt; and &amp;gt; . Suficiente para que una
persona curiosa envie una de las siguientes
	instrucciones :
</P>

    <UL>
      <LI><CODE>&lt;!--#printenv --&gt;</CODE> (recuerda el espacio despu&eacute;s de
      <CODE>printenv&nbsp;</CODE> )</LI>

      <LI><CODE>&lt;!--#exec cmd="cat /etc/passwd"--&gt;</CODE></LI>
    </UL>
    Con el primero, <BR>

<CODE>LibroDeInvitados.cgi?email=pappy&amp;texte=%3c%21--%23printenv%20--%3e</CODE>
    <BR>
    obtienes algunas l&iacute;neas de informaci&oacute;n sobre el sistema :
<PRE>
<SMALL>DOCUMENT_ROOT=/home/web/sites/www8080
HTTP_ACCEPT=image/gif, image/jpeg, image/pjpeg, image/png, */*
HTTP_ACCEPT_CHARSET=iso-8859-1,*,utf-8
HTTP_ACCEPT_ENCODING=gzip
HTTP_ACCEPT_LANGUAGE=en, fr
HTTP_CONNECTION=Keep-Alive
HTTP_HOST=www.esiea.fr:8080
HTTP_PRAGMA=no-cache
HTTP_REFERER=http://www.esiea.fr:8080/~grenier/cgi/LibroDeInvitados.cgi?
 email=&amp;texte=%3C%21--%23include+file%3D%22LibroDeInvitados.cgi%22--%3E
HTTP_USER_AGENT=Mozilla/4.76 [fr] (X11; U; Linux 2.2.16 i686)
PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin
REMOTE_ADDR=194.57.201.103
REMOTE_HOST=nef.esiea.fr
REMOTE_PORT=3672
SCRIPT_FILENAME=/mnt/c/nef/grenier/public_html/cgi/LibroDeInvitados.html
SERVER_ADDR=194.57.201.103
SERVER_ADMIN=master8080@nef.esiea.fr
SERVER_NAME=www.esiea.fr
SERVER_PORT=8080
SERVER_SIGNATURE=&lt;ADDRESS&gt;Apache/1.3.14 Server www.esiea.fr Port
8080&lt;/ADDRESS&gt;

SERVER_SOFTWARE=Apache/1.3.14 (Unix)  (Red-Hat/Linux) PHP/3.0.18
GATEWAY_INTERFACE=CGI/1.1
SERVER_PROTOCOL=HTTP/1.0
REQUEST_METHOD=GET
QUERY_STRING=
REQUEST_URI=/~grenier/cgi/LibroDeInvitados.html
SCRIPT_NAME=/~grenier/cgi/LibroDeInvitados.html
DATE_LOCAL=Tuesday, 27-Feb-2001 15:33:56 CET
DATE_GMT=Tuesday, 27-Feb-2001 14:33:56 GMT
LAST_MODIFIED=Tuesday, 27-Feb-2001 15:28:05 CET
DOCUMENT_URI=/~grenier/cgi/LibroDeInvitados.shtml
DOCUMENT_PATH_INFO=
USER_NAME=grenier
DOCUMENT_NAME=LibroDeInvitados.html
</SMALL>
</PRE>
    <BR>
    <BR>

    <P>La instrucci&oacute;n <CODE>exec</CODE>, suministra casi lo mismo que una shell
     :</P>
<small>
<PRE>
LibroDeInvitados.cgi?email=ppy&amp;texte=%3c%21--%23exec%20cmd="cat%20/etc/passwd"%20--%3e
</PRE>
</small>

    <P>No intentes "<CODE>&lt;!--#include
    file="/etc/passwd"--&gt;</CODE>", el path es relativo al directorio donde
 puedes encontrar el fichero HTML y no puede contener "<CODE>..</CODE>".
    El fichero de Apache <CODE>error_log</CODE> , contendr&aacute; un mensaje indicando un intento de acceso a un fichero prohibido
    . El usuario podr&aacute; ver el mensaje <CODE>[an error occurred while
    processing this directive]</CODE> en la p&aacute;gina HTML.</P>

    <P>SSI no es necesario frecuentemente y es mejor desactivarlo del servidor.
    Sin embargo, la causa del problema es la combinaci&oacute;n entre la aplicaci&oacute;n mal programada LibroDeInvitados y SSI.
	</P>

    <A NAME="203lfindex3">&nbsp;</A>
<H2>Scripts en Perl</H2>


    <P>En esta secci&oacute;n, vamos a presentar los agujeros de seguridad relacionados con los scripts CGI escritos en Perl.
 	Para hacerlo mas claro, no daremos todo el c&oacute;digo sino solamente las partes requeridas para entender el problema.
</P>

    <P>Cada uno de nuestros scripts est&aacute; programado siguiendo la plantilla siguiente :
    </P>
<PRE>
#!/usr/bin/perl -wT
BEGIN { $ENV{PATH} = '/usr/bin:/bin' }
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};   # Hacemos %ENV m&aacute;s segura =:-)
print "Content-type: text/html\n\n";
print "&lt;HTML&gt;\n&lt;HEAD&gt;";
print "&lt;TITLE&gt;Comando remoto&lt;/TITLE&gt;&lt;/HEAD&gt;\n";
&amp;ReadParse(\%input);
# Podemos usar $input por ejemplo as&iacute;:
# print "&lt;p&gt;$input{archivo}&lt;/p&gt;\n";
# ########################################## #
# Principio de la descripci&oacute;n del problema   #
# ########################################## #



# #################################### #
# Fin de la descripci&oacute;n del problema   #
# #################################### #

form:
print "&lt;form action=\"$ENV{&Ntilde;OMBRE_DEL_SCRIPT'}\"&gt;\n";
print "&lt;input type=texto name=archivo&gt;\n &lt;/form&gt;\n";
print "&lt;/BODY&gt;\n";
print "&lt;/HTML&gt;\n";
exit(0);

# el primer argumento tiene que ser una referencia a un hash
# El hash ser&aacute; rellenado con datos.
sub ReadParse($) {
  my $in=shift;
  my ($i, $key, $val);
  my $in_primero;
  my @in_segundo;

  # Leer en texto
  if ($ENV{'REQUEST_METHOD'} eq "GET") {
    $in_first = $ENV{'QUERY_STRING'};
  } elsif ($ENV{'REQUEST_METHOD'} eq "POST") {
    read(STDIN,$in_primero,$ENV{'CONTENT_LENGTH'});
  }else{
    die "ERROR: M&eacute;todo de petici&oacute;n desconocido\n";
  }

  @in_segundo = split(/&amp;/,$in_primero);

  foreach $i (0 .. $#in_segundo) {
    # Convertir los caracteres + en espacios
    $in_segundo[$i] =~ s/\+/ /g;

    # Partir entre la clave y el valor.
    ($key, $val) = split(/=/,$in_segundo[$i],2);

    # Convertir %XX de n&uacute;meros hexadecimales a alfanum&eacute;ricos
    $key =~ s/%(..)/pack("c",hex($1))/ge;
    $val =~ s/%(..)/pack("c",hex($1))/ge;

    # Asociar una clave con un valor
    # \0 es el separador m&uacute;ltiple
    $$in{$key} .= "\0" if (defined($$in{$key}));
    $$in{$key} .= $val;

  }
  return length($#in_segundo);
}

</PRE>

    <P>Despu&eacute;s vamos a aprender m&aacute;s sobre los argumentos pasados al int&eacute;rprete Perl (<CODE>-wT</CODE>).
    Empezamos limpiando las variables de entorno <CODE>$ENV</CODE> y <CODE>$PATH</CODE>
    y enviamos seguidamente la cabecera HTML (esto es parte del protocolo html implementado por el navegador cliente y
el servidor. Aunque no podamos verlo desde el lado del cliente).
	La funci&oacute;n <CODE>ReadParse()</CODE> lee los argumentos pasados al script.
	Esto puede hacerse m&aacute;s facilmente con m&oacute;dulos, pero as&iacute; podemos ver el c&oacute;digo entero.
	Ahora vamos a presentar algunos ejemplos.
</P>

    <A NAME="203lfindex4">&nbsp;</A>
<H3>El byte null</H3>


    <P>Perl considera cada car&aacute;cter de la misma forma, cosa que difiere de las funciones en C, por ejemplo.
 	En Perl, el car&aacute;cter null al final de una cadena (string) es como cualquier otro. Qu&eacute; implica eso ?</P>

    <P>Vamos a a&ntilde;adir el siguiente c&oacute;digo a nuestro script para crear
    <CODE>showhtml.cgi</CODE>&nbsp; :</P>
<PRE>
  # showhtml.cgi
  my $archivo= $input{archivo}.".html";
  print "&lt;BODY&gt;Archivo : $archivo&lt;BR&gt;";
  if (-e $archivo) {
      open(FILE,"$archivo") || goto form;
      print &lt;FILE&gt;;
  }
</PRE>
    <BR>
    <BR>

    <P>La funci&oacute;n <CODE>ReadParse()</CODE> obtiene el &uacute;nico argumento :
    el nombre del archivo a mostrar. Para prevenir que se pueda leer algo m&aacute;s que ficheros HTML,
	a&ntilde;adimos la extensi&oacute;n "<CODE>.html</CODE>" al final del nombre del fichero. Pero,
    recuerda, el car&aacute;cter null es como cualquiera otro...</P>

    <P>De este modo, si nuestra petici&oacute;n es
    <CODE>showhtml.cgi?archivo=%2Fetc%2Fpasswd%00</CODE> el archivo es llamado
    <CODE>my $archivo = "/etc/passwd\0.html"</CODE> y nuestros pasmados ojos estar&aacute;n mirando algo
que no parece HTML.</P>

    <P>Qu&eacute; es lo que pasa ? El comando <CODE>strace</CODE> nos muestra como Perl
    abre un fichero:</P>
<PRE>
  /tmp &gt;&gt;cat &gt;open.pl &lt;&lt; EOF
  &gt; #!/usr/bin/perl
  &gt; open(FILE, "/etc/passwd\0.html");
  &gt; EOF
  /tmp &gt;&gt;chmod 0700 open.pl
  /tmp &gt;&gt;strace ./open.pl 2&gt;&amp;1 | grep open
  execve("./open.pl", ["./open.pl"], [/* 24 vars */]) = 0
  ...
  open("./open.pl", O_RDONLY)             = 3
  read(3, "#!/usr/bin/perl\n\nopen(FILE, \"/et"..., 4096) = 51
  open("/etc/passwd", O_RDONLY)           = 3
</PRE>
    <BR>
    <BR>

    <P>El &uacute;ltimo <CODE>open()</CODE> presentado por <CODE>strace</CODE>
    corresponde a la llamada de sistema escrita en C. Como podemos ver la extensi&oacute;n
    <CODE>.html</CODE> ha desaparecido, y esto nos permite abrir /etc/passwd.</P>

    <P>Este problema es solucionado con una expresi&oacute;n regular muy simple que borre todos los caracteres null:
    </P>
<PRE>
s/\0//g;
</PRE>
    <BR>
    <BR>


    <A NAME="203lfindex5">&nbsp;</A>
<H3>Utilizando pipes (tuber&iacute;as)</H3>


    <P>Aqu&iacute; tenemos un script sin protecci&oacute;n alguna que muestra un archivo especificado del &aacute;rbol de directorios
 /home/httpd/ :</P>
<PRE>
#pipe1.cgi

my $archivo= "/home/httpd/".$input{archivo};
print "&lt;BODY&gt;File : $archivo&lt;BR&gt;";
open(FILE,"$archivo") || goto form;
print &lt;FILE&gt;;
</PRE>
    <BR>
    <BR>

    <P>No vayais a re&iacute;ros con este ejemplo! He visto cosas parecidas en muchos scripts.</P>

    <P>El primer exploit es obvio :</P>
<PRE>
pipe1.cgi?archivo=..%2F..%2F..%2Fetc%2Fpasswd
</PRE>
    Suficiente para "subir" al &aacute;rbol de directorios y acceder a cualquier fichero.
Pero hay algo mucho m&aacute;s interesante : ejecutar el comando que t&uacute; escojas. En
    Perl, el comando <CODE>open(FILE, "/bin/ls")</CODE> abre el archivo binario
    "<CODE>/bin/ls</CODE>" ... pero
    <CODE>open(FILE,&nbsp;"/bin/ls&nbsp;|")</CODE> ejecuta dicho comando.
    A&ntilde;adiendo un simple pipe <CODE>|</CODE> cambia la conducta de <CODE>open()</CODE>. <BR>
    <BR>

    <P>Otro problema viene del hecho que la existencia del archivo no es testeada,
  esto nos permite ejecutar cualquier comando y adem&aacute;s pasarle argumentos:

<PRE>pipe1.cgi?archivo=..%2F..%2F..%2Fbin%2Fcat%20%2fetc%2fpasswd%20|</PRE>
    muestra el contenido del fichero de passwords.</P>

    <P>Testeando la existencia del archivo da menos libertad a open
    :</P>
<PRE>
#pipe2.cgi

my $archivo= "/home/httpd/".$input{archivo};
print "&lt;BODY&gt;File : $archivo&lt;BR&gt;";
if (-e $archivo) {
  open(FILE,"$archivo") || goto form;
  print &lt;FILE&gt;
} else {
  print "-e fallado: el fichero no existe\n";
}
</PRE>
    Aqu&iacute; el ejemplo anterior ya no funciona. El test "<CODE>-e</CODE>"
    falla ya que no encuentra el archivo "<CODE>../../../bin/cat
    /etc/passwd |</CODE>". <BR>
    <BR>

    <P>Vamos a probar el comando <CODE>/bin/ls</CODE>. Su conducta ser&aacute; la misma que antes.
    Eso es, si intentamos, por ejemplo de listar el contenido del directorio
<CODE>/etc</CODE> , "<CODE>-e</CODE>"
    testea la existencia del fichero "<CODE>../../../bin/ls /etc |</CODE>",
 que no existe. Como no suministremos el nombre de un fichero "fantasma" no vamos a obtener
nada interesante :(</P>

    <P>Sin embargo, a&uacute;n hay alguna alternativa.
 El fichero <CODE>/bin/ls</CODE> existe (en la mayor&iacute;a de los sistemas) y pasar&iacute;a el chequeo,
 pero si <CODE>open()</CODE> es llamado con este nombre de archivo
 se mostrar&iacute;a el archivo binario, pero no se ejecutar&iacute;a. Debemos buscar una soluci&oacute;n para
poner una tuber&iacute;a (pipe) '<CODE>|</CODE>' al final del nombre,
pero que no sea testeado con "<CODE>-e</CODE>". Ya conocemos la soluci&oacute;n : el byte null. Si enviamos
 "<CODE>../../../bin/ls\0|</CODE>" , el test de existencia pasa ya que solo considera
    "<CODE>../../../bin/ls</CODE>", pero <CODE>open()</CODE> puede ver el pipe
   y luego ejecuta el comando. As&iacute; que la URL que suministra el contenido del directorio actual es:
</P>
<PRE>
pipe2.cgi?archivo=../../../bin/ls%00|
</PRE>

    <A NAME="203lfindex6">&nbsp;</A>
<H3>Salto de l&iacute;nea</H3>


    <P>El script finger.cgi ejecuta la instrucci&oacute;n <CODE>finger</CODE>
    en nuestra m&aacute;quina :</P>
<PRE>
#finger.cgi

print "&lt;BODY&gt;";
$login = $input{'login'};
$login =~ s/([;&lt;&gt;\*\|`&amp;\$!#\(\)\[\]\{\}:'"])/\\$1/g;
print "Login $login&lt;BR&gt;\n";
print "Finger&lt;BR&gt;\n";
$CMD= "/usr/bin/finger $login|";
open(FILE,"$CMD") || goto form;
print &lt;FILE&gt;
</PRE>
    <BR>
    <BR>

    <P>Este script utiliza, como m&iacute;nimo, una protecci&oacute;n &uacute;til: tiene en cuenta algunos caracteres extra&ntilde;os
para prevenir que sean interpretados por la shell poniendo un '<CODE>\</CODE>' delante. As&iacute;, el punto y coma
 es cambiado a "<CODE>\;</CODE>" por la expresi&oacute;n regular. Pero la lista no contiene todos los caracteres importantes.
 Entre otros, el salto de l&iacute;nea '<CODE>\n</CODE>'.
    </P>

    <P>En tu shell preferida puedes validar una instrucci&oacute;n pulsando la tecla
     <CODE>RETURN</CODE> o <CODE>ENTER</CODE>
    , que env&iacute;a el car&aacute;cter '<CODE>\n</CODE>'. En Perl, puedes hacer lo mismo.
    Ya hemos visto como la instrucci&oacute;n <CODE>open()</CODE>
    nos permite ejecutar un comando cuando la l&iacute;nea termina con un pipe
 '<CODE>|</CODE>'.</P>

    <P>Para simular este comportamiento es suficiente con a&ntilde;adir un salto de l&iacute;nea y una instrucci&oacute;n
, despu&eacute;s de enviar el login al comando finger :</P>

    <CENTER>
<PRE>
finger.cgi?login=kmaster%0Acat%20/etc/passwd
</PRE>
    </CENTER>
    <BR>
    <BR>

    <P>Hay otros caracteres interesantes para ejecutar varias instrucciones en una sola l&iacute;nea:
 </P>

    <UL>
      <LI><CODE>;</CODE>&nbsp; : acaba con la primera instrucci&oacute;n y va a ejecutar la pr&oacute;xima
;</LI>

      <LI><CODE>&amp;&amp;</CODE>&nbsp; : si la primera instrucci&oacute;n no falla
 (<EM>por ejemplo, </EM> devuelve un 0), la pr&oacute;xima va a ser ejecutada;
</LI>

      <LI><CODE>||</CODE>&nbsp; : si la primera instrucci&oacute;n falla
      (<EM>por ejemplo, </EM> devuelve un valor no null), luego la pr&oacute;xima es ejecutada.</LI>
    </UL>
    <BR>
     Estos no funcionan aqu&iacute; ya que el script est&aacute; protegido de ellos gracias a la expresi&oacute;n regular.
Pero, vamos a buscar soluciones.

    <A NAME="203lfindex7">&nbsp;</A>
<H3>La barra invertida y el punto y coma</H3>


    <P>El script <CODE>finger.cgi</CODE> previo evita problemas con algunos caracteres extra&ntilde;os.
	As&iacute;, la URL
    <CODE>&lt;finger.cgi?login=kmaster;cat%20/etc/passwd</CODE> no resulta ya que el punto y coma es
 evitado. Sin embargo, hay un car&aacute;cter que no est&aacute; protegido: la barra invertida '<CODE>\</CODE>'.</P>


    <P>Imaginemos por un momento un script que evite la ascensi&oacute;n en el &aacute;rbol de directorios
utilizando la expresi&oacute;n regular <CODE>s/\.\.//g</CODE> para desembarazarnos de "<CODE>..</CODE>".
No importa! Las shells pueden manejar varios '<CODE>/</CODE>' a la vez (simplemente prueba <CODE>cat
    ///etc//////passwd</CODE> para quedar convencido).</P>

    <P>Por ejemplo, en el script anterior <CODE>pipe2.cgi</CODE>, la variable
    <CODE>$fichero</CODE> es inicializada con el prefijo
    "<CODE>/home/httpd/</CODE>". Parece que usando esta expresi&oacute;n regular
 ser&iacute;a suficiente para evitar la ascensi&oacute;n en el &aacute;rbol de directorios.
	Evidentemente, esta expresi&oacute;n protege a
    "<CODE>..</CODE>", pero qu&eacute; pasa si nosotros protegemos el car&aacute;cter
    '<CODE>.</CODE>' ? Eso es, la expresi&oacute;n regular
    no concuerda si el nombre del fichero es <CODE>.\./.\./etc/passwd</CODE>.
    En realidad, esta cadena funciona bien con la llamada <CODE>system()</CODE> (o
    con <CODE>`&nbsp;...&nbsp;`</CODE>), pero falla con <CODE>open()</CODE> o el test "<CODE>-e</CODE>".</P>

    <P>Vamos atr&aacute;s con el script <CODE>finger.cgi</CODE>. Utilizando el punto y coma
 la URL <CODE>finger.cgi?login=kmaster;cat%20/etc/passwd</CODE> no da el resultado esperado ya que
el punto y coma es filtrado por la expresi&oacute;n regular. Eso es, la shell recibe la instrucci&oacute;n:
</P>
<PRE>
/usr/bin/finger kmaster\;cat /etc/passwd
</PRE>
    Los siguientes errores son encontrados en los logs del servidor web :
<PRE>
finger: kmaster;cat: no such user.
finger: /etc/passwd: no such user.
</PRE>
	Estos mensajes son id&eacute;nticos a los que obtendr&iacute;as si lo escribieses en una shell.
	El problema viene del hecho que la shell considera el car&aacute;cter protegido
   '<CODE>;</CODE>' como parte de la cadena "<CODE>kmaster;cat</CODE>" . <BR>
    <BR>

    <P>Necesitamos separar las dos instrucciones, la primera para el script y
 la siguiente que queremos ejecutar. Debemos proteger
    '<CODE>;</CODE>'&nbsp;: <CODE>
&lt;A HREF="finger.cgi?login=kmaster\;cat%20/etc/passwd"&gt;
    finger.cgi?login=kmaster\;cat%20/etc/passwd&lt;/A&gt;</CODE>. La cadena
    "<CODE>\;</CODE> es cambiada en el script por
    "<CODE>\\;</CODE>", y luego, enviada a la shell. &Eacute;ste lee lo siguiente :
</P>
<PRE>
/usr/bin/finger kmaster\\;cat /etc/passwd
</PRE>
    La shell divide la cadena en dos:
    <OL>
      <LI><CODE>/usr/bin/finger kmaster\</CODE> que probablemente fallar&aacute;...  no sufras por eso ;-)</LI>

      <LI><CODE>cat /etc/passwd</CODE> que mostrar&aacute; el fichero de passwords.
     </LI>
    </OL>
    La soluci&oacute;n es simple : el car&aacute;cter barra invertida '<CODE>\</CODE>' tambi&eacute;n debe ser filtrado.
<BR>
    <BR>


    <A NAME="203lfindex8">&nbsp;</A>
<H3>Utilizando un car&aacute;cter " no protegido</H3>


    <P>A veces, el par&aacute;metro es "protegido" con comillas. Hemos cambiado ligeramente
	el script previo <CODE>finger.cgi</CODE> para proteger la variable
	<CODE>$login</CODE>.</P>

    <P>Sin embargo, si las comillas no son filtradas sera una consideraci&oacute;n in&uacute;til.
	Suficiente con a&ntilde;adir una en nuestra petici&oacute;n.
As&iacute;, la primera comilla " enviada, cierra la abierta por el script.
 Luego, escribes el comando, y la segunda comilla abriendo la &uacute;ltima (que cerrar&iacute;a) del script.
   </P>

    <P>El script finger2.cgi ilustra la idea :</P>
<PRE>
#finger2.cgi

print "&lt;BODY&gt;";
$login = $input{'login'};
$login =~ s/\0//g;
$login =~ s/([&lt;&gt;\*\|`&amp;\$!#\(\)\[\]\{\}:'\n])/\\$1/g;
print "Login $login&lt;BR&gt;\n";
print "Finger&lt;BR&gt;\n";
#Nueva (in)eficiente super protecci&oacute;n :
$CMD= "/usr/bin/finger \"$login\"|";
open(FILE,"$CMD") || goto form;
while(&lt;FILE&gt;) {
  print;
}
</PRE>
    <BR>
    <BR>

    <P>La URL que ejecutar&aacute; el comando se convierte en :</P>
<PRE>
finger2.cgi?login=kmaster%22%3Bcat%20%2Fetc%2Fpasswd%3B%22
</PRE>
    La shell recibe el comando <CODE>/usr/bin/finger "$login";cat
    /etc/passwd""</CODE> y las comillas ya no ser&aacute;n un problema. <BR>
    <BR>

    <P>Recuerda que si quieres proteger los par&aacute;metros de tu script con comillas,
	debes filtrarlos igual que la barra invertida o el punto y coma.
</P>

    <A NAME="203lfindex9">&nbsp;</A>
<H3>Programando en Perl</H3>


    <A NAME="203lfindex10">&nbsp;</A>
<H3>Opciones de Warning y tainting</H3>


    <P>Cuando programemos en Perl es aconsejable la opci&oacute;n <CODE>w</CODE> o
    "<CODE>use warnings;</CODE>" (Perl 5.6.0 y siguientes) ya que nos informar&aacute; sobre problemas
 potenciales como variables no inicializadas o expresiones/funciones obsoletas.
	</P>

    <P>La opci&oacute;n <CODE>T</CODE> (<EM>taint mode</EM>) proporciona mayor seguridad.
Este modo activa varios tests.
	El m&aacute;s importante concierne a una posible <EM>corrupci&oacute;n</EM> (tainting) de las variables.
	Las variables pueden estar limpias o posiblemente corruptas.
	Los datos que provienen del exterior del programa son considerados corruptos
	hasta que no hayan sido limpiadas.
	Las variables que pueden ser corruptas no se pueden asignar a objetos que ser&aacute;n usados
 en el exterior del programa (llamadas a otros comandos de la shell).
</P>

    <P>En taint mode, los argumentos de la l&iacute;nea de comandos, las variables de entorno,
	algunos resultados de llamadas de sistema (<CODE>readdir()</CODE>,
    <CODE>readlink()</CODE>, <CODE>readdir()</CODE>, ...) y los datos que provienen de archivos,
 	son considerados sospechosos y por lo tanto son vigilados.
	</P>

    <P>Para limpiar una variable debes pasarla a trav&eacute;s de una expresi&oacute;n regular.
	Evidentemente, utilizar <CODE>.*</CODE> es in&uacute;til. El objetivo
	es forzarte a tener en cuenta los argumentos proporcionados.
	Debemos intentar utilizar siempre una expresi&oacute;n regular lo m&aacute;s espec&iacute;fica posible.
</P>

    <P>No obstante, este modo no protege de todo: no se vigilan los argumentos pasados
	a <CODE>system()</CODE> o <CODE>exec()</CODE> como una lista de variables.
	Debemos ser muy cuidadosos cuando uno de nuestros scripts utilize estas funciones.
	Las instrucciones <CODE>exec&nbsp;"sh",&nbsp;'-c',&nbsp;$arg;</CODE> son consideradas como seguras,
	est&eacute; como est&eacute; <CODE>$arg</CODE> :(</P>

    <P>Tambi&eacute;n es recomendado "use strict;" al principio de tus programas.
	As&iacute; forzamos la obligaci&oacute;n de declarar todas las variables; algunas personas
	pueden encontrarlo molesto pero es obligatorio cuando utilizemos
	    <CODE>mod-perl</CODE>.</P>

    <P>De este modo, tus scripts en Perl deben empezar as&iacute; :</P>
<PRE>
#!/usr/bin/perl -wT
use strict;
use CGI;
</PRE>
    con Perl 5.6.0 :
<PRE>
#!/usr/bin/perl -T
use warnings;
use strict;
use CGI;
</PRE>
    <BR>
    <BR>


    <A NAME="203lfindex11">&nbsp;</A>
<H3>La llamada <CODE>open()</CODE></H3>


    <P>Muchos programadores abren un fichero simplemente utilizando
    <CODE>open(FILE,"$fichero") || ...</CODE>. Ya hemos visto los riesgos
de este c&oacute;digo. Para reducir este riesgo es suficiente con especificar el modo
para abrirlo:
</P>

    <UL>
      <LI><CODE>open(FILE,"&lt;$fichero") || ...</CODE> para solo lectura;</LI>

      <LI><CODE>open(FILE,"&gt;$fichero") || ...</CODE> para solo escritura
      </LI>
    </UL>
      En efecto, no abras tus ficheros de forma mal especificada. <BR>
    <BR>


    <P>Antes de acceder a un fichero es recomendable chequear si &eacute;ste existe.
	Esto no evita las condiciones de carrera presentadas en el art&iacute;culo anterior, pero
	es &uacute;til respecto a algunos trucos como comandos con sus argumentos.
</P>
<PRE>
if ( -e $fichero ) { ... }
</PRE>

    <P>Desde la versi&oacute;n de Perl 5.6, hay una nueva sintaxis para la llamada
    <CODE>open()</CODE> : <CODE>open(FILEHANDLE,MODO,LISTA)</CODE>. Con
    el modo '&lt;' , el fichero se abre para lectura; con '&gt;'
    , el fichero es truncado o creado si es necesario, y abierto para escritura.
    Hay un par de modos muy interesantes para la comunicaci&oacute;n con otros procesos.
 Si el modo es '|-' o '-|', el argumento LISTA es interpretado como un comando y es
respectivamente encontrado antes o despu&eacute;s de la tuber&iacute;a.
</P>

    <P>Antes de Perl 5.6 y <CODE>open()</CODE> con tres argumentos,
    algunas personas utilizaban el comando <CODE>sysopen()</CODE>.</P>

    <A NAME="203lfindex12">&nbsp;</A>
<H3>Filtrando la entrada</H3>


    <P>Existen dos m&eacute;todos : Podemos especificar los caracteres prohibidos, o definir expl&iacute;citamente
los carecteres permitidos utilizando expresiones regulares.
    Los programas de ejemplo te habr&aacute;n convencido que es muy f&aacute;cil olvidarse de filtrar
	caracteres que pueden ser potencialmente peligrosos, es por esta raz&oacute;n que el segundo m&eacute;todo es recomendado.
</P>

    <P>Pr&aacute;cticamente, lo que hacemos es lo siguiente : primero, chequeamos si la petici&oacute;n
	contiene s&oacute;lo caracteres permitidos. Luego, filtramos los caracteres considerados
	como peligrosos entre los permitidos.
</P>
<PRE>
#!/usr/bin/perl -wT

# filtro.pl

#  Las variables $seguro y $peligroso definen respectivamente
#  los caracteres sin riesgo y los arriesgados.
#  Es suficiente con a&ntilde;adir/quitar algunos para cambiar el filtro.
#  Solamente la entrada $input que contenga los caracteres inclu&iacute;dos en
#  las definiciones es v&aacute;lida.

use strict;

my $input = shift;

my $seguro = '\w\d';
my $peligroso = '&amp;`\'\\|"*?~&lt;&gt;^(){}\$\n\r\[\]';
#Note:
#  '/', espacio y tab no son parte de las definiciones


if ($input =~ m/^[$seguro$peligroso]+$/g) {
    $input =~ s/([$peligroso]+)/\\$1/g;
} else {
    die "Hay caracteres no permitidos en la entrada $input\n";
}
print "input = [$input]\n";
</PRE>
    <BR>
    <BR>

    <P>Este script define dos conjuntos de caracteres :</P>

    <UL>
      <LI><CODE>$seguro</CODE> contiene los caracteres no prohibidos
      (en este caso, s&oacute;lo n&uacute;meros y letras);</LI>

      <LI><CODE>$peligroso</CODE> contiene los caracteres permitidos, pero que
pueden ser potencialmente peligrosos; deber&aacute;n ser filtrados.
</LI>
    </UL>
	Cualquier petici&oacute;n que contenga un caracter que no est&eacute; presente en uno de los
	dos conjuntos deber&aacute; ser immediatamente descartado.
	<BR>
    <BR>


    <A NAME="203lfindex13">&nbsp;</A>
<H2>Scripts PHP</H2>


    <P>No querr&iacute;a ser pol&eacute;mico pero creo que es mejor escribir scripts
    en PHP que no en Perl. M&aacute;s exactamente, como administrador de sistemas,
    prefiero que mis usuarios escriban scripts con lenguaje PHP que no en Perl.
  	Cualquiera que programe mal - o de forma insegura - en PHP puede dejar un agujero
	de seguridad igual de peligroso que en Perl.
	Si es as&iacute;, porqu&eacute; prefiero PHP? Pu&eacute;s porqu&eacute; en este lenguaje puedes activar
	un Modo Seguro (Safe mode) cuando haya problemas de programaci&oacute;n
    (<CODE>safe_mode=on</CODE>) o desactivar funciones peligrosas
    (<CODE>disable_functions=...</CODE>). Este modo impide
    acceder a ficheros que no sean propiedad del usuario, o cambiar variables de entorno
	sin que est&eacute; expl&iacute;citamente permitido, ejecutar comandos, etc.
</P>

    <P>Por defecto el banner de Apache nos informa sobre la versi&oacute;n de PHP que
	estamos usando.
 </P>
<PRE>
$ telnet localhost 80
Trying 127.0.0.1...
Connected to localhost.localdomain.
Escape character is '^]'.
HEAD / HTTP/1.0

HTTP/1.1 200 OK
Date: Tue, 03 Apr 2001 11:22:41 GMT
Server: Apache/1.3.14 (Unix)  (Red-Hat/Linux) mod_ssl/2.7.1
        OpenSSL/0.9.5a PHP/4.0.4pl1 mod_perl/1.24
Connection: close
Content-Type: text/html

Connection closed by foreign host.
</PRE>
    Suficiente con escribir <CODE>expose_PHP = Off</CODE> en
    <CODE>/etc/php.ini</CODE> para esconder dicha informaci&oacute;n :
<PRE>
Server: Apache/1.3.14 (Unix)  (Red-Hat/Linux) mod_ssl/2.7.1
OpenSSL/0.9.5a mod_perl/1.24
</PRE>
    <BR>
    <BR>


    <P>El fichero <CODE>/etc/php.ini</CODE> (PHP4) o
    <CODE>/etc/httpd/php3.ini</CODE> tiene muchos par&aacute;metros que permiten
   	hacer el sistema m&aacute;s robusto.
   Por ejemplo,
    la opci&oacute;n "<CODE>magic_quotes_gpc</CODE>" a&ntilde;ade unas comillas en los argumentos
	recibidos por los m&eacute;todos <CODE>GET</CODE>, <CODE>POST</CODE> y v&iacute;a cookies;
 	esto soluciona algunos problemas de seguridad que nos hemos
encontrado con Perl.
</P>

    <A NAME="203lfindex14">&nbsp;</A>
<H2>Conclusi&oacute;n</H2>


    <P>Entre los art&iacute;culos de esta serie, &eacute;ste es probablemente el m&aacute;s f&aacute;cil de entender.
	Nos ense&ntilde;a vulnerabilidades que pueden ser explotadas cada d&iacute;a en la web.
	Hay muchas otras, frecuentemente relacionadas con mala programaci&oacute;n
	(por ejemplo, un script que env&iacute;a correo electr&oacute;nico, que coge como argumento
	el campo <CODE>From:</CODE>, proporciona un buen lugar para enviar spam
	(correo no deseado). Los ejemplos son muy numerosos. En seguida que hay un script
	en un sitio web, habr&aacute; como m&iacute;nimo una persona que intentar&aacute; usarlo de forma fraudulenta.
</P>

    <P>Este art&iacute;culo termina la serie sobre programaci&oacute;n segura. Esperamos
	haberte mostrado los principales agujeros de seguridad presentes en muchas
aplicaciones y que a partir de ahora tengas en cuenta el factor "seguridad" cuando
dise&ntilde;es y programes tus aplicaciones.
	Los problemas de seguridad son muchas veces olvidados debido al limitado
	prop&oacute;sito de la aplicaci&oacute;n (uso interno, uso en una red privada, modelo temporal,
etc.). Sin embargo, un m&oacute;dulo originariamente dise&ntilde;ado para un uso muy restringido puede
convertirse en la base de una aplicaci&oacute;n mucho mayor, y luego los cambios ser&aacute;n m&aacute;s caros.
</P>
    <HR>
<A NAME="203lfindex15">&nbsp;</A>
<H2>Algunos caracteres unicode</H2>

    <CENTER>
      <A name="tab_unicode"></A>

      <TABLE border width="45%" nosave="">
        <TR>
          <TD>Unicode</TD>

          <TD>Car&aacute;cter</TD>
        </TR>

        <TR>
          <TD>%00</TD>

          <TD>\0 (final de cadena)</TD>
        </TR>

        <TR>
          <TD>%0a</TD>

          <TD>\n (salto de carro)</TD>
        </TR>

        <TR>
          <TD>%20</TD>

          <TD><EM>espacio</EM></TD>
        </TR>

        <TR>
          <TD>%21</TD>

          <TD>!</TD>
        </TR>

        <TR>
          <TD>%22</TD>

          <TD>"</TD>
        </TR>

        <TR>
          <TD>%23</TD>

          <TD>#</TD>
        </TR>

        <TR>
          <TD>%26</TD>

          <TD>&amp; (ampersand)</TD>
        </TR>

        <TR>
          <TD>%2f</TD>

          <TD>/</TD>
        </TR>

        <TR>
          <TD>%3b</TD>

          <TD>;</TD>
        </TR>

        <TR>
          <TD>%3c</TD>

          <TD>&lt;</TD>
        </TR>

        <TR>
          <TD>%3e</TD>

          <TD>&gt;</TD>
        </TR>

        <TR>
          <TD>
          </TD>

          <TD>
          </TD>
        </TR>

        <CAPTION align="BOTTOM">
          Tab 1 : Correspondencia de caracteres en Unicode
        </CAPTION>
      </TABLE>
    </CENTER>
    <HR>

    <A NAME="203lfindex16">&nbsp;</A>
<H2>Enlaces</H2>


    <UL>
      <LI><CODE>man perlsec</CODE>&nbsp;: P&aacute;gina del manual de Perl sobre seguridad;</LI>

      <LI><A href=

"http://www.php.net/manual/fr/security.php">www.php.net/manual/fr/security.php
</A>&nbsp;:
      securidad en php;</LI>

      <LI><A href=
      "http://phrack.infonexus.com/">phrack.infonexus.com/</A>&nbsp;:
      otra referencia, &eacute;chale un vistazo al art&iacute;culo de Rain Forest
      Puppy (rfp) en Phrack 55.</LI>

      <LI><A href="http://www.unicode.org">www.unicode.org</A></LI>

      <LI>La p&aacute;gina de Christophe Blaess : <A href=

"http://perso.club-internet.fr/ccb/">perso.club-internet.fr/ccb/</A></LI>

      <LI>La p&aacute;gina de Christophe Grenier : <A href=

"http://www.esiea.fr/public_html/Christophe.GRENIER/">www.esiea.fr/public_html
/Christophe.GRENIER/</A></LI>

      <LI>La p&aacute;gina de Fr&eacute;d&eacute;ric Raynal : <A href=
      "http://www-rocq.inria.fr/~raynal/">www-rocq.inria.fr/~raynal/</A></LI>
    </UL>

    <P></P>
    <HR>
<a name="guestbook"> </a>
    <A NAME="203lfindex17">&nbsp;</A>
<H2>El programa LibroDeInvitados.cgi defectuoso</H2>

<PRE>
#!/usr/bin/perl -w

# LibroDeInvitados.cgi

BEGIN { $ENV{PATH} = '/usr/bin:/bin' }
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};   # Hacemos %ENV m&aacute;s seguro =:-)
print "Content-type: text/html\n\n";
print "&lt;HTML&gt;\n&lt;HEAD&gt;&lt;TITLE&gt;Libro De Visitas Peligroso
&lt;/TITLE&gt;&lt;/HEAD&gt;\n";
&amp;ReadParse(\%input);
my $email= $input{email};
my $texto= $input{texto};
$texto =~ s/\n/&lt;BR&gt;/g;

print "&lt;BODY&gt;&lt;A HREF=\"LibroDeInvitados.html\"&gt;
       GuestBook &lt;/A&gt;&lt;BR&gt;&lt;form
action=\"$ENV{'SCRIPT_NAME'}\"&gt;\n
      Email: &lt;input type=texto name=email&gt;&lt;BR&gt;\n
      Texte:&lt;BR&gt;\n&lt;textarea name=\"texto\" rows=15 cols=70&gt;
      &lt;/textarea&gt;&lt;BR&gt;&lt;input type=submit value=\"Adelante!\"&gt;
      &lt;/form&gt;\n";
print "&lt;/BODY&gt;\n";
print "&lt;/HTML&gt;";
open (FILE,"&gt;&gt;LibroDeInvitados.html") || die ("No es posible la escritura\n");
print FILE "Email: $email&lt;BR&gt;\n";
print FILE "Texto: $texto&lt;BR&gt;\n";
print FILE "&lt;HR&gt;\n";
close(FILE);
exit(0);

sub ReadParse {
  my $in =shift;
  my ($i, $key, $val);
  my $in_first;
  my @in_second;

  # Read in text
  if ($ENV{'REQUEST_METHOD'} eq "GET") {
    $in_first = $ENV{'QUERY_STRING'};
  } elsif ($ENV{'REQUEST_METHOD'} eq "POST") {
    read(STDIN,$in_first,$ENV{'CONTENT_LENGTH'});
  }else{
    die "ERROR: M&eacute;todo de petici&oacute;n desconocido\n";
  }

  @in_second = split(/&amp;/,$in_first);

  foreach $i (0 .. $#in_second) {
    # Convertir los + en espacios
    $in_second[$i] =~ s/\+/ /g;

    # Dividir entre la clave y el valor.
    ($key, $val) = split(/=/,$in_second[$i],2);

    # Convertir los n&uacute;meros hexadecimales %XX a alfanum&eacute;ricos
    $key =~ s/%(..)/pack("c",hex($1))/ge;
    $val =~ s/%(..)/pack("c",hex($1))/ge;

    # Asociar una clave con su valor.
    $$in{$key} .= "\0" if (defined($$in{$key}));
    $$in{$key} .= $val;

  }

  return length($#in_second);
}

</PRE>
    <HR>
  




<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Formulario de "talkback" para este art&iacute;culo</h2>
Cada art&iacute;culo tiene su propia p&aacute;gina de "talkback". A trav&eacute;s de esa p&aacute;gina puedes enviar un comentario o consultar los comentarios de otros lectores
<center>
<table border="0"  CELLSPACING="2" CELLPADDING="1">
 <tr BGCOLOR="#C2C2C2"><td align=center>
  <table border="3"  CELLSPACING="2" CELLPADDING="1">
   <tr BGCOLOR="#C2C2C2"><td align=center>
    <A href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=203&amp;lang=es"><b>&nbsp;Ir a la p&aacute;gina de "talkback"&nbsp;</b></a>
   </td></tr></table>
</td></tr></table>
</center>

<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%">
<TR><TD ALIGN=CENTER BGCOLOR="#9999AA" WIDTH="50%">
<A HREF="../../common/lfteam.html">Contactar con el equipo de LinuFocus</A>
<BR><FONT COLOR="#FFFFFF">&copy;  Fr&eacute;d&eacute;ric Raynal, Christophe Blaess, Christophe Grenier, <a href="../../common/copy.html">FDL</a> <BR><a href="http://www.linuxfocus.org">LinuxFocus.org</a></FONT>
<BR><a href="http://cgi.linuxfocus.org/cgi-bin/lfcomment?lang=es&amp;article=article203.html" target="_TOP">Pinchar aqu&iacute; para informar de alg&uacute;n problema o enviar comentarios a LinuxFocus</A><BR></TD>
<TD BGCOLOR="#9999AA">
<!-- TRANSLATION INFO -->
<font size=2>Informaci&oacute;n sobre la traducci&oacute;n:</font>
<TABLE>
  <tr><td><font size="2">fr --&gt; -- :  Fr&eacute;d&eacute;ric Raynal, Christophe Blaess, Christophe Grenier <small>&lt;pappy(at)users.sourceforge.net, ccb(at)club-internet.fr, grenier(at)nef.esiea.fr&gt;</small></font></td></tr>
  <tr><td><font size="2">fr --&gt; en: Georges Tarbouriech &lt;georges.t(at)linuxfocus.org&gt;</font></td></tr>
  <tr><td><font size="2">en --&gt; es: Gerard Farr&agrave;s Ballabriga &lt;gerard.farras(at)campus.uab.es&gt;</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2001-11-23, generated by lfparser version 2.21</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
