<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML lang="es">

<HEAD>

    <STYLE>
      P { text-indent: 1em } 
    </Style>
    <META http-equiv="Content-Type" content="text/html; charset=uso-8859-1">
    <TITLE>LinuxFocus Septiembre 1998: Programación con Java II</TITLE>
    

</HEAD>
  


  <BODY bgcolor="#ffffff"  text="#000000" alink="#336633" link="#336633" vlink="#336633">
    
    
    
    <!-- MAP for top navegation bar -->
    <MAP name="top">
      <AREA shape="rect" coords="367, 9, 418, 30" alt="Home" href="../">
      <AREA shape="rect" coords="423, 9, 457, 30" alt="Map" href="../map.html">
      <AREA shape="rect" coords="463, 9, 508, 30" alt="Index" href="../indice.html">
      <AREA shape="rect" coords="514, 9, 558, 30" alt="Search" href="../search.html">
    </MAP>
    
    

    <!-- MAP for bottom navegation bar -->
    <MAP name="bottom">
      <AREA shape="rect" coords="78, 0, 163, 15"   alt="News" href="../News/">
      <AREA shape="rect" coords="189, 0, 284, 15"  alt="Archives" href="../Archives/">
      <AREA shape="rect" coords="319, 0,  395, 15" alt="Links" href="../Links">
      <AREA shape="rect" coords="436, 0,  523, 15" alt="About LF" href="../aboutus.html">
    </MAP>
    
    
    
    <center>
      <IMG src="../../common/images/Topbar-es.gif" width="600" height="40" border="0" alt="[Top Bar]" ismap usemap="#top" ><BR>
	  <IMG src="../../common/images/Bottombar-es.gif" width="600" height="21" border="0" alt="[Bottom Bar]" ismap usemap="#bottom">
    </CENTER>
    
    
    <!-- SHORT BIO ABOUT THE AUTHOR -->
    <TABLE  align="left" width="30%" border="0" cellspacing="0" cellpadding="5">

      <TR>
	<TD>
	  <IMG src="../../common/images/Who.gif" width="173" height="164" alt="[Photo of the Author]"><BR>
	      <FONT color="#336633" size="+2">Jose M. Fernández </FONT><BR>
	      <FONT color="#336633">Acerca del Author</FONT>: 
	  Diplomado en informática, en la especialidad de
		  planificación y control de sistemas informáticos por
		  la universidad de Málaga a finales de los años
		  80. Desde entonces trabajó primero como programador
		  y después como analista de aplicaciones en empresas
		  siempre relacionadas con la Administración. Siempre
		  he trabajado con grandes sistemas (y
		  profesionalmente sigo haciéndolo) pero hace año y
		  medio por casualidad tropecé con Linux y descubrí
		  que en este mundo la libertad se escribe con letras
		  MAYÚSCULAS.
	      <BR>
		
		<P><A href="mailto:fgcia@correoweb.com">Escribe al autor</A></P>
		
	  
	  <!--   INDEX      -->
	  
	  <font color="#336633">Contenidos</FONT>: <BR>
	  
	  <A href="#cuestiones">Cuestiones Lexicas</A><BR>
	  <A href="#tipos">Tipos de datos, variables, operadores</A><BR>
	  <A href="#sentencias">Sentencias de control</A><BR>
	  <A href="#clases">Clases, Métodos, Herencia </A><BR>
	  
	  
	  
	  
	  <SPACER TYPE=VERTICAL SIZE=100>
	    
	</TD>
      </TR>
      
    </TABLE>
    
    
    
    
    <!--   BODY OF THE ARTICLE    -->
    <H2> Java. Parte II </H2>
    <IMG src="../../common/images/illustration8.gif" alt="[Ilustration]" width="100" height="100" hspace="10" >
  </img>
    
    <p align="top">
      <FONT color="#336633" size="2">Resumen</FONT>: 
      <FONT size="2" face="Helvetica,Arial,Roman">


    <p>Esta serie de artículos  tiene como modelo los libros  clásicos
    de programación por lo que intentaremos seguir su estructura en la
    forma   de presentar   los  contenidos.  Una   vez   realizada una
    introducción  y definidas las  características  del lenguaje en el
    primer artículo, continuaremos en   este segundo con los  tipos de
    datos,  variables, sentencias de  control etc., hasta llegar a las
    clases, el  tema central y   más importante de  toda  la serie  de
    artículos.    Las  clases   son la   base  de   este   lenguaje de
    programación.  Para poder  centrarnos en el tema  de las clases la
    primera parte la haremos lo más esquemática posible  ya que al fin
    y   al  cabo no varía  mucho   respecto al resto   de lenguajes de
    programación.</p>
      </FONT>
      
    </P>
    
    

    <HR size="0" noshadow></hr>
	    
    

    <A name="cuestiones"></A>
    <H3>Cuestiones Léxicas</H3> 
    
    <P>Formalmente un programa en  Java está compuesto por un conjunto
    de  comentarios, identificadores, literales, separadores, espacios
    en blanco y palabras clave. </p>


    <p>El compilador recoge código  escrito en formato  <I>Unicode</I>
    expandiendo el  número de  bytes  de los 8   del ASCII a 16 y  por
    consiguiente  amplia el juego de caracteres  para  adaptarse a los
    caracteres de los  idiomas no  latinos.   Los espacios en  blanco,
    tabuladores  y los    saltos  de  líneas  son   eliminados  por el
    compilador ya que no son parte del conjunto de símbolos, esto hace
    que los programas en Java se puedan formatear de  la forma que más
    nos guste.  </P>

    <P>Hay tres estilos de comentarios en Java:</P>

    <dl>
      <dt><b>// comentario</b>  </dt><dd> Se ignoran  los caracteres desde //
      hasta el final de la línea.</dd>
      
      <dt><b>/*  comentario */</b></dt><dd> Se  ignoran  todos los caracteres
      entres /* y */. Estos comentarios  pueden tener una extensión de
      varias líneas.</dd>
      
      <dt><b>/** comentario **/</b></dt><dd> Igual que los comentarios
      /* */, pero sólo deberían utilizarse  estos comentarios antes de
      las declaraciones ya que la herramienta javadoc los utiliza para
	generar documentación automática.</dd>
    </dl>
      
    <P>Los identificadores son los nombres que se dan a las variables,
    clases y  métodos.  Pueden  ser cualquier  secuencia de letras  en
    mayúsculas  y minúsculas, números   y los  caracteres  subrayado y
    signo dólar(<tt>$</tt>). No pueden comenzar por un número.</P>

    <P>En  Java hay  algunos   caracteres    que  se utilizan     como
    separadores.  El  separador  utilizado con  más  frecuencia  es el
    (<tt>;</tt>) pero además encontraremos:</P>


    
    <center>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH="90%">
	<TR><TD  >
	    <CENTER>Símbolo</TD>
	  <TD  >
	    <CENTER>Descripción</TD>
	</TR>
	<TR><TD  >
	    <CENTER>()</TD>
	  <TD  >
	    
	      <P>Contiene   listas de parámetros   en la  definición y
	      llamada   a   los  métodos. Se   utiliza   asimismo para
	      precedencia en    expresiones, contener  expresiones  en
	      sentencias de control y en conversiones de tipos.</TD>
	</TR>
	<TR><TD  >
	    <CENTER>{}</TD>
	  <TD >
	    <P>Para  contener los valores de las matrices
	      inicializadas automáticamente.    Para  definir  un
	      bloque  de código,  para  clases, métodos, y
	      ámbitos locales.</TD>
	</TR>
	<TR><TD  >
	    <CENTER>[]</TD>
	  <TD >
	    <P>Para definir tipos matriz. Para referencia
		valores de una matriz.</TD>
	</TR>
	<TR><TD  >
	    <CENTER>;</TD>
	  <TD  >
	    <P>Separador de sentencias.</TD>
	</TR>
	<TR><TD  >
	    <CENTER>,</TD>
	  <TD  >
	    <P>Separa  identificadores consecutivos  en la declaración
	    de variables.  Encadena sentencias dentro de una sentencia
	    <tt>for</tt>.</TD>
	</TR>
	<TR><TD  >
	   <CENTER>.</TD>
	  <TD  >
	    <P>Para separar nombres de paquetes, subpaquetes y clases.
	    Para separar una   variable o método  de una  variable  de
	    referencia.</TD>
	</TR>
      </TABLE>
    </center>
    
    <P>Las  palabras claves  son  identificadores   utilizados por  el
    lenguaje Java y no pueden utilizarse de ninguna  otra forma que la
    que está definida por el  mismo.  En el cuadro siguiente mostramos
    todas las palabras claves de Java:</P>



    <center>
      <table width="90%" cellspacing="1" cellpadding="5" border="1">
	<tr align="center"><td>
	    <tt>abstract</tt></td>
	  <td>
	    <tt>double</tt></td>
	  <td>
	    <tt>int</tt></td>
	  <td>
	    <tt>super</tt></td>
	</tr>
	<tr align="center"><td>
	    <tt>boolean</tt></td>
	  <td>
	    <tt>else</tt></td>
	  <td>
	    <tt>interface</tt></td>
	  <td>
	    <tt>switch</tt></td>
	</tr>
	<tr align="center"><td>
	    <tt>break</tt></td>
	<td>
	  <tt>extends</tt></td>
	<td>
	  <tt>long</tt></td>
	<td>
	  <tt>synchronized</tt></td>
      </tr>
      <tr align="center"><td>
	  <tt>byte</tt></td>
	<td>
	  <tt>false</tt></td>
	<td>
	  <tt>native</tt></td>
	<td>
	  <tt>this</tt></td>
      </tr>
      <tr align="center"><td>
	  <tt>byvalue</tt></td>
	<td>
	  <tt>final</tt></td>
	<td>
	  <tt>new</tt></td>
	<td>
	  <tt>threadsafe</tt></td>
      </tr>
      <tr align="center"><td>
	  <tt>case</tt></td>
	<td>
	  <tt>finally</tt></td>
	<td>
	  <tt>null</tt></td>
	<td>
	  <tt>throw</tt></td>
      </tr>
      <tr align="center"><td>
	  <tt>catch</tt></td>
	<td>
	  <tt>float</tt></td>
	<td>
	  <tt>package</tt></td>
	<td>
	  <tt>transient</tt></td>
      </tr>
      <tr align="center"><td>
	  <tt>char</tt></td>
	<td>
	  <tt>for</tt></td>
	<td>
	  <tt>private</tt></td>
	<td>
	  <tt>true</tt></td>
      </tr>
      <tr align="center"><td>
	  <tt>class</tt></td>
	<td>
	  <tt>goto</tt></td>
	<td>
	  <tt>protected</tt></td>
	<td>
	  <tt>try</tt></td>
      </tr>
      <tr align="center"><td>
	  <tt>const</tt></td>
	<td>
	  <tt>if</tt></td>
	<td>
	  <tt>public</tt></td>
	<td>
	  <tt>void</tt></td>
      </tr>
      <tr align="center"><td>
	  <tt>continue</tt></td>
	<td>
	  <tt>implements</tt></td>
	<td>
	  <tt>return</tt></td>
	<td>
	  <tt>while</tt></td>
      </tr>
      <tr align="center"><td>
	  <tt>default</tt></td>
	<td>
	  <tt>import</tt></td>
	<td>
	  <tt>short</tt></td>
	<td>&nbsp;</td>
      </tr>
      <tr align="center"><td>
	  <tt>do</tt></td>
	<td>
	  <tt>instanceof</tt></td>
	<td>
	  <tt>static</tt></td>
	<td>&nbsp;</td>
      </tr>
    </table></center>
 
    <A name="tipos"></A>
    <H3>Tipos de datos, Variables, Operadores.</H3>

    <P>En este  punto hay  que  volver a insistir  en  que Java  es un
      lenguaje fuertemente  tipado, cada variable  tiene un  tipo y cada
      tipo está definido estrictamente.  En todas las asignaciones, bien
      sean  explícitas o a  través de paso  de  parámetros en llamadas a
      métodos,  se  comprueba la  compatibilidad de  los tipos.   No hay
      conversión automática entre tipos.   El compilador comprueba todas
      las expresiones  y  parámetros para  asegurar  que los  tipos  son
      compatibles.</P>

    <P>En él artículo  anterior  comentamos que  Java  era un lenguaje
      totalmente  orientado    a  objetos, pues    bien,  por razones de
      eficiencia  Java define ocho  tipos de datos  "simples" que no son
      objetos.   Además por razones de portabilidad   todos los tipos de
      datos tienen un rango definido estrictamente.</P>
    
    <P>Los tipos   de datos simples los  podemos  distribuir en cuatro
      grupos:</P>


    <P ALIGN="center">

    <TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH="90%" cols="4" align="center">
      <colgroup align="center"></colgroup>
      <THEAD>
	<TR align=center><TD  ><Tbody>
	  <center>TIPO</TD>
	  <TD  >
	    <center>NOMBRE</TD>
	  <TD  >
	    <center>TAMAÑO</TD>
	  <TD  >
	    <center>RANGO</TD>

	  <Tbody>
	    <TR align=center><TD  >
		Entero</TD>
	      <TD  >
		<tt>long</TD>
	      <TD  >
		64</TD>
	      <TD  >
		-9.223.372.036.854.775.808  <br>a<br>
		9.223.372.036.854.775.807</TD>
	    </TR>
	    <TR align=center><TD  >&nbsp;</TD>
	      <TD  >
		int</TD>
	      <TD  >
		32</TD>
	      <TD  >
		-2.147.483.648 <br>a</br> 2.147.483.647</TD>
	    </TR>
	    <TR  align=center><TD  >&nbsp;</TD>
	      <TD  >
		short</TD>
	      <TD  >
		16</TD>
	      <TD  >
		-32.768 a 37.767</TD>
	    </TR>
	    <TR  align=center><TD  >&nbsp;</TD>
	      <TD  >
		byte</TD>
	      <TD  >
		8</TD>
	      <TD  >
		-128 a 127</TD>
	    </TR>
	    <TR  align=center><TD  >
		Coma flotante</TD>
	      <TD  >
		float</TD>
	      <TD  >
		32</TD>
	      <TD  >
		3.4 e-038 a 3.4 e+038</TD>
	    </TR>
	    <TR  align=center><TD  >&nbsp;</TD>
	      <TD  >
		double</TD>
	      <TD  >
		64</TD>
	      <TD  >
		1.7 e-308 a 1.7 e+308</TD>
	    </TR>
	    <TR  align=center><TD  >
		Caracter</TD>
	      <TD  >
		char</TD>
	      <TD  >
		16</TD>
	      <TD  >
		Unicode</TD>
	    </TR>
	    <TR  align=center><TD  >
		Boleano</TD>
	      <TD  >
		boolean</TD>
	      <TD  >&nbsp;</TD>
	      <TD  >
		true o false</TD>
	    </TR>
    </TABLE></p>

    <h4>Variables:</h4>

    <P>Una variable se define por la combinación de un identificador y
    un tipo.  Opcionalmente  podemos inicializar la  variable al mismo
    tiempo que  la  declaramos.  Toda variable   tiene un ámbito  y un
    tiempo de vida.   Todas las  variables  tienen que ser  declaradas
    antes de  ser usadas.  Se pueden  declarar  en cualquier parte del
    programa, incluso en el mismo momento de ser utilizada por primera
    vez.</P>

    <P>La  forma general de  la   declaración de una   variable
      es:</P>

    <CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=484>
	<TR><TD >
	    <tt>
	    <P>tipo     identificador      [=valor]    [,identificador
	    [=valor]......];</P>
	  </tt>
	  </TD>
	</TR>
      </TABLE>
    </CENTER>


    <P>donde  <tt>tipo</tt>  puede ser un  tipo  básico de Java, una
    clase o interfaces.  Si inicializamos la variable, la expresión de
    inicialización debe  se del  mismo   tipo  o compatible   con   el
    especificado en la variable.</P>

    <P>Ejemplos :</P>

    <CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=484>
	<TR><TD >
	    <pre>

         int  a = 4, b, c=7;
	 char c;
	 miclase clase;</pre></TD></TR>
      </TABLE>
    </CENTER>

    
    <P>Como regla general, la variable definida dentro de un ámbito no
    podrá ser  accedida desde fuera  de éste (se define  como "ámbito"
    como la porción  de código  delimitado entre llaves  <tt>{}</tt>).
    Una variable no mantendrá su valor una vez que  se ha salido de su
    ámbito.</P>

    <P>La mayoría de    los  lenguajes de programación    definen  dos
    categorías de ámbitos: global y local. Estos ámbitos tradicionales
    no encajan con el modelo orientado a objetos de Java.  En éste los
    dos principales ámbitos  son los definidos  por una clase y por un
    método. </P>

    <h4>Conversión de tipos:</h4>

    <P>Java permite,  aunque en la teoría  se niegue, asignar un valor
    de un tipo  a  una variable  de otro  tipo, si  los dos tipos  son
    compatibles se realiza una conversión automática y si no lo son se
    puede realizar una conversión explícita entre tipos incompatibles.
    Para realizar una conversión  automática de tipos se debe  cumplir
    las siguientes condiciones:</P>

    <ul>
      <li> Los dos tipos son compatibles.</li>

      <li> El tipo destino es más grande que el tipo origen.</li>
    </ul>

    <P>Por ejemplo, un tipo <tt>int</tt>  es lo suficientemente grande
    como  para almacenar un tipo  <tt>byte</tt> por lo que no necesita
    una conversión explícita.   Los tipos numéricos no son compatibles
    con  <tt>char</tt> o <tt>boolean</tt> y  estos  no son compatibles
    con el resto.   Si quisiéramos asignar  un valor <tt>int</tt> a un
    <tt>byte</tt> tendríamos que utilizar una conversión explícita que
    tiene el siguiente formato:</P>

    <CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=484>
	<TR><TD >
	    <pre>

(tipo) valor
	    </pre>
	  </TD>
	</TR>
      </TABLE>
    </CENTER>


    <P>  donde   <tt>tipo</tt>   indica  el tipo  al  que   se   va  a
      convertir. Ejemplo :</P>

    <CENTER>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=484>
	<TR><TD >
	    <pre>

         int a;
         char b;
         a=(int) b;
	    </pre>
	  </TD>
	</TR>
      </TABLE>
    </CENTER>
    

    <P>Con la conversión automática de tipos hay que  tener un poco de
      cuidado  ya que  al    realizar  la conversión  de  puede   perder
      información. Por ejemplo:</P>

    <P>La conversión de tipos en coma flotante a enteros pierde
      la parte decimal:</P>

    
    <CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH="90%">
	<TR><TD >
	    <pre>

         int a;
         double d= 125.43;
         a=(int) d;
	    </pre>
	    <P>la variable a tiene el valor 125.</P>
	    <pre>
         byte   b;
         int i=257;
         b=(byte) i;
	    </pre>
	    <P>la variable b tiene el valor 1, que  es el resultado de
	      dividir 257 entre  256 donde  256 es   el rango del   tipo
	      byte.</P>
	    <pre>
         byte b;
         double d= 340.123;
         b=(byte) d;
	    </pre>
	    <P>donde b tendrá el valor de 84;</P>
	    
	  </TD>
	</TR>
      </TABLE>
    </CENTER>
    

    <P>Todas  estas conversiones se  realizan con el beneplácito
      del compilador y del interprete que no ponen ningún tipo de
      reparo a ello.</P>


    <h4> Operadores:</h4>

    <P>Existe   un amplio conjunto  de  operadores, los cuales podemos
      agrupar  en cuatro  categorías:    aritméticos, a nivel  de   bit,
      relacionales   y  lógicos.      Como  norma  general   funcionarán
      exactamente igual que en otros lenguajes pero hay algunas pequeñas
      diferencias que iremos matizando sobre la marcha.</P>

    <h5>Operadores Aritméticos:</h5>

    <center>
      <table cellspacing="1" cellpadding="5">
	<tr><td> <center>Operador</center></td>
	  <td>
	    <center>Descripción</center></td>
	</tr>
	<tr><td> <center>+</center></td>
	  <td>
	    <p>Suma</p></td>
	</tr>
	<tr><td> <center>-</center></td>
	  <td>
	    <p>Resta</p></td>
	</tr>
	<tr><td> <center>*</center></td>
	  <td>
	    <p>Multiplicación</p></td>
	</tr>
	<tr><td> <center>/</center></td>
	  <td>
	    <p>División</p></td>
	</tr>
	<tr><td> <center>%</center></td>
	  <td>
	    <p>Modulo(resto de la división)</p></td>
	</tr>
	<tr><td> <center>++</center></td>
	  <td>
	    <p>Incremento</p></td>
	</tr>
	<tr><td> <center>+=</center></td>
	  <td>
	    <p>Suma y asignación</p></td>
	</tr>
	<tr><td> <center>-=</center></td>
	  <td>
	    <p>Resta y asignación</p></td>
	</tr>
	<tr><td> <center>*=</center></td>
	  <td>
	    <p>Multiplicación y asignación</p></td>
	</tr>
	<tr><td> <center>/=</center></td>
	  <td>
	    <p>División y asignación</p></td>
	</tr>
	<tr><td> <center>%=</center></td>
	  <td>
	    <p>Módulo y asignación</p></td>
	</tr>
	<tr><td> <center>--</center></td>
	  <td>
	    <p>Decremento</p></td>
	</tr>
      </table></center>


    <P>El operador  módulo se  puede  aplicar tanto  a  valores
      enteros como en coma flotante. Por ejemplo:</P>

    <CENTER>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=472>
	<TR><TD >
	    <pre>

	 int     a= 38;
	 double  d= 41.95;
	 int     c= a % 10;
	 double  e= d % 10;</pre>
	  </TD>
	</TR>
      </TABLE>
    </CENTER>
    

    <P>La  variable c contiene el valor  8.  La variable e contiene el
      valor 1.95;</P>

    <P>Los operadores con asignación son útiles en construcciones del tipo:</P>
    <div>
      <P> <tt>a = a + 4;</tt>    es equivalente a     <tt> a += 4;</tt>   </P>
      <P> <tt>a = a % 2;</tt>    es equivalente a      <tt>a %= 2;</tt></P>
    </div>
    <P>En general podemos indicar que las sentencias de la forma: </P>

    <P><tt>  var=var op  expresión; </tt></p>

    <p>se pueden sustituir por:</p>
    <p><tt> var op= expresión; </tt></P>


    <h5>Operadores a nivel de Bit:</h5>


    <P>Se  definen  algunos operadores  a nivel de   bit que se pueden
      aplicar a tipos  entero:  <tt>long, int, short,  char</tt>  y <tt>
	byte</tt> que pueden modificar los bits de sus operandos.</P>

    <center>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5>
	<TR><TD  >
	    <center>Operador</TD>
	  <TD  >
	    <center>Descripción</TD>
	</TR>
	<TR><TD  >
	    <center>~</TD>
	  <TD  >
	    <P>NOT unário a nivel de bit</TD>
	</TR>
	<TR><TD  >
	    <center>&amp;</TD>
	  <TD  >
	    <P>AND a nivel de bit</TD>
	</TR>
	<TR><TD  >
	    <center>|</TD>
	  <TD  >
	    <P>OR a nivel de bit</TD>
	</TR>
	<TR><TD  >
	    <FONT SIZE=1><center>/\</TD>
	  <TD  >
	    <P>OR exclusivo a nivel de bit</TD>
	</TR>
	<TR><TD  >
	    <center>&gt;&gt;</TD>
	  <TD  >
	    <P>Desplazamiento a la derecha</TD>
	</TR>
	<TR><TD  >
	    <center>&gt;&gt;&gt;&gt;</TD>
	  <TD  >
	    <P>Desplazamiento a la derecha rellenando con ceros</TD>
	</TR>
	<TR><TD  >
	    <center>&lt;&lt;</TD>
	  <TD  >
	    <P>Desplazamiento a la izquierda</TD>
	</TR>
	<TR><TD  >
	    <center>&amp;=</TD>
	  <TD  >
	    <P>AND a nivel de bit y asignación</TD>
	</TR>
	<TR><TD  >
	    <center>|=</TD>
	  <TD  >
	    <P>OR a nivel de bit y asignación</TD>
	</TR>
	<TR><TD  >
	    <center>/\=</TD>
	  <TD  >
	    <P>OR exclusivo a nivel de bit y asignación</TD>
	</TR>
	<TR><TD  >
	    <center>&gt;&gt;=</TD>
	  <TD  >
	    <P>Desplazamiento a la derecha y asignación</TD>
	</TR>
	<TR><TD  >
	    <center>&gt;&gt;&gt;&gt;=</TD>
	  <TD  >
	    <P>Desplazamiento a la   derecha  rellenado con ceros    y
	      asignación</TD>
	</TR>
	<TR><TD  >
	    <center>&lt;&lt;=</TD>
	  <TD  >
	    <P>Desplazamiento a la izquierda y asignación</TD>
	</TR>
      </TABLE>
    </center>
    
    
    <h5>Operadores relacionales:</h5>

    <P>Determinan   la  relación  que   un  operando  tiene  con otro,
      específicamente  igualando  y   ordenando.  El   resultado  de  la
      operación es un valor booleano.</P>


    <center>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5>
	<TR><TD  >
	    <CENTER>Operador</TD>
	  <TD  >
	    <CENTER>Descripción</TD>
	</TR>
	<TR><TD  >
	    <center> = =</TD>
	  <TD  >
	    <P>Igual a</TD>
	</TR>
	<TR><TD  >
	    <center>!=</TD>
	  <TD  >
	    <P>Distinto de </TD>
	</TR>
	<TR><TD  >
	    <center>&gt;</TD>
	  <TD  >
	    <P>Mayor que</TD>
	</TR>
	<TR><TD  >
	    <center>&lt;</TD>
	  <TD  >
	    <P>Menor que</TD>
	</TR>
	<TR><TD  >
	    <center>&gt;=</TD>
	  <TD  >
	    <P>Mayor o igual que</TD>
	</TR>
	<TR><TD  >
	    <center>&lt;=</TD>
	  <TD  >
	    <P>Menor o igual que</TD>
	</TR>
      </TABLE>
    </center>

    <P>A diferencia  de algunos lenguajes(C/C++) los valores booleanos
      son <tt>True</tt> y <tt>False</tt>, valores no numéricos.</P>

    <h5>Operadores lógicos booleanos:</h5>

    <P>Operan únicamente  con operandos  booleanos y   dan como
      resultado otro operador booleano.</P>
    
    <center>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5>
	<TR><TD  >
	    <CENTER>Operador</center></TD>
	  <TD   align="center">
	    Descripción</TD>
	</TR>
	<TR><TD  >
	    <center>&amp;</TD>
	  <TD  >
	    <P>AND lógico</TD>
	</TR>
	<TR><TD  >
	    <center>|</TD>
	  <TD  >
	    <P>OR lógico</TD>
	</TR>
	<TR><TD  >
	    <center>/\</TD>
	  <TD  >
	    <P>XOR lógico(OR exclusivo)</TD>
	</TR>
	<TR><TD  >
	    <center>||</TD>
	  <TD  >
	    <P>OR en cortocircuito</TD>
	</TR>
	<TR><TD  >
	    <center>&amp;&amp;</TD>
	  <TD  >
	    <P>AND en cortocircuito</TD>
	</TR>
	<TR><TD  >
	    <center>!</TD>
	  <TD  >
	    <P>NOT unario lógico</TD>
	</TR>
	<TR><TD  >
	    <center>&amp;=</TD>
	  <TD  >
	    <P>Asignación AND</TD>
	</TR>
	<TR><TD  >
	    <center>|=</TD>
	  <TD  >
	    <P>Asignación OR</TD>
	</TR>
	<TR><TD  >
	    <center>/\=</TD>
	  <TD  >
	    <P>Asignación XOR</TD>
	</TR>
	<TR><TD  >
	    <center>= =</TD>
	  <TD  >
	    <P>Igual a</TD>
	</TR>
	<TR><TD  >
	    <center>!=</TD>
	  <TD  >
	    <P>Distinto de</TD>
	</TR>
	<TR><TD  >
	    <center>?:</TD>
	  <TD  >
	    <P>If-then-else ternario</TD>
	</TR>
      </TABLE></center>
    

    <P>El operador OR  en cortocircuito tiene como resultado verdadero
      cuando  el  primer  operador es  verdadero  independientemente del
      segundo  operador.   De     forma similar el     operador   AND en
      cortocircuito es   falso  cuando  el  primer operador    es  falso
      independientemente del valor del segundo operador.</P>
    
    <P>El formato general del operador ternario es:</P>
    
    <P><tt>Expesion1 ? expesion2 : expresion3</tt></P>
    
    <P>Si    <tt>Expresion1</tt>    es  true     se    ejecutará    la
      <tt>expresion2</tt>,   si     es   false     se     ejecutará   la
      <tt>expresion3</tt>.</P>


    <h4>Precedencia de operadores:</h4>

    <center>
      Alta
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5>
	<TR><TD >
	    <center>( )</TD>
	  <TD >
	    <center>[ ]</TD>
	  <TD >
	    <center>.</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>++</TD>
	  <TD >
	    <center>--</TD>
	  <TD >
	    <center>~</TD>
	  <TD >
	    <center>!</TD>
	</TR>
	<TR><TD >
	    <center>*</TD>
	  <TD >
	    <center>/</TD>
	  <TD >
	    <center>%</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>+</TD>
	  <TD >
	    <center>-</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>&gt;&gt;</TD>
	  <TD >
	    <center>&gt;&gt;&gt;&gt;</TD>
	  <TD >
	    <center>&lt;&lt;</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>&gt;</TD>
	  <TD >
	    <center>&gt;=</TD>
	  <TD >
	    <center>&lt;</TD>
	  <TD >
	    <center>&lt;=</TD>
	</TR>
	<TR><TD >
	    <center>= =</TD>
	  <TD >
	    <center>!=</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>&amp;</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>'</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>|</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>&amp;&amp;</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>||</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>?:</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	</TR>
	<TR><TD >
	    <center>=</TD>
	  <TD >
	    <center>Op=</TD>
	  <TD >&nbsp;</TD>
	  <TD >&nbsp;</TD>
	</TR>
      </TABLE>
      Baja
    </center>
    

    <A name="sentencias"></A>
    <H3>Sentencias de control</H3>

    <P>Las sentencias de  control  el Java  se pueden dividir  en tres
      categorías: Selección, Iteración y Salto.</P>

    <center>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5>
	<TR><TD  VALIGN="TOP">
	    <center>Grupo</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>Sentencia</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    <center>Descripción</TD>
	</TR>
	<TR><TD  VALIGN="TOP">
	    <center></P>
	      <center>Selección</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>if</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    <pre>
if ( condición ) 
  sentencia1;
else  sentencia2; 
	    </pre>    </TD>
	</TR>
	<TR><TD  VALIGN="TOP">&nbsp;</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>if múltiple</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    <pre>
if ( condición ) 
  sentencia;
else if ( condición) 
  sentencia;
else if ( condición) 
sentencia;
.
.
else 
  sentencia;</pre></TD>
	</TR>
	<TR><TD  VALIGN="TOP">&nbsp;</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>switch</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    <pre>
switch ( expresión){
  case valor1:
     sentencia;
     break;
  case valor2:
     sentencia;
     break;
.
.
.
.
  default:
     sentencia;
}</pre></TD>
	</TR>
	<TR><TD  VALIGN="TOP">
	    <center>Iteración</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>while</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    <pre>
while ( condición) {
  sentencias;
}</pre>
	  </TD>
	</TR>
	<TR><TD  VALIGN="TOP">&nbsp;</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>do while</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    <pre>
do {
   sentencias;
} while (condición)</pre></TD>
	</TR>
	<TR><TD  VALIGN="TOP">&nbsp;</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>for</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    <pre>
for (iniciación, condición, iteración) {
    sentencias;
}
	    </pre>
	  </TD>
	</TR>
	<TR><TD  VALIGN="TOP">
	    <center>Salto</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>break</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    Para escapar de un  switch.<br>
	    Para escapar de un bucle</TD>
	</TR>
	<TR><TD  VALIGN="TOP">&nbsp;</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>continue</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    Escapa de la iteración del bucle pero continua en el mismo
	    bucle</TD>
	</TR>
	<TR><TD  VALIGN="TOP">&nbsp;</TD>
	  <TD WIDTH="23%" VALIGN="TOP">
	    <center>return</TD>
	  <TD WIDTH="57%" VALIGN="TOP">
	    Volver explícitamente desde un método</TD>
	</TR>
      </TABLE>
    </center>
    
    
    <A name="clases"></A>
    <H3>Clases, Métodos, Herencia</H3>
    
    <P>Como indicamos en el primer artículo Java es un lenguaje que se
      diseñó partiendo   de  cero y   como resultado  de  esto  fue  una
      aproximación limpia y útil a  la programación orientada a objetos.
      De hecho todos los programas Java  son orientados a objetos.  Como
      puede   comprender  no  intente buscar en   este   artículo y  los
      siguientes  algo para    ampliar   sus conocimientos    sobre   la
      programación   orientada  a  objetos,   para  ello hay  literatura
      abundante y amplia para profundizar en  su conocimiento tanto como
      se quiera. Pero   es tan importante   la programación orientada  a
      objetos para Java que es necesario entender sus principios básicos
      antes de  empezar a programar en  este lenguaje.  No nos queda más
      remedio   que  manejar    y  utilizar  elementos    principios   y
      características  de  este  paradigma  aunque siempre seguiremos la
      nomenclatura de Java e intentaremos de la forma  más breve y clara
      posible definir  los  elementos que  hacen   de Java  un  lenguaje
      totalmente orientado a objetos.</P>

    <h4>CLASES :</h4>

    <P>Es el núcleo de Java. Define la forma y naturaleza de un
      objeto, constituye la base  de la programación orientada  a
      objetos. Una  clase define un nuevo  tipo de dato, este nuevo tipo
      se puede utilizar para crear objetos de este tipo.</P>

    <P>Una clase es  un modelo (plantilla) para  un objeto y un objeto
      es   una instancia  de una  clase.  Java no   soporta funciones  o
      variables globales todas las acciones (métodos) de los programas se
      definen dentro de una clase.</P>

    <P>Una   clase se      define utilizando   la     palabra    clave
      <tt>class</tt>. La  forma general de  la definición de una clase
      es:</P>


    <CENTER>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH="90%">
	<TR><TD >
	    <pre>
Class  nombre_de_clase {
  Tipo variable_de_instancia1;
  Tipo variable_de_instancia2;
  .
  .
  ...
  tipo variable_de_instancia;

  tipo nombre_de_metodo1(lista_de_parametros){
    //cuerpo del método
  }
  .
  .
  ..
  tipo nombre_de_metodo(lista_de_parametros){
    //cuerpo del método
  }
}
	    </pre>  
	  </TD>
	</TR>
      </TABLE>
    </CENTER>


    <P>Los  datos  o  variables  definidos   en  una clase  se  llaman
      variables  de instancias. El código   está contenido en los
      métodos,   estos  son los  que   determinan  como se pueden
      utilizar los datos de una clase.</P>

    <P>Para  obtener objetos de una   clase es necesario realizar  dos
      pasos:</P>

    <OL TYPE="a">

      <LI>declarar una variable del tipo de la clase. Esta variable no
	define un objeto, es una variable con la que podemos referenciar
	un objeto.</LI> 

      <LI>Asignar  dinámicamente  memoria   para el   objeto  y
	obtener una referencia del mismo.</LI>

    </OL>


    <P>Este  segunda  paso se realiza utilizando   el operador new, su
      formato general es:</P>

    <CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=496>
	<TR><TD >
	    <pre>

variable = new nonbre_de_clase();
	    </pre>
	  </TD>
	</TR>
      </TABLE>
    </CENTER>
    

    <P>Donde  <tt>variable</tt>  es una  variable de la  clase  que se
    quiere crear y <tt>nombre_de_clase</tt> es  el nombre de la  clase
    que está  siendo instanciado. Gráficamente podíamos representar el
    creación de un objeto de la forma siguiente:</P>


    <center><IMG SRC="../../common/images/figure8-2.jpg" WIDTH=512 HEIGHT=275></center>


    <h4>MÉTODOS:</h4>

    <P>El formato general de un método es:</P>

    <CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=484>
	<TR><TD VALIGN="TOP">
	    <pre>

tipo nombre_del_metodo (lista_de_parametros) {
  //cuerpo del método
}    </pre>
	  </TD>
	</TR>
      </TABLE>
    </CENTER>
    
    
    <P><tt>tipo</tt> indica el tipo de dato devuelto por el método,
    puede ser cualquier tipo valido incluido los tipos de clase o no
    puede devolver ningún valor (void).</P>

    <P>La  lista  de   parámetros  es una   secuencia   de parejas  de
    tipo-identificador  separados  por    coma.  Los  parámetros   son
    variables que reciben  el valor de  los argumentos que se pasan al
    método, si el método no tiene  parámetros entonces la lista estará
    vacía.  </P>

    <P>Los métodos que devuelven  un valor distinto de <tt>void</tt> a
    la rutina que lo llama utiliza:</P>

    <CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=484>
	<TR>
	  <TD VALIGN="TOP">
	    <pre>

return valor;	    </pre>
	  </TD>
	</TR>
      </TABLE>
    </CENTER>
    

    <P>Donde valor es el valor devuelto.</P>
    
    <P>Java da mucho  poder y  flexibilidad a  los métodos por  lo que
    iremos, desde aquí, hasta el final del artículo, describiendo cada
    uno de los aspectos más importantes de los métodos.</P>

    <P>Aunque  antes de seguir   avanzando  repasaremos todo lo  visto
    hasta ahora viendo  un ejemplo  simple.   Crearemos una  clase que
    calcule la capacidad de un recipiente rectangular(como una especie
    de piscina):</P>


    <center>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5 width="90%">
	<TR><TD VALIGN="TOP">
	    <center>Código</TD>
	  <TD  VALIGN="TOP">
	    <center>Comentarios</TD>
	</TR>
	<TR>
	  <TD VALIGN="TOP">
	    <pre>
class capacidad {
  double  largo;
  double  ancho;
  double  alto;

  void  CalcVolumen () {

    double volumen ;
    volumen= largo*ancho*alto;
    System.out.println("Volumen:" 
                       + volumen);

  }
}	    </pre>
	  </TD>
	  <TD  VALIGN="center">
	    <P>Como vemos, hemos  definido una clase que hemos llamado
	    <tt>capacidad</tt> en la que  definimos tres variables  de
	    instancia: <tt>largo, ancho</tt> y <tt>alto</tt>.  También
	    se define un método que calcula el volumen del recipiente.
	    El archivo  fuente  lo llamaremos <tt>capacidad.java</tt>,
	    al   compilarlo      creará      una     clase     llamada
	    <tt>capacidad.class</tt>
	    <BR>
	  </TD>
	</TR>
      </TABLE>
    </center>

    <P>Esta clase por  sí sola no realiza ninguna  acción ya que no es
    un "applet"  ni  tiene el  método <tt>main()</tt>  para ejecutarlo
    desde  la línea de  comando.  Hemos creado   un modelo o plantilla
    para   crear objetos  o   instancias  de esta  clase.  Para  poder
    ejecutarla crearemos una  clase  que se  pueda ejecutar  desde  la
    línea de comandos.</P>

    <center><TABLE BORDER CELLSPACING=1 CELLPADDING=5 width="90%">
	<TR><TD  VALIGN="TOP">
	    <center>Código</TD>
	  <TD  VALIGN="TOP">
	    <center>Comentarios</TD>
	</TR>
	<TR>
	  <TD  VALIGN="center">
	    <pre>
class ejemplo {
  public static void main(String Arg[]){
    capacidad p1=new capacidad();
    capacidad p2=new capacidad();
    p1.largo = 16;
    p1.ancho=3;
    p1.alto=2;
    //
    p2.largo = 25;
    p2.ancho=6;
    p2.alto=3;
    //
    p1.CalcVolumen();
    //
    p2.CalcVolumen();
  }
} </pre>
	  </TD>
	  <TD  VALIGN="TOP">
	    <P>Declaramos     dos   variables  del   tipo    capacidad
	    <tt>p1,p2</tt>.  Con el operador   <tt>new</tt> creamos dos objetos
	    del  tipo capacidad a  los cuales podemos referenciarnos a
	    través de las variables <tt>p1, p2</tt>.</P>

	    <P>A continuación asignamos   valores a las  variables  de
	    cada uno de los objetos creados.</P>

	    <P>Llamamos  al   método <tt>CalcVolumen</tt>   del objeto
	    referenciado  en  p1   y   como  resultado tendremos   por
	    pantalla:</P> <P>"el volumen es 80".</P>

	    <P>Idem      para     el      objeto    referenciado    en
	    <tt>p2</tt>. Obtenemos como resultado:</P>

	    <P>"el volumen es 450" </TD>
	</TR>
      </TABLE>
    </center>

    <P>Cuando se ejecuta <tt>p1.CalcVolumen()</tt>, el interprete de
    Java transfiere el control al código definido dentro de
    <tt>CalcVolumen()</tt>, una vez que se ejecuta todas las
    sentencias el control vuelve a la rutina llamante y la ejecución
    continua en la línea siguiente a la llamada.</P>

    <h5>Métodos con parámetros. Devolución de valores.</h5>

    <P>La mayoría de los métodos se utilizan con parámetros que
    permiten generalizarlos.  Además los métodos pueden a su vez
    devolver valores por lo que podemos construir métodos que puedan
    trabajar con diversidad de datos y puedan ser utilizados en
    diferentes situaciones.</P>

    <P>Nuestro ejemplo lo mejoraremos: </P>

    <center><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH="90%">
	<TR><TD  VALIGN="TOP">
	    <center>Código</TD>
	  <TD  VALIGN="TOP">
	    <center>Comentarios</TD>
	</TR>
	<TR>
	  <TD  VALIGN="center">
	    <pre>
class capacidad {

  double  CalcularVolumen (double l, 
                           double a,
                           double p){
    double volumen=l*a*p ;
    return volumen;
  }
}</pre>
	  </TD>
	  <TD  VALIGN="center">

	    <P>El método <tt>CalcVolumen</tt>  ha sido modificado para
	    que reciba tres  parámetros.  Además  se define  para  que
	    devuelva un tipo  double,   acción  que realiza con     la
	    instrucción return volumen.</TD>
	</TR>
	<TR><TD  VALIGN="center">
	    <pre>
class ejemplo {
  public static void main(String Arg[]) {
    capacidad p1=new capacidad();
    capacidad p2=new capacidad();
    double vol;
    vol=p1.CalcVolumen(10,3,2);
    System.out.println("Volumen:" + vol);
    //
    vol=p2.CalcVolumen(25,5,2);
    System.out.println("Volumen:" + vol);
  }
}</pre>
	  </TD>
	  <TD  VALIGN="center">

	    <P>La llamada al método se realiza enviando los parámetros
	    deseados.   Además  devuelve  el valor  del   método en la
	    variable  vol,   que debe   ser  del  mismo   tipo  que el
	    método. </TD>
	</TR>
      </TABLE>
    </center>


    <P>Un  aspecto  importante de las   clases  son los constructores.
    Estos definen qué ocurre cuando se crea un objeto de una clase. La
    mayoría  de   las   clases  definen  explícitamente   sus  propios
    constructores dentro  de la definición de  la clase, pero si no se
    especifica, entonces Java utiliza un constructor por defecto (esto
    es lo que ocurre en nuestro ejemplo).</P>

    <P>Un constructor incluido en una clase tiene exactamente el mismo
    nombre que la  clase, sintácticamente es similar  a  un método. Es
    ejecutado automáticamente después de crear el objeto, antes de que
    termine el operador <tt>new</tt>.</P>

    <P>Los    constructores   no devuelven   ningún   tipo,   ya   que
    implícitamente devuelve el propio tipo de  la clase.  La tarea del
    constructor  es inicializar todo el  estado  interno de un  objeto
    para que el código que crea  una instancia tenga el objeto integro
    y utilizable  inmediatamente.    Los  constructores  por   defecto
    inicializan  las variables de  instancias por defecto. Como ocurre
    con los métodos, los constructores pueden  tener parámetros con lo
    que  hacen a   estos muchos más  útiles.    Volveremos a modificar
    nuestro ejemplo para ver estos nuevos aspectos.</P>

    <center>
      <TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH="90%">
	<TR><TD  VALIGN="TOP">
	    <center>Código</TD>
	  <TD  VALIGN="TOP">
	    <center>Comentarios</TD>
	</TR>
	<TR><TD  VALIGN="center">
	    <pre>
Class capacidad {
  double  largo;
  double  ancho;
  double  alto;
  //
  capacidad(double l, 
            double a, 
            double p){
    largo=l;
    ancho=a;
    altao=p;
  }
  //
  void  CalcularVolumen () {

    double volumen ;
    volumen= largo*ancho*alto;
    return volumen;
  }
}</pre>
	  </TD>
	  <TD  VALIGN="center">

	    <P>A la   clase se  le  añade  un  constructor,  que tiene
	    aspecto de un  método con el nombre igual  a la clase pero
	    sin tipo. Este   constructor inicializa las  variables  de
	    instancias declaradas con los argumentos pasados. </TD>
	</TR>
	<TR>
	  <TD  VALIGN="TOP">
	    <pre>
class ejemplo {
  public static void main(String Arg[]) {
    capacidad p1=new capacidad(10,5,2);
    capacidad p2=new capacidad(25,6,2);
    double vol;
    vol=p1.CalcVolumen();
    System.out.println("Volumen:" + vol);
    //
    vol=p2.CalcVolumen();
    System.out.println("Volumen:" + vol);
}</preZ
	  </TD>
	  <TD  VALIGN="center">

	    <P>El operador   <tt>new</tt> crea  las  instancias  de la
	    clase, pasando los parámetros necesarios al constructor de
	    dicha clase.</TD>
	</TR>
      </TABLE>
    </center>


    <P>Cuando no hay ninguna referencia a un  objeto se asume que este
    objeto no se va  a utilizar más  y la memoria utilizada  por dicho
    objeto  se libera.  No hay necesidad  de destruir explícitamente a
    los objetos, este proceso se hace de forma esporádica y automática
    durante la ejecución del programa.</P>

    <P>No obstante para añadir un finalizador a una clase se realiza
    añadiendo un método <tt>finalice()</tt>, el interprete ejecutará
    este método cuando destruya al objeto. En este método incluiremos
    aquellas acciones que se quieran realizar antes de destruir al
    objeto.</P>

    <h5>Sobrecarga de Métodos.</h5>

    <P>El polimorfismo (una interfaz múltiples  métodos) es uno de los
    pilares básicos de  la  programación  orientada  a  objetos.  Java
    implementa el    polimorfismo por   medio   de  la   sobrecarga de
    métodos.</P>

    <P>En una  clase  se pueden  definir  varios métodos con el
      mismo nombre, pero con lista de  parámetros distinta o tipo
      de  valores devuelto.     Cuando  se  invoca   al    método
      sobrecargado  el  interprete de   Java utiliza   el  tipo  y/o los
      argumentos con los que se invoca para determinar la versión
      del método que debe ejecutar.</P>

    <P>Cada   versión  del     método sobrecargado puede
      realizar tareas distintas aunque esto hace totalmente imposible el
      polimorfismo, por lo que es  muy recomendable que la sobrecarga de
      métodos implique una relación. De la misma forma que
      se sobrecargan   los  métodos  se  pueden   sobrecargas los
      constructores.</P>

    <h5>Paso de Argumentos.</h5>

    <P>En general los lenguajes  de programación permiten pasar
      los argumentos de dos formas:</P>

    <dl>

      <dt><b> Por valor:</b></dt><dd> Copia el  valor del argumento en
      la varible-parametro de la rutina.</dd>

      <dt><b> Por referencia:</b></dt><dd>  Se pasa la referencia  (la
      dirección  de memoria) donde está el  valor, en  este caso si la
      rutina modifica  el valor también se  modifica en el proceso que
      lo llama.</dd>

    </dl>

    <P>En Java existen también dos medios  para pasar parámetros a los
    métodos.  Si el argumento  es  un tipo simple   éste se pasa   por
    valor,  pero    cuando el argumento   es   un objeto se   pasa por
    referencia.</P>

    <h5>Control de Acceso.</h5>

    <P>Otro pilar básico de  la programación orientada  a objeto es la
    encapsulación. Ésta relaciona  los   datos con el código   que  la
    utiliza. Además la encapsulación proporciona el control de acceso,
    es decir que  parte del programa  puede acceder a  los miembros de
    una clase.</P>

    <P>Las   especificaciones de  acceso    en  Java  son  <tt>public,
    private</tt> y <tt>protected</tt>.  Cuando un método o variable de
    instancia  se  define  como  <tt>public</tt>  entonces  puede  ser
    accedido  por  cualquier parte del  programa.   Si  se define como
    private sólo puede ser accedido  por otros  miembros de su  clase.
    Por defecto todos los  métodos o variables de instancia (miembros)
    son  <tt>public</tt> (para  su propio paquete).   El especificador
    protected se utiliza cuando se trabaja con herencias que veremos a
    continuación.</P>

    <h4>HERENCIA.</h4>

    <P>Los tres elementos que define la programación orientada objetos
    son el  polimorfismo, la encapsulación  y por fin la herencia, por
    este mecanismo podemos definir una  clase general (superclase) con
    unas características comunes y  esta superclase puede ser heredada
    por otras clases más especificas añadiendo cada una de estas cosas
    particulares.</P>

    <P>Para que  una clase B herede  las características de una
      superclase A, en la definición de la clase B haremos:</P>

    <CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=5 WIDTH=484>
	<TR><TD VALIGN="TOP">
	    <pre>

Class B extends A {
  // defincion de la clase
}</pre>
	  </TD>
	</TR>
      </TABLE>
    </CENTER>


    <P>La clase B incluye todos los miembros de  la superclase A, ésta
    última es también   una   clase autónoma  y   puede  ser utilizada
    libremente, además B puede se una superclase de otra clase.</P>

    <P>Java no permite una herencia  múltiple de varias superclases en
    una subclase.</P>

    <P>Si     en    la  superclase     hay  miembros  definidos   como
    <tt>private</tt> no pueden ser accedidos por las clases herederas.
    Cuando    una subclase  necesite    referenciar a  una  superclase
    inmediata se  puede utilizar  la palabra reservada <tt>super</tt>.
    Con   esto  podemos  llamar al constructor     o a miembros  de la
    superclase que han sido ocultados por la subclase.</P>

    <P>Cuando un  método de una subclase  tiene el mismo nombre y tipo
    que  un método  de   la superclase se    dice que el  método  está
    sobrescrito.  Esto constituye la base de  unos de los aspectos más
    poderosos de Java  que es  la "Selección  de método dinámica",  es
    decir, es en tiempo de ejecución  cuando se resuelve qué método es
    el llamado, es el tipo  del objeto que  está siendo referenciado y
    no el tipo de la variable de referencia el que determina el método
    a ejecutar.</P>

    <P>En   el  siguiente artículo  veremos  en   toda su potencia  la
      herencia con las clases abstractas, interfaces etc.</P>


    
    <H3>Referencias</H3>
    <UL>
      <LI><b><i>JAVA manual  de  referencia</i></b>. Patrick  Naughton
      Herbert Schildt. Mcgraw-Hill.</li>
      
      <LI><b><i>Programando  con  JAVA</i></b>. Tim  Ritchey. Prentice
      Hall.</li>
      
      <LI><b><i>Tutorial   de  Java</i></b>.  Manual en castellano  en
      formato      HTML    obtenido    de       la    dirección     <A
      HREF="http://www.fie.us.es/info/internet/JAVA">www.fie.us.es/info/internet/JAVA</A>.
      Agustín Froufe.</li>
      
      
      <LI><b><i>The   Java Tutorial</i></b>.    Manual  en ingles   en
      formato      HTML    obtenido      en     la     dirección    <A
      HREF="http://www.javasoft.com/">www.javasoft.com</A>. Sun.</li>
      
      <LI><b><i>Tutoriales   de   la      propia   instalación     del
      JDK</i></b>.</li>

      <Li><b><i>Java      cliente-servidor</i></b>.Cédric     Nicolas,
      Chistophe Avare y Frederic Najman. Gestión 2000.</li>
    </UL>


    <HR size="1" noshade>

    <p align=right><i>Texto original en Castellano</i></P>

    <!-- ARTICLE FOOT -->
    <BR clear="all">
    <CENTER>
      <TABLE width="95%">

	<TR>
	  <TD align="center" bgcolor="#666666">
	    <FONT color="#ffffff">
	      Páginas web mantenidas por Miguel Ángel Sepúlveda<BR>
	      &copy; Jose M. Fernandez 1998<BR>
	      <B>LinuxFocus 1998</B>
	    </FONT>
	  </TD>
	</TR>

      </TABLE>
    </CENTER>



  </BODY>

</HTML>






