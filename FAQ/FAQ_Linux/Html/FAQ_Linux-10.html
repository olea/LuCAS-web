<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>FAQ sobre Linux para principiantes - es.comp.os.linux: Mail/News</TITLE>
 <LINK HREF="FAQ_Linux-11.html" REL=next>
 <LINK HREF="FAQ_Linux-9.html" REL=previous>
 <LINK HREF="FAQ_Linux.html#toc10" REL=contents>
</HEAD>
<BODY>
<A HREF="FAQ_Linux-11.html">Next</A>
<A HREF="FAQ_Linux-9.html">Previous</A>
<A HREF="FAQ_Linux.html#toc10">Contents</A>
<HR>
<H2><A NAME="s10">10. Mail/News</A></H2>

<H2><A NAME="ss10.1">10.1 ¿Qué es el correo electronico?</A>
</H2>

<P>El correo electrónico es casi probablemente el servicio más útil para muchos de los usuarios de Internet, permitiendo intercambio de información casi instantáneamente. Este servicio consiste, dicho de una manera sencilla, en el envío de un bloque de información de texto (aunque puede llevar incluida información multimedia o en general cualquier otro fichero adjunto) de un remitente a un destino, de igual modo que el correo convencional. La diferencia radica en que en lugar de necesitar lapiz y papel, nuestro correo electronico (email, de electronic mail) es generado normalmente por nuestro programa de correo como un bloque de texto a enviar con el siguiente formato:
<PRE>
  From:     &lt;direccion_email_del_remitente>
  To:       &lt;direccion_destino_del_email>
  Subject:  &lt;tema_del_que_se_habla>
  Otros:    &lt;otros_campos_de_informacion>
  &lt;texto_que_deseamos_enviar.>
  .
</PRE>

Las direcciones de email son direcciones en servidores de correo igual que las direcciones postales lo son para la localización geográfica (por ejemplo, mi email es santiago.romero@iname.com, y un mensaje a dicha direccion llegaría a mi máquina servidora de correo de donde yo lo recogería para su lectura).
<P>Un ejemplo de email seria el siguiente:
<PRE>
  From: agonzalo@server.es
  Date: Wed, 12 May 1999 22:19:24 +0200
  Organization: Universidad de Sevilla
  To: santiago.romero@iname.com
  Subject: Una pregunta sobre configuraciones...

  Hola, te queria hacer una pregunta...
  ¿me puedes ayudar con fetchmail?
</PRE>

Este bloque de texto se envia al servidor de correo de nuestro proveedor (o al nuestro, como ahora veremos) quien se encargara de moverlo por Internet hasta llegar al destinatario de nuestro mensaje. Podemos dividirlo en 2 partes: la cabecera del mensaje (todos los campos From, To, etc.), necesaria para el correcto envio del mismo, y el cuerpo del mensaje (el texto en si) que es lo que deseamos enviar.
<P>Obviamente no tenemos que generar nosotros todo eso en un fichero de texto y despues realizar las operaciones para su envio (o recepción), sino que existen programas (clientes de correo) en los cuales introducimos el mensaje y éstos generan las cabeceras necesarias para los programas, permitiendonos además su envio y recepción. Ejemplos de clientes de correo son Pine, Netscape Communicator, MailX, Kmail, etc.
<P>
<P>
<H2><A NAME="ss10.2">10.2 ¿Cómo puedo leer y contestar correo con mail/mailx?</A>
</H2>

<P>El correo electrónico en Linux no puede considerarse como un extra al sistema operativo, sino que forma parte del mismo pues es una característica casi inherente a todo Linux. Esto quiere decir que aunque no hayamos instalado ningún cliente de correo como Netscape o Pine, probablemente dispondremos en el sistema de herramientas ya preparadas para ello.
<P>Dentro de casi cualquier sistema Linux disponemos de un programa básico de email en consola (modo texto) llamado Mailx que nos permitirá el envio, lectura y contestación de mensajes de correo electrónico. En resumen, posibilita el envío de texto y datos dentro de una estructura coherente llamada mensaje, con su cabecera (campos: FROM (persona que envía el mensaje), TO (persona destinataria del mismo), SUBJECT (tema del que trata el mensaje) y CC o carbon copy (lista de personas que recibirán una copia del mismo).) y su BODY (cuerpo del mensaje), pudiendo incluir además ficheros añadidos que vienen incluidos dentro del paquete del mensaje (attach).
<P>Para explicar el uso de mailx se va a usar un sencillo ejemplo en un máquina con un sólo usuario: sromero, además del obligatoriamente existente root (puede obternerse la lista de usuarios presentes en el sistema y en qué terminal están trabajando simplemente ejecutando la orden who). Suponga os que somos el usuario sromero y queremos enviarle un mensaje a root para testear las capacidades de envio de email. La manera más sencilla de enviar un mensaje a un usuario de la red es ejecutar mail :
<PRE>
  [sromero@localhost info]$ mail root
  Subject: Prueba de MailX.
  Esto es el cuerpo del mensaje. Es una prueba de mailx.
  Un mensaje se acaba con un punto (.) al principio de línea.
  .
  Cc: (intro) 
</PRE>

Al ejecutar mail root se nos ha preguntado el tema (subject), el cuerpo del mensaje (acabado en punto (.)), y a quién se le deseaba enviar copias del mismo (Cc), cosa que hubiera sido bastante útil si nuestro mensaje fuera una invitación a un grupo de amigos o una información para un grupo concreto de personas. Tras escribir esto, el mensaje escrito se graba como un fichero de texto (con el mismo nombre que el destinatario del mensaje, y al que se añadirán más mensajes conforme se le vayan enviando a dicho destinatario) en el directorio /var/spool/mail, a la espera de que el usuario destino los lea y vayan siendo eliminados del mismo.
<P>Si root está conectado o entra más tarde en cualquier terminal del sistema, recibirá un mensaje de aviso indicando que el sistema ha detectado la llegada de correo para el usuario:
<PRE>
  You have mail.
</PRE>

Para realizar la lectura del correo electrónico, simplemente se invoca al programa mail, obteniendo una lista del correo pendiente y esperando el programa a que el usuario lo lea, responda, borre o almacene para más tarde:
<PRE>
  [root@localhost /root]# mail
  Mail version 8.1 6/6/93.  Type ? for help.
  "/var/spool/mail/root": 3 messages 3 new
  >N  1 sromero   Thu Jul 30 17:04  17/55   "Prueba de MailX."
   N  2 sromero   Thu Jul 30 17:15  17/50   "Pregunta sobre adm"
   N  3 sromero   Thu Jul 30 17:16  15/44   "Felices vacaciones!"
  &amp; _
</PRE>

Como puede verse, mail nos muestra los mensajes pendientes (en este caso 3) por responder, con su usuario de origen (sromero), la fecha y el tema, con el cursor virtual (>) situado sobre el primero (es decir, indicando sobre cual actuará una orden de lectura, respuesta o borrado), y con un promtp (el carácter &amp;) a la espera de recepción de órdenes sobre qué hacer con dicho correo.
<P>Estas órdenes son:
<PRE>
  'número' -> Listar el mensaje .
  't' -> lista el mensaje actual (el apuntado por >)
  'n' -> Pasar al siguiente mensaje y visualizarlo.
  'd' -> Borrar mensaje.
  'e' -> Editar mensaje
  'r' -> Responder mensaje.
  'q' -> Salir de mailx.
</PRE>

A la mayoría de estas opciones se les puede pasar un nº de mensaje (desde 1 hasta n) para indicar sobre qué mensaje realizar la acción (ejemplo 'd 3' o 'delete 3'). Otras opciones, obtenidas mediante la ayuda de mailx, son:
<PRE>
  &amp; ?
  Mail Commands
  t    listar mensaje
  n    ir al mensaje especificado y listarlo.
  e    editar mensaje
  f    ver cabeceras del mensaje
  d    borrar mensaje
  s    añadir mensajes a un fichero
  u    recuperar mensajes borrados
  R    Responder a los remitentes del mensaje
  r    Responder al remitente y a todos los destinatarios.
  pre  hacer ir los mensajes de nuevo a /usr/spool/mail
  m    enviar mensaje a los usuarios especificados.
  q    salir grabando mensajes en mbox
  h    mostrar cabeceras activas.
  !    permite ejecutar una shell o comandos de shell
</PRE>

En el caso de no disponer de correo en ese momento, mail nos avisa con un:
<PRE>
  [root@localhost root]# mail
 No mail for root
</PRE>

Otro fichero asociado es el fichero .signature de nuestro directorio home, utilizado como fichero de firmas y cuyo contenido es incluido al
final de los emails escritos y respondidos por nosotros, pudiendo editarse y rellenarse con cualquier editor estándar de Linux para
incluir nuestra firma personal. Este fichero es utilizado por la mayoría de gestores de correo de Linux como fichero de firmas por
defecto, tal y como hace Mail, Pine, Netscape, Kmail, etc.
<P>
<P>
<P>
<H2><A NAME="ss10.3">10.3 Envio de correo: Sendmail basico</A>
</H2>

<P>Una de las necesidades básicas en nuestros sistemas Linux es el envio de correo electrónico o email a direcciones fuera de nuestra red local
(a Internet, por ejemplo) o, en general,  de nuestra propia máquina. Cuando escribimos un email en mailx, en Netscape, o en cualquier otro
cliente de news, hace falta alguien que lleve dicho mensaje hasta el servidor de correo saliente (SMTP) de nuestro proveedor de Internet
para que éste deje cada mensaje en el buzón destino correcto. Esta es una de las tareas que sendmail puede realizar en nuestras máquinas.
<P>En nuestros envios de mensajes, pues, necesitamos un agente que extraiga dicho correo de <CODE>/var/spool</CODE> y lo envie a nuestro Proveedor de
Servicios de Internet (por ejemplo, a smtp.arrakis.es). Sendmail es un programa tan completo que su estudio dispone de libros de cientos de paginas
(incluso hay alguno que llega al millar de ellas) para abordar su gestión completa. Ya que muchos disponemos de Linux en nuestras propias máquinas (y somos también root de ellas), vamos a exponer el método más sencillo de configuración para uso con un sólo Proveedor de Servicios de Internet (ISP).
<P>Lo primero es saber si lo tenemos instalado y con el daemon funcionando. Normalmente dicho paquete estará instalado y funcionado ya que es un
daemon básico en todas las distribuciones Linux. Para arrancar el daemon (si no lo tenemos ya funcionando) y de paso chequear si está instalado,
basta con ir a <CODE>/etc/rc.d/init.d</CODE> en el caso de Redhat (en otras distribuciones puede variar el directorio) y ejecutar:
<PRE>
  /etc/rc.d/init.d/sendmail stop
  /etc/rc.d/init.d/sendmail start
</PRE>

Obtendremos lo siguiente.
<PRE>
  [root@compiler /root]# /etc/rc.d/init.d/sendmail stop
  Shutting down sendmail: sendmail
  [root@compiler /root]# /etc/rc.d/init.d/sendmail start
  Starting sendmail: sendmail
</PRE>

Tambien podemos observar simplemente si durante el arranque y lanzamiento de los daemons del sistema sendmail es iniciado con lo que no haría falta
su lanzamiento manual.
<P>Tras asegurarnos de disponer de sendmail instalado y si somos root de nuestra máquina procederemos a la configuración más básica y sencilla
del mismo (también es posible contactar con el administrador o root de la misma si no lo somos), que consiste en la edición del fichero de
configuración <CODE>/etc/sendmail.cf</CODE>, (por ejemplo con el editor joe, emacs, jed, etc) con el fin de modificar algunas líneas del mismo y configurar
sendmail para nuestro uso:
<UL>
<LI>Buscamos una línea similar a la siguiente:
<PRE>
  # "Smart" relay host (may be null)
  DS
</PRE>

Esta línea hay que cambiarla de forma que referencie a nuestro servidor de correo saliente o smtp (para que sendmail envie a dicho servidor
nuestro correo). A título de ejemplo, mi servidor de correo saliente es smtp.arrakis.es, por lo que la línea debe quedar como:
<PRE>
  # "Smart" relay host (may be null)
  DSsmtp.arrakis.es
</PRE>

La dirección del servidor de correo saliente puede ser otra, pero suelen tener todas el mismo formato (stmp.ctv.es, smtp.arrakis.es, etc). De todas
formas nuestro proveedor debe de facilitarnos el nombre de la máquina servidora de correo saliente al inscribirnos en dicho ISP.
<P>
</LI>
<LI>Ahora tenemos que enmascarar nuestra dirección de correo (es decir, modificar el fichero de configuración para que las direcciones de retorno de emails no sean las que tenemos en nuestra máquina (como sromero@localhost), sino las direcciones de retorno reales. Para ello buscamos la siguiente línea:
<PRE>
  # Who I masquerade as (null for no masquerading)
  DM
</PRE>

A esta línea se le añade el dominio de nuestra dirección de correo. Si mi dirección email es sromero@arrakis.es, el dominio es arrakis.es:
<PRE>
  # Who I masquerade as (null for no masquerading)
  DMarrakis.es
</PRE>
</LI>
</UL>

Con estos cambios estamos forzando a que cuando se escribe un email, la dirección de retorno del mismo tenga el dominio correcto, cosa que se podría modificar de igual manera (sin el retoque de sendmail.cf) si nuestro programa para leer/contestar el correo permite hacerlo (en PINE, por ejemplo, modificamos la cabecera FROM en las opciones, en CUSTOMIZED-HEADERS). Para un usuario medio (acceso a Internet, recogida y envio de correo en un
proveedor, etc.), el método comentado del sendmail.cf es más que suficiente. Además existen otros métodos e incluso otros MTAs (agendes de correo) como qmail o smail, que pueden realizar el mismo papel de una manera más sencilla.
<P>Una vez realizada la configuración, supongamos que desde un usuario cualquiera enviamos un email a jose@proveedor.es, mediante el comando mail
jose@proveedor.es. Dicho email se grabará en <CODE>/var/spool/mqueue</CODE> a la espera de ser enviado a nuestro ISP quien a su vez lo enviará al usuario juan. Es decir, los emails que enviemos a Internet se guardarán en el directorio del correo hasta que se realice su envio mediante sendmail en la próxima conexión a Internet, gracias al comando "sendmail -q". Los mensajes en cola de envío se encuentran en <CODE>/var/spool/mqueue</CODE> (por si queremos releerlos o borrar alguno), y podemos consultarlos mediante el comando mailq.
<P>Sendmail es un daemon o demonio, es decir, está ejecutandose en nuestra consola continuamente tratando de enviar el correo cada X tiempo. Para evitar esto, y obligarle a que el envío se realice manualmente por nuestra parte, debemos modificar el arranque de sendmail en el fichero <CODE>/etc/rc.d/init.d/sendmail</CODE> cambiándolo para que arranque con las siguientes opciones:
<PRE>
  daemon /usr/sbin/sendmail -bd -oDeliveryMode=d
</PRE>

Otro problema común es recibir una advertencia (warning) cada vez que un mensaje lleve más de X hroas sin ser enviado (4 por defecto). Para evitar eso tan sólo hay que editar /etc/sendmail.cf y comentar (colocando un símbolo # al principio de la línea, y, por tanto, deshabilitándola) la siguiente opción:
<PRE>
  Timeout.queuewarn=4h
</PRE>

Otra opción a comentar (añadiendo # al principio de la línea correspondiente en sendmail.cf) es la siguiente:
<PRE>
  Timeout.queuereturn=5d
</PRE>

Esta opción especifica que si el correo no ha podido ser enviado durante 5 días debe ser devuelto a sendmail. Esto puede ser util si estamos enviando los emails a un proveedor y se pierden, con lo que gracias a la devolución podrían ser reenviados, pero en nuestro caso no va a ser necesario pues los mensajes residiran en nuestro disco duro hasta el momento en que los enviemos.
<P>En resumen: sendmail es un agente de transporte de correo (MTA) que recoge nuestros emails y los deja temporalmente como simples ficheros de texto que son en /var/spool/mqueue a la espera de realizar su distribucion a los destinatarios especificados. Esta entrega se puede hacer bien mediante el comando "sendmail -q" o bien esperando a que el sistema llame a sendmail (lo llama cada X tiempo, siendo este tiempo programable) para que lo distribuya. Este tiempo, así como los restantes parámetros de configuración (como el servidor SMTP, que es el lugar a donde sendmail debe enviar los mensajes, es decir, nuestro proveedor de Internet) se pueden especificar en el fichero de configuración /etc/sendmail.cf .
<P>Gracias a sendmail podremos enviar mensajes de corre electronico estando desconectados de Internet, mensajes que serán enviados por él cuando se realice la próxima conexión. Esto nos permitirá responder el correo electrónico desde nuestro cliente de correo, con el siguiente mecanismo: una vez configurado sendmail, en nuestro cliente de correo ponemos como SMTP la direccion IP de nuestra máquina (nuestra IP de red, nuestro nombre de máquina o bien 127.0.0.1 o localhost) de modo que cuando escribamos un mensaje en Netscape y pulsemos en Enviar, éste será enviado *a nuestra propia máquina* de tal forma que sendmail se encargará de enviarlo durante la próxima conexión a Internet cuando se ejecute mediante "sendmail -q" o como daemon temporal. Esto nos permite contestar el correo electronico en nuestro cliente favorito, sin gasto de teléfono por nuestra parte, y pudiendo simplemente enviar los mensajes y dejar que sendmail los distribuya al conectar a Internet.
<P>
<P>
<P>
<H2><A NAME="ss10.4">10.4 Recogida de correo: Fetchmail</A>
</H2>

<P>Si con programas como sendmail es posible enviar el correo a nuestra máquina estando desconectados de Internet para su posterior distribución
cuando se conecte a la Red, con Fetchmail es posible hacer el proceso inverso, es decir, recoger TODO el correo de todos los servidores POP
o IMAP deseados para su posterior recogida desde nuestra máquina y lectura en modo desconectado.
<P>Fetchmail es el daemon encargado de la recogida de correo, para posteriormente pasárselo a sendmail, que es quien lo distribuye. La
forma más sencilla de configurar fetchmail es creando un fichero .fetchmailrc en el directorio personal del usuario (ya sea <CODE>/home/usuario</CODE>
o incluso <CODE>/root</CODE>), de forma que sea el mismo usuario quien recoja el correo y se lo pase al usuario/usuarios que deban leerlo. Dicho fichero tiene un formato como el que sigue:
<PRE>
  defaults
  fetchall
  flush
  pass8bits

  poll servidor_de_correo
  proto pop3
  user usuario
  pass password
  to usuario_local
</PRE>

(pueden haber más bloques poll/proto/user/pass/to si hay mas servidores de correo de donde deseemos recoger el mismo)
<P>Las opciones incluidas en este fichero son las siguientes:
<UL>
<LI>defaults:  establece los valores por defecto para fetchmail.
</LI>
<LI>fetchall:  recoge todos los mensajes pendientes en el servidor de correo.
</LI>
<LI>flush: una vez recogidos los mensajes son borrados del servidor de correo. Para nuestras primeras pruebas es recomendable  cambiar este parámetro por keep, para que los mantenga y así no los perdamos en caso de un error de configuración.
</LI>
<LI>pass8bits: Indica que el mensaje puede contener carácteres de 8 bits (acentos, eñes, etc.).
</LI>
<LI>Bloque poll/proto/user/pass: Indica las características de nuestro servidor de correo. Si disponemos de más de un servidor de correo, se deben incluir tantos bloques de este tipo (repetir la estructura para ambos) como servidores dispongamos.
</LI>
<LI>poll: Indica el servidor de correo entrante (POP o IMAP) de donde leer el correo (en mi caso se trata simplemente de anteponer pop al dominio de mi ISP, quedando pop.arrakis.es).
</LI>
<LI>proto pop3: Indica que nuestro servidor de correo entrante utiliza POP para la recogida del correo (alternativo a IMAP).
</LI>
<LI>user y pass: Indican la cuenta del correo y password del usuario. Algunas cuentas de correo típicas son como las siguientes:
<PRE>
  user sromero@arrakis       &lt;- en arrakis
  user sromero               &lt;- en CTV
</PRE>

(consultar con nuestro ISP cual es el login de nuestra cuenta de correo). Si nuestro password es numérico tal vez haga falta encerrarlo entre comillas dobles "".
</LI>
<LI>to usuario: Indica a qué cuenta de usuario se le ha de pasar el correo. Usuario ha de ser una cuenta de nuestro sistema Linux, tales como sromero, o root.</LI>
</UL>
<P>Un ejemplo de fichero .fetchmailrc para un usuario sromero@arrakis.es en /home/sromero sería el siguiente:
<PRE>
  defaults
  flush
  fetchall
  pass8bits
  poll pop.arrakis.es
  proto pop3
  user sromero@arrakis
  pass mipassword
  to sromero
</PRE>

Además, este fichero tiene que tener unos permisos de lectura/escritura concretos, debido a que posee nuestro password de correo, cosa que se
realiza con la orden chmod:
<PRE>
  [sromerolocalhost sromero]#   chmod 0600 .fetchmailrc
</PRE>

La forma de recoger el correo es, estando conectado, ejecutar la orden "fetchmail".
<P>Por último, podemos hacer que fetchmail corra en forma de demonio (el equivalente en MSDOS sería como un programa residente), y que recoja
el correo sólo cada X segundos, cosa muy sencilla de realizar añadiendo la siguiente opción al fichero .fetchmailrc:
<PRE>
  set daemon X
 
  (ejemplo: set daemon 300)
</PRE>

Esto haria que fetchmail buscara correo nuevo cada 300 segundos sin necesidad de ser lanzado por nuestra parte con el comando "fetchmail".
<P>Una vez recogidos los mensajes (ya sea en forma manual o como daemon), éstos son depositados por sendmail en <CODE>/var/spool/mail</CODE>, de manera que
puedan ser accedidos por cualquier programa de correo del sistema (mailx, pine, y, como veremos ahora, Netscape). Simplemente debemos
configurar nuestro cliente de correo especificando como servidor POP nuestra propia máquina (localhost, 127.0.0.1, etc). Tras haber recogido
todos los mensajes con fetchmail y ya desconectados de la Red, en el cliente de correo (por ejemplo Netscape) le damos a GET NEW
MESSAGES (Obtener nuevos mensajes) y aparecerán ante nosotros los emails recogidos por fetchmail dispuestos para ser respondidos totalmente offline.
<P>
<P>
<P>
<H2><A NAME="ss10.5">10.5 Sendmail y Fetchmail: Todo Offline</A>
</H2>

<P>Con fetchmail y sendmail, trabajar con el correo electrónico en modo desconectado (tanto leer como contestar el correo OFFLINE, con el
consiguiente ahorro de dinero en tiempo de conexión) consiste simplemente en lo siguiente:
<PRE>
  [root@localhost root]# pppd
  [root@localhost root]# sendmail -q
  [root@localhost root]# fechmail
  [root@localhost root]# killall pppd
</PRE>

Con la primera línea conectamos a Internet, para posteriormente enviar el correo pendiente en la cola de mensajes (los enviados por nosotros a nuestramáquina), así como recoger el correo entrante en nuestro ISP con fetchmail (y dejarlo en nuestra máquina listo para recogerlo con Netscape, Pine o nuestro cliente de correo).
<P>Gracias a esto en apenas unos minutos de conexión enviamos todo el correo saliente y recogemos los nuevos mensajes, dejándolos en nuestro sistema listos para su contestación con el modem desconectado. Otra opción es incluir las llamadas a las funciones de envío y recogida en el fichero /etc/ppp/ip-up, de manera que la recogida sea automática al realizarse la conexión. Además podremos utilizar procmail para distribuir el correo, de manera que todos los usuarios de una red tengan la misma dirección de email en Internet pero luego puedan enviarse mensajes a usuarios individuales con esa misma dirección, etc. Las posibilidades de actuación de Linux son infinitas en este campo, pudiendo crear listas de correo, filtros anti-spam, etc.
<P>
<P>
<P>
<H2><A NAME="ss10.6">10.6 ¿Cómo configuro Netscape para trabajar Offline?</A>
</H2>

<P>Si disponemos de nuestros emails en <CODE>/var/spool/mails</CODE> nada nos impide utilizar Netscape para trabajar con ellos, y así de paso trabajar en modo
desconectado u offline. Para ello tan sólo hemos de ir a las opciones del programa (edit->preferences), y modificar los datos que especifican nuestro servidor de correo entrante y saliente.
<P>Para ello vamos a la pestaña Mail &amp; Groups, submenú Mail Server y como Outgoing mail (SMTP) server especificamos localhost (nuestro ordenador), de
manera que al enviar emails con Netscape vayan a parar al directorio <CODE>/var/spool/mail</CODE>. Como Mail server type especificamos la opción
"Movemail Application", y seleccionamos Built in, para que utilice la herramienta interna de Netscape para la recogida del correo, tal y como
se puede ver en la figura adjunta.
<P>Por último como root habremos de cambiar los permisos del directorio /var/spool/mail para que Netscape pueda escribir en ellos:
<PRE>
  [root@localhost root]# cd /var/spool
  [root@localhost spool]# chmod 01777 mail
</PRE>

(otra posibilidad es buscar la aplicacion movemail y darle permisos de root.root y atributos +s para que tome privilegios de administrador).
<P>Una vez realizado esto, todas las recepciones y envíos se realizan sobre el directorio /var/spool/mail y /var/spool/mqueue, con lo que podremos
leer y responder desde Netscape los emails recogidos con fetchmail, y cuyas respuestas serán enviadas por sendmail en la siguiente conexión a
Internet. De la misma manera, podemos especificar localhost como servidor de correo entrante (pop) y saliente (smtp) en otros programas de correo
para que accedan a nuestra máquina y podamos trabajar en modo desconectado, como en el programa Kmail incluido en KDE, en Pine, etc.
<P>
<P>
<P>
<H2><A NAME="ss10.7">10.7 ¿Qué son las news o grupos de noticias?</A>
</H2>

<P>Las news (grupos de noticias) son un interesante servicio de Internet que
permite el intercambio de mensajes en un foro común sobre un determinado
tema de interés para todos sus lectores. En cuanto a formato, son algo
similar a los emails: simples mensajes de texto formados por la cabecera
del mensaje seguida del cuerpo, y donde a su vez la cabecera se divide
en diferentes campos que indican el remitente, el grupo destinatario o
el tema del mensaje.
<P>Si se busca información de un determinado tema (programación, electrónica,
diseño, imágenes, etc.), sólo es necesario apuntar nuestro programa de news
(por ejemplo, Collabra Discussion Groups, de Netscape, incluido con
Communicator) hacia el grupo adecuado para disponer de la posibilidad de
intercambio de información e intereses comunes entre un gran grupo de
usuarios interesados en el mismo tema. Apuntándose, por ejemplo, al
grupo es.comp.os.linux estaremos en conexión con un grupo temático
dedicado exclusivamente al habla sobre este S.O. Si enviamos un mensaje
al grupo, todas las personas suscritas al mismo podrán leerlo y contestarlo
(algo así como enviar emails pero a un lugar donde lo pueden leer todas
las personas interesadas en el tema) tanto personalmente como al grupo
en general, pudiendo por tanto aprender mucho sobre el tema tratado.
La variedad de temas disponibles en los diferentes grupos permiten nuestra
participación activa, yendo desde la simple lectura (de la que se puede
aprender mucho) hasta la colaboración con el grupo respondiendo a preguntas
que ayuden a otros lectores a desarrollarse.
<P>
<P>
<P>
<H2><A NAME="ss10.8">10.8 ¿Cómo se accede a las news?</A>
</H2>

<P>En general, basta con instalar un cliente de news e indicarle la
direccion de nuestro servidor de news (el nombre o IP de la máquina
que contiene los grupos), tal como news.arrakis.es, news.ctv.es, o
como quiera que se llame nuestro proveedor de servicios de Internet.
También existen diferentes servidores de news gratuitos, algunos de
ellos sin limitaciones y otros que sólo permiten postear mensajes de
un determinado nº de líneas, o donde el nº de líneas de texto nuevo
sea mayor que el texto al que se contesta, ya que al ser como un
email, se puede dejar el texto anterior al contestar:
<PRE>
  Ejemplo:

  --------------------------------------------------
  > JuanJO preguntó:
  > ¿alguien sabe como hacer esto?

   Pues tienes que ir al directorio... [etc]
  --------------------------------------------------
</PRE>

Sabido ya nuestro servidor de news y el puerto de acceso (general-
mente el 119) la configuración del acceso simplemente consiste en
ir a las opciones del cliente de news que deseemos usar e indicarle
como "Servidor de News" la dirección de nuestro server, y como puerto,
el apropiado para el mismo.
<P>Una vez realicemos la configuración, el cliente de news se bajará
del servidor remoto una lista de todos los grupos temáticos disponibles
y de las descripciones de los contenidos, para que posteriormente
podamos seleccionar aquellos de nuestro interés. Suelen haber miles
o decenas de miles de grupos diferentes, ordenados por tematicas.
Los grupos de news son como una jerarquía donde cada grupo se divide
en subgrupos hasta llegar a aquel de la tematica deseada:
<PRE>
  es.*                   -> todos los grupos de news en castellano
                            (hay miles de ellos)
  es.ciencia.*           -> grupos de news sobre ciencia.
                            (hay unas decenas, de electrónica,
                             matemáticas, biología, etc)
  es.ciencia.electronica -> grupo de news sobre electronica en castellano.

  o bien:
 
  es.comp.*              -> grupos relacionados con ordenadores.
  es.comp.os.*           -> grupo de news dedicados a S. Operativos.
  es.comp.os.linux       -> grupo de news sobre el S.O. Linux.
  es.comp.os.windows     -> grupo de news sobre el "S.O." Windows
  (etc...)
</PRE>

Esta lista de grupos y sus descripciones se almacena en nuestro PC
para que posteriormente a su download completo (suele tardar bastante
al ser muy extensa) podamos suscribirnos a aquellos grupos que más
nos interesen. En el caso del autor, y como ejemplo, uso Netscape
Communicator y estoy suscrito a es.ciencia.electronica, es.comp.os.linux
y rec.games.programmer, los cuales recibo en diferentes carpetas para
leer mensajes de cada uno de los temas por separado (cada vez que conecto
a Internet recojo los nuevos mensajes de cada grupo y envio mis respuestas).
<P>Tanto Netscape Communicator como otros lectores/clientes de noticias
(Slrn, Krn, Xrn) dan acceso a la lectura y gestión de artículos de las
news siempre y cuando estemos conectados a Internet (trabajando online),
es decir, hay que estar conectado, recoger los nuevos mensajes, y leerlos
y contestarlos estando conectados lo cual conlleva un gasto (innecesario
como veremos) de teléfono a la hora de leer, responder y descartar los
mensajes que nos interesen.
<P>Existen algunos programas que permiten hacer algo más ahorrativo: al entrar
en el grupo de news que nos interesa, podremos leer las cabeceras de los
mensajes disponibles (como por ejemplo en el programa HY-News), marcar los
que nos interesen y posteriormente bajarlos para leerlos una vez
desconectados de la línea, si bien el marcado de cabeceras requiere un tiempo
de lectura y elección que puede llegar a bastantes minutos si estamos suscritos
a diferentes grupos, aunque siempre es mejor esto que responder todos los
artículos online.
<P>En Linux disponemos de la posibilidad (de nuevo formando parte gratuita
del Sistema Operativo y no como un extra a añadir al mismo) de instalar
clientes de news (y servidores) que nos permitirán trabajar en modo
desconectado de la misma manera que se puede hacer con el correo (en
aquel caso mediante fetchmail y sendmail). Estos programas funcionan
bajandose TODOS los nuevos articulos/mensajes de news (a gran velocidad
al ser conexion directa al servidor) para luego en nuestro cliente de
correo especificar como servidor de news nuestro propio PC (localhost)
de modo que podremos leer y contestar las news totalmente offline.
<P>En este aspecto podemos elegir principalmente entre leafnode
e inn+suck. Éstos 2 ultimos paquetes (inn y suck) son muy potentes y
mucho más avanzados para nuestros propósitos iniciales, de modo que
si nuestro uso de las news es sencillo (no queremos montar nuestro
propio servidor sino simplemente obtener un medio para leer las news
offline) nos quedaremos con leafnode mucho más sencillo de instalar y
configurar.
<P>
<P>
<P>
<H2><A NAME="ss10.9">10.9 Leafnode como servidor de NNTP</A>
</H2>

<P>Como puede leerse en la página del manual (man fetch) leafnode es un
paquete de trabajo con news diseñado para ordenadores pequeños con pocos
usuarios, de manera que no ocupa mucho espacio y permite la gestión de
muchos grupos. El diseño de leafnode está pensado para que sea capaz
de autoreparar errores cuando ocurran, y que no necesite mantenimiento
manual. Es decir: nos encontramos ante un programa que requiere poco
espacio y mantenimiento, pero que en cambio nos proporciona total acceso
a la gestión de grupos de noticias, gracias a leafnode (un servidor de NNTP),
fetch, el programa que se encarga de recoger las news de Internet y dejarlas
en nuestro disco duro para su posterior lectura por parte del programa que
deseemos, y texpire, que se encarga de eliminar los mensajes viejos para
recuperar disco duro y deshacernos de los artículos no deseados según el
tiempo de expiración que hayamos configurado.
<P>Leafnode es un programa incluido en la mayoría de las distribuciones Linux
(sobre todo en las de RedHat), y si no disponemos de él puede encontrarse
en ftp.redhat.com en el directorio pub/manhattan/contrib/i386 (versión 1.5)
o en la sección de viejos RPMs (la versión 1.4). Algunas (caso de algunas
distribuciones Manhattan) versiones tienen un fallo con Netscape, pero al
autor le consta que a partir de la versión 1.9 este fallo fue corregido
completamente (NOTA: El autor usa leafnode 1.4 ya que le sigue funcionando
perfectamente y no ve ninguna necesidad de actualizar a la version 1.9 :).
La instalación en formato rpm es mediante el comando rpm -i, y para
paquetes .deb y tar.gzs también se debe seguir el método habitual de instalación
ya conocido por los que usan distribuciones Debian o Slackware, además de poder
convertir el paquete de rpm a cualquier otro formato mediante el script alien,
incluido en muchas distribuciones y que podemos encontrar en el home de Debian.
<P>
<P>
<P>
<H2><A NAME="ss10.10">10.10 Configuracion de Leafnode</A>
</H2>

<P>Una vez instalado leafnode se debe proceder a configurarlo. Como root
entramos en el directorio /usr/lib/leafnode y editamos el fichero config,
donde leeremos algo similar a lo siguiente (fichero de configuración de
la versión 1.4):
<PRE>
  # This is the NNTP server leafnode fetches its news from.
  # You need read and post access to it.
  server = news.arrakis.es

  # Unread discussion threads will be deleted after this many days if
  # you don't define special expire times. Mandatory.
  expire = 5

  # Non-standard expire times (no regex possible)
  #groupexpire comp.linux.misc = 5   # group too big to hold articles 20 day
  #groupexpire any.newsgroup = 100  # very interesting, hold articles longe

  # Never fetch more than this many articles from one group in one run.
  maxfetch = 2000

  # Specifies an upper limit on how many groups an article may be posted to. 
  maxcrosspost = 0
</PRE>

El significado de las diferentes opciones es muy descriptivo:
<P>La opción server indica el servidor de donde leafnode ha de leer las
noticias. En este caso se tiene especificado como servidor
news.arrakis.es. En principio esta línea no contendrá ningún valor
si es la primera vez que lo configuramos, así que será necesario
incluir aqui el nombre de nuestro servidor de noticias habitual
(news.ctv.es, news.arrakis.es, etc.).
<P>Con expire=5 le indicamos a leafnode que si un tema (thread o hebra)
de artículos no ha sido tratado durante 5 días o más, debe borrarlo
(lo haremos con texpire). Es decir, si un hipotético tema llamado
«Pregunta simple», y sus respuestas «Re: Pregunta simple» llevan 5
días sin ser tratados, todos estos mensajes son eliminados del disco
duro para ahorrar espacio (debido a que es considerado como tema
antiguo). El número de días puede ser modificado a nuestro gusto
mediante esta opción.
<P>Las 2 opciones groupexpire comentadas permiten especificar excepciones
a diferentes grupos (por ejemplo, si queremos que en un determinado grupo
se guarden los artículos más días) con respecto al tiempo considerado para
eliminar artículos. En este sentido, se utiliza para hacer una excepción
para un grupo concreto sobre el valor de expire generalizado para todos
los grupos (por ejemplo, si un grupo tiene un flujo muy grande de mensajes
puede no interesarnos que caduquen a los 5 dias sino a los 3).
<P>El parámetro maxfetch especifica el máximo número de artículos a recoger
cada vez de cada grupo. La primera vez que recojamos los mensajes de un
grupo nos recogerá este número de posts, así que es recomendable ponerlo
a 500 inicialmente y despues de la primera recogida de grupos dejarlo
en el valor deseado.
<P>La opción maxcrosspost indica el número máximo de grupos a los que un
artículo puede ir dirigido (para evitar el crossposting o repeticion
del mismo mensaje en diferentes grupos), o cero para no indicar límite
de grupos.
<P>Una vez configurado el programa conectamos a Internet y
ejecutamos el programa de recogida de news (fetch) mediante la orden:
<PRE>
  [root@localhost root]#   fetch -v
</PRE>

Mediante esta orden, y al ser la primera vez que llamamos al programa,
fetch se dedicará a bajarse de nuestro servidor de news todos los nombres y
descripciones de los grupos de noticias existentes para que posteriormente
podamos suscribirnos a cualquiera de ellos.
<P>Si queremos seguir el proceso y saber que hace en todo momento
leafnode, podemos ejecutar el siguiente comando en otra consola
virtual o xterm:
<PRE>
  tail -f /var/log/messages
</PRE>

Veremos algo similar a:
<PRE>
  Jan 2 11:07:00 localhost fetch: Registered group arrakis.binarios
  Jan 2 11:07:00 localhost fetch: Registered group arrakis.consultas
  Jan 2 11:07:00 localhost fetch: Registered group arrakis.general
  Jan 2 11:07:00 localhost fetch: Registered group arrakis.noticias
  Jan 2 11:07:00 localhost fetch: Registered group a.bsu.programming
  Jan 2 11:07:00 localhost fetch: Registered group a.bsu.religion
  (y un largo etc).
</PRE>

El parámetro -v (verbose) le indica a leafnode que muestre mensajes en pantalla
indicando qué hace en cada momento. Hay diferentes niveles de explicación
(-v, -vv, ...-vvvvv) que nos permitirán saber qué hace el programa y observar
la progresión del mismo. Tras un tiempo (dependiendo de la velocidad de nuestro
modem), el programa terminará de recoger los nombres de los newsgroups
(proceso largo, debido a la gran cantidad de ellos, así que tendremos que
tener paciencia esta primera vez de ejecución), y habremos de resetear el
inetd para que se active nuestro servidor de news (leafnode):
<PRE>
  [root@localhost root]#   /etc/rc.d/init.d/inet  restart
</PRE>

Por último (aunque suele ser realizado automáticamente al instalar el
paquete), debemos asegurarnos de que tenemos abierto el puerto de nntp (de
nuestro servidor de noticias) en el archivo /etc/inetd.conf, simplemente
comprobando si existe (y creando en caso negativo) una línea similar a la
siguiente:
<PRE>
  nntp  stream  tcp  nowait  news  /usr/sbin/tcpd  /usr/sbin/leafnode
</PRE>

Tras esto podemos desconectar de Internet y prepararnos para elegir los
grupos a los que deseamos suscribirnos, como veremos a continuación.
<P>Nota: Es posible que si instalamos leafnode desde un fichero tar.gz,
el path destino de instalacion sea /usr/local/sbin/leafnode, de modo
que la linea anterior debe cambiar para ajustarse al path donde leafnode
este disponible.
<PRE>
  nntp  stream  tcp  nowait  news  /usr/sbin/tcpd  /usr/local/sbin/leafnode
</PRE>

Las ultimas versiones llevan un mayor número de opciones las cuales
podemos (y deberíamos) consultar en la página man de fetch.
<P>
<P>
<P>
<H2><A NAME="ss10.11">10.11 Suscripcion a los grupos de noticias deseados</A>
</H2>

<P>Una vez tenemos la lista de grupos y sus descripciones (Active List) en
nuestro disco duro, llega el momento de suscribirse a los grupos que
deseamos recoger. Para ello nos vamos a /var/spool/news/interesting.groups
y creamos allí ficheros con los nombres de los grupos a los que nos queremos
suscribir. Dicho de una manera sencilla, si nos queremos suscribir a
es.comp.os.linux y es.ciencia.electrónica, por ejemplo, dentro de
/var/spool/news/interesting.groups creamos dichos ficheros sin contenido
alguno:
<PRE>
  [root@localhost root]#   touch  es.comp.os.linux
  [root@localhost root]#   touch  es.ciencia.electronica
</PRE>

El comando touch sirve para actualizar la fecha de un fichero, y si no
existe se encarga de crearlo (vacío, de cero bytes). El directorio
interesting.groups es para leafnode una base de datos de los grupos que
debe bajarse, estando especificados en forma de ficheros. Después de los
2 touch, el contenido del directorio es el siguiente:
<PRE>
  [root@localhost interesting.groups]# ls -l
  total 0
  -rw-r--r--   1 news     news     es.ciencia.electronica
  -rw-r--r--   1 news     news     es.comp.os.linux
</PRE>

Mediante esto, cada vez que recojamos los artículos llamando a fetch
(como ahora veremos), leafnode se bajará los artículos nuevos de estos 2
grupos. Por supuesto, es posible suscribirse a tantos grupos como sea
necesario, creando los ficheros con touch (o creandolos con cualquier
editor de texto y grabándolos vacíos).
<P>Tras esto ya estamos suscritos a diferentes grupos en el leafnode, lo
cual significa que leafnode se bajará los mensajes de dichos grupos.
El siguienet paso sería ir al cliente de news y poner como Groups
Server (servidor de news, de nntp o de grupos) el nombre o IP de nuestra
propia máquina, como 127.0.0.1 o localhost. Tras esto veremos aparecer
en el cliente de news (por ejemplo en Netscape Communicator) la lista
de grupos que hay en nuestro sistema (la que se bajó leafnode) y nos
podremos suscribir a los grupos que deseamos leer en nuestro netscape
(Join Discussion Groups).
<P>Es decir, primero con Leafnode nos suscribimos a los grupos que
deseamos recibir en el sistema, y luego cada usuario, en su cliente
de news, se suscribe, de dichos grupos que se reciben, a los que
desea leer en su cliente.
<P>
<P>
<P>
<H2><A NAME="ss10.12">10.12 Recogida de news</A>
</H2>

<P>Una vez configurado todo el sistema de leafnode, veamos el proceso que
se seguiría cada vez que se deseen recoger los artículos de las news cada
día (o cada vez que se use Internet). Para ello, conectamos a Internet (por
ejemplo, ejecutamos pppd, enviamos nuestro correo con sendmail, recogemos
los mensajes nuevos con fetchmail, etc.) y ejecutamos el siguiente comando:
<PRE>
  [root@localhost root]#   fetch -v
</PRE>

En ese momento, leafnode enviará los artículos que hayamos respondido (si
es la primera vez, no habremos escrito nada todavía) y después comenzará
a bajarse todos los artículos nuevos de los grupos a los que nos hayamos
suscrito en <CODE>/var/spool/news/interesting.groups</CODE>. Nótese que leafnode la
primera vez se bajará unos 2000 mensajes de cada grupo (depende de la
opción maxfetch especificada en el fichero de configuración, por lo que
recomendamos que inicialmente se deje en 500 para colocarla en 2000 tras
la primera recogida), pero a partir de ese momento en la siguiente conexión
sólo se bajará los artículos nuevos.
<P>Nótese también que leafnode se baja todo el grupo (todos los mensajes, no
siendo necesario marcar cabeceras), con lo que no es necesario pasar
tiempo marcando los artículos deseados, sino que posteriormente dispondremos
de todo el grupo para su lectura en offline. Además leafnode es muy rápido
bajando los artículos, pues lo hace a altas velocidades y permite también
ser añadido al script ip-up para su recogida automática tras la conexión.
<P>Una vez recogidos los artículos estos son dejados en <CODE>/var/spool/news</CODE> (en
nuestro disco duro) para que puedan ser accedidos por cualquier cliente de
news, como Krn, Xrn, Netscape, etc. Por otra parte, una vez por semana
leafnode realiza una actualización de la lista de grupos y descripciones
(no recogida completa sino actualización) aunque esto se puede evitar si
así lo deseamos, como veremos más adelante.
<P>Otra de las ventajas de que la recogida se haga por medio de un comando
de consola es que podemos colocar en un script de shell (como ya dijimos,
algo similar a un BATCH de MSDOS, pero mucho más potente), que nos haga la
recogida automática de correo y news para nuestro ordenador. Para ello
creamos un fichero "recoge" con el siguiente contenido:
<PRE>
  # Script para recogida de correo
  echo Enviando correo pendiente...
  sendmail -q
  echo Recogiendo correo entrante...
  fetchmail
  echo Posteando y recogiendo news...
  fetch -v
</PRE>

Tras crear este fichero, le damos permisos de ejecución (chmod +x recoge),
y ya puede ser utilizado en alguna consola virtual o xterm para recoger el
correo+news automáticamente (enviar y recoger correo y news), mientras
navegamos o trabajamos con el resto del sistema.
<P>
<P>
<P>
<H2><A NAME="ss10.13">10.13 Configuracion del cliente de news para trabajar con leafnode</A>
</H2>

<P>La configuración del cliente que utilicemos es muy sencilla, y consiste en
cambiar el servidor de news que tuvieramos especificado en las opciones del
programa (por ejemplo, news.arrakis.es) por nuestra propia máquina (localhost),
con lo que cuando sea pulsado el botón de "Coger nuevos mensajes", por ejemplo,
se estará accediendo a nuestra máquina (concretamente a leafnode) para leer
dichos nuevos mensajes de <CODE>/var/spool/news</CODE>, es decir, los artículos recogido
por fetch.
<P>En Netscape Communicator esto se especifica en el menú Edit, opción
Preferences, pestaña Mail &amp; Groups, subopción Groups Server, donde
especificaremos 127.0.0.1 (o localhost) como Groups Server y nuestro home
(<CODE>/home/sromero</CODE> en mi caso) en la opción Discussion Groups (news) directory.
Tras eso nos suscribiremos a los grupos deseados (cada usuario puede elegir
cualquier grupo de los especificados en interesting.groups) mediante la
opción Join Discussion Groups del menú File. El proceso es similar para
otros clientes como Krn, Slrn (con un sencillo fichero de configuración) o
incluso el editor de texto Emacs (que puede utilizarse también para gestionar
las news).
<P>Una vez realizado esto, al pulsar sobre "Get new messages" estaremos
accediendo a nuestro disco duro para leer los ultimos artículos recogidos
por leafnode, y al enviar un mensaje en realidad estará siendo grabado como
un fichero de texto en el directorio /var/spool/news/out.going, donde se
almacenan todos los mensajes enviados offline hasta que en la próxima
conexión fetch los envíe a nuestro servidor de news (y por tanto, sean
posteados en Internet).
<P>
<P>
<P>
<H2><A NAME="ss10.14">10.14 Eliminacion de noticias antiguas (Texpire)</A>
</H2>

<P>Cada cierto tiempo debemos limpiar nuestro disco duro para eliminar
mensajes antiguos. Esto no significa que debamos entrar en el directorio
news para comprobar qué mensajes están atrasados y eliminarlos, porque
como ya se ha comentado, leafnode es un programa diseñado para automatizar
todo este tipo de procesos. Para ello sólo tendremos que ejecutar el
programa texpire (incluido con leafnode), que se encarga de recorrer todos
los grupos de que dispongamos en nuestro disco duro y eliminar aquellos
threads que sobrepasen sin actualizar el número de días indicado en el
fichero de configuración de leafnode (en nuestro ejemplo indicamos 10 días).
Al ejecutar texpire la salida suele ser algo parecido a lo siguiente
(la aparición de varios grupos a los que no estamos suscritos es debido a
que hay mensajes con crossposting, dirigidos a varios grupos):
<PRE>
  [root@localhost root]# texpire
  es.ciencia.electronica: 10 articles deleted, 182 kept
  es.ciencia.misc: 21 articles deleted, 25 kept
  es.comp.hackers: 1 articles deleted, 10 kept
  es.comp.lenguajes.java: 10 articles deleted, 1 kept
  es.comp.os.linux: 100 articles deleted, 690 kept
  total: 142 articles deleted, 1012 kept
</PRE>

Realizando esto regularmente mantendremos nuestro disco duro sólo con los
últimos mensajes deseados en lugar de ir llenándolo con la acumulación de
mensajes antiguos. La cantidad de días a los que hayamos configurado texpire
variará el nivel de limpieza de artículos viejos. Texpire es automáticamente
ejecutado por "cron" (la parte de Linux que se encarga de ejecutar procesos
a determinadas horas), pero para que cron tenga utilidad es necesario tener
conectado el ordenador todo el dia (cron hace las cosas a unas determinadas
horas), cosa que viene muy bien en las estaciones de trabajo pero que a
nosotros no obliga a usar el "anacron" (no necesita tener el ordenador
permanentemente conectado) o a hacerlo manualmente (la forma más sencilla,
simplemente llamando a texpire cada 15 días, ejecutándolo en la línea
de comandos del sistema).
<P>Normalmente a texpire le costará cerca de un mes de uso empezar a borrar
artículos, de modo que aunque inicialmente veamos que al llamarlo no
borra los artículos antiguos, debemos dejarlo porque eso quiere decir
que ninguno de los artículos ha expirado aún (o que hemos puesto un
tiempo de expiracion muy grande. Un tiempo razonable es 5 dias, pero
eso depende fundamentalmente del tráfico del grupo en cuestión).
Además texpire está basado en detectar TEMAS caducados (no artículos).
Esto implica que un TEMA caduca cuando no se postee ningún
mensaje sobre él (o respuesta) en el tiempo especificado, tras el
cual será borrado. Estar basado en temas hace que se tarde más
(inicialmente) en comenzar a borrar artículos viejos, pero que a partir
de la primera expiración de artículos el proceso sea contínuo y eficiente.
<P>Por Internet es posible encontrar también un programa en PERL llamado
texpire.pl el cual hace un borrado artículo por artículo (no basado
en cuando un TEMA caduca sino en cuando un ARTICULO caduca) que también
puede utilizarse para este fin. No obstante el uso de texpire es más
adecuado ya que viene integrado con leafnode y su funcionamiento es
excelente.
<P>
<P>
<P>
<H2><A NAME="ss10.15">10.15 ¿Cómo hacer que leafnode no actualice la lista de grupos?</A>
</H2>

<P>Por otra parte, si no queremos que leafnode trate de actualizar los
grupos de news cada semana es posible modificar el código fuente del
programa, aunque lo más sencillo es actualizar la fecha del fichero de
grupos para que leafnode lo trate como si se acabara de actualizar.
Esto se hace mediante la siguiente orden, que podemos poner en cualquier
fichero del sistema (por ejemplo en /etc/rc.d/rc.local):
<PRE>
  touch -m /var/spool/news/active.read
</PRE>

Este fichero (active.read) lo usa leafnode para saber cuándo fue la
última vez que buscó nuevos grupos de news en el servidor. Cuando
pasa una semana (fetch mirará para ello la fecha del fichero),
leafnode tratará de bajarse de nuevo la lista de grupos para ver
si hay grupos nuevos (proceso que suele tardar bastante). Para
evitar esto, touch actualiza la fecha del archivo y fetch nunca
detecta que haya pasado una semana, no actualizando la lista de
grupos y descripciones.
<P>En las últimas versiones, posiblemente podamos forzar a leafnode
a no leer la lista de grupos o a releerla de nuevo usando algún switch
de línea de comandos (al estilo fetch -n), para lo cual siempre es
aconsejable la lectura de la página man correspondiente (man fetch).
<P>
<P>
<P>
<H2><A NAME="ss10.16">10.16 Problemas de acceso con Leafnode</A>
</H2>

<P>Si al recoger las news con Netscape o cualquier otro cliente de news
obtenemos el siguiente mensaje de error:
<PRE>
  "An error occurred with the News server.
  If you are unable to connect again, contact the
  administrator for this server."
</PRE>

Lo primero que deberemos hacer será comprobar si leafnode está
correctamente funcionando en el puerto 119 de nuestra máquina,
haciendo un telnet localhost 119:
<PRE>
  [root@compiler]  telnet localhost 119
  Trying 127.0.0.1...
  Connected to localhost.
  Escape character is '^]'.
  Connection closed by foreign host.
</PRE>

En ese caso, debemos modificar los ficheros <CODE>/etc/hosts.allow</CODE> y
<CODE>/etc/hosts.deny</CODE> para permitir a nuestros usuarios que tengan
acceso a leafnode. Una manera es dejar vacíos ambos ficheros (así
es como lo tengo yo) permitiendo a cualquier el acceso a leafnode,
y otra es modificar el hosts.deny (nunca he necesitado realizarlo
así pero es otra manera de solucionarlo) es dejar el siguiente
contenido en el fichero <CODE>/etc/hosts.deny</CODE>:
<PRE>
  # /etc/hosts.deny
  # The PARANOID wildcard matches any host whose name does not
  # match its address.
  ALL: PARANOID
  #-- leafnode begin
  leafnode: ALL
  #-- leafnode end
</PRE>

Una salida de "telnet localhost 119" correcta debería ser:
<PRE>
  [root@compiler]  telnet localhost 119
  Trying 127.0.0.1...
  Connected to localhost
  Escape character is '^]'.
  200 Leafnode NNTP Daemon, version 1.4 running at localhost
</PRE>
<P>
<P>
<P>
<HR>
<A HREF="FAQ_Linux-11.html">Next</A>
<A HREF="FAQ_Linux-9.html">Previous</A>
<A HREF="FAQ_Linux.html#toc10">Contents</A>
</BODY>
</HTML>
