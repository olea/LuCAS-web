.\" MAN PAGE COMMENTS to
.\"
.\"	Chet Ramey
.\"	Information Network Services
.\"	Case Western Reserve University
.\"	chet@ins.CWRU.Edu
.\"
.\"	Last Change: Wed Apr  1 12:16:09 EST 1998
.\"
.\" Translated into Spanish on Wed 1 through Sat 18 July 1998 by
.\" Gerardo Aburruzaga García <gerardo@cica.es>
.\"
.\" bash_builtins, strip all but Built-Ins section
.if \n(zZ=1 .ig zZ
.TH BASH 1 "1 Abril 1998" GNU
.\"
.\" There's some problem with having a `@'
.\" in a tagged paragraph with the BSD man macros.
.\" It has to do with `@' appearing in the }1 macro.
.\" This is a problem on 4.3 BSD and Ultrix, but Sun
.\" appears to have fixed it.
.\" If you're seeing the characters
.\" `@u-3p' appearing before the lines reading
.\" `possible-hostname-completions
.\" and `complete-hostname' down in READLINE,
.\" then uncomment this redefinition.
.\"
.de }1
.ds ]X \&\\*(]B\\
.nr )E 0
.if !"\\$1"" .nr )I \\$1n
.}f
.ll \\n(LLu
.in \\n()Ru+\\n(INu+\\n()Iu
.ti \\n(INu
.ie !\\n()Iu+\\n()Ru-\w\\*(]Xu-3p \{\\*(]X
.br\}
.el \\*(]X\h|\\n()Iu+\\n()Ru\c
.}f
..
.\"
.\" File Name macro.  This used to be `.PN', for Path Name,
.\" but Sun" doesn't seem to like that very much.
.\"
.de FN
\fI\|\\$1\|\fP
..
.SH NOMBRE
bash \- GNU Bourne-Again SHell (el Shell de Bourne otra vez, de GNU)
.SH SINOPSIS
.B bash
[opciones]
[fichero]
.SH DERECHOS DE COPIA
.\" En el original, ".if n ... (C) ..." O sea, "si estamos en nroff
.\" (por contraposición a troff), ... se imprime (C) en vez de ©.
.\" Pero a mí no me gusta; esto está diseñado para leerse no con el
.\" código ASCII sino con el ISO-Latin1, que tiene el carácter ©, así
.\" que ¿por qué no utilizarlo? (N. del T.) 
.if n Bash es Copyright \(co 1989, 1991, 1993, 1995, 1996 por la Free Software Foundation, Inc.
.if t Bash es Copyright \(co 1989, 1991, 1993, 1995, 1996 por la Free Software Foundation, Inc. 
.SH DESCRIPCIÓN
.B Bash
es un intérprete de un lenguaje de órdenes compatible con \fBsh\fP que
ejecuta órdenes leídas desde la entrada estándar o desde un fichero. 
.B Bash
también incorpora características útiles tomadas de los shells de
\fIKorn\fP y \fIC\fP (\fBksh\fP y \fBcsh\fP).
.PP
.B Bash
está pensado con la intención de ser una implementación conforme con
la especificación POSIX de Shell y Herramientas, de la IEEE (Grupo de
Trabajo 1003\.2 de la IEEE).
.SH OPCIONES
Además de las opciones de un solo carácter documentadas en la
descripción de la orden interna \fBset\fP, \fBbash\fR
interpreta las siguientes opciones cuando es llamado:
.PP
.PD 0
.TP 10
.BI \-c "\| cadena\^"
Si la opción
.B \-c
está presente, entonces las órdenes se leen de
.IR cadena .
Si hay argumentos tras la
.IR cadena ,
se asignan a los parámetros posicionales, empezando por
.BR $0 .
.TP
.B \-r
Si la opción
.B \-r
está presente, entonces el shell se vuelve
.I restringido
(vea
.SM
.B "SHELL RESTRINGIDO"
más abajo).
.TP
.B \-i
Si la opción 
.B \-i
está presente, el shell es
.IR interactivo .
.TP
.B \-s
Si la opción
.B \-s
está presente, o si no quedan argumentos tras el procesado de las
opciones, entonces las órdenes se leen desde la entrada estándar. Esta
opción permite definir los parámetros posicionales cuando se llama a
un shell interactivo.
.TP
.B \-D
Se muestra en la salida estándar una lista de cadenas de caracteres
entrecomilladas precedidas por \fB$\fP.
Estas cadenas son las que están sujetas a traducción cuando la
localización en curso no es C ni POSIX.
Esta opción implica también la \fB\-n\fP; no se ejecuta ninguna orden.
.TP
.B \-\-
Un
.B \-\-
señala el fin de las opciones e inhabilita cualquier posterior
procesado de opciones. Cualesquier argumentos tras
.B \-\-
se tratan como nombres de fichero y argumentos. Un argumento
.B \-
es equivalente a \fB\-\-\fP.
.PD
.PP
.B Bash
también interpreta una variedad de opciones multi-carácter.
Estas opciones deben aparecer en la línea de órdenes antes de las
opciones de un solo carácter para que puedan ser reconocidas.
.PP
.PD 0
.TP
.B \-\-dump\-po\-strings
Equivalente a \fB\-D\fP, pero la salida es en el formato de un fichero
\fBpo\fP (objeto portable), del \fIgettext\fP de GNU.
.TP
.B \-\-dump\-strings
Equivalente a \fB\-D\fP.
.TP
.B \-\-help
Muestra un mensaje de modo de empleo en la salida estándar y acaba con
éxito.
.TP
.B \-\-login
Hace que
.B bash
actúe como si se le hubiera llamado como un shell de entrada (vea
.SM
.B LLAMADA
más abajo).
.TP
.B \-\-noediting
No utiliza la biblioteca de GNU
.B readline
para leer líneas de órdenes en interactivo.
.TP
.B \-\-noprofile
No lee ni el fichero de arranque de sistema
.FN /etc/profile
ni ninguno de los ficheros de inicio personales
.IR ~/.bash_profile ,
.IR ~/.bash_login ,
ni
.IR ~/.profile .
Por omisión,
.B bash
lee estos ficheros cuando se le llama como un shell de entrada (vea
.SM
.B LLAMADA
más adelante).
.TP
.B \-\-norc
No lee ni ejecuta el fichero de inicio personal
.I ~/.bashrc
si el shell es interactivo.
Esta opción está activa de forma predeterminada si el shell se llama como
.BR sh .
.TP
.B \-\-posix
Cambia el comportamiento de \fBbash\fP donde la operación normal
difiera del estándar POSIX 1003.2, de forma que concuerde con éste.
.TP
\fB\-\-rcfile\fP \fIfichero\fP
Ejecuta órdenes desde
.I fichero
en vez de desde el fichero de inicio personal estándar
.I ~/.bashrc
si el shell es interactivo (vea
.SM
.B LLAMADA
más abajo).
.TP
.B \-\-restricted
El shell se vuelve restringido (vea
.SM
.B "SHELL RESTRINGIDO"
más abajo).
.TP
.B \-\-verbose
Equivale a  \fB\-v\fP.
.TP
.B \-\-version
Muestra información en la salida estándar sobre la versión de esta
instanciación de 
.B bash
y acaba con éxito.
.PD
.SH ARGUMENTOS
Si quedan argumentos tras el procesado de las opciones, y no se han
dado ni la opción
.B \-c
ni la
.BR \-s ,
se supone que el primer argumento es el nombre de un fichero que
contiene órdenes del shell.
Si
.B bash
se llama de esta manera,
.B $0
se define con el nombre del fichero, y los parámetros posicionales se
definen con los restantes argumentos.
.B Bash
lee y ejecuta órdenes de este fichero, luego acaba.
El estado de salida de \fBbash\fP es el de la última orden ejecutada en
el guión.
Si no se ejecuta ninguna orden, el estado de salida es 0.
.SH LLAMADA
Un \fIshell de entrada\fP es aquél cuyo primer carácter del argumento
cero es un 
.BR \- ,
o uno que ha sido llamado con la opción
.BR \-\-login .
.PP
Un shell \fIinteractivo\fP es uno cuya entrada y salida estándares
están conectadas a terminales (según determina
.IR isatty (3)),
o uno que ha sido llamado con la opción
.BR \-i .
.SM
Se define
.B PS1
y
.B $\-
incluye
.B i
si
.B bash
es interactivo,
permitiendo así a un guión del shell o a un fichero de arranque el
comprobar este estado.
.PP
Los siguientes párrafos describen cómo
.B bash
ejecuta sus ficheros de arranque.
Si cualquiera de los ficheros existe pero no puede leerse,
.B bash
informa de un error.
Las tildes de la ñ se expanden en nombres de ficheros como se describe
más abajo en
.B "Expansión de la tilde"
en la sección
.SM
.BR EXPANSIÓN .
.PP
Cuando
.B bash
se llama como un shell de entrada interactivo, primero lee y ejecuta
órdenes desde el fichero \fI/etc/profile\fP, si es que existe.
Tras leer ese fichero, busca \fI~/.bash_profile\fP,
\fI~/.bash_login\fP, y \fI~/.profile\fP, en ese orden, y lee y ejecuta
órdenes del primero de ellos que exista y se pueda leer.
La opción
.B \-\-noprofile
puede emplearse cuando se llame al shell para inhibir este
comportamiento. 
.PP
Cuando un shell de entrada termina,
.B bash
lee y ejecuta órdenes desde el fichero \fI~/.bash_logout\fP, si existe.
.PP
Cuando se arranca un shell interactivo que no es de entrada,
.B bash
lee y ejecuta órdenes desde \fI~/.bashrc\fP, si es que existe.
Esto puede evitarse mediante la opción
.BR \-\-norc .
La opción \fB\-\-rcfile\fP \fIfichero\fP forzará a
.B bash
a leer y ejecutar órdenes desde \fIfichero\fP en vez de \fI~/.bashrc\fP.
.PP
Cuando
.B bash
se arranque de forma no interactiva, por ejemplo para ejecutar un
guión del shell, busca la variable
.SM
.B BASH_ENV
en el entorno, expande su valor si está definida, y utiliza el valor
expandido como el nombre de un fichero a leer y ejecutar.
.B Bash
se comporta como si se ejecutaran las siguientes órdenes:
.sp .5
.RS
\f(CWif [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi\fR
.RE
.sp .5
pero el valor de la variable
.SM
.B PATH
no se emplea para buscar el nombre del fichero.
.PP
Si
.B bash
se llama con el nombre
.BR sh ,
intenta imitar el comportamiento de arranque de versiones históricas de
.B sh
tanto como sea posible, pero sin salirse del
estándar POSIX.
Cuando se llama como un shell interactivo de entrada, primero intenta
leer y ejecutar órdenes desde
.I /etc/profile
y
.IR ~/.profile ,
en ese orden.
La opción
.B \-\-noprofile
puede emplearse para inhibir este comportamiento.
Cuando se llama como un shell interactivo con el nombre
.BR sh ,
.B bash
busca la variable
.SM
.BR ENV ,
expande su valor si está definida, y emplea el valor expandido como el
nombre de un fichero a leer y ejecutar.
Como un shell llamado como
.B sh
no intenta leer y ejecutar órdenes desde cualquier otro fichero de
arranque, la opción
.B \-\-rcfile
no tiene efecto.
Un shell no interactivo llamado con el nombre
.B sh
no intenta leer ningún fichero de arranque.
Cuando se llama como
.BR sh ,
.B bash
entra en modo
.I posix
después de leer los ficheros de arranque.
.PP
Cuando
.B bash
se arranca en modo
.IR posix ,
como ocurre cuando se da la opción de línea de órdenes
.BR \-\-posix ,
sigue el estándar POSIX para los ficheros de arranque.
En este modo, los shells interactivos expanden la variable
.SM
.B ENV
y se leen y ejecutan órdenes desde el fichero cuyo nombre es el valor
expandido de dicha variable. 
No se lee ningún otro fichero de arranque.
.PP
.B Bash
intenta determinar cuándo está siendo llamado por el duende de shell
remoto, usualmente \fIrshd\fP.
Si
.B bash
determina que está siendo ejecutado por \fIrshd\fP, lee y ejecuta
órdenes desde \fI~/.bashrc\fP, si tal fichero existe y se puede leer.
Esto no lo hará si se le llama con el nombre \fBsh\fP.
La opción
.B \-\-norc
puede emplearse para inhibir este comportamiento, y la opción
.B \-\-rcfile
puede utilizarse para forzar la lectura de otro fichero, pero
\fIrshd\fP no llama generalmente al shell con estas opciones ni
permite que se den.
.SH DEFINICIONES
.PP
Las siguientes definiciones se usan a través del resto de este documento.
.PD 0
.TP
.B blanco
Un espacio en blanco o tabulación (tab).
.TP
.B palabra
Una secuencia de caracteres considerados por el shell como una sola
unidad. 
También se conoce como un
.B lexema 
(token).
.TP
.B nombre
Una
.I palabra
que consiste solamente en caracteres alfanuméricos y subrayados, y
comienza con un carácter alfabético o un subrayado. También se llama
.BR identificador .
.TP
.B metacarácter
Un carácter que, cuando no está entrecomillado, separa palabras. Uno
de los siguientes:
.br
.RS
.PP
.if t \fB|  &  ;  (  )  <  >  espacio  tab\fP
.if n \fB|  & ; ( ) < > espacio tab\fP
.RE
.PP
.TP
.B operador de control
Un \fIlexema\fP que realiza una función de control. Es uno de los
siguientes símbolos:
.RS
.PP
.if t \fB\(bv\(bv  &  &&  ;  ;;  (  )  |  <nueva-línea>\fP
.if n \fB|| & && ; ;; ( ) | <nueva-línea>\fP
.RE
.PD
.SH "PALABRAS RESERVADAS"
\fIPalabras reservadas\fP son palabras que tienen un significado
especial para el shell. Las siguientes palabras se reconocen como
reservadas cuando no van entrecomilladas y, o son la primera palabra
de una orden simple (vea 
.SM
.B GRAMÁTICA DEL SHELL
más abajo) o la tercera palabra de una orden
.B case 
o
.BR for :
.if t .RS
.PP
.B
.if n ! case  do done elif else esac fi for function if in select then until while { } time [[ ]]
.if t !    case    do    done    elif    else    esac    fi    for    function    if    in    select    then    until    while    {    }    time    [[    ]]
.if t .RE
.RE
.SH "GRAMÁTICA DEL SHELL"
.SS Órdenes simples
.PP
Una \fIorden simple\fP es una secuencia de asignaciones opcionales de
variables seguida por palabras separadas por \fBblancos\fP y
redirecciones, y terminadas por un \fIoperador de control\fP. La
primera palabra especifica la orden a ser ejecutada. Las palabras
restantes se pasan como argumentos a la orden pedida.
.PP
El valor devuelto de una \fIorden simple\fP es su estado de salida, ó
128+\fIn\^\fP si la orden ha terminado debido a la señal
.IR n .
.SS Tuberías
.PP
Una \fItubería\fP es una secuencia de una o más órdenes separadas por
el carácter
.BR | .
El formato de una tubería es:
.RS
.PP
[\fBtime\fP [\fB\-p\fP]] [ ! ] \fIorden\fP [ \fB|\fP \fIorden2\fP ... ]
.RE
.PP
La salida estándar de
.I orden
se conecta a la entrada estándar de
.IR orden2 .
Esta conexión se realiza antes que cualquier redirección especificada
por la orden (vea
.SM
.B REDIRECCIÓN
más abajo).
.PP
Si la palabra reservada
.B !
precede una tubería, el estado de salida de ésta es el NO lógico del
de la última orden. De otro modo, el estado de la tubería es el de
salida de la última orden.
El shell espera que todas las órdenes de la tubería terminen antes de
devolver un valor.
.PP
Si la palabra reservada
.B time
precede una tubería, se informa del tiempo transcurrido, así como del
de usuario y sistema, consumido en la ejecución de la tubería, cuando
ésta termina.
La opción \fB\-p\fP cambia el formato de salida al especificado por POSIX.
La variable
.SM
.B TIMEFORMAT
puede definirse como una cadena de caracteres de formato que
especifique cómo la información de tiempos debería mostrarse; vea la
descripción de
.SM
.B TIMEFORMAT
bajo
.B "Variables del Shell"
más abajo.
.PP
Cada orden en una tubería se ejecuta como un proceso separado (esto
es, en un subshell).
.SS Listas
.PP
Una \fIlista\fP es una secuencia de una o más tuberías separadas por
uno de los operadores
.BR ; ,
.BR & ,
.BR && ,
o
.BR \(bv\(bv ,
y terminada opcionalmente por uno de
.BR ; ,
.BR & ,
o
.BR <nueva-línea> .
.PP
De estos operadores de listas,
.B &&
y
.B \(bv\(bv
tienen igual precedencia, seguidos por
.B ;
y
.BR &,
que tienen igual precedencia.
.PP
Si una orden se termina mediante el operador de control
.BR & ,
el shell ejecuta la orden en \fIsegundo plano\fP en un subshell.
El shell no espera que la orden acabe, y el estado devuelto es 0. Las
órdenes separadas por un
.B ;
se ejecutan secuencialmente; el shell espera que cada orden termine,
por orden. El estado devuelto es el estado de salida de la última
orden ejecutada.
.PP
Los operadores de control
.B &&
y
.B \(bv\(bv
denotan listas Y (AND) y O (OR) respectivamente.
Una lista Y tiene la forma
.RS
.PP
\fIorden\fP \fB&&\fP \fIorden2\fP
.RE
.PP
.I orden2
se ejecuta si y sólo si
.I orden
devuelve un estado de salida 0.
.PP
Una lista O tiene la forma
.RS
.PP
\fIorden\fP \fB\(bv\(bv\fP \fIorden2\fP
.PP
.RE
.PP
.I orden2
se ejecuta si y sólo si
.I orden
devuelve un estado de salida distinto de cero. El estado de salida de
las listas Y y O es el de la última orden ejecutada en la lista.
.SS Órdenes compuestas
.PP
Una \fIorden compuesta\fP es una de las siguientes:
.TP
(\fIlista\fP)
\fIlista\fP se ejecuta en un subshell. Después de que la orden se
completa, las asignaciones a variables y órdenes internas que
afectaran al entorno del shell no permanecen en efecto. El estado de
retorno es el de salida de \fIlista\fP.
.TP
{ \fIlista\fP; }
\fIlista\fP se ejecuta simplemente en el entorno del shell en curso.
\fIlista\fP debe terminarse con un salto de línea o un punto y coma.
Esto se conoce como una \fIorden de grupo\fP.
El estado de retorno es el de salida de
\fIlista\fP.
.TP
((\fIexpresión\fP))
La \fIexpresión\fP se evalúa de acuerdo a las reglas descritas abajo
bajo la sección
.SM
.BR "EVALUACIÓN ARITMÉTICA" .
Si el valor de la expresión es distinto de cero, el estado de retorno
es 0; de otro modo el estado de retorno es 1. Esto es equivalente
exactamente a
\fBlet "\fIexpresión\fP"\fR.
.TP
\fB[[\fP \fIexpresión\fP \fB]]\fP
Devuelve un estado de 0 ó 1 dependiendo de la evaluación de la
expresión condicional \fIexpresión\fP.
Las expresiones se componen de las primarias descritas adelante bajo
.SM
.BR "EXPRESIONES CONDICIONALES" .
No tienen lugar división de palabras ni expansión de nombres de camino
en las palabras entre el \fB[[\fP y el \fB]]\fP; sí se realizan la
expansión de tilde, expansión de parámetros y variables, expansión
aritmética, sustitución de orden, sustitución de proceso y eliminación
de comillas.
.if t .sp 0.5
.if n .sp 1
Cuando se emplean los operadores \fB==\fP y \fB!=\fP, la cadena a la
derecha del operador se considera un patrón y se hace concordar de
acuerdo a las reglas descritas más adelante bajo el epígrafe
\fBConcordancia de patrones\fP.
El valor devuelto es 0 si la cadena concuerda o no concuerda con el
patrón, respectivamente, y 1 en otro caso.
Cualquier parte del patrón puede entrecomillarse para forzar la
concordancia como una cadena de caracteres pura.
.if t .sp 0.5
.if n .sp 1
Las expresiones pueden combinarse mediante los siguientes operadores,
listados en orden decreciente de precedencia:
.if t .sp 0.5
.if n .sp 1
.RS
.PD 0
.TP
.B ( \fIexpresión\fP )
Devuelve el valor de \fIexpresión\fP.
Esto puede emplearse para cambiar la precedencia normal de los operadores.
.TP
.B ! \fIexpresión\fP
Verdad si
.I expresión
es falsa.
.TP
\fIexpresión1\fP \fB&&\fP \fIexpresión2\fP
Verdad si ambas
.I expresión1
y
.I expresión2
son verdaderas.
.TP
.if t \fIexpresión1\fP \fB\(bv\(bv\fP \fIexpresión2\fP
.if n \fIexpresión1\fP \fB||\fP \fIexpresión2\fP
Verdad si una al menos de
.I expresión1
o
.I expresión2
es verdad.
.PD
.RE
.LP
Los operadores \fB&&\fP y
.if t \fB\(bv\(bv\fP
.if n \fB||\fP
no ejecutan \fIexpresión2\fP si el valor de
\fIexpresión1\fP es suficiente para determinar el valor de retorno de
la expresión condicional entera.
.TP
\fBfor\fP \fInombre\fP [ \fBin\fP \fIpalabra\fP; ] \fBdo\fP \fIlista\fP ; \fBdone\fP
La lista de palabras que va detrás de \fBin\fP se expande, generando
una lista de elementos. La variable \fInombre\fP se define como cada
elemento de la lista en cada iteración, y \fIlista\fP se ejecuta cada
vez. Si la \fIpalabra\fP de \fBin\fP se omite, la orden \fBfor\fP
ejecuta \fIlista\fP una vez para cada parámetro posicional que esté
definido (vea
.SM
.B PARÁMETROS
más abajo).
El estado de retorno es el de salida de la última orden que se
ejecuta.
Si la expansión de los elementos después del \fBin\fP resulta en una
lista vacía, no se ejecuta ninguna orden y el estado de salida es 0.
.TP
\fBselect\fP \fInombre\fP [ \fBin\fP \fIpalabra\fP; ] \fBdo\fP \fIlista\fP ; \fBdone\fP 
La lista de palabras que sigue a \fBin\fP se expande, generando una
lista de elementos. El conjunto de palabras expandidas se muestra en
la salida estándar de errores, cada una precedida por un número. Si la
\fIpalabra\fP del \fBin\fP se omite, se muestran los parámetros
posicionales (vea
.SM
.B PARÁMETROS
más abajo).  Entonces se muestra el indicador
.B PS3
y se lee una línea desde la entrada estándar.
Si la línea consiste en un número correspondiente a una de las
palabras mostradas, entonces el valor de
.I nombre
se pone a esa palabra. Si la línea está vacía, las palabras y el
indicador se muestran de nuevo. Si se lee EOF, la orden se
completa. Cualquier otro valor leída hace que
.I nombre
se ponga a un valor vacío. La línea leída se guarda en la variable
.BR REPLY .
La
.I lista
se ejecuta tras cada selección hasta que se ejecute una orden
.B break
o
.BR return .
El estado de salida de
.B select
es el de la última orden ejecutada en
.IR lista ,
o cero si no se ha ejecutado ninguna orden.
.TP
\fBcase\fP \fIpalabra\fP \fBin\fP [ ( \fIpatrón\fP [ \fB|\fP \fIpatrón\fP ] \
... ) \fIlista\fP ;; ] ... \fBesac\fP
Una orden \fBcase\fP expande primero \fIpalabra\fP, e intenta hacerla
concordar contra cada \fIpatrón\fP por turnos, empleando las mismas
reglas de concordancia que para la expansión de nombres de caminos (vea
.B Expansión de nombre de camino
más abajo).  Cuando se encuentre una concordancia, se ejecuta la
\fIlista\fP correspondiente. Tras la primera concordancia, no se
intentan más. El estado de salida es cero si no concuerda ningún
patrón. De otro modo, es el estado de salida de la última orden
ejecutada en \fIlista\fP. 
.TP
\fBif\fP \fIlista\fP; \fBthen\fP \fIlista;\fP \
[ \fBelif\fP \fIlista\fP; \fBthen\fP \fIlista\fP; ] ... \
[ \fBelse\fP \fIlista\fP; ] \fBfi\fP
La
.I lista
.B if 
se ejecuta. Si su estado de salida es cero, se ejecuta la
\fIlista\fP \fBthen\fP. De otro modo, se ejecuta por turno cada
\fIlista\fP \fBelif\fP, y si su estado de salida es cero, se ejecuta
la \fIlista\fP \fBthen\fP correspondiente y la orden se completa. Si
no, se ejecuta la \fIlista\fP \fBthen\fP si está presente. El estado
de salida es el de la última orden ejecutada, o cero si ninguna
condición fue verdadera.
.TP
.PD 0
\fBwhile\fP \fIlista\fP; \fBdo\fP \fIlista\fP; \fBdone\fP
.TP
\fBuntil\fP \fIlista\fP; \fBdo\fP \fIlista\fP; \fBdone\fP
.PD
La orden \fBwhile\fP ejecuta continuamente la \fIlista\fP \fBdo\fP
siempre que la última orden de \fIlista\fP devuelva un estado de
salida cero. La orden \fBuntil\fP es idéntica a la \fBwhile\fP,
excepto en que la comprobación es al revés;
la
.I lista
.B do
se ejecuta mientras que la última orden en
.I lista
devuelva un estado de salida distinto de cero.
El estado de salida de las órdenes \fBwhile\fP y \fBuntil\fP es el de
la última orden de la \fIlista\fP \fBdo\fP ejecutada, o cero si no se
ejecutó ninguna orden. 
.TP
[ \fBfunction\fP ] \fInombre\fP () { \fIlista\fP; }
Esto define una función llamada \fInombre\fP. El \fIcuerpo\fP de la
función es la
.I lista
de órdenes entre { y } . Esta lista se ejecuta cada vez que se
especifica \fInombre\fP como el nombre de una orden simple. El estado
de salida de una función es el de la última orden ejecutada en el
cuerpo. (Vea
.SM
.B FUNCIONES
más abajo.)
.SH COMENTARIOS
En un shell no interactivo, o en uno interactivo en el que la opción 
.B interactive_comments
de la orden interna
.B shopt
está activa (vea
.SM
.B "ÓRDENES INCORPORADAS DEL SHELL"
más abajo), una palabra que empiece por
.B #
hace que esa palabra y todos los caracteres que queden en esa línea no
sean tenidos en cuenta. Un shell interactivo sin la opción 
.B interactive_comments
habilitada, no admite comentarios. La opción
.B interactive_comments
está activa de forma predeterminada en shells interactivos.
.SH ENTRECOMILLADO
El \fIentrecomillado\fP se emplea para quitar el significado especial
para el shell de ciertos metacaracteres o palabras. Puede emplearse
para que no se traten caracteres especiales de forma especial, para
que palabras reservadas no sean reconocidas como tales, y para evitar
la expansión de parámetros.
.PP
Cada uno de los \fImetacaracteres\fP listados a continuación bajo el
epígrafe 
.SM
.B DEFINICIONES
tiene un significado especial para el shell y deben ser protegidos o
entrecomillados si quieren representarse a sí mismos. Hay 3 mecanismos
de protección: el 
.IR "carácter de escape" ,
comillas simples, y comillas dobles.
.PP
Una barra inclinada inversa no entrecomillada (\fB\e\fP) es el
.IR "carácter de escape" .
Preserva el valor literal del siguiente carácter que lo acompaña, con
la excepción de <nueva-línea>.  Si aparece un par \fB\e\fP<nueva-línea>
y la barra invertida no está ella misma entre comillas, el \fB\e\fP<nueva-línea>
se trata como una continuación de linea (esto es, se quita del flujo
de entrada y no se tiene efectivamente en cuenta).
.PP
Encerrar caracteres entre apóstrofos preserva el valor literal de cada
carácter entre las comillas. Una comilla simple no puede estar entre
comillas simples, ni siquiera precedida de una barra invertida.
.PP
Encerrar caracteres entre comillas dobles preserva el valor literal de
todos los caracteres de dentro de las comillas, con la excepción de
.BR $ ,
.BR ` ,
y
.BR \e .
Los caracteres
.B $
y
.B `
mantienen sus significados especiales dentro de comillas dobles. La
barra invertida mantiene su significado especial solamente cuando está
seguida por uno de los siguientes caracteres:
.BR $ ,
.BR ` ,
\^\fB"\fP\^",
.BR \e ,
o
.BR <nueva-línea> .
Una comilla doble puede ser entrecomillada entre otras comillas dobles
precediéndola de una barra invertida.
.PP
Los parámetros especiales
.B *
y
.B @
tienen un significado especial cuando están entre comillas dobles (vea
.SM
.B PARÁMETROS
más abajo).
.PP
Las palabras de la forma \fB$\fP'\fIcadena\fP' se tratan de forma
especial. La palabra se expanda a \fIcadena\fP, con los caracteres
protegidos par barra invertida reemplazados según especifica el
estándar ANSI/ISO de C. Las secuencias de escape con barra invertida,
si están presentes, se descodifican como sigue:
.RS
.PD 0
.TP
.B \ea
alerta (campana)
.TP
.B \eb
espacio-atrás
.TP
.B \ee
un carácter de escape (ESC)
.TP   
.B \ef
nueva página
.TP  
.B \en
nueva linea
.TP     
.B \er
retorno de carro
.TP
.B \et
tabulación horizontal
.TP   
.B \ev
tabulación vertical
.TP
.B \e\e
barra invertida
.TP   
.B \e\fInnn\fP
el carácter cuyo código es el valor octal \fInnn\fP (de uno a tres dígitos)
.TP
.B \ex\fInnn\fP
el carácter cuyo código es el valor hexadecimal \fInnn\fP
.PD
.RE
.LP
El resultado traducido es entrecomillado con comillas simples, como si
el signo de dólar no hubiera estado presente.
.PP
Una cadena entre comillas dobles precedida por un signo de dólar
(\fB$\fP) hará que la cadena se traduzca según la localización en
curso. Si ésta es \fBC\fP o \fBPOSIX\fP, el signo de dólar no se tiene
en cuenta.
Si la cadena se traduce y reemplaza, el reemplazo se entrecomilla con
comillas dobles.
.SH PARÁMETROS
Un
.I parámetro
es una entidad que almacena valores.
Puede ser un 
.IR nombre ,
un número, o uno de los caracteres especiales listados a continuación
bajo el epígrafe
.BR "Parámetros especiales" .
En lo que se refiere al shell, una
.I variable
es un parámetro identificado por un
.IR nombre .
.PP
Un parámetro está definido si se le ha asignado un valor. La cadena
vacía es un valor válido. Una vez que una variable está definida, sólo
puede quitarse de la lista de variables mediante la orden interna
.B unset
(vea 
.SM
.B ÓRDENES INTERNAS DEL SHELL
más adelante).
.PP
A una
.I variable
se le puede asignar un valor mediante una sentencia de la forma 
.RS
.PP
\fInombre\fP=[\fIvalor\fP]
.RE
.PP
Si no se da el
.IR valor ,
a la variable se asigna la cadena vacía. Todos los
.I valores
están sujetos a expansión de tilde, de parámetros y variables, de
cadena, de orden, aritmética, y eliminación de comillas (vea
.SM
.B EXPANSIÓN
más abajo).  Si la variable tiene activado su atributo
.B integer
(vea
.B declare
más abajo en
.SM
.BR "ÓRDENES INTERNAS DEL SHELL" )
entonces
.I valor
está sujeto a expansión aritmética incluso si no se emplea la
expansión $((...)) (vea
.B "Expansión aritmética"
más adelante).
No se realiza la división de palabras, con la excepción de
\fB"$@"\fP como se explica más adelante bajo el epígrafe
.BR "Parámetros especiales" .
La expansión de nombres de camino no se efectúa.
.SS Parámetros posicionales
.PP
Un
.I parámetro posicional
es un parámetro denotado por uno o más dígitos, distintos del simple
0. Los parámetros posicionales se asignan a partir de los argumentos
del shell cuando éste es llamado, y pueden ser reasignados mediante la
orden interna
.BR  set .
Los parámetros posicionales no pueden ser asignados con sentencias de
asignación. Los parámetros posicionales se reemplazan temporalmente
cuando se ejecuta una función del shell (vea
.SM
.B FUNCIONES
abajo).
.PP
Cuando un parámetro posicional consistente en más de un solo dígito se
expande, debe rodearse por llaves (vea
.SM
.B EXPANSIÓN
abajo).
.SS Parámetros especiales
.PP
El shell trata de forma especial a ciertos parámetros. Éstos sólo
pueden referenciarse; no se permite asignarles nada. 
.PD 0
.TP
.B *
Se expande a los parámetros posicionales, empezando por 1. Cuando la
expansión ocurre entre comillas dobles, se expande a una sola palabra
con el valor de cada parámetro separado por el primer carácter de la
variable especial
.SM
.BR IFS .
Esto es, "\fB$*\fP" es equivalente 
a "\fB$1\fP\fIc\fP\fB$2\fP\fIc\fP\fB...\fP", donde
.I c
es el primer carácter del valor de la variable
.SM
.BR IFS .
Si
.SM
.B IFS
no está definida, los parámetros se separan por espacios.
Si
.SM
.B IFS
es la cadena vacía, los parámetros se juntan sin ningún separador.
.TP
.B @
Se expande a los parámetros posicionales, empezando desde 1. Cuando la
expansión ocurre dentro de comillas dobles, cada parámetro se expande
a una palabra separada. Esto es, "\fB$@\fP" es equivalente a
"\fB$1\fP" "\fB$2\fP" ...
Cuando no hay parámetros posicionales, "\fB$@\fP" y
.B $@
se expanden a nada (esto es, se borran).
.TP
.B #
Se expande al número en base 10 de parámetros posicionales.
.TP
.B ?
Se expande al estado de la tubería más recientemente ejecutada en
primer plano.
.TP
.B \-
Se expande a las opciones del shell activas actualmente según se hayan
especificado en la llamada, mediante la orden interna
.BR set ,
o las que haya puesto el mismo shell (como la opción
.BR \-i ).
.TP
.B $
Se expande al PID del shell. En un subshell (), se expande al PID del
shell actual, no al del subshell.
.TP
.B !
Se expande al PID de la orden más recientemente ejecutada en segundo
plano (asíncronamente).
.TP
.B 0
Se expande al nombre del shell o guión del shell. Este parámetro se
pone en el inicio del shell. Si
.B bash
se llama con un fichero de órdenes,
.B $0
se pone al nombre de ese fichero. Si
.B bash
se arranca con la opción 
.BR \-c ,
entonces
.B $0
se pone al primer argumento tras la cadena que se va a ejecutar, si
hay alguno presente. Si no, se pone al nombre de fichero empleado para
llamar a
.BR bash ,
como se da en el argumento cero.
.TP
.B _
En el arranque del shell, se pone al nombre absoluto de fichero del
shell o guión del shell que se está ejecutando, tal como se ha pasado
en la lista de argumentos. 
Subsecuentemente, se expande al último argumento de la orden anterior,
tras la expansión.
También se pone al nombre completo del fichero de cada orden ejecutada,
y se pone en el entorno exportado a esa orden.
Cuando se está comprobando si hay correo nuevo, este parámetro
contiene el nombre del fichero de correo o buzón que se está
comprobando actualmente.
.PD
.SS Variables del shell
.PP
El shell pone automáticamente las siguientes variables:
.PP
.PD 0
.TP
.B PPID
El PID del proceso padre del shell. Esta variable es de lectura exclusiva.
.TP
.B PWD
El directorio de trabajo actual como lo pone la orden
.BR cd .
.TP
.B OLDPWD
El directorio de trabajo anterior como lo puso la orden
.BR cd .
.TP
.B REPLY
La línea de entrada leída por la orden interna
.B read
cuando no se le dan argumentos.
.TP
.B UID
Se expande al UID del usuario en curso, puesta en el arranque del
shell. Esta variable es de lectura exclusiva.
.TP
.B EUID
Se expande al UID efectivo del usuario en curso, puesta en el arranque del
shell. Esta variable es de lectura exclusiva.
.TP
.B GROUPS
Una variable vector conteniendo la lista de grupos de los que el
usuario actual es miembro. Esta variable es de lectura exclusiva.
.TP
.B BASH
Se expande al nombre completo del fichero empleado para llamar a esta
instancia de
.BR bash .
.TP
.B BASH_VERSION
Se expande a una cadena que describe la versión de esta instancia de 
.BR bash .
.TP
.B BASH_VERSINFO
Una variable vector de lectura exclusiva cuyos miembros contienen
información de versión para esta instancia de
.BR bash .
Los valores asignados a los miembros del vector son como sigue:
.sp .5
.RS
.PD 0
.TP 24
.B BASH_VERSINFO[\fR0\fP]
El número mayor de versión (la \fIdistribución\fP).
.TP
.B BASH_VERSINFO[\fR1\fP]
El número menor de versión (la \fIversión\fP).
.TP
.B BASH_VERSINFO[\fR2\fP]
El nivel de parcheo.
.TP
.B BASH_VERSINFO[\fR3\fP]
La versión de construcción.
.TP
.B BASH_VERSINFO[\fR4\fP]
El estado de la distribución (por ejemplo, \fIbeta1\fP).
.TP
.B BASH_VERSINFO[\fR5\fP]
El valor de \fBMACHTYPE\fP.
.PD
.RE
.TP
.B SHLVL
Se incrementa en uno cada vez que se arranca una nueva instancia de
.BR bash .
.TP
.B RANDOM
Cada vez que este parámetro sea referenciado, se genera un entero
aleatorio entre 0 y 32767. La secuencia de números aleatorios puede
iniciarse asignando un valor a 
.SM
.BR RANDOM .
Si
.SM
.B RANDOM
no está definido, pierde sus propiedades especiales, incluso si
posteriormente es redefinido.
.TP
.B SECONDS
Cada vez que este parámetro es referenciado, se devuelve en él el
número de segundos transcurridos desde la llamada al shell. Si se
asigna un valor a
.SM
.BR SECONDS ,
el valor devuelto en posteriores referencias es el número de segundos
desde la asignación más el valor asignado.
Si
.SM
.B SECONDS
no está definido, pierde sus propiedades especiales, incluso si
posteriormente es redefinido.
.TP
.B LINENO
Cada vez que este parámetro es referenciado, el shell sustituye un
número en base 10 representando el número de línea secuencial actual
(empezando por 1) dentro de un guión o función. Si no estamos en un
guión o función, no se garantiza que el valor sustituido tenga
significado. 
Si
.SM
.B LINENO
no está definido, pierde sus propiedades especiales, incluso si
posteriormente es redefinido.
.TP
.B HISTCMD
El número de "historia", o índice en la lista "histórica", de la orden
actual.
Si
.SM
.B HISTCMD
no está definido, pierde sus propiedades especiales, incluso si
posteriormente es redefinido.
.TP
.B DIRSTACK
Una variable vector (vea
.B Vectores
más abajo) que aloja los contenidos actuales de la pila de
directorios. Los directorios aparecen en la pila en el orden en el que
se muestran con la orden interna
.BR dirs .
La asignación a miembros de este vector puede emplearse para modificar
directorios que ya estén en la pila, pero entonces deben utilizarse
las órdenes internas
.B pushd
y
.B popd
para añadir y quitar directorios.
La asignación a esta variable no cambiará el directorio de trabajo.
Si
.SM
.B DIRSTACK
no está definido, pierde sus propiedades especiales, incluso si
posteriormente es redefinido.
.TP
.B PIPESTATUS
Una variable vector (vea
.B Vectores
más abajo) que contiene una lista de valores de estado de salida de
los procesos en la tubería en primer plano ejecutada más recientemente
(que puede contener una sola orden).
.TP
.B OPTARG
El valor del último argumento que es una opción procesado por la orden
interna
.B getopts
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
más abajo).
.TP
.B OPTIND
El índice del siguiente argumento a ser procesado por la orden 
interna
.B getopts
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
más abajo).
.TP
.B HOSTNAME
Puesto automáticamente al nombre del anfitrión (computador) actual.
.TP
.B HOSTTYPE
Puesto automáticamente a una cadena que describe de forma unívoca el
tipo de máquina en la que
.B bash
se está ejecutando.
El valor predefinido depende del sistema.
.TP
.B OSTYPE
Puesto automáticamente a una cadena que describe el sistema operativo
en el que
.B bash
se está ejecutando.
El valor predefinido depende del sistema. En Linux es "linux".
.TP
.B MACHTYPE
Puesto automáticamente a una cadena que describe completamente el tipo
de sistema en el que
.B bash
se está ejecutando, en el formato estándar de GNU
\fIcpu-compañía-sistema\fP. 
El valor predefinido depende del sistema.
.TP
.B SHELLOPTS
Una lista, de elementos separados por dos puntos, de opciones activas
del shell. Cada palabra en la lista es un argumento válido para la
opción  
.B \-o
de la orden interna
.B set
(vea
.SM
.B "ÓRDENES INTERNAS DEL SHELL"
abajo). Las opciones que aparecen en
.SM
.B SHELLOPTS
son aquéllas que aparecen como
.I on
en \fBset \-o\fP.
Si esta variable está en el ambiente cuando
.B bash
empieza, cada opción del shell en la lista se activará antes de leer
cualquier fichero de inicio.
Esta variable es de lectura exclusiva.
.PD
.PP
El shell hace uso de las siguientes variables. En algunos casos, 
.B bash
asigna un valor predeterminado a una variable; estos casos se dicen
abajo. 
.PP
.PD 0
.TP
.B IFS
El
.I Separador Interno de Campo
que se emplea para la división de palabras tras la expansión y para
dividir líneas en palabras con la orden interna
.BR read .
El valor predeterminado es ``<espacio><tab><nueva-línea>''.
.TP
.B PATH
El camino de búsqueda para órdenes, programas ejecutables. Es una
lista de directorios separados por dos puntos en los cuales el shell
busca órdenes (vea
.SM
.B EJECUCIÓN DE ÓRDENES
más abajo). El camino predeterminado depende del sistema, y lo pone el
administrador que instala
.BR bash .
Un valor común es ``/usr/local/bin:/bin:/usr/bin:.''.
.TP
.B HOME
El directorio inicial de trabajo del usuario en curso; el argumento
predeterminado para la orden interna \fBcd\fP.
El valor de esta variable se usa también cuando se realiza la
expansión de tilde.
.TP
.B CDPATH
El camino de búsqueda para la orden
.BR cd .
Es una lista de directorios separados por dos puntos en los cuales el
shell busca directorios destino especificados por la orden
.BR cd .
Un valor de muestra es ``.:~:/usr''.
.TP
.B BASH_ENV
Si este parámetro está definido cuando \fBbash\fP está ejecutando un
guión del shell, su valor se interpreta como un nombre de fichero que
contiene órdenes para iniciar el shell, como en
.IR ~/.bashrc .
El valor de
.SM
.B BASH_ENV
está sujeto a expansión de parámetros, sustitución de órdenes y
expansión aritmética, antes de ser interpretado como un nombre de
fichero. 
.SM
.B PATH
no se usa para buscar el nombre de fichero resultante.
.TP
.B MAIL
Si este parámetro está puesto a un nombre de fichero y la variable
.SM
.B MAILPATH
no está definida,
.B bash
informa al usuario de la llegada de correo en el fichero
especificado. 
.TP
.B MAILCHECK
Especifica cuán a menudo (en segundos)
.B bash
comprueba si hay correo nuevo. El valor predeterminado es 60 s. Cuando
es tiempo de comprobar si hay correo, el shell lo hace antes de
mostrar el indicador primario. Si esta variable no está definida, el
shell no comprueba si hay correo nuevo.
.TP
.B MAILPATH
Una lista de nombres de fichero separados por dos puntos donde hay que
comprobar si hay correo nuevo. El mensaje que haya que mostrar cuando
llegue correo a un fichero particular puede especificarse separando el
nombre de fichero del mensaje con un '?'. Cuando se use en el texto
del mensaje, \fB$_\fP se expande al nombre del fichero de correo en curso.
Ejemplo:
.RS
.PP
\fBMAILPATH\fP='/var/spool/mail/bfox?"Tienes carta":~/shell\-mail?"¡$_ tiene carta!"'
.PP
.B Bash
proporciona un valor predeterminado para esta variable, pero la
localización de los ficheros de correo del usuario que emplea es
dependiente del sistema (e.g., /var/spool/mail/\fB$USER\fP).
.RE
.TP
.B PS1
El valor de este parámetro se expande (vea
.SM
.B INDICADORES
abajo) y se emplea como la cadena del indicador primario. El valor
predeterminado es ``\fB\es\-\ev\e$ \fP''.
.TP
.B PS2
El valor de este parámetro se expande como con
.B PS1
y se emplea como la cadena del indicador secundario. El valor
predeterminado es ``\fB> \fP''.
.TP
.B PS3
El valor de este parámetro se emplea como el indicador para la orden
.B select
(vea
.SM
.B GRAMÁTICA DEL SHELL
más arriba).
.TP
.B PS4
El valor de este parámetro se expande como con
.B PS1
y el valor se imprime antes de cada orden que
.B bash
muestra durante una traza de ejecución. El primer carácter de
.SM
.B PS4
se replica múltiples veces, tantas como sean necesarias, para indicar
múltiples niveles de indirección. El valor predeterminado es ``\fB+ \fP''.
.TP
.B TIMEFORMAT
El valor de este parámetro se emplea como una cadena de formato para
especificar cómo debe mostrarse la información de tiempos para
tuberías precedidas por la palabra reservada
.BR time .
El carácter \fB%\fP introduce una secuencia de escape que se expande a
un valor de tiempo o a otra información.
Las secuencias de escape y sus significados son como sigue; los
corchetes denotan partes opcionales.
.sp .5
.RS
.PD 0
.TP 10
.B %%
Un \fB%\fP literal.
.TP
.B %[\fIp\fP][l]R
El tiempo total transcurrido en segundos.
.TP
.B %[\fIp\fP][l]U
El número de segundos de CPU gastados en modo usuario.
.TP
.B %[\fIp\fP][l]S
El número de segundos de CPU gastados en modo sistema.
.TP
.B %P
El porcentaje de CPU, computado como (%U + %S) ÷ %R.
.PD
.RE
.IP
La \fIp\fP opcional es un dígito que especifica la \fIprecisión\fP,
el número de decimales.
Un valor de 0 hace que no se muestre ningún decimal, ni el punto o
coma decimal.
Como mucho se pueden especificar tres decimales; valores de \fIp\fP
mayores de 3 se cambian a 3. Si \fIp\fP no se especifica, se usa
precisamente el valor 3.
.IP
La \fIl\fP opcional especifica un formato más largo, incluyendo
minutos, en la forma \fIMM\fPm\fISS\fP.\fIFF\fPs.
El valor de \fIp\fP determina si se incluye o no la fracción.
.IP
Si esta variable no está definida, \fBbash\fP actúa como si tuviera el
valor \fB$'\enreal\et%3lR\enuser\et%3lU\ensys\t%3lS'\fP.
Si el valor es nulo, no se muestra ninguna información de tiempos.
Se añade un salto de línea al final cuando se muestra la cadena de
formato. 
.TP
.B HISTSIZE
El número de órdenes a recordar en la historia de órdenes (vea
.SM
.B HISTORIA
abajo).  El valor predeterminado es 500.
.TP
.B HISTFILE
El nombre del fichero en el que se guarda la historia de órdenes (vea
.SM
.B HISTORIA
abajo).  El valor predeterminado es \fI~/.bash_history\fP.  Si no está
definido, no se guarda la historia de órdenes cuando se acaba un shell
interactivo.
.TP
.B HISTFILESIZE
El número máximo de líneas contenidas en el fichero de historia. Cuando
se asigna un valor a esta variable, el fichero de historia se trunca,
si es menester, para contener no más de ese número de líneas. El valor
predeterminado es 500. El fichero de historia se trunca también a este
tamaño tras escribir en él cuando un shell interactivo termina.
.TP
.B OPTERR
Si se pone al valor 1,
.B bash
muestra mensajes de error generados por la orden interna
.B getopts
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
abajo).
.SM
.B OPTERR
se inicia a 1 cada vez que se llama al shell o cuando se ejecuta un
guión del shell.
.TP
.B LANG
Empleado para determinar la categoría de localización ("escenario")
para cualquier categoría no seleccionada específicamente con una
variable de las que empiezan por \fBLC_\fP.
.TP
.B LC_ALL
Esta variable tiene preferencia sobre el valor de \fBLANG\fP y de
cualquier otra variable de las que empiecen por \fBLC_\fP
especificando una categoría de localización.
.TP
.B LC_COLLATE
Esta variable determina el orden de clasificación empleado cuando se
ordene el resultado de una expansión de nombres de caminos, y
determina el comportamiento de expresiones de rango, clases de
equivalencia, y secuencias de clasificación dentro de expansiones de
nombres de caminos y concordancia de patrones.
.TP
.B LC_CTYPE
Esta variable determina la interpretación de caracteres y el
comportamiento de clases de caracteres dentro de expansiones de
nombres de caminos y concordancia de patrones.
.TP
.B LC_MESSAGES
Esta variable determina la localización empleada para traducir cadenas
entrecomilladas con comillas dobles precedidas por un \fB$\fP.
.TP
.B PROMPT_COMMAND
Si está definido, el valor se ejecuta como una orden antes de mostrarse
cada indicador primario.
.TP
.B IGNOREEOF
Controla la acción de un shell interactivo al recibir un carácter
.SM
.B EOF
como sola entrada. Si está definido, el valor es el número de caracteres
.SM
.B EOF
consecutivos que deben teclearse como los primeros caracteres de una
línea de entrada antes de que
.B bash
acabe. Si la variable existe pero no tiene un valor numérico, o
ninguno, el valor predeterminado es 10. Si no existe,
.SM
.B EOF
significa el final de la entrada para el shell.
.TP
.B TMOUT
Si se define a un valor mayor que cero, el valor se interpreta como el
número de segundos que hay que esperar una entrada después de
mostrarse el indicador primario.
.B Bash
termina después de esperar ese número de segundos si no recibe ninguna
entrada.
.TP
.B FCEDIT
El editor predeterminado para la orden interna
.BR fc .
.TP
.B FIGNORE
Una lista de sufijos separados por dos puntos que no hay que tener en
cuenta cuando se realice una terminación de nombres de ficheros (vea
.SM
.B READLINE
abajo).
Un nombre de fichero cuyo sufijo concuerde con una de las entradas en
.SM
.B FIGNORE
se excluye de la lista de nombres de ficheros a completar.
Un valor de muestra es ``.o:~''.
.TP
.B GLOBIGNORE
Una lista de patrones separados por dos puntos que definen en conjunto
de nombres de ficheros que no hay que tener en cuenta en la expansión
de nombres de caminos. Si un nombre de fichero que concordaba en un
patrón de expansión de nombres de caminos también concuerda con uno de
los patrones en
.SM
.BR GLOBIGNORE ,
se quita de la lista de concordancias.
.TP
.B INPUTRC
El nombre de fichero para el de inicio de
.BR readline ,
en vez del predeterminado
.FN ~/.inputrc
(vea
.SM
.B READLINE
abajo).
.TP
.B HISTCONTROL
Si se define a un valor de
.IR ignorespace ,
las líneas que comiencen con un carácter
.B espacio
no se meten en la lista de historia. Si se pone a un valor de
.IR ignoredups ,
las líneas que concuerden con la última línea de la historia, no se
meten. 
Un valor de
.I ignoreboth
combina las dos opciones.
Si no está definido, o si lo está a otro valor distinto de los de
antes, todas las líneas leídas por el analizador léxico se guardan en
la lista de la historia, sujeto esto al valor de
.BR HISTIGNORE .
La función de esta variable ha sido tomada por
.BR HISTIGNORE .
La segunda línea y siguientes de una orden compuesta multi-línea no se
comprueban, y se añaden a la historia sin importar el valor de
.BR HISTCONTROL .
.TP
.B HISTIGNORE
Una lista de patrones separados por dos puntos empleados para decidir
qué líneas de órdenes deben guardarse en la lista de historia. Cada
patrón se ancla al principio de la línea y debe especificar la línea
completamente (no se añade ningún `\fB*\fP'). Cada patrón se comprueba
con la línea tras aplicarse las comprobaciones especificadas por
.BR HISTCONTROL .
Además de los caracteres normales de concordancia de patrones del
shell, `\fB&\fP' concuerda con la línea de historia anterior.
`\fB&\fP'  puede protegerse empleando una barra inversa. Ésta se quita
antes de intentarse una concordancia.
La segunda línea y siguientes de una orden compuesta multi-línea no se
comprueban, y se añaden a la historia sin importar el valor de
.BR HISTIGNORE .
.TP
.B histchars
Los dos o tres caracteres que controlan la expansión y separación en
lexemas de la historia (vea
.SM
.B EXPANSIÓN DE HISTORIA
abajo).  El primer carácter es el
.IR "carácter de expansión de historia" ,
el carácter que señala el comienzo de una expansión de historia,
normalmente `\fB!\fP'.
El segundo carácter es el carácter de
.IR "sustitución rápida" ,
que se usa como una abreviatura para reejecutar la orden anterior,
sustituyendo una cadena por otra en la orden. El valor predeterminado
es `\fB^\fP'.
El tercer carácter, opcional, es el carácter que indica que el resto
de la línea es un comentario cuando se encuentra como el primer
carácter de una palabra, normalmente es `\fB#\fP'.  El carácter de
comentario de historia hace que la sustitución de historia se salte en
el resto de palabras de la línea. No hace que necesariamente el
analizador  léxico del shell trate al resto de la línea como un a un
comentario. 
.TP
.B HOSTFILE
Contiene el nombre de un fichero con el mismo formato que
.FN /etc/hosts
que debería leerse cuando el shell necesite completar un nombre de
anfitrión (computador). El fichero puede ser cambiado
interactivamente; la siguiente vez que se intente completar un nombre
de computador,
.B bash
añade el contenido del nuevo fichero a la base de datos ya existente.
.TP
.B auto_resume
Esta variable controla cómo el shell interactúa con el usuario para el
control de trabajos. Si esta variable está definida, las órdenes
simples de una palabra sin redirección se tratan como candidatas para
reanudar un trabajo existente parado. No se permite ninguna
ambigüedad; si hay más de un trabajo que empiece con la cadena
tecleada, se selecciona el trabajo al que se ha accedido más recientemente.
El
.I nombre
de un trabajo parado, en este contexto, es la línea de órdenes
empleada para arrancarlo.
Si se define al valor
.IR exact ,
la cadena suministrada debe concordar exactamente con el nombre de un
trabajo parado; si se define como
.IR substring ,
la cadena suministrada necesita concordar con una subcadena del nombre
de un trabajo parado. El valor
.I substring
proporciona una funcionalidad análoga a la del identificador de trabajo
.B %?
(vea
.SM
.B CONTROL DE TRABAJOS
adelante). Si se pone a cualquier otro valor, la cadena suministrada
debe ser un prefijo del nombre de un trabajo parado; esto proporciona
una funcionalidad análoga a la del identificador de trabajo
.BR % .
.PD
.SS Vectores
.B Bash
proporciona variables vectores, monodimensionales. Cualquier variable
puede usarse como un vector; la orden interna
.B declare
declarará un vector explícitamente. No hay un límite máximo en el
tamaño de un vector, ni ningún requisito para que los miembros se
indexen o asignen de forma contigua. Los vectores se indexan empleando
enteros y su primer elemento es el de índice cero, como en C.
.PP
Un vector se crea automáticamente si se asigna algo a una variable con
la sintaxis \fInombre\fP[\fIíndice\fP]=\fIvalor\fP. El
.I índice
se trata como una expresión aritmética que debe evaluarse a un número
mayor o igual a cero. Para declarar un vector explícitamente, emplee
.B declare \-a \fInombre\fP
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
abajo).
También se acepta
.BR "declare \-a \fInombre\fP[\fIíndice\fP]" ,
donde el \fIíndice\fP no se tiene en cuenta. Se pueden especificar
atributos para una variable vector mediante las órdenes internas
.B declare
y
.BR readonly .
Cada atributo se aplica a cada uno de los miembros del vector.
.PP
Se asignan valores a los vectores mediante asignaciones compuestas de
la forma
\fInombre\fP=\fB(\fPvalor\fI1\fP ... valor\fIn\fP\fB)\fP, donde cada
\fIvalor\fP es de la forma [\fIíndice\fP]=\fIcadena\fP.  Sólo
\fIcadena\fP es necesario.  Si se suministra el índice entre corchetes
y la asignación, se asigna a ese índice; si no, el índice del elemento
asignado es el último índice al que la sentencia le asignó algo, más
uno. Los índices empiezan en cero. Esta sintaxis también la acepta la
orden interna
.BR declare .
Se puede asignar a los elementos individuales del vector empleando la
sintaxis 
\fInombre\fP[\fIíndice\fP]=\fIvalor\fP, ya presentada antes.
.PP
Cualquier elemento de un vector puede referenciarse mediante 
${\fInombre\fP[\fIíndice\fP]}.  Las llaves son necesarias para evitar
conflictos con la expansión de nombres de caminos. Si
\fIíndice\fP es \fB@\fP o \fB*\fP, la palabra se expande a todos los
miembros de \fInombre\fP.  Estos índices difieren solamente cuando la
palabra aparece entre comillas dobles. Si la palabra está entre
comillas dobles,
${\fInombre\fP[*]} se expande a una sola palabra
con el valor de cada miembro del vector separados por el primer
carácter de la variable especial
.SM
.BR IFS ,
y ${\fInombre\fP[@]} expande cada elemento de
\fInombre\fP a una palabra separada. Cuando no hay miembros del vector,
${\fInombre\fP[@]} se expande a nada. Esto es análogo a la expansión
de los parámetros especiales \fB*\fP y \fB@\fP (vea
.B Parámetros especiales
arriba).  ${#\fInombre\fP[\fIíndice\fP]} se expande a la longitud de
${\fInombre\fP[\fIíndice\fP]}.  Si \fIíndice\fP es \fB*\fP o
\fB@\fP, la expansión es el número de elementos del vector.
Referenciar una variable vector sin índice es equivalente a
referenciar el elemento cero.
.PP
La orden interna
.B unset
se emplea para destruir vectores.  \fBunset\fP \fBnombre\fP[\fIíndice\fP]
destruye el elemento del vector con el \fIíndice\fP especificado.
\fBunset\fP \fInombre\fP, donde \fInombre\fP es un vector, o
\fBunset\fP \fInombre\fP[\fIíndice\fP], donde
\fIíndice\fP es \fB*\fP o \fB@\fP, borra el vector entero.
.PP
Las órdenes internas
.BR declare ,
.BR local ,
y
.B readonly
aceptan cada una una opción
.B \-a
para especificar un vector (array). La orden interna
.B read
acepta una
.B \-a
para asignar una lista de palabras leídas desde la entrada estándar a
un vector. Las órdenes internas
.B set
y
.B declare
muestran valores de un vector en una manera tal que les permite ser
reutilizadas como asignaciones.
.SH EXPANSIÓN
La expansión se realiza en la línea de órdenes una vez que la orden ha
sido dividida en palabras. Hay siete clases de expansión:
.IR "expansión de llaves" ,
.IR "expansión de tilde" ,
.IR "expansión de parámetro y variable" ,
.IR "sustitución de orden" ,
.IR "expansión aritmética" ,
.IR "división de palabras",
.IR "expansión de nombre de camino" .
.PP
La orden de las expansiones es: expansión de llaves, de tilde, de
parámetro, variable y aritmética, y sustitución de orden (hechas de
izquierda a derecha), división de palabras, y expansión de nombre de
camino. 
.PP
En sistemas que puedan admitirla, hay una expansión adicional
disponible: \fIsustitución de proceso\fP.
.PP
Sólo la expansión de llaves, división de palabras, y expansión de
nombre de camino, pueden cambiar el número de palabras de la
expansión; las otras expanden una palabra simple a otra palabra
simple. Las únicas excepciones a esto son las expansiones de
"\fB$@\fP" y "\fB${\fP\fInombre\fP\fB[@]}\fP"
como se ha explicado más arriba (vea
.SM
.BR PARÁMETROS ).
.SS Expansión de llaves
.PP
La
.I "expansión de llaves"
es un mecanismo por el cual pueden generarse cadenas arbitrarias. Este
mecanismo es similar a la \fIexpansión de nombre de camino\fP, pero
los nombres de ficheros no necesitan existir. Los patrones a ser
expandidos con la expansión de llaves toman la forma de un 
.I preámbulo 
opcional seguido por una serie de cadenas separadas por comas entre un
par de llaves, seguido por un
.I post scriptum 
opcional.
El preámbulo sirve de prefijo a cada cadena de entre las llaves, y el
post scriptum se añade luego a cada cadena resultante, expandiendo de
izquierda a derecha.
.PP
Las expansiones de llaves pueden anidarse. Los resultados de cada
cadena expandida no se ordenan; se preserva el orden de izquierda a
derecha. Por ejemplo, a\fB{\fPd,c,b\fB}\fPe se expande a `ade ace abe'.
.PP
La expansión de llaves se realiza antes que cualquier otra, y
cualquier carácter especial para otras expansiones se preserva en el
resultado. Es estrictamente textual.
.B Bash
no aplica ninguna interpretación sintáctica al contexto de la
expansión ni al texto entre las llaves.
.PP
Una expansión de llaves correctamente formada debe contener llaves de
apertura y cierre sin entrecomillar, y por lo menos una coma sin
entrecomillar. Cualquier expansión de llaves formada incorrectamente se
deja tal cual. Una \fB{\fP o \fB,\fP puede protegerse con una barra
invertida para evitar que sea considerada como parte de una expansión
de llaves.
.PP
Esta construcción se emplea normalmente como una abreviatura cuando el
prefijo común de las cadenas a generar es mayor que en el ejemplo de
antes: 
.RS
.PP
mkdir /usr/local/src/bash/{old,new,dist,bugs}
.RE
o
.RS
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
.RE
.PP
La expansión de llaves introduce una pequeña incompatibilidad con
versiones históricas de
.BR sh .
.B sh
no trata especialmente a las llaves de apertura o cierre cuando
aparecen como parte de una palabra, y las deja en la entrada.
.B Bash
quita las llaves de palabras, como una consecuencia de la expansión de
llaves. Por ejemplo, una palabra introducida a
.B sh
como \fIfichero{1,2}\fP
aparece así mismo en la entrada. La misma palabra se muestra como
.I fichero1 fichero2
tras la expansión hecha por
.BR bash .
Si se desea una compatibilidad estricta con
.BR sh ,
arranque
.B bash
con la opción
.B +B 
o inhabilite la expansión de llaves con la opción
.B +B
de la orden interna
.B set
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
abajo).
.SS Expansión de tilde
.PP
Si una palabra comienza con un carácter tilde de la ñ sin
entrecomillar (`\fB~\fP'), todos los caracteres que precedan a la
primera barra inclinada sin entrecomillar (o todos los caracteres, si
no hay ninguna barra inclinada sin proteger), se consideran un
\fIprefijo\-tilde\fP. Si ninguno de los caracteres en el prefijo-tilde
están protegidos, los caracteres en el prefijo-tilde que siguen a la
tilde se tratan como un posible \fInombre de entrada\fP de usuario
(login). 
Si este nombre de entrada es la cadena vacía, la tilde se reemplaza
con el valor del parámetro del shell
.SM
.BR HOME .
Si
.SM
.B HOME
no está definida, se sustituye en su lugar el directorio de trabajo
inicial del usuario que está ejecutando el shell.
De otra forma, el prefijo-tilde se reemplaza con el directorio de
trabajo inicial (de casa) asociado con el nombre de entrada
especificado. 
.PP
Si el prefijo-tilde es un `~+', el valor de la variable del shell
.SM
.B PWD
reemplaza al prefijo-tilde.
Si el prefijo-tilde es un `~\-', el valor de la variable del shell
.SM
.BR OLDPWD ,
si está definido, se sustituye.
Si los caracteres que siguen a la tilde en el prefijo-tilde consisten
en un número \fIN\fP, prefijado opcionalmente por un `+' o un `\-', el
prefijo-tilde se reemplaza con el elemento correspondiente de la pila
de directorios, como lo mostraría la orden interna
.B dirs
llamada con el prefijo-tilde como argumento.
Si los caracteres tras la tilde en el prefijo-tilde consisten en un
número sin un `+' ni `\-' iniciales, se supone `+'.
.PP
Si el nombre de entrada es inválido, o si la expansión de tilde falla,
la palabra se deja tal cual.
.PP
A cada asignación de variable se comprueba si hay prefijos-tilde sin
entrecomillar inmediatamente tras un
.B :
o un
.BR = .
En estos casos, la expansión de tilde también tiene lugar.
Consecuentemente, uno puede usar nombres de ficheros con tildes en
asignaciones a
.SM
.BR PATH ,
.SM
.BR MAILPATH ,
y
.SM
.BR CDPATH ,
y el shell asigna el valor expandido.
.SS Expansión de parámetro
.PP
El carácter `\fB$\fP' introduce la expansión de parámetro,
sustitución de orden, o expansión aritmética. El nombre de parámetro o
símbolo a ser expandido puede estar encerrado entre llaves, que son
opcionales pero sirven para proteger a la variable en la expansión de
caracteres que la sigan y puedan interpretarse como parte de su
nombre. 
.PP
Cuando se empleen llaves, la de cierre es la primera `\fB}\fP'
no protegida con una barra invertida o en una cadena entrecomillada, y
no dentro de una expansión aritmética empotrada, sustitución de orden,
o expansión de parámetro.
.PP
.PD 0
.TP
${\fIparámetro\fP}
Se sustituye el valor de \fIparámetro\fP.  Se requieren llaves cuando
.I parámetro
es un parámetro posicional de más de un dígito,
o cuando
.I parámetro
viene seguido por un carácter que no debe interpretarse como parte de
su nombre.
.PD
.PP
Si el primer carácter de \fIparámetro\fP es un signo de cierre de exclamación,
se introduce un nivel de indirección de variable.
\fBBash\fP emplea el valor de la variable formada a partir del resto de
\fIparámetro\fP como el nombre de la variable; luego, esta variable se
expande y ese valor se emplea en el resto de la sustitución, en vez del
propio valor de \fIparámetro\fP.
Esto se conoce como \fIexpansión indirecta\fP.
.PP
En cada uno de los casos anteriores, \fIpalabra\fP está sujeta a
expansión de tilde, expansión de parámetro, sustitución de orden, y
expansión aritmética. Cuando no se realiza la expansión de subcadena,
\fBbash\fP comprueba si un parámetro está sin definir o es nulo; si
omitimos los dos puntos la comprobación sólo es para la no definición
del parámetro.
.PP
.PD 0
.TP
${\fIparámetro\fP\fB:\-\fP\fIpalabra\fP}
\fBEmplear valores predeterminados\fP.
Si
.I parámetro
no está definido o está vacío, se sustituye la expansión de
.IR palabra .
De otro modo, se sustituye el valor de
.IR parámetro .
.TP
${\fIparámetro\fP\fB:=\fP\fIpalabra\fP}
\fBAsignar valores predeterminados\fP.
Si
.I parámetro
no está definido o es nulo, la expansión de
.I palabra
se asigna a
.IR parámetro .
Luego, el valor de
.I parámetro
se sustituye. No se puede asignar nada de esta manera a los parámetros
posicionales ni a los especiales.
.TP
${\fIparámetro\fP\fB:?\fP\fIpalabra\fP}
\fBMuestra un error si no está definido o está vacío\fP.
Si
.I parámetro
es nulo o no está definido, la expansión de \fIpalabra\fP (o un
mensaje a tal efecto si
.I palabra
no está presente) se escribe en la salida estándar de errores y el
shell, si no es interactivo, acaba. De otra manera, se sustituye el
valor de \fIparámetro\fP.
.TP
${\fIparámetro\fP\fB:+\fP\fIpalabra\fP}
\fBEmplear un valor alternativo\fP.
Si
.I parámetro
está vacío o no está definido, no se sustituye nada; de otro modo, se
sustituye la expansión de
.IR palabra .
.TP
.PD 0
${\fIparámetro\fP\fB:\fP\fIdesplazamiento\fP}
.TP
${\fIparámetro\fP\fB:\fP\fIdesplazamiento\fP\fB:\fP\fIlongitud\fP}
.PD
\fBExpansión de subcadena.\fP
Expande hasta \fIlongitud\fP caracteres de \fIparámetro\fP,
empezando en los caracteres especificados por \fIdesplazamiento\fP.
Si se omite la \fIlongitud\fP, se expande a la subcadena de
\fIparámetro\fP, empezando en el carácter especificado por \fIdesplazamiento\fP.
\fIlongitud\fP y \fIdesplazamiento\fP son expresiones aritméticas (vea
.SM
.B
EVALUACIÓN ARITMÉTICA
más abajo).
\fIlongitud\fP debe evaluarse a un número mayor o igual a cero.
Si \fIdesplazamiento\fP se evalúa a un número menor que cero, el valor
se emplea como un desplazamiento desde el final del valor de \fIparámetro\fP.
Si \fIparámetro\fP es \fB@\fP, el resultado es \fIlongitud\fP
parámetros posicionales empezando en \fIdesplazamiento\fP.
Si \fIparámetro\fP es un nombre de vector indexado por @ o *,
el resultado es \fIlongitud\fP miembros del vector empezando con 
${\fIparámetro\fP[\fIdesplazamiento\fP]}.
La indexación de la subcadena empieza por cero a menos que se empleen
los parámetros posicionales, en cuyo caso empieza por 1.
.TP
${\fB#\fP\fIparámetro\fP}
Se sustituye la longitud en caracteres del valor de \fIparámetro\fP.
Si
.I parámetro
es
.B *
o 
.BR @ ,
el valor sustituido es el número de parámetros posicionales.
Si
.I parámetro
es un nombre de vector indexado por
.B *
o
.BR @ ,
el valor sustituido es el número de elementos en el vector.
.TP
.PD 0
${\fIparámetro\fP\fB#\fP\fIpalabra\fP}
.TP
${\fIparámetro\fP\fB##\fP\fIpalabra\fP}
.PD
La
.I palabra
se expande para producir un patrón lo mismo que en una expansión de
nombre de camino. Si el patrón concuerda con el principio del valor de
.IR parámetro ,
entonces el resultado de la expansión es el valor expandido de
.I parámetro
con el patrón más corto que concuerde (el caso ``\fB#\fP) o con el
patrón más largo que concuerde (el caso ``\fB##\fP'') eliminado.
Si
.I parámetro
es
.B @
o
.BR * ,
la operación de borrado del patrón se aplica a cada parámetro
posicional por turnos, y la expansión es la lista resultante.
Si
.I parámetro
es una variable vector indexada con
.B @
o
.BR * ,
la operación de borrado del patrón se aplica a cada miembro del vector
por orden, y la expansión es la lista resultante.
.TP
.PD 0
${\fIparámetro\fP\fB%\fP\fIpalabra\fP}
.TP
${\fIparámetro\fP\fB%%\fP\fIpalabra\fP}
.PD
La \fIpalabra\fP se expande para producir un patrón justo como en la
expansión de nombre de camino.
Si el patrón concuerda con una porción del final del valor expandido de
.IR parámetro ,
entonces el resultado de la expansión es el valor expandido de
.I parámetro
con el patrón más corto que concuerde (el caso ``\fB%\fP'') o el más
largo (el caso ``\fB%%\fP'') borrado.
Si
.I parámetro
es
.B @
o
.BR * ,
la operación de borrado del patrón se aplica a cada parámetro
posicional por orden, y la expansión es la lista resultante.
Si
.I parámetro
es una variable vector indexada por
.B @
o
.BR * ,
la operación de borrado del patrón se aplica a cada miembro del vector
por orden, y la expansión es la lista resultante.
.TP
.PD 0
${\fIparámetro\fP\fB/\fP\fIpatrón\fP\fB/\fP\fIcadena\fP}
.TP
${\fIparámetro\fP\fB//\fP\fIpatrón\fP\fB/\fP\fIcadena\fP}
.PD
El \fIpatrón\fP se expande para producir un patrón justo como en la
expansión de nombre de camino.
\fIparámetro\fP se expande y la concordancia más larga de \fIpatrón\fP
contra este valor se reemplaza por \fIcadena\fP.
En la primera forma, sólo se reemplaza la primera concordancia.
La segunda forma hace que todas las concordancias de \fIpatrón\fP se
reemplacen con \fIcadena\fP.
Si \fIpatrón\fP empieza por \fB#\fP, debe concordar con el principio
de la \fIcadena\fP.
Si \fIpatrón\fP empieza por \fB%\fP, debe concordar con el final de 
la \fIcadena\fP.
Si \fIcadena\fP está vacía, las concordancias de \fIpatrón\fP se borran
y el \fB/\fP que sigue al \fIpatrón\fP puede omitirse.
Si
.I parámetro
es
.B @
o
.BR * ,
la operación de sustitución se aplica a cada parámetro posicional por
orden, y la expansión es la lista resultante.
Si
.I parámetro
es una variable vector indexada por
.B @
o
.BR * ,
la operación de sustitución se aplica a cada miembro del vector por
orden, y la expansión es la lista resultante.
.SS Sustitución de orden
.PP
\fILa sustitución de orden\fP permite a la salida de una orden
reemplazar al nombre de la orden. Hay dos formas:
.PP
.RS
.PP
\fB$(\fP\fIorden\fP\|\fB)\fP
.RE
u
.RS
\fB`\fP\fIorden\fP\fB`\fP
.RE
.PP
.B Bash
realiza la expansión ejecutando \fIorden\fP y
reemplazando la sustitución de orden con la salida estándar de la
orden, quitando los saltos de línea finales.
Los saltos de línea empotrados no se borran, pero pueden ser
eliminados durante la división de palabras.
La sustitución de orden \fB$(cat \fIfichero\fP)\fR puede reemplazarse por
lo equivalente pero más rápido \fB$(< \fIfichero\fP)\fR.
.PP
Cuando se emplea la forma de sustitución al viejo estilo con las
comillas inversas, la barra invertida mantiene su significado literal
excepto cuando es seguida por
.BR $ ,
.BR ` ,
o
.BR \e .
La primera comilla inversa no precedida por una barra invertida
termina la sustitución de orden.
Cuando se emplea la forma $(\^\fIorden\fP\|), todos los caracteres
entre los paréntesis forman parte de la orden; ninguno se trata especialmente.
.PP
Las sustituciones de orden pueden anidarse. Para anidar cuando se
emplee la forma de comillas inversas, proteja las comillas inversas
internas con barras inversas.
.PP
Si la sustitución aparece dentro de las dobles comillas, la división
de palabras y la expansión de nombres no se realiza en los resultados.
.SS Expansión aritmética
.PP
La expansión aritmética permite la evaluación de una expresión
aritmética y la sustitución del resultado. El formato para la
expansión aritmética es:
.RS
.PP
\fB$((\fP\fIexpresión\fP\fB))\fP
.RE
.PP
La
.I expresión
se trata como si estuviera entre comillas dobles, pero un signo de
doble comilla dentro de los paréntesis no se trata especialmente.
Todos los lexemas en la expresión están sujetos a expansión de
parámetro, expansión de cadena, sustitución de orden, y eliminación de
comillas.
Las sustituciones aritméticas pueden anidarse.
.PP
La evaluación se realiza de acuerdo a las reglas listadas más abajo en
.SM
.BR "EVALUACIÓN ARITMÉTICA" .
Si
.I expresión
no es válida,
.B bash
imprime un mensaje indicando el fallo y no ocurre ninguna sustitución.
.SS Sustitución de proceso
.PP
La \fIsustitución de proceso\fP se admite en sistemas que acepten
tuberías con nombre (\fIFIFOs\fP) o el método \fB/dev/fd\fP de nombrar
ficheros abiertos.
Toma una de las formas siguientes:
\fB<(\fP\fIlista\^\fP\fB)\fP
o
\fB>(\fP\fIlista\^\fP\fB)\fP.
El proceso \fIlista\fP se ejecuta con su entrada o salida conectada a un
\fIFIFO\fP o a algún fichero en \fB/dev/fd\fP.  El nombre de este fichero
se pasa como argumento a la orden en curso como el resultado de la
expansión. Si se emplea la forma \fB>(\fP\fIlista\^\fP\fB)\fP, escribir
en el fichero proporciona la entrada para \fIlista\fP.  Si se emplea
la forma \fB<(\fP\fIlista\^\fP\fB)\fP, el fichero pasado como argumento
deberá leerse para obtener la salida de \fIlista\fP.
.PP
Cuando esté disponible, se realiza la \fIsustitución de proceso\fP
simultáneamente con la expansión de parámetro y variable, sustitución
de orden y expansión aritmética.
.SS División de palabras
.PP
El shell examina los resultados de la 
expansión de parámetro,
sustitución de orden
y
expansión aritmética
que no ocurrieron dentro de comillas dobles
para realizar la
.IR "división de palabras" .
.PP
El shell trata cada carácter de
.SM
.B IFS
como un delimitador, y divide los resultados de las otras expansiones
en palabras separadas por estos caracteres. Si
.SM
.B IFS
no está definido, o su 
valor es exactamente
.BR <espacio><tab><nueva-línea> ,
el valor predeterminado, entonces
cualquier secuencia de caracteres de
.SM
.B IFS
sirve para delimitar palabras. Si
.SM
.B IFS
tiene algún otro valor, entonces las secuencias de
los caracteres blancos
.B espacio
y
.B tabulador
no se tienen en cuenta al principio y al final de la palabra, siempre
que el carácter de espacio en blanco esté en el valor de
.SM
.BR IFS
(un carácter de espacio en blanco de
.SM
.BR IFS ).
Cualquier carácter en
.SM
.B IFS
que no sea espacio en blanco de
.SM
.BR IFS ,
junto con cualquier carácter de espacio en blanco adyacente de
.SM
.BR IFS ,
delimita un campo.
Una secuencia de caracteres de espacio en blanco de 
.SM
.B IFS
también se trata como un delimitador.
Si el valor de
.SM
.B IFS
es nulo, no se realiza la división de palabras.
.PP
Los argumentos nulos explícitos (\^\f3"\^"\fP o \^\f3'\^'\fP\^) se
mantienen. Los argumentos nulos no protegidos implícitos, resultantes
de la expansión de
.I parámetros
que no tienen valores, se eliminan.
Si un parámetro sin ningún valor se expande dentro de comillas dobles,
el resultado es un argumento nulo, y es mantenido.
.PP
Observe que si no hay expansión, tampoco se realiza la división de palabras.
.SS Expansión de nombre de camino
.PP
Tras la división de palabras,
a menos que la opción
.B \-f
esté puesta,
.B bash
examina cada palabra buscando los caracteres
.BR * ,
.BR ? ,
.BR ( ,
y
.BR [ .
Si uno de estos caracteres aparece, entonces la palabra se considera
como un
.IR patrón ,
y se reemplaza por una lista ordenada alfabéticamente de nombres de
ficheros que concuerden con el patrón.
Si no se encuentran nombres de ficheros concordantes,
y la opción del shell
.B nullglob
está deshabilitada, la palabra se deja tal cual.
Si la opción
.B nullglob
está puesta, y no ha habido ninguna concordancia,
la palabra se elimina.
Si la opción del shell
.B nocaseglob
está puesta, la búsqueda de la concordancia se realiza sin importar si
los caracteres alfabéticos son letras mayúsculas o minúsculas.
Cuando un patrón se usa para expansión de nombre de camino,
el carácter
.B ``.''
al principio de un nombre o inmediatamente después de una barra
inclinada debe concordar explícitamente, a menos que esté puesta la
opción del shell
.BR dotglob .
En la concordancia de un nombre de camino, el carácter de barra
inclinada debe siempre coincidir explícitamente.
En otros casos, el carácter
.B ``.''
no se trata de forma especial.
Vea la descripción de
.B shopt
más abajo en
.SM
.B ÓRDENES INTERNAS DEL SHELL
para una descripción de las opciones del shell
.BR nocaseglob ,
.BR nullglob ,
y
.BR dotglob .
.PP
La variable del shell
.SM
.B GLOBIGNORE
puede utilizarse para restringir el conjunto de nombres de ficheros
que concuerden con un
.IR patrón .
Si
.SM
.B GLOBIGNORE
está definido, cada nombre de fichero concordante que también coincida
con uno de los patrones en
.SM
.B GLOBIGNORE
se quita de la lista de concordancias.
Los nombres de fichero
.B ``.''
y
.B ``..''
nunca son tenidos en cuenta, incluso cuando
.SM
.B GLOBIGNORE
esté puesto. Sin embargo, definir
.SM
.B GLOBIGNORE
tiene el efecto de activar la opción del shell
.BR dotglob ,
de modo que todos los otros nombres de fichero que comiencen con un
.B ``.''
concordarán.
Para obtener el comportamiento antiguo de no hacer caso de nombres de
ficheros que comienzan con un
.BR ``.'' ,
haga que
.B ``.*''
sea uno de los patrones de
.SM
.BR GLOBIGNORE .
La opción
.B dotglob
está deshabilitada cuando
.SM
.B GLOBIGNORE
no está definido.
.PP
\fBPatrones\fP
.PP
Cualquier carácter que aparezca en un patrón, aparte de los especiales
descritos más adelante, concuerda consigo mismo. El carácter NUL no
puede estar en un patrón. Los caracteres de patrón especiales deben
protegerse si han de concordar literalmente consigo mismos.
.PP
Los caracteres de patrón especiales tienen los siguientes significados:
.PP
.PD 0
.TP
.B *
Concuerda con cualquier cadena de caracteres, incluida la cadena vacía.
.TP
.B ?
Concuerda con un solo carácter cualquiera.
.TP
.B [...]
Concuerda con uno de los caracteres entre corchetes. Un par de
caracteres separados por un signo menos denota un
.IR rango ;
cualquier carácter léxicamente entre esos dos, incluidos,
concuerda. Si el primer carácter tras el
.B [
es un
.B !
o un
.BR ^ ,
entonces la concordancia es con cualquier carácter de los que no estén
entre los corchetes.
Un
.B \-
puede representarse para la concordancia incluyéndolo como el primer o
último carácter del conjunto.
Un
.B ]
puede hacerse concordar incluyéndolo como el primer carácter del conjunto.
.br
.if t .sp 0.5
.if n .sp 1
Dentro de
.B [
y
.BR ] ,
se pueden especificar \fIclases de caracteres\fP mediante la sintaxis
\fB[:\fP\fIclase\fP\fB:]\fP, donde \fIclase\fP es una de las
siguientes clases definidas en el estándar POSIX.2:
.PP
.RS
.B
.if n alnum alpha ascii blank cntrl digit graph lower print punct space upper xdigit
.if t alnum   alpha   ascii   blank   cntrl   digit   graph   lower   print   punct   space   upper   xdigit
.br
Una clase de caracteres concuerda con cualquier carácter que
pertenezca a esa clase.
.br
.if t .sp 0.5
.if n .sp 1
Dentro de
.B [
y
.BR ] ,
una \fIclase de equivalencia\fP se puede especificar empleando la sintaxis
\fB[=\fP\fIc\fP\fB=]\fP, que concuerda con todos los caracteres con el
mismo peso de clasificación (tal como lo defina la localización en
curso) que el carácter \fIc\fP.
.br
.if t .sp 0.5
.if n .sp 1
Dentro de
.B [
y
.BR ] ,
la sintaxis \fB[.\fP\fIsímbolo\fP\fB.]\fP concuerda con el símbolo de
clasificación 
\fIsímbolo\fP.
.RE
.PD
.PP
Si la opción del shell \fBextglob\fP se activa usando la orden interna
\fBshopt\fP, se reconocen algunos operadores de patrones
extendidos. En la siguiente descripción, una \fIlista\-patrón\fP es
una lista de uno o más patrones separados por un \fB|\fP. Se pueden
formar patrones compuestos usando uno o más de los siguientes
sub-patrones: 
.sp 1
.PD 0
.RS
.TP
\fB?(\fP\^\fIlista-patrón\^\fP\fB)\fP
Concuerda con ninguna o una ocurrencia de los patrones dados
.TP
\fB*(\fP\^\fIlista-patrón\^\fP\fB)\fP
Concuerda con ninguna o más ocurrencias de los patrones dados
.TP
\fB+(\fP\^\fIlista-patrón\^\fP\fB)\fP
Concuerda con una o más ocurrencias de los patrones dados
.TP
\fB@(\fP\^\fIlista-patrón\^\fP\fB)\fP
Concuerda exactamente con uno de los patrones dados
.TP
\fB!(\fP\^\fIlista-patrón\^\fP\fB)\fP
Concuerda con cualquier cosa excepto con uno de los patrones dados
.RE
.PD
.SS Eliminación de comillas
.PP
Tras las expansiones precedentes, todas las ocurrencias no
entrecomilladas de los caracteres
.BR \e ,
.BR ' ,
y \^\f3"\fP\^ 
.\" "
que no resulten de una de las expansiones anteriores, se eliminan.
.SH REDIRECCIÓN
Antes de que se ejecute una orden, su entrada y salida pueden ser
.I redirigidas
usando una notación especial interpretada por el shell.
La redirección también se puede emplear para abrir y cerrar ficheros
en el entorno de ejecución del shell en curso. Los operadores de
redirección siguientes pueden preceder o aparecer en cualquier sitio
de una 
.I orden simple
o pueden ir detrás de una
.IR orden .
Las redirecciones se procesan en el orden en el que aparecen, de
izquierda a derecha.
.PP
En las descripciones siguientes, si se omite el número del descriptor
de fichero, y el primer carácter del operador de redirección es
.BR < ,
la redirección se refiere a la entrada estándar (descriptor de fichero
0). Si el primer carácter del operador de redirección es
.BR > ,
la redirección se refiere a la salida estándar (descriptor de fichero
1).
.PP
La palabra tras el operador de redirección en las descripciones
siguientes, a menos que se diga otra cosa, está sujeta a la expansión
de llaves, expansión de tilde, expansión de parámetro, sustitución de
orden, expansión aritmética, eliminación de comillas, y expansión de
nombre de camino.
Si se expande a más de una palabra,
.B bash
informa de un error.
.PP
Observe que el orden de las redirecciones es significativo. Por ejemplo,
la orden
.RS
.PP
ls \fB>\fP listadir 2\fB>&\fP1
.RE
.PP
dirige la salida estándar normal y la de errores, ambas, al fichero
.IR listadir ,
mientras que la orden
.RS
.PP
ls 2\fB>&\fP1 \fB>\fP listadir
.RE
.PP
dirige solamente la salida estándar al fichero
.IR listadir ,
porque la salida de errores estándar se ha duplicado como salida
estándar antes de que ésta se redirigiera a
.IR listadir .
.PP
Un fallo en la apertura o creación de un fichero hace que la
redirección fracase.
.SS Redirección de la entrada
.PP
La redirección de la entrada hace que el fichero cuyo nombre resulte
de la expansión
de
.I palabra
se abra para lectura en el descriptor de fichero
.IR n ,
o la entrada estándar (descriptor de fichero 0) si no se especificó 
.IR n .
.PP
El formato general para la redirección de la entrada es:
.RS
.PP
[\fIn\fP]\fB<\fP\fIpalabra\fP
.RE
.SS Redirección de la salida
.PP
la redirección de la salida hace que el fichero cuyo nombre resulte de
la expansión de
.I palabra
se abra para escritura en el descriptor de fichero
.IR n ,
o la salida estándar (descriptor de fichero 1) si
.I n
no se especificó. Si el fichero no existe se crea; si existe se trunca
a longitud cero, se vacía.
.PP
El formato general para la redirección de la salida es:
.RS
.PP
[\fIn\fP]\fB>\fP\fIpalabra\fP
.RE
.PP
Si el operador de redirección es
.BR > ,
y la opción
.B noclobber
de la orden interna
.B set
ha sido activada, la redirección fallará si el nombre de fichero
resultante de la expansión de \fIpalabra\fP existiera y fuera un
fichero regular.
Si el operador de redirección es
.BR >| ,
o es
.B >
y la opción
.B noclobber
de la orden interna
.B set
no está activada, la redirección se intenta incluso si el fichero
nombrado por \fIpalabra\fP existe.
.SS Añadir a la salida redirigida
.PP
La redirección de la salida en esta forma
hace que el fichero cuyo nombre resulte de la expansión de
.I palabra
se abra para añadir en el descriptor de fichero
.IR n ,
o la salida estándar (descriptor de fichero 1) si
.I n
no se especificó. Si el fichero no existe, se crea.
.PP
El formato general para añadir a la salida es:
.RS
.PP
[\fIn\fP]\fB>>\fP\fIpalabra\fP
.RE
.PP
.SS Redirección de la salida estándar normal y de errores
.PP
.B Bash
permite que ambas salidas estándares, la normal (descriptor de fichero
1) y la de errores (descriptor de fichero 2) se redirijan hacia el
fichero cuyo nombre sea la expansión de 
.I palabra
con esta construcción.
.PP
hay dos formatos para la redirección de la salida estándar y la salida
de errores:
.RS
.PP
\fB&>\fP\fIpalabra\fP
.RE
y
.RS
\fB>&\fP\fIpalabra\fP
.RE
.PP
De las dos formas, es preferible la primera.
Ésta es semánticamente equivalente a
.RS
.PP
\fB>\fP\fIpalabra\fP 2\fB>&\fP1
.RE
.SS  Documentos internos
.PP
Este tipo de redirección instruye al shell a leer la entrada desde la
fuente en curso hasta que vea una línea que contenga solamente
.I palabra
(sin blancos detrás).
Todas las líneas leídas hasta ese punto se emplean como la entrada
estándar de una orden.
.PP
El formato de los documentos internos es como sigue:
.RS
.PP
.nf
\fB<<\fP[\fB\-\fP]\fIpalabra\fP
		       \fIdocumento\-interno\fP
\fIdelimitador\fP
.fi
.RE
.PP
No se realiza la expansión de parámetro, sustitución de orden,
expansión de nombre de camino ni expansión aritmética en
.IR palabra .
Si cualquier carácter de
.I palabra
está entrecomillado, el
.I delimitador
es el resultado de la eliminación de comillas en
.IR palabra ,
y las líneas en el documento interno no se expanden.
Si \fIpalabra\fP no está entrecomillada,
todas las líneas del documento interno están sujetas a expansión de
parámetro, sustitución de orden y expansión aritmética. En el último
caso, el par
.B \e<nueva-línea>
no se tiene en cuenta, y
debe emplearse
.B \e
para proteger los caracteres
.BR \e ,
.BR $ ,
y
.BR ` .
.PP
Si el operador de redirección es
.BR <<\- ,
entonces se quitan de las líneas de la entrada todos los caracteres de
tabulación iniciales, así como de  la línea que contiene
.IR delimitador .
Esto permite que los documentos internos dentro de guiones del shell
se sangren de manera natural.
.SS "Duplicación de descriptores de fichero"
.PP
El operador de redirección
.RS
.PP
[\fIn\fP]\fB<&\fP\fIpalabra\fP
.RE
.PP
se emplea para duplicar descriptores de ficheros de entrada.
Si
.I palabra
se expande a uno o más dígitos, el descriptor de fichero denotado por
.I n
se hace ser una copia de este descriptor de fichero.
Si los dígitos en
.I palabra
no especifican un descriptor de fichero abierto para entrada, se
produce un error de redirección.
Si
.I palabra
se evalúa a
.BR \- ,
el descriptor de fichero
.I n
se cierra. Si
.I n
no se especifica, se emplea la entrada estándar (descriptor de fichero
0).
.PP
El operador
.RS
.PP
[\fIn\fP]\fB>&\fP\fIpalabra\fP
.RE
.PP
se emplea similarmente para duplicar descriptores de ficheros de
salida. Si
.I n
no se especificó, se emplea la salida estándar (descriptor de fichero 1).
Si los dígitos en
.I palabra
no especifican un descriptor de fichero abierto para salida, se
produce un error de redirección.
Como un caso especial, si \fIn\fP se omite, y \fIpalabra\fP no se
expande a uno o más dígitos, se redirigen la salida estándar y la
salida estándar de errores como se describió con anterioridad.
.SS "Apertura de descriptores de ficheros para lectura y escritura"
.PP
El operador de redirección
.RS
.PP
[\fIn\fP]\fB<>\fP\fIpalabra\fP
.RE
.PP
hace que el fichero cuyo nombres sea la expansión de
.I palabra
se abra para lectura y para escritura en el descriptor de fichero
.IR n ,
o en el descriptor de fichero 0 si no se especifica
.IR n .
Si el fichero no existe, se crea.
.SH ALIAS
Los alias permiten que una cadena se sustituya por una palabra cuando
se emplee como la primera palabra de una orden simple.
El shell mantiene una lista de
.I alias
que pueden ponerse y quitarse con las órdenes internas
.B alias
y
.B unalias
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
abajo).
Se mira a ver si la primera palabra de cada orden, si no está
entrecomillada, tiene un alias. Si es así, cada palabra se reemplaza
con el texto del alias. El nombre del alias y el texto de reemplazo
pueden contener cualquier entrada válida para el shell, incluyendo los
.I metacaracteres
listados arriba, con la excepción de que el nombre del alias no puede
contener un \fI=\fP. La primera palabra del texto de reemplazo se
comprueba si es un alias, pero si es un alias idéntico al que se está
expandiendo, no se expande una segunda vez. Esto significa que uno
puede poner un alias
.B ls
a
.BR "ls \-F" ,
por ejemplo, y
.B bash
no intenta expandir recursivamente el texto de reemplazo.
Si el último carácter del valor del alias es un
.IR blanco ,
entonces la siguiente palabra de la orden que sigue al alias también
se mira para la expansión de alias.
.PP
Los alias se crean y listan con la orden
.BR alias ,
y se quitan con la orden
.BR unalias .
.PP
No hay ningún mecanismo para poder usar argumentos en el texto de
reemplazo. Si se necesitan, debería emplearse mejor una función del
shell. 
.PP
Los alias no se expanden cuando el shell no es interactivo, a menos
que se haya puesto la opción
.B expand_aliases
mediante 
.B shopt
(vea la descripción de
.B shopt
bajo
.SM
\fBÓRDENES INTERNAS DEL SHELL\fP
abajo).
.PP
Las reglas que conciernen a la definición y uso de los alias son algo
confusas. 
.B Bash
siempre lee por lo menos una línea completa de entrada antes de
ejecutar cualquiera de las órdenes de esa línea. Los alias se expanden
cuando se lee una orden, no cuando se ejecuta. Por lo tanto, una
definición de alias que aparezca en la misma línea que otra orden no
tiene efecto hasta que se lea la siguiente línea de entrada.
Las órdenes que sigan a la definición de alias en esa línea no se ven
afectadas por el nuevo alias.
Este comportamiento también hay que tenerlo en cuenta cuando se
ejecutan funciones.
Los alias se expanden cuando se lee una definición de función, no
cuando la función se ejecuta, porque una definición de función es en
sí misma una orden compuesta. Como consecuencia, los alias definidos
en una función no están disponibles hasta después de que esa función
se ejecute. Para asegurarse, ponga siempre las definiciones de alias
en una línea separada, y no emplee la orden
.B alias
en órdenes compuestas.
.PP
Para casi cualquier propósito, los alias pueden sustituirse por
funciones del shell.
.SH FUNCIONES
Una función del shell, definida como se describió anteriormente bajo
.SM
.BR "GRAMÁTICA DEL SHELL" ,
guarda una serie de órdenes para una ejecución posterior.
Las funciones se ejecutan en el contexto del shell en curso; no se
crea ningún nuevo proceso para interpretarlas (en contraste con la
ejecución de un guión del shell). 
Cuando una función se ejecuta, los argumentos de la función se
convierten en los parámetros posicionales durante su ejecución. El
parámetro especial
.B #
se actualiza para reflejar el cambio. El parámetro posicional 0
permanece intacto. Todos los demás aspectos del entorno de ejecución
del shell son idénticos entre una función y quien la llama con la
excepción de que la trampa
.SM
.B DEBUG
(vea la descripción de la orden interna
.B trap
bajo
.SM
.B ÓRDENES INTERNAS DEL SHELL
más adelante) no se hereda.
.PP
Variables locales a la función se pueden declarar con la orden interna
.BR local .
Normalmente, las variables y sus valores se comparten entre la función
y quien la llama, como variables globales.
.PP
Si se ejecuta la orden interna
.B return
en una función, éste se acaba y la ejecución se reanuda con la
siguiente orden tras la llamada a la función. Cuando una función se
completa, los valores de los parámetros posicionales y el parámetro especial
.B #
se restauran a los valores que tenían antes de la ejecución de la función.
.PP
Los nombres de función y sus definiciones pueden listarse con la opción
.B \-f
de las órdenes internas
.B declare
o
.BR typeset .
La opción
.B \-F
de
.B declare
o
.B typeset
listará solamente los nombres de las funciones.
Las funciones pueden exportarse de modo que los subshells las tengan
definidas automáticamente con la opción 
.B \-f
de la orden interna
.BR export .
.PP
Las funciones pueden ser recursivas. No se impone ningún límite en el
número de llamadas recursivas.
.SH "EVALUACIÓN ARITMÉTICA"
El shell permite que se evalúen expresiones aritméticas, bajo ciertas
circunstancias (vea la orden interna \fBlet\fP y
\fBExpansión aritmética\fP).
La evaluación se hace con enteros largos sin comprobación de
desbordamiento, aunque la división por 0 se atrapa y se señala como un
error. La lista siguiente de operadores se agrupa en niveles de
operadores de igual precedencia.
Los niveles se listan en orden de precedencia decreciente.
.PP
.PD 0
.TP
.B \- +
menos y más unarios
.TP
.B ! ~
negación lógica y de bits
.TP
.B **
exponenciación
.TP
.B * / %
multiplicación, división, resto
.TP
.B + \-
adición, sustracción
.TP
.B << >>
desplazamientos de bits a izquierda y derecha
.TP
.B <= >= < >
comparación
.TP
.B == !=
igualdad y desigualdad
.TP
.B &
Y de bits (AND)
.TP
.B ^
O exclusivo de bits (XOR)
.TP
.B |
O inclusivo de bits (OR)
.TP
.B &&
Y lógico (AND)
.TP
.B ||
O lógico (OR)
.TP
.B \fIexpr\fP?\fIexpr\fP:\fIexpr\fP
evaluación condicional
.TP
.B = *= /= %= += \-= <<= >>= &= ^= |=
asignación
.PD
.PP
Se permite que las variables del shell actúen como operandos; se
realiza la expansión de parámetro antes de la evaluación de la
expresión. 
El valor de un parámetro se fuerza a un entero largo dentro de una
expresión. Una variable del shell no necesita tener activado su
atributo de entero para emplearse en una expresión.
.PP
Las constantes con un 0 inicial se interpretan como números octales.
Un 0x ó 0X inicial denota un número en hexadecimal.
De otro modo, los números toman la forma [\fIbase#\fP]n, donde \fIbase\fP
es un número en base 10 entre 2 y 64 que representa la base
aritmética, y \fIn\fP es un número en esa base. 
Si \fIbase\fP se omite, entonces se emplea la base 10.
Los dígitos mayores que 9 se representan por las letras minúsculas,
las metras mayúsculas, _, y @, en este orden.
Si \fIbase\fP es menor o igual que 36, las letras minúsculas y
mayúsculas pueden emplearse indistintamente para representar números
entre 10 y 35.
.PP
Los operadores se evalúan en orden de precedencia. Las sub-expresiones
entre paréntesis se evalúan primero y pueden sustituir a las reglas de
precedencia anteriores.
.SH "EXPRESIONES CONDICIONALES"
Las expresiones condicionales son empleadas por la orden compuesta
\fB[[\fP y por las órdenes internas \fBtest\fP y \fB[\fP para
comprobar los atributos de ficheros y realizar comparaciones de
cadenas y aritméticas.
Las expresiones se forman a partir de las primarias monarias o
binarias siguientes.
Si cualquier argumento \fIfichero\fP de una de estas primarias es de
la forma /dev/fd/\fIn\fP, entonces se comprueba el descriptor de
fichero  \fIn\fP.
.sp 1
.PD 0
.TP
.B \-a \fIfichero\fP
Verdad si \fIfichero\fP existe.
.TP
.B \-b \fIfichero\fP
Verdad si \fIfichero\fP existe y es un fichero especial de bloques.
.TP
.B \-c \fIfichero\fP
Verdad si \fIfichero\fP existe y es un fichero especial de caracteres.
.TP
.B \-d \fIfichero\fP
Verdad si \fIfichero\fP existe y es un directorio.
.TP
.B \-e \fIfichero\fP
Verdad si \fIfichero\fP existe.
.TP
.B \-f \fIfichero\fP
Verdad si \fIfichero\fP existe y es un fichero regular.
.TP
.B \-g \fIfichero\fP
Verdad si \fIfichero\fP existe y tiene el bit SGID.
.TP
.B \-k \fIfichero\fP
Verdad si \fIfichero\fP existe y tiene el bit ``pegajoso'' (STIcky).
.TP
.B \-p \fIfichero\fP
Verdad si \fIfichero\fP existe y es una tubería con nombre (FIFO).
.TP
.B \-r \fIfichero\fP
Verdad si \fIfichero\fP existe y se puede leer.
.TP
.B \-s \fIfichero\fP
Verdad si \fIfichero\fP existe y tiene un tamaño mayor que cero.
.TP
.B \-t \fIfd\fP
Verdad si el descriptor de fichero
.I fd
está abierto y se refiere a una terminal.
.TP
.B \-u \fIfichero\fP
Verdad si \fIfichero\fP existe y tiene el bit SUID.
.TP
.B \-w \fIfichero\fP
Verdad si \fIfichero\fP existe y se puede modificar.
.TP
.B \-x \fIfichero\fP
Verdad si \fIfichero\fP existe y es ejecutable.
.TP
.B \-O \fIfichero\fP
Verdad si \fIfichero\fP existe y su propietario es el UID efectivo.
.TP
.B \-G \fIfichero\fP
Verdad si \fIfichero\fP existe y su grupo es el GID efectivo.
.TP
.B \-L \fIfichero\fP
Verdad si \fIfichero\fP existe y es un enlace simbólico o blando.
.TP
.B \-S \fIfichero\fP
Verdad si \fIfichero\fP existe y es un zócalo (socket).
.TP
.B \-N \fIfichero\fP
Verdad si \fIfichero\fP existe y ha sido modificado desde que se leyó
la última vez.
.TP
\fIfichero1\fP \-\fBnt\fP \fIfichero2\fP
Verdad si \fIfichero1\fP es más reciente (según la fecha de
modificación) que \fIfichero2\fP.
.TP
\fIfichero1\fP \-\fBot\fP \fIfichero2\fP
Verdad si \fIfichero1\fP es más antiguo que \fIfichero2\fP.
.TP
\fIfichero1\fP \fB\-ef\fP \fIfichero2\fP
Verdad si \fIfichero1\fP y \fIfichero2\fP tienen los mismos números de
nodo-í y de dispositivo.
.TP
.B \-o \fInombre-opción\fP
Verdad si la opción del shell
.I nombre-opción
está activada.
Vea la lista de opciones bajo la descripción de la opción
.B \-o
de la orden interna
.B set
más abajo.
.TP
.B \-z \fIcadena\fP
Verdad si la longitud de \fIcadena\fP es cero.
.TP
.B \-n \fIcadena\fP
.TP
\fIcadena\fP
Verdad si la longitud de
.I cadena
no es cero.
.TP
\fIcadena1\fP \fB==\fP \fIcadena2\fP
Verdad si las cadenas son iguales.  También se puede emplear \fB=\fP
en vez de
\fB==\fP.
.TP
\fIcadena1\fP \fB!=\fP \fIcadena2\fP
Verdad si las cadenas no son iguales.
.TP
\fIcadena1\fP \fB<\fP \fIcadena2\fP
Verdad si \fIcadena1\fP se ordena lexicográficamente antes de \fIcadena2\fP
en la localización en curso.
.TP
\fIcadena1\fP \fB>\fP \fIcadena2\fP
Verdad si \fIcadena1\fP se clasifica lexicográficamente tras
\fIcadena2\fP en la localización en curso.
.TP
.I \fIarg1\fP \fBOP\fP \fIarg2\fP
.SM
.B OP
es uno de
.BR \-eq ,
.BR \-ne ,
.BR \-lt ,
.BR \-le ,
.BR \-gt ,
o
.BR \-ge .
Estos operadores aritméticos binarios devuelven verdadero si
\fIarg1\fP es igual a, distinto de, menor que, menor o igual a,
mayor que, o mayor o igual a \fIarg2\fP, respectivamente.
.I Arg1
y
.I arg2
pueden ser enteros positivos o negativos.
.PD
.SH "EXPANSIÓN DE ORDEN SIMPLE"
Cuando se ejecuta una orden simple, el shell realiza las siguientes
expansiones, asignaciones y redirecciones, de izquierda a derecha.
.IP 1.
Las palabras que el analizador ha marcado como asignaciones de
variables (aquéllas que preceden al nombre de la orden) y
redirecciones se guardan para un procesado posterior.
.IP 2.
Las palabras que no sean asignaciones de variables ni redirecciones se
expanden. Si tras la expansión quedan aún palabras, la primera palabra
se toma como el nombre de la orden y las palabras restantes son los
argumentos. 
.IP 3.
Se ejecutan las redirecciones como se describió más arriba bajo
.SM
.BR REDIRECCIÓN .
.IP 4.
El texto tras el \fB=\fP en cada asignación de variable está sujeto a
expansión de tilde, expansión de parámetro, sustitución de orden,
expansión aritmética y eliminado de comillas antes de ser asignado a
la variable.
.PP
Si no resulta ningún nombre de orden, las asignaciones de variables
afectan al entorno actual del shell. De otro modo, las variables se
añaden al entorno de la orden ejecutada y no afectan al entorno del
shell en curso.
Si cualquiera de las asignaciones intenta dar un valor a una variable
de lectura exclusiva, se produce un error, y la orden acaba con un
estado distinto de cero.
.PP
Si no resulta ningún nombre de orden, se hacen las redirecciones, pero
no afectan al entorno del shell en curso. Un error de redirección hace
que el shell acabe con un estado distinto de cero.
.PP
Si hay un nombre de orden tras la expansión, la ejecución procede como
se describió antes. De otro modo, la orden sale. Si una de las
expansiones contenía una sustitución de orden, el estado de salida de
la orden es el de la última sustitución de orden realizada. Si no
había sustituciones de órdenes, la orden acaba con un estado de cero. 
.SH "EJECUCIÓN DE ÓRDENES"
Después de que una orden ha sido dividida en palabras, si el resultado
es una orden simple y una lista opcional de argumentos, tienen lugar
las siguientes acciones.
.PP
Si el nombre de la orden no contiene barras inclinadas, el shell
intenta localizarla. Si existe una función del shell con ese nombre,
esa función se llama como se describió arriba en
.SM
.BR FUNCIONES .
Si el nombre no coincide con el de ninguna función, el shell lo busca
en la lista de órdenes internas. Si se encuentra, se llama a la orden
interna correspondiente.
.PP
Si el nombre no es ni una función del shell ni una orden interna, y no
contiene barras inclinadas,
.B bash
busca en cada elemento de
.SM
.B PATH
un directorio que contenga un fichero ejecutable con ese nombre.
.B Bash
emplea una tabla de dispersión (hash) para recordar los nombres de
camino completos de los ficheros ejecutables (vea
.B hash
en
.SM
.B "ÓRDENES INTERNAS DEL SHELL"
abajo).
Sólo se realiza una búsqueda completa de los directorios de
.SM
.B PATH
si la orden no se encuentra en la tabla de dispersión.
Si la búsqueda no es satisfactoria, el shell muestra un mensaje de
error y devuelve un estado de salida de 127.
.PP
Si la búsqueda fue exitosa, o si el nombre de la orden contiene una o
más barras inclinadas, el shell ejecuta el programa con ese nombre en
un entorno de ejecución separado.
El argumento 0 se pone al nombre dado, y el resto de argumentos de la
orden se ponen a los argumentos dados, si los hay.
.PP
Si esta ejecución fallara porque el fichero no tuviera un formato
ejecutable, y el fichero no fuera un directorio, se supone que es un
\fIguión del shell\fP, un fichero 
que contiene órdenes del shell. Se crea un subshell para ejecutarlo. 
Este subshell se reinicia a sí mismo, así que el efecto es el mismo
que si se hubiera llamado a un nuevo shell para manejar el guión, con
la excepción de que el hijo retiene las localizaciones de órdenes
recordadas por el padre (vea
.B hash
abajo en
.SM
\fBÓRDENES INTERNAS DEL SHELL\fP).
.PP
Si el programa es un fichero que empieza con los dos caracteres
.BR #! ,
el resto de la primera línea especifica un intérprete para el
programa. El shell ejecuta el intérprete especificado en sistemas
operativos que no manejen por sí mismos este formato de
ejecutable. Los argumentos del intérprete consisten en un solo
argumento opcional tras el nombre del intérprete en la primera linea
del programa, seguido del nombre del programa, seguido por los
argumentos de la orden, si los hubiera.
.SH ENTORNO DE EJECUCIÓN DE ÓRDENES
El shell tiene un \fIentorno de ejecución\fP, que consiste en lo
siguiente:
.sp 1
.IP \(bu
ficheros abiertos heredados por el shell en la llamada, quizás
modificada por redirecciones suministradas a la orden interna
.B exec
.IP \(bu
el directorio de trabajo en curso, establecido por \fBcd\fP, \fBpushd\fP
o \fBpopd\fP, o heredado por el shell en la llamada
.IP \(bu
la máscara de modo de creación de ficheros, establecida por
.B umask
o heredada del padre del shell
.IP \(bu
las trampas en curso establecidas por
.B trap
.IP \(bu
parámetros del shell que han sido establecidos por asignaciones de
variables o con \fBset\fP, o heredados del padre del shell en el entorno
.IP \(bu
funciones del shell definidas durante la ejecución o heredadas del
padre del shell en el entorno
.IP \(bu
opciones activadas en la llamada (bien por omisión o mediante
argumentos en la línea de órdenes) o por
.B set
.IP \(bu
opciones activadas mediante
.B shopt
.IP \(bu
alias del shell definidos con
.B alias
.IP \(bu
varios identificadores de proceso, incluyendo los de trabajos en
segundo plano, el valor de \fB$$\fP, y el valor de 
.B $PPID
.PP
Cuando una orden simple distinta de una interna o una función del
shell se va a ejecutar, se llama en un entorno de ejecución separado
que consiste en lo siguiente. A menos que se diga otra cosa, los
valores se heredan del shell.
.sp 1
.IP \(bu
los ficheros abiertos del shell, más las modificaciones y adiciones
especificadas en la orden por redirecciones
.IP \(bu
el directorio de trabajo en curso
.IP \(bu
la máscara de modo de creación de ficheros
.IP \(bu
variables del shell marcadas para la exportación, junto con variables
exportadas para la orden, pasadas en el entorno
.IP \(bu
las trampas capturadas por el shell se restauran a los valores
del padre del shell, y las trampas que no son tenidas en cuenta por el
shell tampoco lo son
.PP
Una orden llamada en este entorno separado no puede afectar al entorno
de ejecución del shell.
.PP
La sustitución de órdenes y las órdenes asíncronas se llaman en un
entorno de subshell que es un duplicado del entorno del shell, excepto
que las trampas capturadas por el shell se restauran a los valores que
el shell heredó de su padre en la llamada. Las órdenes internas que se
llaman como parte de una tubería se ejecutan también en un entorno de
subshell. Los cambios hechos al entorno del subshell no pueden afectar
al entorno de ejecución del shell.
.SH ENTORNO
Cuando se llama a un programa, se le da un vector de cadenas de
caracteres llamado el
.IR entorno .
Esto es una lista de parejas
\fInombre\fP\-\fIvalor\fP, de la forma
.IR "nombre\fR=\fPvalor" .
.PP
El shell le permite manipular el entorno de varias maneras. En la hora
de la llamada, el shell escudriña el entorno y crea un parámetro para
cada nombre encontrado, marcándolo automáticamente para la
.I exportación
a procesos hijos. Las órdenes ejecutadas heredan el entorno.
Las órdenes
.B export
y
.B declare \-x
permiten añadir y quitar parámetros y funciones del entorno. Si el
valor de un parámetro en el entorno se modifica, el nuevo valor pasa
a formar parte del entorno, reemplazando al antiguo. El entorno
heredado por cualquier orden ejecutada consiste en el entorno inicial
del shell, cuyos valores pueden ser modificados en el shell, menos
las parejas quitadas mediante la orden
.B unset
más las adiciones con las órdenes
.B export
y
.BR "declare \-x" .
.PP
El entorno para cualquier
.I orden simple
o función puede aumentarse temporalmente prefijándola con asignaciones
de parámetros, como se describió arriba en
.SM
.BR PARÁMETROS .
Estas sentencias de asignación afectan solamente al entorno visto por
esa orden.
.PP
Si la opción
.B \-k
está puesta (vea la orden interna
.B set
más adelante), entonces
.I todas
las asignaciones de parámetros se ponen en el entorno para una orden,
no sólo las que preceden a su nombre.
.PP
Cuando
.B bash
llama a una orden externa, la variable
.B _
se pone con el nombre completo del fichero de la orden y se pasa a esa
orden en su entorno.
.SH "ESTADO DE SALIDA"
Para los propósitos del shell, una orden que acabe con un estado de
salida cero, ha tenido éxito. Un estado de salida de cero indica
éxito. Un estado de salida distinto de cero indica fallo.
Cuando una orden termina por una señal fatal, \fBbash\fP emplea el
valor de 128+\fBseñal\fP como el estado de salida.
.PP
Si una orden no se encuentra, el proceso hijo creado para ejecutarla
devuelve un estado de 127. Si una orden se encuentra pero no es
ejecutable, el estado de salida es 126.
.PP
Si una orden falla debido a un error durante la expansión o
redirección, el estado de salida es mayor que cero.
.PP
Las órdenes incorporadas en el shell devuelven un estado de 0
(\fIverdad\fP) si acaban con éxito, y distinto de cero (\fIfalso\fP)
si ocurre un error mientras se ejecutan.
Todas las órdenes internas devuelven un estado de salida de 2 para
indicar un modo de empleo incorrecto.
.PP
El propio \fBbash\fP devuelve el estado de salida de la última orden
ejecutada, a menos que ocurra un error de sintaxis, en cuyo caso acaba
con un estado distinto de cero. Vea también la orden interna
.B exit
abajo.
.SH SEÑALES
Cuando \fBbash\fP es interactivo, en la ausencia de trampas, no hace
caso de
.SM
.B SIGTERM
(de modo que \fBkill 0\fP no mata un shell interactivo),
y se captura y maneja
.SM
.B SIGINT
(de manera que la orden interna \fBwait\fP es interrumpible).
En todos los casos, 
.B bash
no hace caso de
.SM
.BR SIGQUIT .
Si el control de trabajos tiene efecto,
.B bash
no hace caso de
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU ,
y
.SM
.BR SIGTSTP .
.PP
Los trabajos síncronos empezados por 
.B bash
tienen manejadores de señal puestos a los valores heredados por el
shell de su padre.
Cuando el control de trabajo no está en efecto, las órdenes internas
no hacen caso de
.SM
.B SIGINT
ni
.SM
.B SIGQUIT
tampoco.
Las órdenes ejecutadas como resultado de sustitución de orden no hacen
caso de las señales de control de trabajo generadas mediante el teclado
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU ,
ni
.SM
.BR SIGTSTP .
.PP
El shell, de forma predeterminada, acaba cuando recibe una señal
.SM
.BR SIGHUP .
Antes de salir, reenvía la señal
.SM
.B SIGHUP
a todos los trabajos, en ejecución o parados.
A los trabajos parados se les envía
.SM
.B SIGCONT
para asegurarse de que reciben la señal
.SM
.BR SIGHUP .
Para prevenir que el shell envíe la señal a un trabajo particular,
debería quitarse de la lista de trabajos con la orden interna
.B disown
(vea
.SM
.B "ÓRDENES INTERNAS DEL SHELL"
más abajo) o marcarlo para no recibir
.SM
.B SIGHUP
empleando
.BR "disown \-h" .
.PP
Si la opción del shell
.B huponexit
se ha puesto mediante
.BR shopt ,
.B bash
envía una señal
.SM
.B SIGHUP
a todos los trabajos cuando un shell de entrada interactivo se acaba.
.PP
Cuando \fBbash\fP recibe una señal para la que se ha puesto una trampa
mientras se se está esperando que una orden se complete, la trampa no
se ejecutará hasta que la orden se complete.
Cuando \fBbash\fP está esperando una orden asíncrona mediante la orden
interna \fBwait\fP, la recepción de una señal para la que se ha
definido una trampa, hará que la orden interna 
.B wait
regrese inmediatamente con un estado de salida mayor que 128,
inmediatamente tras que se ejecute la trampa.
.SH "CONTROL DE TRABAJOS"
El
.I control de trabajos
se refiere a la capacidad de parar selectivamente (\fIsuspender\fP) la
ejecución de procesos y continuar (\fIreanudar\fP) su ejecución
posteriormente. Un usuario emplea esta facilidad típicamente a través
de una interfaz interactiva suministrada conjuntamente por el
controlador de terminal del sistema y 
.BR bash .
.PP
El shell asocia un
.I  trabajo
con cada tubería. Mantiene una tabla de trabajos ejecutándose
actualmente, que pueden listarse con la orden
.BR jobs .
Cuando
.B bash
arranca un trabajo asíncronamente (en 
.IR "segundo plano" ),
imprime una línea con un aspecto como ésta:
.RS
.PP
[1] 25647
.RE
.PP
indicando que este trabajo es el número 1 y que el PID del último
proceso en la tubería asociada con él es 25647.
Todos los procesos en una misma tubería son miembros del mismo
trabajo. 
.B Bash
emplea la
abstracción del
.I  trabajo
como la base para el control de trabajos.
.PP
Para facilitar la implementación de la interfaz del usuario al control
de trabajos, el sistema mantiene la noción de un 
.I identificador (ID) de grupo de procesos de la terminal en curso.
Los miembros de este grupo de procesos (procesos cuyo PGID es igual al
PGID de la terminal en curso) reciben señales generadas por el teclado
como
.SM
.BR SIGINT .
Se dice que estos procesos están en
.IR "primer plano" .
Los procesos en
.I segundo plano
son aquéllos cuyo PGID difiere del de la terminal; tales procesos son
inmunes a señales generadas desde el teclado.
Sólo los procesos en primer plano tienen permitido leer o escribir en
la terminal. A los procesos en segundo plano que intenten leer de (o
escribir en) la terminal, el controlador de terminal les manda una señal
.SM
.B SIGTTIN (SIGTTOU)
que, a menos que  sea capturada, suspende el proceso.
.PP
Si el sistema operativo en el que
.B bash
se está ejecutando, admite el
control de trabajos (Linux lo admite, por supuesto),
.B bash
le permite usarlo.
Teclear el carácter
.I suspender
(típicamente
.BR ^Z ,
Control-Z) mientras que un proceso se está ejecutando,
hace que ese proceso se pare y le devuelve a Ud. al
.BR bash .
Teclear el carácter
.I "suspensión diferida"
(típicamente
.BR ^Y ,
Control-Y) hace que el proceso se pare cuando
intente leer entrada desde la terminal, y el control se devuelve a
.BR bash .
El usuario puede entonces manipular el estado de este trabajo,
empleando la orden
.B bg
para continuar con él en segundo plano, la orden
.B fg
para continuar con él en primer plano, o la orden
.B kill
para matarlo. Un \fB^Z\fP tiene efecto inmediatamente,
y tiene el efecto adicional colateral de que la salida pendiente y lo
que haya en el búfer de entrada del teclado se descartan. 
.PP
Hay varias formas de referirse a un trabajo en el shell.
El carácter
.B %
introduce un nombre de trabajo. El trabajo número
.I n
puede ser referenciado como
.BR %n .
Un trabajo puede ser referenciado utilizando un prefijo del nombre
empleado para arrancarlo, o usando una subcadena que aparezca en su
línea de órdenes.
Por ejemplo.
.B %ce
se refiere a un trabajo
.B ce
parado. Si un prefijo concuerda con más de un trabajo,
.B bash
informa de un error. Usar
.BR %?ce ,
por otra parte, se refiere a cualquier trabajo que contenga la cadena
.B ce
en su línea de órdenes. Si la subcadena concuerda con más de un trabajo,
.B bash
informa de un error. Los símbolos
.B %%
y
.B %+
se refieren a la noción que tiene el shell del
.IR "trabajo en curso" ,
que es el último trabajo parado mientras estaba en primer plano o se
arrancó en segundo plano.
El 
.I "trabajo anterior"
puede referenciarse usando
.BR %\- .
En la salida relativa a trabajos (e.g., la salida de la orden
.BR jobs ),
el trabajo actual se marca siempre con un
.BR + ,
y el anterior con un
.BR \- .
.PP
Si simplemente damos el nombre de un trabajo, esto puede traerlo a
primer plano:
.B %1
es un sinónimo de
\fB``fg %1''\fP,
que trae el trabajo número 1 desde el segundo plano al primero.
Similarmente,
.B ``%1 &''
reanuda el trabajo 1 en el segundo plano, equivalente a
\fB``bg %1''\fP.
.PP
El shell se entera inmediatamente de cuando un trabajo cambia de estado.
Normalmente,
.B bash
espera hasta que está a punto de mostrar un indicador antes de
informar de cambios en el estado de un trabajo, para no interrumpir
cualquier otra salida. Si la opción
.B \-b
de la orden interna
.B set
está activada,
.B bash
informa de tales cambios inmediatamente.
.PP
Si se intenta salir de
.B bash
mientras hay trabajos parados, el shell muestra un mensaje de
aviso. La orden
.B jobs
se puede usar entonces para inspeccionar sus estados.
Si se hace un segundo intento de salir sin ninguna otra orden
intermedia, el shell no muestra ningún otro aviso, y los trabajos
parados se hacen terminar.
.SH INDICADORES
Cuando se ejecuta interactivamente,
.B bash
muestra el indicador primario
.SM
.B PS1
cuando está dispuesto para leer una orden, y el secundario
.SM
.B PS2
cuando necesita más entrada para completar una orden.
.B Bash
permite que estas cadenas indicadoras se personalicen insertando un
número de caracteres especiales protegidos con la barra inversa, que
se interpretan como sigue:
.RS
.PD 0
.TP
.B \ea
un carácter de alerta ASCII (07)
.TP
.B \ed
la fecha en el formato "Día-Semana Mes Día" (ejemplo, "Tue May 26") en
inglés
.TP
.B \ee
un carácter de escape (ESC) ASCII (033)
.TP
.B \eh
el nombre del computador anfitrión hasta el primer `.'
.TP
.B \eH
el nombre del computador anfitrión completo
.TP
.B \en
salto de línea
.TP
.B \er
retorno de carro
.TP
.B \es
el nombre del shell, el nombre base de
.B $0
(la porción que sigue a la última barra inclinada)
.TP
.B \et
la hora actual en el formato de 24 horas HH:MM:SS
.TP
.B \eT
la hora actual en el formato de	12 horas HH:MM:SS
.TP
.B \e@
la hora actual en el formato de 12 horas con indicador AM/PM
.TP
.B \eu
el nombre de usuario del usuario en curso
.TP
.B \ev
la versión de \fBbash\fP (e.g., 2.00)
.TP
.B \eV
la distribución de \fBbash\fP, versión + nivel de parcheo (e.g., 2.00.0)
.TP
.B \ew
el directorio de trabajo en curso
.TP
.B \eW
el nombre base del directorio de trabajo
.TP
.B \e!
el número de historia de esta orden
.TP
.B \e#
el número de orden de esta orden
.TP
.B \e$
si el UID efectivo es 0 (el super-usuario), un
.BR # ,
si no un
.B $
.TP
.B \e\fInnn\fP
el carácter correspondiente al número octal \fInnn\fP
.TP
.B \e\e
una barra inclinada invertida
.TP
.B \e[
empieza una secuencia de caracteres no imprimibles, que pueden
emplearse para empotrar una secuencia de control del terminal en el
indicador 
.TP
.B \e]
termina una secuencia de caracteres no imprimibles
.PD
.RE
.PP
El número de orden y el número de historia son usualmente diferentes:
el número de historia de una orden es su posición en la lista de
historia, que puede incluir órdenes restauradas desde el fichero de
historia (vea
.SM
.B HISTORIA
más abajo), mientras que el número de orden es la posición en la
secuencia de órdenes ejecutadas durante la sesión de shell actual.
Después de que la cadena es descodificada, se expande mediante la
expansión de parámetros, sustitución de órdenes, expansión aritmética,
expansión de cadena, y eliminación de comillas, sujeta al valor de la
opción del shell
.B promptvars
(vea la descripción de la orden
.B shopt
bajo
.SM
.B "ÓRDENES INTERNAS DEL SHELL"
más adelante).
.SH READLINE
\fIReadline\fP (leer línea) es la biblioteca que maneja la lectura de
la entrada cuando se usa un shell interactivo, a menos que se haya
dado la opción 
.B \-\-noediting
cuando se llamó.
De forma predeterminada, las órdenes de edición de la línea son
similares a las de emacs.
También se dispone de una interfaz de edición de líneas al estilo de vi.
Para desactivar la edición de líneas una vez que el shell está en
ejecución, use las opciones
.B +o emacs
o
.B +o vi
de la orden interna
.B set
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
abajo).
.SS "Notación de Readline"
.PP
En esta sección, se emplea la notación al estilo de emacs para denotar
las teclas.
Las teclas de control se representan por medio de C\-\fItecla\fP;
así, C\-n significa Control\-N. De forma similar,
las teclas
.I meta
(Alt)
se representan con M\-\fItecla\fP, de forma que M\-x significa
Meta\-X. (En teclados sin tecla
.IR meta ,
M\-\fIx\fP significa ESC \fIx\fP, i.e., pulsar la tecla de escape
(Esc) y luego la tecla
.IR x .
Esto hace que ESC sea el \fIprefijo meta\fP.
La combinación M\-C\-\fIx\fP quiere decir ESC\-Control\-\fIx\fP,
o pulsar la tecla Escape y luego mantener presionada la tecla Control
mientras se pulsa la tecla
.IR x .)
.PP
Las órdenes de readline pueden recibir
.I argumentos
numéricos que actúan normalmente como un número de repetición.
Algunas veces, empero, lo que tiene significado es el signo del
argumento. Pasar un argumento negativo a una orden que actúa en la
dirección adelante (p. ej., \fBkill\-line\fP) hace que esa orden actúe
en la dirección contraria, hacia atrás.
Las órdenes cuyo comportamiento con argumentos se desvíe de esto se
señalan más adelante.
.PP
Cuando una orden se describe como que \fIcorta\fP texto, el texto
borrado se guarda para una posible futura recuperación
(\fIpegado\fP). El texto cortado se guarda en un \fIanillo de
corte\fP. Cortes consecutivos hacen que el texto se acumule en una
unidad, que puede pegarse toda de golpe, de una vez. Las órdenes que
no cortan texto separan los trozos de texto en el anillo de corte.
.SS "Inicio de Readline"
.PP
Readline se personaliza poniendo órdenes en un fichero de inicio
(el fichero \fIinputrc\fP).
El nombre de este fichero se toma del valor de la variable
.SM
.BR INPUTRC .
Si esta variable no está definida, el valor predeterminado es
.IR ~/.inputrc .
Cuando un programa que hace uso de la biblioteca readline arranca, el
fichero de inicio se lee, y se establecen las definiciones de teclas y
variables. 
Sólo se permiten unas pocas construcciones básicas en el fichero de
inicio de readline.
Las líneas en blanco no se tienen en cuenta.
Las líneas que comiencen con un \fB#\fP son comentarios.
Las líneas que comiencen con un \fB$\fP indican construcciones condicionales.
Otras líneas representan definiciones de teclas y definiciones de variables.
.PP
Las definiciones predeterminadas de teclas pueden cambiarse con un fichero
.IR inputrc  .
Otros programas que usen esta biblioteca pueden añadir sus propias
órdenes y definiciones.
.PP
Por ejemplo, el poner
.RS
.PP
M\-Control\-u: universal\-argument
.RE
o
.RS
C\-Meta\-u: universal\-argument
.RE
dentro del fichero
.I inputrc
haría que M\-C\-u ejecutara la orden de  readline
.IR universal\-argument .
.PP
Se reconocen los siguientes nombres simbólicos de caracteres:
.IR RUBOUT ,
.IR DEL ,
.IR ESC ,
.IR LFD ,
.IR NEWLINE ,
.IR RET ,
.IR RETURN ,
.IR SPC ,
.IR SPACE ,
y
.IR TAB .
Además de los nombres de órdenes, readline permite que se enlace una
tecla cualquiera a una cadena de caracteres que se inserta cuando la
tecla se pulse (una \fImacro\fP).
.SS "Definiciones de teclas de Readline"
.PP
La sintaxis para controlar las definiciones de teclas en el fichero
.I inputrc
es simple.  Todo lo que se requiere es el nombre de la orden
o el texto de una macro y una secuencia de teclas con la cual debe
enlazarse. El nombre se puede especificar en una de dos formas:
como un nombre simbólico de tecla, posiblemente con prefijos
\fIMeta\-\fP o \fIControl\-\fP, o como una secuencia de teclas.
Cuando se use la forma \fBnombre-tecla\fP:\^\fInombre-función\fP o \fImacro\fP,
.I nombre-tecla
es el nombre de una tecla en inglés. Por ejemplo:
.sp
.RS
Control-u: universal\-argument
.br
Meta-Rubout: backward-kill-word
.br
Control-o: "> salida"
.RE
.LP
En el ejemplo de arriba,
.I C\-u
se enlaza a la función
.BR universal\-argument ,
.I M\-DEL
se vincula a la función
.BR backward\-kill\-word ,
y
.I C\-o
se define como que se ejecute la macro
expresada en la parte derecha (esto es, insertar el texto
.I "> salida"
en la línea).
.PP
En la segunda forma, \fB"sectecla"\fP:\^\fInombre-función\fP o \fImacro\fP,
.B sectecla
difiere de la
.B nombre-tecla
de antes en que las cadenas que representan una secuencia entera de
teclas pueden especificarse poniendo la secuencia entre comillas
dobles. Así se pueden utilizar algunas teclas de escape al estilo de
GNU Emacs, como en el siguiente ejemplo. 
.sp
.RS
"\eC\-u": universal\-argument
.br
"\eC\-x\eC\-r": re\-read\-init\-file
.br
"\ee[11~": "Tecla de Función 1"
.RE
.PP
En este ejemplo,
.I C\-u
se enlaza de nuevo a la función
.BR universal\-argument .
.I "C\-x C\-r"
se vincula a la función
.BR re\-read\-init\-file ,
y
.I "ESC [ 1 1 ~"
se define como que se inserte el texto
.BR "Tecla de Función 1" .
El conjunto completo de las secuencias de escape al estilo de GNU
Emacs es
.RS
.PD 0
.TP
.B \eC\-
prefijo de control
.TP
.B \eM\-
prefijo meta
.TP
.B \ee
un carácter de Escape
.TP
.B \e\e
barra inclinada inversa
.TP
.B \e"
una " literal
.TP
.B \e'
un ' literal
.RE
.PD
.PP
Además de las secuencias de escape al estilo de GNU Emacs, se dispone
de un segundo conjunto de escapes con la barra invertida:
.RS
.PD 0
.TP
.B \ea
alerta (campana)
.TP
.B \eb
espacio atrás
.TP
.B \ed
borrado
.TP
.B \ef
salto de página
.TP
.B \en
salto de línea
.TP
.B \er
retorno de carro
.TP
.B \et
tabulador horizontal
.TP
.B \ev
tabulador vertical
.TP
.B \e\fInnn\fP
el carácter cuyo código es el valor octal \fInnn\fP (de 1 a 3 dígitos)
.TP
.B \ex\fInnn\fP
el carácter cuyo código es el valor hexadecimal \fInnn\fP (de 1 a 3 dígitos)
.RE
.PD
.PP
Cuando se mete el texto de una macro, se deben emplear comillas simples
o dobles para indicar una definición de macro.
El texto no entrecomillado se supone un nombre de función.
En el cuerpo de la macro, los escapes con barra inversa de arriba se expanden.
La barra inversa protegerá a cualquier otro carácter en el texto de la
macro, incluyendo a " y a '.
.\" "
.PP
.B Bash
permite mostrar o modificar las definiciones de teclas en curso
mediante la orden interna
.BR bind .
El modo de edición puede cambiarse durante una sesión interactiva
empleando la opción
.B \-o
de la orden interna
.B set
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
abajo).
.SS "Variables de Readline"
.PP
Readline tiene variables que se pueden usar para personalizar más aún
su comportamiento. Una variable se puede definir en el fichero
.I inputrc
con una sentencia de la forma
.RS
.PP
\fBset\fP \fInombre-variable\fP \fIvalor\fP
.RE
.PP
Excepto cuando se diga, las variables de readline pueden tomar los valores
.B On
u
.BR Off .
Las variables y sus valores predeterminados son:
.PP
.PD 0
.TP
.B bell\-style (audible)
Controla qué pasa cuando readline quiere tocar el pito de la terminal.
Si se define como \fBnone\fP, readline nunca toca el pito. Si se pone a
\fBvisible\fP, readline usa una alerta visible si está disponible.
Si se pone como \fBaudible\fP, readline intenta hacer sonar el pito de
la terminal. 
.TP
.B comment\-begin (``#'')
La cadena que se inserta cuando se ejecuta la orden de
.B readline 
.BR insert\-comment .
Esta orden está enlazada a
.B M\-#
en modo emacs y a
.B #
en modo vi.
.TP
.B completion\-ignore\-case (Off)
Si se pone a \fBOn\fP, readline realiza la concordancia y terminación
de nombres de ficheros sin importar si las letras son mayúsculas o minúsculas.
.TP
.B completion\-query\-items (100)
Esto determina cuándo se pregunta al usuario si quiere ver el número
de terminaciones posibles generadas por la orden
\fBpossible\-completions\fP.
Puede ponerse a cualquier valor entero mayor o igual a cero. Si el
número de posibles terminaciones es mayor o igual que el valor de esta
variable, al usuario se le pregunta si desea o no verlas; si no,
simplemente se muestran en la terminal.
.TP
.B convert\-meta (On)
Si se pone a \fBOn\fP, readline convertirá caracteres con el octavo
bit a uno a una secuencia de teclas ASCII
poniendo el octavo bit a cero y prefijando un carácter Esc (en efecto,
usando Esc como el \fIprefijo meta\fP).
.TP
.B disable\-completion (Off)
Si se pone a \fBOn\fP, readline inhibirá la terminación de
palabras. Los caracteres para la terminación se insertarán en la línea
como si se hubieran hecho corresponder con \fBself-insert\fP.
.TP
.B editing\-mode (emacs)
Controla si readline empieza con un conjunto de definiciones de teclas
similar a las de \fIemacs\fP o \fIvi\fP.
.B editing\-mode
puede ponerse a los valores
.B emacs
o
.BR vi .
.TP
.B enable\-keypad (Off)
Cuando se pone a \fBOn\fP, readline intentará activar el teclado
auxiliar cuando se llame. Algunos sistemas necesitan esto para activar
las teclas de flechas de cursor.
.TP
.B expand\-tilde (Off)
Si se pone a \fBon\fP, la expansión de tilde se realiza cuando
readline intenta la terminación de palabras.
.TP
.B horizontal\-scroll\-mode (Off)
Cuando se pone a \fBOn\fP, esto hace que readline use una sola línea
para pantalla, haciendo rodar la entrada horizontalmente en una sola
línea de la pantalla cuando ésta es más larga que la anchura de la
pantalla; en lugar de seguir en la línea siguiente.
.TP
.B input\-meta (Off)
Si se pone a \fBOn\fP, readline habilitará la entrada de 8 bits (esto
es, no pondrá a cero el octavo bit de los caracteres que lea),
sin importar lo que la terminal diga que admite. El nombre
.B meta\-flag
es un sinónimo para esta variable.
.TP
.B keymap (emacs)
Establece el mapa de teclado actual para readline. El conjunto de
nombres de mapas de teclado válidos es
\fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi,
vi\-command\fP, y
.IR vi\-insert .
\fIvi\fP es equivalente a \fIvi\-command\fP; \fIemacs\fP es
equivalente a \fIemacs\-standard\fP.  El valor predeterminado es
.IR emacs ;
el valor de
.B editing\-mode
también afecta al mapa de teclado predeterminado.
.TP
.B mark\-directories (On)
Si se pone a \fBOn\fP, los nombres de directorios completados tendrán
una barra inclinada añadida al final.
.TP
.B mark\-modified\-lines (Off)
Si se pone a \fBOn\fP, las líneas de historia que hayan sido
modificadas se muestran con un asterisco precediéndolas (\fB*\fP).
.TP
.B output\-meta (Off)
Si se pone a \fBOn\fP, readline mostrará directamente los caracteres
con el octavo bit a uno, en vez de como una secuencia de escape
prefijada con meta.
.TP
.B print\-completions\-horizontally (Off)
Si se pone a \fBOn\fP, readline mostrará terminaciones con 
concordancias clasificadas horizontalmente en orden alfabético, en vez de
verticalmente.
.TP
.B show\-all\-if\-ambiguous (Off)
Esto altera el comportamiento predeterminado de las funciones de
terminación. Si se pone a
.BR on ,
las palabras que tienen más de una posible terminación hacen que las
concordancias se muestren inmediatamente en vez de tocarse el pito de
la terminal.
.TP
.B visible\-stats (Off)
Si se pone a \fBOn\fP, se añade un carácter que represente un tipo de
fichero según lo que devuelve \fIstat\fP(2) cuando se listan las
terminaciones posibles.
.PD
.SS "Construcciones condicionales de Readline"
.PP
Readline implementa una facilidad similar en espíritu a las
características de compilación condicional del preprocesador de C que
permite que las definiciones de teclas y variables se realicen en
función de pruebas o condiciones. Hay cuatro directivas del analizador
que se usan.
.IP \fB$if\fP
La construcción
.B $if
permite que las definiciones se hagan según el modo de edición, la
terminal en uso, o la aplicación que haga uso de readline.
El texto de la condición se extiende hasta el final de la línea; no se
requieren caracteres para aislarla.
.RS
.IP \fBmode\fP
La forma \fBmode=\fP de la directiva \fB$if\fP se usa para ver si
readline está en modo emacs o vi.
Esto se puede emplear en conjunción con la orden \fBset keymap\fP, por
ejemplo, para poner el teclado en los mapas \fIemacs\-standard\fP y
\fIemacs\-ctlx\fP sólo si readline está arrancando en modo emacs.
.IP \fBterm\fP
La forma \fBterm=\fP puede emplearse para incluir definiciones de
teclas específicas de una terminal determinada, quizás para enlazar
las secuencias de teclas generadas por las teclas de función de la
terminal. La palabra en la parte derecha del
.B =
se prueba contra el nombre completo de la terminal y contra la porción
del nombre de la terminal antes del primer \fB\-\fP. Esto permite que
.I sun
concuerde con
.I sun
y con
.IR sun\-cmd ,
por ejemplo.
.IP \fBapplication\fP
La construcción \fBapplication\fP se emplea para incluir
definiciones específicas de la aplicación. Cada programa que usa la
biblioteca readline define el \fInombre de la aplicación\fP, y en un
fichero de arranque se puede comprobar si existe un valor en particular.
Esto se podría emplear para enlazar secuencias de teclas a funciones
útiles para un programa específico. Por ejemplo, la orden siguiente
añade una secuencia de teclas que entrecomilla la palabra en curso o
la anterior en bash:
.sp 1
.RS
.nf
\fB$if\fP Bash
# Entrecomilla la palabra actual o previa
"\eC\-xq": "\eeb\e"\eef\e""
\fB$endif\fP
.fi
.RE
.RE
.IP \fB$endif\fP
Esta orden, como se ha visto en el ejemplo precedente, termina una
orden \fB$if\fP.
.IP \fB$else\fP
Las órdenes en esta rama de la directiva \fB$if\fP se ejecutan si la
comprobación falla.
.IP \fB$include\fP
Esta directiva toma como argumento un solo nombre de fichero y lee
órdenes y definiciones de ese fichero. Por ejemplo, la siguiente
directiva leería de \fI/etc/inputrc\fP:
.sp 1
.RS
.nf
\fB$include\fP \^ \fI/etc/inputrc\fP
.fi
.RE
.SS Búsquedas
.PP
Readline proporciona órdenes para buscar a través de la historia de órdenes
(vea
.SM
.B HISTORIA
abajo) líneas que contengan una cadena especificada.
Hay dos modos de búsqueda:
.I incremental
y
.IR "no incremental" .
.PP
La búsqueda incremental comienza antes de que el usuario haya acabado
de teclear la cadena a buscar.
Tan pronto como se teclea cada carácter de la cadena de búsqueda,
readline muestra la siguiente entrada de la historia que concuerde con
la cadena que se esté tecleando hasta este punto. Una búsqueda
incremental requiere solamente tantos caracteres como se necesiten
para encontrar la entrada deseada en la lista de historia.
El carácter Escape se emplea para terminar una búsqueda incremental.
Control-J también dará por terminada la búsqueda.
Control-G parará abruptamente una búsqueda incremental y restaurará la
línea original.
Cuando la búsqueda se termine, la entrada de la historia que
contuviera la cadena de búsqueda se convierte en la línea en curso.
Para encontrar otras entradas en la lista de historia, teclee
Control-S o Control-R, según sea apropiado.
Esto buscará hacia atrás o  adelante en la historia la siguiente
entrada concordante con la cadena de búsqueda tecleada hasta este punto. 
Cualquier otra secuencia de teclas asociada a una orden de readline
terminará la búsqueda y ejecutará esa orden.
Por ejemplo, una \fInueva-línea\fP terminará la búsqueda y aceptará la
línea, ejecutando de ese modo la orden de la lista de historia.
.PP
Las búsquedas no incrementales leen la cadena de búsqueda entera antes
de empezar a buscar en las líneas de la lista de historia. La cadena
de búsqueda puede ser tecleada por el usuario o ser parte de los
contenidos de la línea en curso.
.SS "Nombres de órdenes de Readline"
.PP
Lo siguiente es una lista de los nombres de las órdenes y las
secuencias de teclas predeterminadas a las que están asociadas.
Los nombres de órdenes sin una secuencia de tecla acompañante
pertenecen a órdenes que no están asociadas a ninguna secuencia de
teclas de forma predeterminada.
.SS Órdenes para el movimiento
.PP
.PD 0
.TP
.B beginning\-of\-line (C\-a)
Mover al principio de la línea en curso.
.TP
.B end\-of\-line (C\-e)
Mover al final de la línea.
.TP
.B forward\-char (C\-f)
Mover un carácter hacia adelante.
.TP
.B backward\-char (C\-b)
Mover un carácter hacia atrás.
.TP
.B forward\-word (M\-f)
Mover adelante hasta el final de la siguiente palabra. Las palabras se
componen de caracteres alfanuméricos (letras y dígitos).
.TP
.B backward\-word (M\-b)
Mover atrás hasta el principio de esta palabra o la anterior. 
Las palabras se
componen de caracteres alfanuméricos (letras y dígitos).
.TP
.B clear\-screen (C\-l)
Limpiar la pantalla dejando la línea en curso al principio de la
pantalla. Con un argumento, refresca la línea en curso sin borrar la
pantalla. 
.TP
.B redraw\-current\-line
Refrescar la línea en curso.
.PD
.SS Órdenes para manipular la lista de historia
.PP
.PD 0
.TP
.B accept\-line (Nueva-línea, Intro)
Aceptar la línea sin importar dónde esté el cursor. Si esta línea no
está vacía, añadirla a la lista de historia de acuerdo con el estado
de la variable
.SM
.BR HISTCONTROL .
Si la línea es una de las de la historia, modificada, entonces
restaurar la línea de la historia a su estado original.
.TP
.B previous\-history (C\-p)
Obtener la orden anterior de la lista de historia, moviéndose hacia
atrás en ella.
.TP
.B next\-history (C\-n)
Obtener la orden siguiente de la lista de historia, moviéndose hacia
delante en ella.
.TP
.B beginning\-of\-history (M\-<)
Mover a la primera línea de la lista de historia.
.TP
.B end\-of\-history (M\->)
Mover al final de la historia de entrada; esto es, la línea que está
siendo introducida en la actualidad.
.TP
.B reverse\-search\-history (C\-r)
Buscar hacia atrás empezando en la línea en curso y moviéndose
`arriba' a través de la lista de historia si es necesario. Esta
búsqueda es incremental.
.TP
.B forward\-search\-history (C\-s)
Buscar hacia adelante empezando en la linea en curso y moviéndose
`abajo' a través de la lista de historia si es necesario. Esta
búsqueda es incremental.
.TP
.B non\-incremental\-reverse\-search\-history (M\-p)
Buscar hacia atrás a través de la lista de historia empezando en la
línea en curso empleando una búsqueda no incremental de una cadena
suministrada por el usuario.
.TP
.B non\-incremental\-forward\-search\-history (M\-n)
Buscar hacia delante a través de la lista de historia empezando en la
línea en curso empleando una búsqueda no incremental de una cadena
suministrada por el usuario.
.TP
.B history\-search\-forward
Buscar hacia delante a través de la lista de historia una cadena de
caracteres entre el comienzo de la línea en curso y la posición
actual del cursor (el \fIpunto\fP). Esta búsqueda no es incremental.
.TP
.B history\-search\-backward
Buscar hacia atrás a través de la lista de historia una cadena de
caracteres entre el comienzo de la línea en curso y la posición
actual del cursor (el \fIpunto\fP). Esta búsqueda no es incremental.
.TP
.B yank\-nth\-arg (M\-C\-y)
Insertar el primer argumento de la orden anterior (normalmente la
segunda palabra de la línea previa) en el punto (la posición actual
del cursor). Con un argumento 
.IR n ,
insertar la \fIn\fP\-sima palabra de la orden anterior (las palabras
en la orden anterior empiezan con la palabra 0). Un argumento negativo
inserta la \fIn\fP\-sima palabra desde el final de la orden anterior.
.TP
.B
yank\-last\-arg (M\-.\^, M\-_\^)
Insertar el último argumento de la orden anterior (la última palabra
de la entrada anterior de la lista de historia). Con un argumento, se
comporta exactamente como \fByank\-nth\-arg\fP.
Llamadas sucesivas a \fByank\-last\-arg\fP mueven hacia atrás en la
lista de historia, insertando cada vez el último argumento de cada línea.
.TP
.B shell\-expand\-line (M\-C\-e)
Expandir la línea como hace el shell. Esto realiza la expansión de
alias y de historia así como todas las expansiones de palabra del
shell. Vea
.SM
.B EXPANSIÓN DE HISTORIA
abajo para una descripción de la expansión de historia.
.TP
.B history\-expand\-line (M\-^)
Realizar la expansión de historia en la línea en curso.
Vea
.SM
.B EXPANSIÓN DE HISTORIA
abajo para una descripción de la expansión de historia.
.TP
.B magic\-space
Efectuar la expansión de historia en la línea en curso e insertar un
espacio. 
Vea
.SM
.B EXPANSIÓN DE HISTORIA
abajo para una descripción de la expansión de historia.
.TP
.B alias\-expand\-line
Realizar la expansión de alias en la línea en curso.
Vea
.SM
.B ALIAS
arriba para una descripción de la expansión de alias.
.TP
.B history\-and\-alias\-expand\-line
Realizar la expansión de historia y alias en la línea en curso.
.TP
.B insert\-last\-argument (M\-.\^, M\-_\^)
Un sinónimo para \fByank\-last\-arg\fP.
.TP
.B operate\-and\-get\-next (C\-o)
Aceptar la línea en curso para la ejecución y obtener la línea
siguiente relativa a la actual desde la lista de historia, para la
edición. Cualquier argumento no se tiene en cuenta.
.PD
.SS Órdenes para cambiar el texto
.PP
.PD 0
.TP
.B delete\-char (C\-d)
Borrar el carácter bajo el cursor. Si el punto está al principio de la
línea, no hay caracteres en la línea, y el último carácter tecleado no
estaba asociado a \fBdelete\-char\fP, entonces devolver
.SM
.BR EOF .
.TP
.B backward\-delete\-char (<X], DEL)
Borrar el carácter tras el cursor. Cuando se da un argumento numérico,
guardar el texto borrado en el anillo de corte.
.TP
.B quoted\-insert (C\-q, C\-v)
Añadir el siguiente carácter tecleado a la línea tal cual. Así es como
se pueden insertar caracteres como \fBC\-q\fP, por ejemplo.
.TP
.B tab\-insert (C\-v TAB)
Insertar un carácter de tabulación.
.TP
.B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
Insertar el carácter tecleado.
.TP
.B transpose\-chars (C\-t)
Arrastrar el carácter antes del punto hacia adelante sobre el carácter
en el punto. El punto se mueve adelante también. Si el punto está al
final de la línea, entonces transpone los dos caracteres antes del
punto. Los argumentos negativos no funcionan.
.TP
.B transpose\-words (M\-t)
Arrastrar la palabra tras el cursor al lugar pasado la palabra enfrente del
cursor, moviendo el cursor también sobre esa palabra.
.TP
.B upcase\-word (M\-u)
Poner en mayúsculas la palabra en curso (o la siguiente). Con un
argumento negativo, pone la anterior, pero no mueve el punto.
.TP
.B downcase\-word (M\-l)
Poner en minúsculas la palabra en curso (o la siguiente).  Con un
argumento negativo, pone la anterior, pero no mueve el punto.
.TP
.B capitalize\-word (M\-c)
Poner en mayúscula la inicial de la palabra en curso (o la siguiente).  Con un
argumento negativo, pone la anterior, pero no mueve el punto.
.PD
.SS Cortar y pegar
.PP
.PD 0
.TP
.B kill\-line (C\-k)
Cortar el texto desde la posición actual del cursor hasta el final de
la línea.
.TP
.B backward\-kill\-line (C\-x DEL)
Cortar hacia atrás hasta el principio de la línea.
.TP
.B unix\-line\-discard (C\-u)
Cortar hacia atrás desde el punto hasta el principio de la línea. El
texto cortado se guarda en el anillo de corte.
.\" No hay una diferencia real entre esto y backward-kill-line
\" There is no real difference between this and backward-kill-line
.TP
.B kill\-whole\-line
Cortar todos los caracteres de la línea en curso, sin importar dónde
esté el cursor.
.TP
.B kill\-word  (M\-d)
Cortar desde el cursor hasta el final de la palabra en curso, o si
entre palabras, hasta el final de la siguiente. Los extremos de las
palabras son los mismos que los empleados por \fBforward\-word\fP.
.TP
.B backward\-kill\-word (M\-DEL)
Cortar la palabra tras el cursor. Los extremos de las palabras son los
mismos que los empleados por \fBbackward\-word\fP.
.TP
.B unix\-word\-rubout (C\-w)
Cortar la palabra tras el cursor, empleando el espacio en blanco como
un límite de palabra. Los extremos de las palabras son diferentes de
los de \fBbackward\-kill\-word\fP.
.TP
.B delete\-horizontal\-space (M\-\e)
Borrar todos los espacios y tabuladores alrededor del punto.
.TP
.B kill\-region
Cortar el texto entre el punto y la \fImarca\fP (posición registrada
del cursor). Este texto se conoce como la \fIregión\fP.
.TP
.B copy\-region\-as\-kill
Copiar el texto en la región al anillo de corte.
.TP
.B copy\-backward\-word
Copiar la palabra antes del punto al búfer de corte.
Los extremos de palabras son los mismos que con \fBbackward\-word\fP.
.TP
.B copy\-forward\-word
Copiar la palabra que sigue al punto al búfer de corte.
Los extremos de palabra son los mismos que con \fBforward\-word\fP.
.TP
.B yank (C\-y)
Pegar la cima del anillo de corte en el búfer en donde esté el cursor.
.TP
.B yank\-pop (M\-y)
Rotar en el anillo de corte, y pegar la nueva cima. Sólo funciona tras
un
.B yank
o
.BR yank\-pop .
.PD
.SS Argumentos numéricos
.PP
.PD 0
.TP
.B digit\-argument (M\-0, M\-1, ..., M\-\-)
Añadir este dígito al argumento, acumulándolo, o comenzar con un nuevo
argumento.  M\-\- empieza un argumento negativo.
.TP
.B universal\-argument
Ésta es otra forma de especificar un argumento.
Si esta orden se hace seguir de uno o más dígitos, opcionalmente con
un signo menos inicial, estos dígitos definen el argumento.
Si a la orden siguen dígitos, ejecutar de nuevo 
.B universal\-argument
finaliza el argumento numérico, pero si no, no se tiene en cuenta.
Como un caso especial, si a esta orden sigue inmediatamente un
carácter que no es ni un dígito ni un signo menos, el número del
argumento para la siguiente orden se multiplica por cuatro.
El número del argumento es inicialmente uno, así que ejecutar esta
función por primera vez hace que el número del argumento sea cuatro,
una segunda vez lo hace dieciséis, y así sucesivamente.
.PD
.SS Terminación
.PP
.PD 0
.TP
.B complete (TAB)
Intentar realizar una terminación del texto antes del punto.
.B Bash
intenta la terminación tratando al texto como una variable (si el
texto comienza con \fB$\fP), como un nombre de usuario (si el texto
empieza con \fB~\fP), como un nombre de computador anfitrión (si el
texto comienza con \fB@\fP), o como una orden (incluyendo alias y
funciones), por este orden. Si nada de esto concuerda, se intenta la
terminación de un nombre de fichero.
.TP
.B possible\-completions (M\-?)
Listar las terminaciones posibles del texto antes del punto.
.TP
.B insert\-completions (M\-*)
Insertar todas las terminaciones del texto antes del punto que habrían
sido generadas por
\fBpossible\-completions\fP.
.TP
.B menu\-complete
Similar a \fBcomplete\fP, pero reemplaza la palabra a ser completada
con una sola concordancia de la lista de terminaciones posibles.
La ejecución repetida de \fBmenu\-complete\fP camina por la lista de
terminaciones posibles, insertando cada concordancia por turnos.
Al final de la lista de terminaciones, se hace sonar el pito de la
terminal y el texto original se restaura. 
Un argumento \fIn\fP mueve \fIn\fP posiciones hacia delante en la
lista de concordancias; un argumento negativo se puede emplear para
moverse hacia atrás en la lista.
Esta orden está pensada para ser asociada a \fBTAB\fP, pero no está
asociada a ninguna tecla de forma predeterminada.
.TP
.B complete\-filename (M\-/)
Intentar la terminación de un nombre de fichero en el texto antes del punto.
.TP
.B possible\-filename\-completions (C\-x /)
Listar las posibles terminaciones del texto antes del punto, tratándolo
como un nombre de fichero.
.TP
.B complete\-username (M\-~)
Intentar la terminación del texto antes del punto, tratándolo
como un nombre de usuario.
.TP
.B possible\-username\-completions (C\-x ~)
Listar las posibles terminaciones del texto antes del punto, tratándolo
como un nombre de usuario.
.TP
.B complete\-variable (M\-$)
Intentar la terminación del texto antes del punto, tratándolo
como una variable del shell.
.TP
.B possible\-variable\-completions (C\-x $)
Listar las posibles terminaciones del texto antes del punto, tratándolo
como una variable del shell.
.TP
.B complete\-hostname (M\-@)
Intentar la terminación del texto antes del punto, tratándolo
como un nombre de computador anfitrión.
.TP
.B possible\-hostname\-completions (C\-x @)
Listar las posibles terminaciones del texto antes del punto, tratándolo
como un nombre de computador anfitrión.
.TP
.B complete\-command (M\-!)
Intentar la terminación del texto antes del punto, tratándolo como un
nombre de orden. La terminación de orden intenta hacer concordar el
texto con alias, palabras reservadas, funciones del shell, órdenes
internas del shell, y finalmente nombres de ficheros ejecutables, en
ese orden.
.TP
.B possible\-command\-completions (C\-x !)
Listar las posibles terminaciones del texto antes del punto, tratándolo
como un nombre de orden.
.TP
.B dynamic\-complete\-history (M\-TAB)
Intentar la terminación del texto antes del punto, comparando el texto
con líneas de la lista de historia buscando concordancias para la
terminación. 
.TP
.B complete\-into\-braces (M\-{)
Efectuar la terminación de nombres de ficheros y devolver la lista de
terminaciones posibles encerrada entre llaves de forma que la lista
esté disponible al shell (vea
.B Expansión de llaves
arriba).
.PD
.SS Macros de teclado
.PP
.PD 0
.TP
.B start\-kbd\-macro (C\-x (\^)
Empezar a grabar los caracteres tecleados, en la macro de teclado en
curso. 
.TP
.B end\-kbd\-macro (C\-x )\^)
Parar de grabar los caracteres tecleados en la macro de teclado en
curso, y almacenar la definición.
.TP
.B call\-last\-kbd\-macro (C\-x e)
Reejecutar la última macro de teclado definida, haciendo que los
caracteres en la macro aparezcan como si se hubieran pulsado en el
teclado. 
.PD
.SS Miscelánea
.PP
.PD 0
.TP
.B re\-read\-init\-file (C\-x C\-r)
Leer los contenidos del fichero \fIinputrc\fP, e incorporar
cualesquiera definiciones de teclas o asignaciones de variables que se
hubieran encontrado en él.
.TP
.B abort (C\-g)
Terminar abruptamente la orden de edición en curso y tocar el pito de
la terminal (según el establecimiento de
.BR bell\-style ).
.TP
.B do\-uppercase\-version (M\-a, M\-b, M\-\fIx\fP, ...)
Si el carácter meta \fIx\fP está en minúscula, ejecutar la orden que
esté asociada al carácter correspondiente en mayúscula.
.TP
.B prefix\-meta (ESC)
Convertir en meta el siguiente carácter tecleado.
.SM
.B ESC
.B f
es equivalente a
.BR Meta\-f .
.TP
.B undo (C\-_, C\-x C\-u)
Deshacer de forma incremental, recordado separadamente para cada línea.
.TP
.B revert\-line (M\-r)
Deshacer todos los cambios hechos a esta línea. Esto es como ejecutar
la orden
.B undo
las veces suficientes como para devolver la línea a su estado inicial.
.TP
.B tilde\-expand (M\-~)
Efectuar la expansión de tilde en la palabra en curso.
.TP
.B set\-mark (C\-@, M\-<espacio>)
Establecer la marca en el punto actual. Si se da un argumento
numérico, la marca se establece en esa posición.
.TP
.B exchange\-point\-and\-mark (C\-x C\-x)
Cambia el punto con la marca. La posición actual del cursor se pone en
la posición guardada, y la vieja posición del cursor se guarda como la
marca.
.TP
.B character\-search (C\-])
Se lee un carácter y el punto se mueve a la siguiente ocurrencia de
ese carácter. Un argumento numérico negativo hace que la búsqueda sea
de las ocurrencias anteriores.
.TP
.B character\-search\-backward (M\-C\-])
Se lee un carácter y el punto se mueve a la anterior ocurrencia de
ese carácter. Un argumento numérico negativo hace que la búsqueda sea
de las ocurrencias siguientes.
.TP
.B insert\-comment (M\-#)
El valor de la variable de 
.B readline
.B comment\-begin
se inserta al principio de la línea en curso, y la línea se acepta
como si se hubiera tecleado Intro (nueva-línea). Esto convierte la
línea en curso en un comentario del shell.
.TP
.B glob\-expand\-word (C\-x *)
La palabra antes del punto se trata como un patrón para la expansión
de nombres de caminos y la lista de nombres de fichero concordantes se
inserta, reemplazando a la palabra.
.TP
.B glob\-list\-expansions (C\-x g)
Mostrar la lista de expansiones que habrían sido generadas por
.B glob\-expand\-word
y redibujar la línea.
.TP
.B dump\-functions
Mostrar todas las funciones y sus asociaciones de teclas en el flujo
de salida de readline. Si se da un argumento numérico, la salida se
formatea de tal modo que pueda formar parte de un fichero
\fIinputrc\fP. 
.TP
.B dump\-variables
Mostrar todas las variables de readline a las que se puedan asignar
valores, y éstos, en el flujo de salida de readline. Si se da un
argumento numérico, la salida se formatea de tal manera que pueda
formar parte de un fichero \fIinputrc\fP.
.TP
.B dump\-macros
Mostrar todas las secuencias de teclas de readline asociadas a macros
y las cadenas de caracteres asociadas correspondientes. Si se da un
argumento numérico, la salida se formatea de tal manera que pueda
formar parte de un fichero \fIinputrc\fP.
.TP
.B display\-shell\-version (C\-x C\-v)
Mostrar información de versión acerca de la instancia actual de
.BR bash .
.PD
.SH HISTORIA
Cuando se habilita la opción
.B \-o history
de la orden interna
.BR set ,
el shell da acceso a la
\fIhistoria de órdenes\fP,
la lista de órdenes tecleadas con anterioridad. El texto de los últimos
.SM
.B HISTSIZE
mandatos (por omisión, 500) se guarda en una lista de historia. El
shell almacena cada orden en la lista de historia antes de la
expansión de parámetros y variables (vea
.SM
.B EXPANSIÓN
arriba) pero tras efectuar la expansión de historia, sujeta a los
valores de las variables del shell 
.SM
.B HISTIGNORE
e
.SM
.BR HISTCONTROL .
En el arranque, la historia se inicia a partir del fichero nombrado en
la variable
.SM
.B HISTFILE
(por omisión \fI~/.bash_history\fP).
.SM
.B HISTFILE
se trunca, si es necesario, para contener no más de
.SM
.B HISTFILESIZE
líneas.
Cuando un shell interactivo termina, las últimas
.SM
.B HISTSIZE
líneas se copian de la lista de historia a
.SM
.BR HISTFILE .
Si la opción del shell
.B histappend
está activa (vea la descripción de
.B shopt
bajo
.SM
.B "ÓRDENES INTERNAS DEL SHELL"
más adelante), las líneas se añaden al fichero de historia; si no, el
fichero de historia se sobreescribe.
Si
.SM
.B HISTFILE
no está definido, o si no se puede escribir en el fichero de historia,
la historia no se guarda. Tras guardar la historia, el fichero de
historia se trunca para contener no más de
.SM
.B HISTFILESIZE
líneas. Si
.SM
.B HISTFILESIZE
no está definido, no se trunca.
.PP
La orden interna
.B fc
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
abajo) puede emplearse para listar o editar y re-ejecutar una porción
de la lista de historia.
La orden interna
.B history
se puede utilizar para mostrar o modificar la lista de historia y
manipular el fichero de historia.
Cuando se emplea la edición de líneas de órdenes, están disponibles
las órdenes de búsqueda en cada modo de edición que proporcionan
acceso a la lista de historia.
.PP
El shell permite el control sobre qué órdenes se guarden en la lista
de historia. Las variables
.SM
.B HISTCONTROL
y
.SM
.B HISTIGNORE
se pueden definir de forma que el shell guarde solamente un
subconjunto de las órdenes introducidas.
La opción del shell
.BR cmdhist ,
si está habilitada, hace que el shell intente guardar cada línea de
una orden multi-línea en la misma entrada de la historia, añadiendo
punto y comas donde sea necesario para preservar la corrección sintáctica. 
La opción del shell
.B lithist
hace que el shell guarde la orden con saltos de línea empotrados en
vez de punto y comas. Vea la descripción de la orden interna
.B shopt
abajo en
.SM
.B "ÓRDENES INTERNAS DEL SHELL"
para información sobre cómo establecer y anular opciones del shell.
.SH "EXPANSIÓN DE HISTORIA"
.PP
El shell admite una característica de expansión de historia que es
parecida a la expansión de historia en
.BR csh .
Esta sección describe qué características sintácticas están
disponibles. Esta característica está habilitada de forma
predeterminada en shells interactivos, y puede ser desactivada
mediante la opción
.B \+H
de la orden interna
.B set
(vea
.SM
.B ÓRDENES INTERNAS DEL SHELL
abajo). Los shells no interactivos no realizan la expansión de la
historia de forma predeterminada.
.PP
Las expansiones de historia introducen palabras desde la lista de
historia en el flujo de entrada, facilitando así la repetición de
órdenes, la inserción de argumentos de una orden anterior en la línea
de entrada en curso, o la corrección rápida de errores en una orden
anterior. 
.PP
La expansión de historia se realiza inmediatamente tras la lectura de
una línea completa, antes de que el shell la divida en palabras. Tiene
lugar en dos fases.
En la primera se determina qué línea de la lista de historia hay que
emplear durante la sustitución.
En la segunda se seleccionan porciones de esa línea para su inclusión
en la actual.
La línea seleccionada desde la historia es el \fIevento\fP,
y la porción de esa línea sobre la que se actúa son \fIpalabras\fP.
Se dispone de varios \fImodificadores\fP para manipular las palabras
seleccionadas. La línea se divide en palabras de la misma manera que
cuando se lee la entrada, de forma que ciertas palabras separadas por
\fImeta-caracteres\fP rodeadas por comillas se consideran una sola
palabra. 
Las expansiones de historia se introducen por la aparición del
carácter de expansión de historia, que es por omisión \^\fB!\fP\^.
Sólo las barras inversas (\^\fB\e\fP\^) y las comillas simples pueden
proteger al carácter de expansión de historia.
.PP
Se pueden emplear ciertas opciones que se ponen con la orden interna
.B shopt
para cambiar el comportamiento de la expansión de historia.
Si la opción del shell
.B histverify
está activa (vea la descripción de la orden interna \fBshopt\fP),
y se está usando
.BR readline ,
las sustituciones de historia no se pasan inmediatamente al analizador del
shell.
En vez de eso, la línea expandida se vuelve a cargar en el búfer de edición
de 
.B readline
para una modificación posterior.
Si se está usando
.B readline
y la opción del shell
.B histreedit
está activada, una sustitución de historia fallida se volverá a cargar en el
búfer de edición de
.B readline
para su corrección.
La opción
.B \-p
de la orden interna
.B history
se puede emplear para ver qué hará una expansión de historia antes de usarse. 
La opción
.B \-s
de la orden interna
.B history
se puede emplear para añadir órdenes al final de la lista de historia sin
ejecutarlas realmente, de modo que estén disponibles para rellamadas
posteriores.
.PP
El shell permite el control de los diversos caracteres empleados por el
mecanismo de expansión de historia (vea la descripción de
.B histchars
arriba en
.BR "Variables del shell" ).
.SS Designadores de eventos
.PP
Un designador de evento es una referencia a una entrada de línea de
orden en la lista de historia.
.PP
.PD 0
.TP
.B !
Comenzar una sustitución de historia, excepto cuando le siga un
.BR blanco ,
salto de línea, = o (.
.TP
.B !\fIn\fR
Referirse a la línea de órdenes número
.IR n .
.TP
.B !\-\fIn\fR
Referirse a la línea de orden en curso menos
.IR n .
.TP
.B !!
Referirse a la orden anterior. Esto es lo mismo que `!\-1'.
.TP
.B !\fIcadena\fR
Referirse a la orden más reciente que comience con
.IR cadena .
.TP
.B !?\fIcadena\fR\fB[?]\fR
Referirse a la orden más reciente que contenga
.IR cadena .
El \fB?\fP del final puede omitirse si a
.I cadena
le sigue inmediatamente un salto de línea.
.TP
.B \d\s+2^\s-2\u\fIcadena1\fP\d\s+2^\s-2\u\fIcadena2\fP\d\s+2^\s-2\u
Sustitución rápida. Repetir la última orden, reemplazando
.I cadena1
con
.IR cadena2 .
Equivalente a
``!!:s/\fIcadena1\fP/\fIcadena2\fP/''
(vea \fBModificadores\fP abajo).
.TP
.B !#
La línea de orden entera tecleada hasta ahora.
.PD
.SS Designadores de palabras
.PP
Los designadores de palabras se emplean para seleccionar las
palabras que se deseen del evento.
Un
.B :
separa la especificación de evento del designador de palabra.
Puede omitirse si el designador de palabra comienza con un
.BR ^ ,
.BR $ ,
.BR * ,
.BR \- ,
o
.BR % .
Las palabras se numeran desde el principio de la línea,
con la primera palabra denotada por 0 (cero).
Las palabras se insertan en la línea en curso separadas por espacios simples.
.PP
.PD 0
.TP
.B 0 (cero)
La palabra número 0. Para el shell, ésta es la palabra de la orden.
.TP
.I n
La \fIn\fR\-sima palabra.
.TP
.B ^
El primer argumento. Esto es, la palabra número 1.
.TP
.B $
El último argumento.
.TP
.B %
La palabra que concordaba con la más reciente búsqueda con `?\fIcadena\fR?'.
.TP
.I x\fB\-\fPy
Un rango de palabras; `\-\fIy\fR' abrevia `0\-\fIy\fR'.
.TP
.B *
Todas las palabras menos la número cero. Esto es un sinónimo de
`\fI1\-$\fP'.  No es un error emplear
.B *
si sólo hay una palabra en el evento; en este caso se devuelve la
cadena vacía.
.TP
.B x*
Abreviatura de \fIx\-$\fP.
.TP
.B x\-
Abrevia \fIx\-$\fP como \fBx*\fP, pero omite la última palabra.
.PD
.PP
Si se suministra un designador de palabra sin una especificación de
evento, se usa la orden anterior como el evento.
.SS Modificadores
.PP
Tras el designador opcional de palabra, puede haber una secuencia de
uno o más de los siguientes modificadores, precedido cada uno por un `:'.
.PP
.PD 0
.PP
.TP
.B h
Quitar un componente final de nombre de fichero, dejando sólo la parte
izquierda.
.TP
.B t
Quitar todos los primeros componentes de un nombre de fichero, dejando
la última parte.
.TP
.B r
Quitar un sufijo final de la forma \fI.xxx\fP, dejando el nombre base.
.TP
.B e
Quitar todo salvo el sufijo final.
.TP
.B p
Mostrar la nueva orden pero no ejecutarla.
.TP
.B q
Entrecomillar las palabras sustituidas, escapando de posteriores sustituciones.
.TP
.B x
Entrecomillar las palabras sustituidas como con
.BR q ,
pero romper entre palabras en los
.B blancos
y saltos de línea.
.TP
.B s/\fIviejo\fP/\fInuevo\fP/
Substituir
.I nuevo
por la primera ocurrencia de
.I viejo
en la línea de evento. Se puede emplear cualquier delimitador en vez
de /. El delimitador final es opcional si es el último carácter de la
línea de evento. El delimitador puede entrecomillarse en
.I viejo
y
.I nuevo
con una sola barra inclinada inversa. Si & aparece en
.IR nuevo ,
se reemplaza por
.IR viejo .
Una sola barra inversa protegerá el &. Si
.I viejo
está vacío, se pone al último
.I viejo
substituido, o, si no tuvo lugar ninguna sustitución de historia
previa, a la última
.I cadena
en una búsqueda del tipo \fB!?\fIcadena\fR\fB[?]\fR\fP.
.TP
.B &
Repetir la sustitución anterior.
.TP
.B g
Hace que los cambios se apliquen sobre la línea entera de evento. Esto
se emplea en conjunción con `\fB:s\fP' (p.ej.,
`\fB:gs/\fIviejo\fP/\fInuevo\fP/\fR') 
o `\fB:&\fP'.  Si se usa con
`\fB:s\fP', cualquier delimitador se puede utilizar en lugar de /,
y el delimitador final es opcional si es el último carácter de la
linea de evento.
.PD
.SH "ÓRDENES INTERNAS DEL SHELL"
.\" start of bash_builtins
.zZ
.PP
A menos que se diga otra cosa, cada orden interna documentada en esta
sección que acepte opciones precedidas por
.B \-
también acepta
.B \-\-
para significar el final de las opciones.
.sp .5
.PD 0
.TP
\fB :\fP [\fIargumentos\fP]
.PD
Sin efecto; la orden no hace nada más que expandir
.I argumentos
y realizar cualquier redirección que se haya especificado. Se devuelve
un código de salida cero.
.TP
.PD 0
\fB .\| \fP \fInombre-fichero\fP [\fIargumentos\fP]
.TP
\fBsource\fP \fInombre-fichero\fP [\fIargumentos\fP]
.PD
Lee y ejecuta órdenes desde
.I nombre-fichero
en el entorno actual del shell y devuelve el estado de salida de la
última orden ejecutada desde
.IR nombre-fichero .
Si
.I nombre-fichero
no contiene una barra inclinada, se usan los nombres de fichero en 
.SM
.B PATH
para encontrar el directorio que contenga a
.IR nombre-fichero .
El fichero que se busca en
.SM
.B PATH
no necesita ser ejecutable. Se busca en el directorio de trabajo si no
se encontró el fichero en
.SM
.BR PATH .
Si la opción
.B sourcepath
de la orden interna
.B shopt
está desactivada, la búsqueda en
.SM
.B PATH
no se realiza.
Si se suministran \fIargumentos\fP, se convierten en los parámetros
posicionales cuando se ejecuta \fInombre-fichero\fP. Si no, los
parámetros posicionales permanecen inalterados.
El estado de retorno es el de la última orden de dentro del guión (0
si no se ejecutó ninguna orden), y `falso' si
.I nombre-fichero
no se encontró o no se pudo leer.
.TP
\fBalias\fP [\fB\-p\fP] [\fInombre\fP[=\fIvalor\fP] ...]
\fBAlias\fP sin argumentos o con la opción 
.B \-p
muestra la lista de alias en la forma
\fBalias\fP \fInombre\fP=\fIvalor\fP en la salida estándar.
Cuando se dan argumentos, se define un alias para cada \fInombre\fP
cuyo \fIvalor\fP se da.
Un espacio extra tras  \fIvalor\fP hace que en la siguiente palabra se
realice la sustitución de alias cuando el alias se expande.
Para cada \fInombre\fP en la lista de argumentos para el que no se
suministre un \fIvalor\fP, se muestran el nombre y el valor del alias.
\fBAlias\fP devuelve `verdad' a menos que se dé un \fInombre\fP para
el que no se haya definido un alias.
.TP
\fBbg\fP [\fIespectrab\fP]
Reanuda el trabajo suspendido \fIespectrab\fP en segundo plano, como
si se hubiera arrancado con
.BR & .
Si \fIespectrab\fP no está presente, se emplea la noción que tiene el
shell del \fItrabajo en curso\fP.
.B bg
.I espectrab
devuelve 0 a menos que se ejecute cuando el control de trabajos esté
deshabilitado, o cuando se ejecute con el control de trabajos
habilitado si \fIespectrab\fP no se encontró, o cuando se hubo
arrancado sin control de trabajos.
.TP
.PD 0
\fBbind\fP [\fB\-m\fP \fImapatecl\fP] [\fB\-lpsvPSV\fP]
.TP
\fBbind\fP [\fB\-m\fP \fImapatecl\fP] [\fB\-q\fP \fIfunción\fP] [\fB\-u\fP \fIfunción\fP] [\fB\-r\fP \fIsectecl\fP]
.TP
\fBbind\fP [\fB\-m\fP \fImapatecl\fP] \fB\-f\fP \fInombre-fichero\fP
.TP
\fBbind\fP [\fB\-m\fP \fImapatecl\fP] \fIsectecl\fP:\fInombre\-función\fP
.PD
Muestra las asociaciones actuales de 
.B readline
de teclas y funciones, o asocia una secuencia de teclas a una función
o macro de
.BR readline .
La sintaxis aceptada es idéntica a la de
.IR .inputrc ,
pero cada asociación debe pasarse como un argumento separado;
p.ej., '"\eC\-x\eC\-r": re\-read\-init\-file'.  Las opciones, si se
dan, tienen los siguientes significados:
.RS
.PD 0
.TP
.B \-m \fImapatecl\fP
Usar
.I mapatecl
como el mapa de teclado que va a verse afectado por subsiguientes asociaciones.
Los nombres aceptables de
.I mapatecl
son
\fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi,
vi\-command\fP y
.IR vi\-insert .
\fIvi\fP equivale a \fIvi\-command\fP; \fIemacs\fP es
equivalente a \fIemacs\-standard\fP.
.TP
.B \-l
Lista los nombres de todas las funciones de \fBreadline\fP.
.TP
.B \-p
Muestra los nombres de funciones de \fBreadline\fP de tal forma que
puedan volver a ser leídas.
.TP
.B \-P
Lista los nombres de funciones de \fBreadline\fP actuales y las asociaciones.
.TP
.B \-v
Muestra los nombres de variables de \fBreadline\fP y los valores de
tal manera que puedan volver a ser leídas.
.TP
.B \-V
Lista los nombres de variables de \fBreadline\fP actuales y los valores.
.TP
.B \-s
Muestra las secuencias de teclas de \fBreadline\fP asociadas a macros
y las cadenas correspondientes de tal manera que puedan ser leídas de nuevo.
.TP
.B \-S
Muestra las secuencias de teclas de \fBreadline\fP asociadas a macros
y las cadenas de caracteres correspondientes.
.TP
.B \-f \fInombre-fichero\fP
Lee las asociaciones de teclas desde \fInombre-fichero\fP.
.TP
.B \-q \fIfunción\fP
Pregunta qué teclas llaman a la \fIfunción\fP especificada.
.TP
.B \-u \fIfunción\fP
Desenlaza todas las teclas asociadas a la \fIfunción\fP nombrada.
.TP
.B \-r \fIsectecl\fP
Borra cualquier asociación actual de \fIsectecl\fP.
.PD
.PP
El valor devuelto es 0 a menos que se dé una opción no reconocida o
que ocurra un error.
.RE
.TP
\fBbreak\fP [\fIn\fP]
Sale de un bucle
.BR for ,
.BR while ,
.BR until ,
o
.BR select .
Si se especifica \fIn\fP, sale de \fIn\fP niveles.
.I n
debe ser \(>= 1.  Si
.I n
es mayor que el número de bucles, se sale de todos. El valor devuelto
es 0 a menos que el shell no esté ejecutando un bucle cuando se ejecute
.BR break .
.TP
\fBbuiltin\fP \fIorden\-interna\fP [\fIargumentos\fP]
Ejecuta la orden interna del shell especificada, pasándole los
.IR argumentos ,
y devuelve su estado de salida.
Esto es útil cuando se define una función cuyo nombre es el mismo que
una orden interna del shell, reteniendo la funcionalidad de esa orden
interna dentro de la función.
Por ejemplo, la orden interna \fBcd\fP se puede redefinir normalmente
de esta manera.
El estado de salida es `falso' si
.I orden\-interna
no es una orden incorporada del shell.
.TP
\fBcd\fP [\fB\-LP\fP] [\fIdir\fP]
Cambia el directorio de trabajo en curso a \fIdir\fP.  La variable
.SM
.B HOME
contiene el nombre del directorio predeterminado
.IR dir .
La variable
.SM
.B CDPATH
define el camino de búsqueda del directorio que contenga
.IR dir .
Los nombres de directorios alternativos en
.SM
.B CDPATH
se separan por dos puntos (:). Un nombre de directorio vacío en
.SM
.B CDPATH
es lo mismo que el directorio de trabajo en curso, o sea,
``\fB.\fP''. Si
.I dir
comienza con una barra inclinada (/),
entonces
.SM
.B CDPATH
no se usa. La opción
.B \-P
dice que se va a emplear la estructura física de directorios en vez de
seguir enlaces simbólicos (vea también la opción 
.B \-P
de la orden interna
.BR set );
la opción
.B \-L
hace que se sigan siempre los enlaces simbólicos. El argumento
.B \-
es equivalente a
.SM
.BR $OLDPWD .
El valor de retorno es `verdad' si el directorio de trabajo se cambió
con éxito; `falso' en otro caso.
.TP
\fBcommand\fP [\fB\-pVv\fP] \fIorden\fP [\fIarg\fP ...]
Ejecuta
.I orden
con
.I args
suprimiendo la búsqueda normal de funciones del shell. Sólo se
ejecutarán órdenes incorporadas en el shell o programas encontrados en
la variable
.SM
.BR PATH .
Si se da la opción
.BR \-p ,
se busca la
.I orden
empleándose un valor predeterminado para
.B PATH
que garantiza encontrar todas las utilidades estándar del sistema.
Si se da la opción
.B \-V
o la
.BR \-v ,
se muestra una descripción de
.IR orden .
La opción
.B \-v
muestra una sola palabra que indica la orden o nombre de fichero
ejecutable empleado para la llamada a
.IR orden ;
la opción
.B \-V
produce una descripción algo más prolija.
Si se dan las opciones
.B \-V
o
.BR \-v ,
el estado de salida es 0 si
.I orden
se encontró, y 1 si no. Si no se da ninguna de las dos opciones y
ocurrió un error u
.I orden
no se encontró, el estado de salida es 127. Si no, el estado de salida
de 
.B command
es el estado de salida de
.IR orden .
.TP
\fBcontinue\fP [\fIn\fP]
Reanuda la siguiente iteración del bucle
.BR for ,
.BR while ,
.BR until ,
o
.B select
donde estamos.
Si se especifica
.IR n ,
la reanudación es en el \fIn\fP\-simo bucle que nos rodea. 
.I n
debe ser \(>= 1.  Si
.I n
es mayor que el número de bucles que nos rodean, se reanuda el
bucle más exterior (el de ``más alto nivel''). El valor de retorno es
0 a menos que el shell no esté ejecutando un bucle cuando se ejecute
.BR continue .
.TP
.PD 0
\fBdeclare\fP [\fB\-afFirx\fP] [\fB\-p\fP] [\fInombre\fP[=\fIvalor\fP]]
.TP
\fBtypeset\fP [\fB\-afFirx\fP] [\fB\-p\fP] [\fInombre\fP[=\fIvalor\fP]]
.PD
Declaran variables o les dan atributos.
Si no se dan \fInombre\fPs, entonces muestran los valores de las variables.
La opción
.B \-p
mostrará los atributos y valores de cada
.IR nombre .
Cuando se emplee
.BR \-p ,
otras opciones que se hayan dado no se tienen en cuenta.
La opción
.B \-F
inhibe la presentación de las definiciones de funciones; sólo se
muestran sus nombres y atributos.
La opción
.B \-F
implica
.BR \-f .
Se pueden emplear las siguientes opciones para restringir la salida a
variables con el atributo especificado o para dar atributos a variables:
.RS
.PD 0
.TP
.B \-a
Cada \fInombre\fP es una variable vector (vea
.B Vectores
arriba).
.TP
.B \-f
Usar solamente nombres de funciones.
.TP
.B \-i
La variable se trata como un entero; se realiza la evaluación
aritmética (vea
.SM
.BR "EVALUACIÓN ARITMÉTICA" ") "
cuando a la variable se le asigne un valor.
.TP
.B \-r
Hace que \fInombre\fPs sean de lectura exclusiva.  A estos nombres no
se les pueden asignar valores por medio de subsiguientes asignaciones,
ni se puede anular su definición con \fBunset\fP.
.TP
.B \-x
Marca \fInombre\fPs para la exportación a órdenes subsecuentes a
través del entorno.
.PD
.PP
Usar `+' en vez de `\-'
desactiva el atributo en vez de activarlo, con la excepción de que no
puede emplearse \fB+a\fP para destruir una variable vector. Cuando se
usa en una función, hace local cada
\fInombre\fP, como con la orden interna
.BR local .
El valor de retorno es 0 a menos que se encuentre una opción inválida,
se intente definir una función utilizando "\-f fuu=bar",
se intente asignar un valor a una variable de lectura exclusiva,
se intente asignar un valor a una variable vector sin emplear la
sintaxis de asignación compuesta (vea
.B Vectores
arriba), uno de los \fInombre\fPs no sea un nombre válido de variable
del shell, se intente desactivar el estado de lectura exclusiva para
una variable de sólo lectura, se intente desactivar el estado de
vector para una variable vector, o se intente mostrar una función no
existente con \-f.
.RE
.TP
.B dirs [\fB\-clpv\fP] [+\fIn\fP] [\-\fIn\fP]
Sin opciones, muestra la lista de directorios actualmente recordados.
La forma predeterminada de mostrarlos es en una sola línea con los
nombres de directorios separados por espacios.
Los directorios se añaden a la lista (en realidad, una pila) con la orden
.BR pushd ;
la orden
.B popd
los quita de la pila.
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
Muestra la \fIn\fP\-sima entrada contando desde la izquierda de la
lista mostrada por
.B dirs
cuando se llama sin opciones, empezando por cero.
.TP
\fB\-\fP\fIn\fP
Muestra la \fIn\fP\-sima entrada contando desde la derecha de la
lista mostrada por
.B dirs
cuando se llama sin opciones, empezando por cero.
.TP
.B \-c
Limpia la pila de directorios borrando todas las entradas.
.TP
.B \-l
Produce un listado más largo; el formato predeterminado de listado
emplea una tilde de la eñe para señalar el directorio inicial de
trabajo (el "hogar"). 
.TP
.B \-p
Muestra la pila de directorios con una entrada por cada línea.
.TP
.B \-v
Muestra la pila de directorios con una entrada por línea, 
prefijando cada entrada con su índice en la pila.
.PD
.PP
El valor de retorno es 0 a menos que se dé una opción inválida o que
\fIn\fP indexe más allá del final de la pila de directorios.
.RE
.TP
\fBdisown\fP [\fB\-ar\fP] [\fB\-h\fP] [\fIespectrab\fP ...]
Sin opciones, cada
.I espectrab
se quita de la tabla de trabajos activos.
Si se da la opción \fB\-h\fP, cada
.I espectrab
no se quita de la tabla, sino que se marca de manera que
no se le enviará la señal
.SM
.B SIGHUP
si el shell recibe una señal
.SM
.BR SIGHUP .
Si no hay ningún
.I espectrab
presente, y ni se dan las opciones
.B \-a
ni
.BR \-r ,
se utiliza el trabajo \fIen curso\fP.
Si no se suministra
.IR espectrab ,
la opción
.B \-a
significa quitar o marcar todos los trabajos; la opción
.B \-r
sin un argumento
.I espectrab
restringe la operación a los trabajos en ejecución.
El valor de retorno es 0 a menos que
.I espectrab
no se refiera a un trabajo válido.
.TP
\fBecho\fP [\fB\-neE\fP] [\fIarg\fP ...]
Repite  los \fIarg\fPs, separados por espacios, seguidos por un salto
de línea.
El estado de retorno es siempre 0.
Si se especifica \fB\-n\fP, se suprime el salto de línea final.
Si se da la opción \fB\-e\fP, se activa la interpretación de los
siguientes caracteres de escape (con barra inversa). La opción
.B \-E
desactiva la interpretación de estos caracteres de escape, incluso en
sistemas donde se interpreten de forma predeterminada.
.B echo
no interpreta
.B \-\-
como el fin de las opciones.
.B echo
interpreta las siguientes secuencias de escape:
.RS
.PD 0
.TP
.B \ea
alerta (pito)
.TP
.B \eb
espacio atrás
.TP
.B \ec
suprime el salto de línea final
.TP
.B \ee
un carácter Escape
.TP
.B \ef
salto de página
.TP
.B \en
nueva línea
.TP
.B \er
retorno de carro
.TP
.B \et
tabulador horizontal
.TP
.B \ev
tabulador vertical
.TP
.B \e\e
barra inclinada invertida
.TP
.B \e\fInnn\fP
el carácter cuyo código es el valor octal \fInnn\fP
(de uno a tres dígitos)
.TP
.B \ex\fInnn\fP
el carácter cuyo código es el valor hexadecimal \fInnn\fP
(de uno a tres dígitos)
.PD
.RE
.TP
\fBenable\fP [\fB\-adnps\fP] [\fB\-f\fP \fInombre-fichero\fP] [\fInombre\fP ...]
Activa y desactiva órdenes internas incorporadas en el shell.
Desactivar una orden incorporada en el shell permite que un programa
cuya imagen ejecutable esté en el disco con el mismo nombre, se
ejecute sin tener que especificar un camino completo, aun cuando el
shell normalmente busca las órdenes internas antes que las órdenes
externas en disco.
Si se da \fB\-n\fP, cada \fInombre\fP
se desactiva; si no,
\fInombre\fPs se activan. Por ejemplo, para emplear el programa binario
.B test
encontrado en el
.SM
.B PATH
en vez de la versión incorporada en el shell, ejecute
\f(CWenable -n test\fR.
La opción
.B \-f
significa cargar la nueva orden incorporada
.I nombre
desde el objeto compartido
.IR nombre-fichero ,
en sistemas que admiten la carga dinámica. La opción
.B \-d
borrará una orden interna cargada previamente con
.BR \-f .
Si no se dan argumentos \fInombre\fP, o si se da la opción
.BR \-p ,
se muestra una lista de órdenes internas del shell.
Sin ninguna opción más, la lista consiste en todas las órdenes
internas activas.
Si se da \fB\-n\fP, sólo se muestran las órdenes desactivadas.
Si se da \fB\-a\fP, la lista impresa incluye todas las órdenes
internas, con una indicación en cada una de si está activada o no.
Si se da \fB\-s\fP, la salida se restringe a las órdenes internas
\fIespeciales\fP de POSIX.
El valor de retorno es 0 a menos que un
.I nombre
no sea una orden interna del shell o que haya un problema cargando una
nueva orden incorporada desde un objeto compartido.
.TP
\fBeval\fP [\fIarg\fP ...]
Los \fIarg\fPs se leen y concatenan juntos para formar una sola
orden. Entonces el shell lee y ejecuta esta orden, y su estado de
salida se devuelve como el valor de
.BR eval .
Si no hay 
.IR args ,
o solamente argumentos vacíos,
.B eval
devuelve 0.
.TP
\fBexec\fP [\fB\-cl\fP] [\fB\-a\fP \fInombre\fP] [\fIorden\fP [\fIargumentos\fP]]
Si se especifica
.IR orden ,
reemplaza al shell.
No se crea ningún proceso nuevo. Los
.I argumentos
se convierten en los argumentos de \fIorden\fP.
Si se da la opción
.BR \-l ,
el shell pone un guión en el argumento número cero pasado a
.IR orden .
Esto es lo que hace
.IR login (1).
La opción
.B \-c
hace que 
.I orden
se ejecute con un entorno vacío. Si se da
.B \-a ,
el shell pasa
.I nombre
como el argumento número cero de la orden ejecutada. Si
.I orden
no puede ejecutarse por alguna razón, un shell no interactivo se
acaba, a menos que se haya activado la opción del shell
.BR execfail ,
en cuyo caso devuelve `fallo'.
Un shell interactivo devuelve `fallo' si el fichero no puede
ejecutarse. 
Si
.I orden
no se especifica, cualquier redirección tiene efecto en el shell en
curso, y el estado devuelto es 0. Si hay un error de redirección, el
estado de retorno es 1.
.TP
\fBexit\fP [\fIn\fP]
Hace que el shell acabe con un estado de valor \fIn\fP. Si
.I n
se omite, el valor de salida es el de la última orden ejecutada.
Se ejecuta una trampa puesta en
.SM
.B EXIT
antes de que el shell termine.
.TP
.PD 0
\fBexport\fP [\fB\-fn\fP\^] [\fInombre\fP[=\fIpalabra\fP]] ...
.TP
.B export \-p
.PD
Los
.I nombres
suministrados se marcan para exportación automática al entorno de
órdenes que se ejecuten de ahí en adelante. Si la opción
.B \-f
se da, los
.I nombres
se referirán a funciones.
Si no se dan
.IR nombres ,
o si se da la opción
.BR \-p ,
se muestra una lista de todos los nombres que están exportados en este
shell.
La opción
.B \-n
hace que la propiedad de exportación se quite de las variables
nombradas; o sea, que se quiten del entorno.
.B export
devuelve un estado de salida de 0 a menos que se encuentre una opción
inválida, uno de los \fInombre\fPs no sea un nombre válido de variable
del shell, o que se dé
.B \-f
no siendo
.I nombre
una función.
.TP
.PD 0
\fBfc\fP [\fB\-e\fP \fIeditor\fP] [\fB\-nlr\fP] [\fIprimero\fP] [\fIúltimo\fP]
.TP
\fBfc\fP \fB\-s\fP [\fIpat\fP=\fIrep\fP] [\fIord\fP]
.PD
Corrige orden (Fix Command). En la primera forma, se selecciona un
rango de órdenes desde
.I primero
hasta
.I último
de la lista de historia.
.I Primero
y
.I último
pueden especificarse como una cadena de caracteres (para localizar la
última orden que empezara con esa cadena) o como un número (un índice
en la lista de historia, donde un número negativo se emplea como un 
desplazamiento a partir del número de orden actual). Si no se da
.IR último ,
se pone a la orden en curso para un listado (de forma que
.B fc \-l \-10
muestra las 10 últimas órdenes) o a
.I primero
en otro caso.
Si no se especifica
.IR  primero ,
se pone a la orden previa para una edición y a \-16 para un listado.
.sp 1
La opción
.B \-n
suprime los números de orden en un listado. La opción
.B \-r
invierte el orden de los mandatos. Si se da la opción
.B \-l ,
las órdenes se listan en la salida estándar. Si no, se llama al editor
dado por
.I editor
en un fichero conteniendo esas órdenes.
Si no se da
.IR editor ,
se emplea el valor de la variable
.SM
.BR FCEDIT ,
o el valor de
.SM
.B EDITOR
si
.SM
.B FCEDIT
no está definido. Si no está definida ni una variable ni otra,
.B vi
es el editor que se empleará. Cuando la edición se haya completado,
las órdenes editadas se muestran y ejecutan.
.sp 1
En la segunda forma, \fIorden\fP se re-ejecuta tras que cada instancia de
\fIpat\fP se reemplace por \fIrep\fP.
Un alias de utilidad para emplear con esto es
.if n ``r=fc -s'',
.if t \f(CWr='fc \-s'\fP,
de tal modo que al teclear
.if n ``r cc''
.if t \f(CWr cc\fP
se ejecute la última orden que empezara con
.if n ``cc''
.if t \f(CWcc\fP
y que al teclear
.if n ``r''
.if t \f(CWr\fP
se re-ejecute la última orden.
.sp 1
Si se usa la primera forma, el valor de retorno es 0 a menos que se
encuentre una opción inválida o que
.I primero
o
.I último
especifiquen líneas de historia fuera de rango.
Si se suministra la opción
.BR \-e ,
el valor de retorno es el de la última orden ejecutada, o `fallo' si
ocurre un error con el fichero temporal de órdenes. Si se emplea la
segunda forma, el estado de retorno es de la orden reejecutada, a
menos que
.I ord
no especifique una línea válida de historia, en cuyo caso
.B fc
devuelve `fallo'.
.TP
\fBfg\fP [\fIespectrab\fP]
Reanuda
.I espectrab
en primer plano, y lo hace ser el trabajo en curso.
Si
.I espectrab
no está presente, se usa la noción que tiene el shell del \fItrabajo
en curso\fP. El valor de retorno es el de la orden puesta en primer
plano, o `fallo' si se ejecuta \fBfg\fP cuando el control de trabajos
está desactivado o, cuando se ejecuta con el control de trabajos
activado, si
.I espectrab
no especifica un trabajo válido o
.I espectrab
se refiere a una trabajo que se arrancó sin control de trabajos.
.TP
\fBgetopts\fP \fIcadenaopcs\fP \fInombre\fP [\fIargs\fP]
.B getopts
se usa en procedimientos del shell para analizar los parámetros
posicionales. 
.I cadenaopcs
contiene las letras de opción que se reconocerán; si a una letra le
sigue un signo de dos puntos, se espera que la opción tenga un
argumento, que debería estar separado de ella por espacio en blanco. 
Cada vez que se llama,
.B getopts
pone la siguiente opción en la variable del shell
.IR nombre ,
inicializando
.I nombre
si no existe,
y el índice del siguiente argumento a ser procesado en la
variable
.SM
.BR OPTIND .
.SM
.B OPTIND
se inicializa a 1 cada vez que se llama al shell o al guión del
shell. Cuando una opción requiera un argumento,
.B getopts
pone ese argumento en la variable
.SM
.BR OPTARG .
El shell no pone a cero
.SM
.B OPTIND
automáticamente; debe ser puesto a cero manualmente entre llamadas
múltiples a 
.B getopts
dentro de la misma llamada al shell si hubiera que usar un nuevo
conjunto de parámetros.
.sp 1
Cuando se encuentra el fin de las opciones, \fBgetopts\fP sale con un
valor de retorno mayor que cero.
\fBOPTIND\fP se pone al índice del primer argumento que no es una
opción, y \fBnombre\fP se pone a "?".
.sp 1
.B getopts
normalmente analiza los parámetros posicionales, pero si se dan más
argumentos en
.IR args ,
.B getopts
analiza aquéllos en su lugar.
.sp 1
.B getopts
puede informar de errores de dos maneras. Si el primer carácter de
.I optstring
es dos puntos,
se emplea un informe de error
.IR silencioso  .
En un modo normal de operación se muestran mensajes de diagnósticos
cuando se encuentran opciones inválidas o faltan argumentos de
opciones que los requieran.  
Si la variable
.SM
.B OPTERR
se pone a 0, no se mostrará ningún mensaje de error, incluso si el
primer carácter de
.I optstring
no es dos puntos.
.sp 1
Si se ve una opción inválida,
.B getopts
pone ? en
.I nombre
y, si no estamos en el modo silencioso, se muestra un mensaje de error
y se anula
.SM
.BR OPTARG .
Si
.B getopts
es silencioso, el carácter de opción encontrado se pone en
.SM
.B OPTARG
y no se muestra ningún mensaje de diagnóstico.
.sp 1
Si no se encuentra un argumento necesario, y
.B getopts
no es silencioso,
se pone un signo de cierre de interrogación (\^\fB?\fP\^) en
.IR nombre ,
.B OPTARG
se anula, y se muestra un mensaje de diagnóstico.
Si
.B getopts
es silencioso, entonces se pone un signo de dos puntos (\^\fB:\fP\^) en
.I nombre
y
.SM
.B OPTARG
toma el valor del carácter de opción encontrado.
.sp 1
.B getopts
devuelve `verdad' si una opción, especificada o no, se encuentra.
Devuelve `falso' si se encuentra el final de las opciones o si ocurre
un error.
.TP
\fBhash\fP [\fB\-r\fP] [\fB\-p\fP \fInombre-fichero\fP] [\fInombre\fP]
Para cada
.IR nombre ,
se determina el nombre completo del fichero correspondiente buscando
los directorios en
.B $PATH
y dicho nombre completo se registra.
Si se da la opción
.B \-p
no se busca en el PATH, y se emplea en su lugar
.I nombre-fichero
como el nombre completo de fichero para la orden.
La opción
.B \-r
hace que el shell se olvide de todas las localizaciones
registradas. Si no se dan argumentos, se muestra información acerca de
las órdenes recordadas. El estado de salida es `verdad' a menos que un
.I nombre
no se encuentre o se dé una opción inválida.
.TP
\fBhelp\fP [\fIpatrón\fP]
Muestra información de ayuda sobre las órdenes internas. Si se especifica
.IR patrón ,
.B help
da ayuda detallada sobre todas las órdenes que concuerden con
.IR patrón ;
si no, se muestra ayuda para todas las órdenes internas y estructuras
de control del shell. El estado de retorno es 0 a menos que ninguna
orden concuerde con
.IR patrón .
.TP
.PD 0
\fBhistory\fP [\fB\-c\fP] [\fIn\fP]
.TP
\fBhistory\fP \fB\-anrw\fP [\fInombre-fichero\fP]
.TP
\fBhistory\fP \fB\-p\fP \fIarg\fP [\fIarg ...\fP]
.TP
\fBhistory\fP \fB\-s\fP \fIarg\fP [\fIarg ...\fP]
.PD
Sin opciones, muestra la lista de historia de órdenes con números de
línea. Las líneas marcadas con un
.B *
han sido modificadas. Un argumento de 
.I n
lista solamente las últimas
.I n
líneas.  Si \fInombre-fichero\fP se da, se emplea como el nombre del
fichero de historia; si no, se usa el valor de
.SM
.BR HISTFILE .
Las opciones, si se dan, tienen los siguientes significados:
.RS
.PD 0
.TP
.B \-a
Añade las líneas de historia ``nuevas'' (las introducidas desde el
inicio de la sesión de \fBbash\fP en curso) al fichero de historia.
.TP
.B \-n
Lee las líneas de historia que aún no han sido leídas del fichero de
historia y las mete en la lista de historia actual. Éstas son las
líneas añadidas al fichero de historia desde el comienzo de la sesión
de \fBbash\fP actual.
.TP
.B \-r
Lee los contenidos del fichero de historia y los usa como la historia
en curso.
.TP
.B \-w
Escribe la historia en curso en el fichero de historia,
sobreescribiendo sus contenidos.
.TP
.B \-c
Limpia la lista de historia borrando todas las entradas.
.TP
.B \-p
Realiza la sustitución de historia de los siguientes \fIargs\fP y
muestra el resultado en la salida estándar.
No almacena los resultados en el fichero de historia.
Cada \fIarg\fP debe protegerse para deshabilitar la expansión de
historia normal.
.TP
.B \-s
Almacena los
.I args
en la lista de historia como una sola entrada. La última orden en la
lista de historia se elimina antes de que se añadan los
.IR args .
.PD
.PP
El valor de retorno es 0 a menos que se encuentre una opción inválida
o que ocurra un error mientras se lee o se escribe el fichero de historia.
.RE
.TP
.PD 0
\fBjobs\fP [\fB\-lnprs\fP] [ \fIespectrab\fP ... ]
.TP
\fBjobs\fP \fB\-x\fP \fIorden\fP [ \fIargs\fP ... ]
.PD
La primera forma lista los trabajos activos. Las opciones tienen los
significados siguientes:
.RS
.PD 0
.TP
.B \-l
Lista PIDs además de la información normal.
.TP
.B \-p
Lista solamente el PID del líder del grupo de proceso del trabajo.
.TP
.B \-n
Muestra información solamente sobre trabajos que han cambiado de
estado desde que se notificó al usuario por última vez de su estado.
.TP
.B \-r
Restringe la salida a los trabajos en ejecución.
.TP
.B \-s
Restringe la salida a los trabajos parados.
.PD
.PP
Si se da
.IR espectrab ,
la salida se restringe a la información sobre ese trabajo.
El estado de retorno es cero a menos que se encuentre una opción
inválida o se suministre un
.I espectrab
inválido.
.PP
Si se da la opción
.BR \-x ,
.B jobs
reemplaza cualquier
.I espectrab
encontrado en
.I orden
o
.I args
con el ID de grupo de proceso correspondiente, y ejecuta
.I orden
pasándole
.IR args ,
devolviendo su estado de salida.
.RE
.TP
.PD 0
\fBkill\fP [\fB\-s\fP \fInombre-señal\fP | \fB\-n\fP \fInumseñal\fP | \fB\-\fP\fInombre-señal\fP] [\fIpid\fP | \fIespectrab\fP] ...
.TP
\fBkill\fP \fB\-l\fP [\fInombre-señal\fP | \fIstatus_salida\fP]
.PD
Envía la señal especificada por
.I nombre-señal
o
.I numseñal
a los procesos nombrados por
.I pid
o
.IR espectrab .
.I nombre-señal
es o bien un nombre de señal como
.SM
.B SIGKILL
o un número de señal;
.I numseñal
es un número de señal. Si
.I nombre-señal
es un nombre de señal, éste puede darse con o sin el prefijo
.SM
.BR SIG .
Si
.I nombre-señal
no está presente, entonces se supone
.SM
.BR SIGTERM .
Un argumento de
.B \-l
lista los nombres de señales.
Si se suministran más argumentos cuando se da
.BR \-l ,
se listan los nombres de las señales correspondientes a los
argumentos, y el estado de retorno es 0.
El argumento \fIstatus_salida\fP de
.B \-l
es un número que especifica o bien un número de señal o el estado de
salida de un proceso terminado por una señal.
.B kill
devuelve ``verdad'' si por lo menos se envió con éxito una señal, o
``falso'' si ocurrió un error o se encontró una opción inválida.
.TP
\fBlet\fP \fIarg\fP [\fIarg\fP ...]
Cada
.I arg
es una expresión aritmética a ser evaluada (vea
.SM
.BR "EVALUACIÓN ARITMÉTICA" ).
Si el último
.I arg
se evalúa a 0,
.B let
devuelve 1; si no, devuelve 0.
.TP
\fBlocal\fP [\fInombre\fP[=\fIvalor\fP] ...]
Para cada argumento, se crea una variable local llamada
.IR nombre ,
y se le asigna el valor
.IR valor .
Cuando
.B local
se emplea dentro de una función, hace que la variable
.I nombre
tenga una visibilidad restringida a esa función y sus hijas.
Sin operandos,
.B local
escribe en la salida estándar una lista de las variables locales. Es
un error emplear
.B local
fuera de una función. El estado de retorno es 0 a menos que
.B local
se use fuera de una función, o se dé un
.I nombre
inválido.
.TP
.B logout
Hace terminar un shell de entrada.
.TP
\fBpopd\fP [\-\fBn\fP] [+\fIn\fP] [\-\fIn\fP]
Quita entradas de la pila de directorios. Sin argumentos, 
desapila el directorio de la cima de la pila, y realiza un
.B cd
al nuevo directorio de la pila.
Los argumentos, si se suministran, tienen los siguientes significados:
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
Quita la \fIn\fP\-sima entrada contando desde la izquierda de la lista
mostrada por
.BR dirs ,
empezando por cero. Por ejemplo: ``popd +0''
quita el primer directorio, ``popd +1'' el segundo.
.TP
\fB\-\fP\fIn\fP
Quita la \fIn\fP\-sima entrada contando desde la derecha de la lista
mostrada por
.BR dirs ,
empezando por cero. Por ejemplo: ``popd -0''
quita el último directorio, ``popd -1'' el penúltimo.
.TP
.B \-n
Suprime el normal cambio de directorio cuando se desapilan
directorios, de forma que solamente la pila se manipula.
.PD
.PP
Si la orden
.B popd
es exitosa, también se realiza un
.BR dirs ,
y el estado de retorno es 0.
.B popd
devuelve `falso' si se encuentra una opción inválida, la pila de
directorios está vacía, se especifica una entrada de la pila de
directorios no existente, o falla el cambio de directorio.
.RE
.TP
\fBprintf\fP \fIformato\fP [\fIargumentos\fP]
Escribe los \fIargumentos\fP formateados en la salida estándar bajo el
control del \fIformato\fP.
El \fIformato\fP es una cadena de caracteres que contiene tres tipos
de objetos: caracteres normales, que simplemente se copian en la
salida estándar, caracteres de secuencias de escape, que se convierten
y copian en la salida estándar, y especificaciones de formato, cada
una de las cuales causa la impresión del siguiente \fIargumento\fP
sucesivo de una determinada manera.
Además de los formatos estándares normales de \fIprintf\fP(1), %b hace
que \fBprintf\fP expanda las secuencias de escape de barras inversas
en el correspondiente
\fIargumento\fP, y %q causa que \fBprintf\fP muestre en la salida el
\fIargumento\fP correspondiente en un formato tal que pueda ser
reutilizado como entrada para el shell.
.sp 1
El \fIformato\fP se reutiliza tanto como sea necesario para consumir
todos los \fIargumentos\fP.
Si el \fIformato\fP requiere más \fIargumentos\fP que los que se
suministran, las especificaciones de formato extra se comportan como
si se hubiera dado un valor cero o una cadena vacía, según lo apropiado.
.TP
.PD 0
\fBpushd\fP [\fB\-n\fP] [\fIdir\fP]
.TP
\fBpushd\fP [\fB\-n\fP] [+\fIn\fP] [\-\fIn\fP]
.PD
Añade un directorio a la cima de la pila de directorios, o rota la
pila, haciendo que el directorio de trabajo en curso sea la nueva cima
de la pila. Sin argumentos, intercambia los dos directorios de más
arriba y devuelve 0, a menos que la pila de directorios esté vacía.
Los argumentos, si se suministran, tienen los siguientes significados:
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
Rota la pila de forma que el \fIn\fP\-simo directorio (contando desde
la izquierda de la lista mostrada por
.BR dirs ,
empezando por cero)
esté en la cima.
.TP
\fB\-\fP\fIn\fP
Rota la pila de forma que el \fIn\fP\-simo directorio (contando desde
la derecha de la lista mostrada por
.BR dirs ,
empezando por cero)
esté en la cima.
.TP
.B \-n
Suprime el cambio normal de directorio cuando se añaden directorios a
la pila, de forma que solamente se manipula la pila.
.TP
.B dir
Añade
.I dir
a la pila de directorios en la cima, haciéndolo el nuevo directorio de
trabajo.
.PD
.PP
Si la orden
.B pushd
acaba con éxito, se realiza un
.B dirs
también. Si se emplea la primera forma,
.B pushd
devuelve 0 a menos que falle el cambio a
.IR dir .
Con la segunda forma,
.B pushd
devuelve 0 a menos que la pila de directorios esté vacía, que se
especifique un elemento de la pila de directorios inexistente, o que
el cambio de directorio falle.
.RE
.TP
\fBpwd\fP [\fB\-LP\fP]
Muestra el nombre de fichero absoluto del directorio de trabajo en curso.
El nombre de fichero mostrado no contiene enlaces simbólicos si se da
la opción
.B \-P
o está puesta la opción
.B \-o physical
de la orden interna
.BR set .
Si se usa la opción
.BR \-L ,
los enlaces simbólicos se siguen.
El estado de retorno es 0 a menos que ocurra un error mientras se lea
el nombre del directorio actual o se dé una opción inválida.
.TP
\fBread\fP [\fB\-er\fP] [\fB\-a\fP \fIarray\fP] [\fB\-p\fP \fIprompt\fP] [\fInombre\fP ...]
Se lee una línea desde la entrada estándar, y la primera palabra se
asigna al primer
.IR nombre ,
la segunda palabra al segundo 
.IR nombre ,
y así sucesivamente, con las palabras que sobren y sus separadores
intervinientes asignadas al último
.IR nombre .
Si hay menos palabras leídas de la entrada estándar que nombres, a los
sobrantes se les asignan valores vacíos.
Se emplean los caracteres en
.SM
.B IFS
para dividir la línea en palabras.
Las opciones, si se dan, tienen los siguientes significados:
.RS
.PD 0
.TP
.B \-r
Un par formado por una barra inclinada inversa y un salto de línea a
continuación sí es tenido en cuenta, y la barra inversa se considera
parte de la línea.
.TP
.B \-p
Muestra \fIprompt\fP, sin un salto de línea al final,
antes de intentar leer nada de la entrada. El indicador se muestra
solamente si la entrada viene de una terminal.
.TP
.B \-a
Las palabras se asignan secuencialmente a los elementos de la variable
vector 
.IR array ,
empezando por 0.
Se anula la posible previa definición de
.I array
antes de que se asignen nuevos valores.
Otros argumentos \fInombre\fP no se tienen en consideración.
.TP
.B \-e
Si la entrada estándar viene de una terminal,
se emplea
.B readline
(vea
.SM
.B READLINE
arriba) para obtener la línea.
.PD
.PP
Si no se suministran
.IR nombres ,
la línea leída se asigna a la variable
.SM
.BR REPLY .
El código de retorno es cero, a menos que se llegue al fin de la entrada.
.RE
.TP
\fBreadonly\fP [\fB\-apf\fP] [\fInombre\fP ...]
.PD
Los
\fInombres\fP dados se marcan como de lectura exclusiva; los valores
de estos
.I nombres
no pueden cambiarse por posteriores asignaciones.
Si se da la opción
.BR \-f ,
se marcan así las funciones correspondientes a los \fInombres\fP.
La opción
.B \-a
restringe las variables a vectores.
Si no se da ningún argumento
.IR nombre ,
o si se da la opción
.BR \-p ,
se muestra una lista de todos los nombres de lectura exclusiva.
La opción
.B \-p
hace que la salida se muestre en un formato que puede ser reutilizado
como entrada. El estado de retorno es 0 a menos que se encuentre una
opción inválida, uno de los
.I nombres
no sea un nombre válido de variable del shell, o se dé
.B \-f
con un
.I nombre
que no es una función.
.TP
\fBreturn\fP [\fIn\fP]
Hace que una función acabe y devuelva el valor especificado por
.IR n .
Si
.I n
se omite, el estado devuelto es el de la última orden ejecutada en el
cuerpo de la función. Si se emplea fuera de una función, pero durante
la ejecución de un guión por la orden
.B .
(\fBsource\fP), hace que el shell pare la ejecución de ese guión y
devuelva o
.I n
o el estado de salida de la última orden ejecutada dentro del guión
como el estado de salida del guión. Si se emplea fuera de una función
y no durante la ejecución de un guión por \fB.\fP\^, el estado de
salida es `falso'.
.TP
\fBset\fP [\fB\-\-abefhkmnptuvxBCHP\fP] [\fB\-o\fP \fIopción\fP] [\fIarg\fP ...]
Sin opciones, se muestra el nombre y valor de cada variable del shell
en un formato que puede ser reutilizado como entrada.
La salida se clasifica según la localización en curso.
Cuando se dan opciones, se establecen o quitan atributos del shell.
Cualesquier argumentos que queden tras que se procesen las opciones se
tratan como valores para los parámetros posicionales y se asignan, en
orden, a
.BR $1 ,
.BR $2 ,
.B ...
.BR $\fIn\fP .
Las opciones, si se especifican, tienen los siguientes significados:
.RS
.PD 0
.TP 8
.B \-a
Automáticamente marca variables, que se modifiquen o creen, para
exportación al entorno de las órdenes subsiguientes.  
.TP 8
.B \-b
Informa del estado de los trabajos en segundo plano terminados
inmediatamente, en vez de esperar a justo antes de mostrar el
siguiente indicador primario. Esto sólo es efectivo cuando el control
de trabajos está habilitado.
.TP 8
.B \-e
Sale inmediatamente si una \fIorden simple\fP (vea
.SM
.B GRAMÁTICA DEL SHELL
arriba) acaba con un estado distinto de cero. El shell no acaba si la
orden que falle es parte de un bucle
.I until
o
.IR while ,
parte de una sentencia
.IR if ,
parte de una lista
.B &&
o
.BR \(bv\(bv ,
o si el valor devuelto por la orden se invierte mediante
.BR ! .
.TP 8
.B \-f
Deshabilita la expansión de nombres de caminos.
.TP 8 
.B \-h
Recuerda la localización de órdenes una vez que se buscan para la 1ª
ejecución. Esto está habilitado de forma predeterminada.
.TP 8
.B \-k
Todos los argumentos en forma de sentencias de asignación se ponen en
el entorno para una orden, no solamente aquéllos que precedan al
nombre de la orden.
.TP 8
.B \-m
Modo de monitor.  Se habilita el control de trabajos. Esta opción está
puesta de forma predeterminada para shells interactivos en sistemas
que lo admitan (vea
.SM
.B CONTROL DE TRABAJOS
arriba). Los procesos en segundo plano se ejecutan en un grupo de
proceso separado, y se imprime cuando se completan una línea
conteniendo su estado de salida.
.TP 8
.B \-n
Lee órdenes pero no las ejecuta. Esto puede emplearse para comprobar
si un guión del shell tiene errores de sintaxis. Para shells
interactivos esta opción no tiene efecto.
.TP 8
.B \-o \fInombre\-opción\fP
El \fInombre\-opción\fP puede ser uno de los siguientes:
.RS
.TP 8
.B allexport
Lo miso que
.BR \-a .
.TP 8
.B braceexpand
Lo miso que
.BR \-B .
.TP 8
.B emacs
Emplea una interfaz de edición de líneas de órdenes al estilo de
emacs. Esto está activo de forma predeterminada cuando el shell es
interactivo, a menos que se haya arrancado con la opción
.BR \-\-noediting .
.TP 8
.B errexit
Lo mismo que
.BR \-e .
.TP 8
.B hashall
Lo mismo que
.BR \-h .
.TP 8
.B histexpand
Lo mismo que
.BR \-H .
.TP 8
.B history
Habilita la historia de órdenes, según se describió arriba bajo
.SM
.BR HISTORIA .
Esta opción está habilitada por omisión en shells interactivos.
.TP 8
.B ignoreeof
El efecto es como si se hubiera ejecutado la orden del shell
\f(CWIGNOREEOF=10\fP 
(vea
.B Variables del shell
arriba).
.TP 8
.B keyword
Lo mismo que
.BR \-k .
.TP 8
.B monitor
Lo mismo que
.BR \-m .
.TP 8
.B noclobber
Lo mismo que
.BR \-C .
.TP 8
.B noexec
Lo mismo que
.BR \-n .
.TP 8
.B noglob
Lo mismo que
.BR \-f .
.TP 8
.B notify
Lo mismo que
.BR \-b .
.TP 8
.B nounset
Lo mismo que
.BR \-u .
.TP 8
.B onecmd
Lo mismo que
.BR \-t .
.TP 8
.B physical
Lo mismo que
.BR \-P .
.TP 8
.B posix
Cambia el comportamiento de
.B bash
donde la operación predeterminada difiera del estándar
POSIX 1003.2, de forma que se siga éste.
.TP 8
.B privileged
Lo mismo que
.BR \-p .
.TP 8
.B verbose
Lo mismo que
.BR \-v .
.TP 8
.B vi
Emplea una interfaz de edición de la línea de órdenes al estilo de vi.
.TP 8
.B xtrace
Lo mismo que
.BR \-x .
.sp .5
.PP
Si se da
.B \-o
sin ningún \fInombre\-opción\fP, se muestran los valores de las opciones activas.
Si se da
.B +o
sin ningún \fInombre\-opción\fP, se muestra en la salida estándar una
serie de órdenes
.B set
para recrear las opciones según están puestas o no actualmente.
.RE
.TP 8
.B \-p
Activa el modo
.IR privilegiado .
En este modo, el fichero correspondiente a
.B $ENV
no es procesado, las funciones del shell no se heredan desde el
entorno,y la variable \fBSHELLOPTS\fP, si aparece en el entorno, no se
tiene en consideración.
Esta opción se activa automáticamente en el arranque si el
identificador efectivo del usuario (o grupo) no es igual al
identificador real del usuario (o grupo). 
Desactivar esta opción hace que los identificadores efectivos de
usuario y grupo se pongan con los valores de los identificadores
reales de usuario y grupo respectivamente.
.TP 8
.B \-t
Sale tras leer y ejecutar una sola orden.
.TP 8
.B \-u
Trata las variables no definidas como un error cuando realiza la
expansión de parámetros. Si la expansión se intenta hacer sobre una
variable no definida, el shell muestra un mensaje de error y, si no es
interactivo, sale con un estado distinto de cero.
.TP 8
.B \-v
Repite en la salida las líneas de entrada del shell tras leerlas.
.TP 8
.B \-x
Tras expandir cada \fIorden simple\fP, muestra el valor expandido de
.SM
.BR PS4 ,
seguido por la orden y sus argumentos expandidos.
.TP 8
.B \-B
El shell realiza la expansión de llaves (vea
.B Expansión de llaves
arriba). Esto está activado de forma predeterminada.
.TP 8
.B \-C
Si está activo,
.B bash
no sobreescribe un fichero existente con los operadores de redirección
.BR > ,
.BR >& ,
ni
.BR <> .
Esto puede cambiarse cuando se crean ficheros de salida mediante el
empleo del operador
.B >|
en vez de
.BR > .
.TP 8
.B \-H
Permite la sustitución de historia mediante \fB!\fP\^.
Esta opción está activada por omisión cuando el shell es interactivo.
.TP 8
.B \-P
Si está activada, el shell no sigue enlaces simbólicos cuando ejecuta
órdenes como
.B cd
que cambian el directorio de trabajo. En su lugar emplea la estructura
de directorio física. De forma predeterminada,
.B bash
sigue la cadena lógica de directorios cuando ejecuta órdenes que
cambian el directorio de trabajo.
.TP 8
.B \-\-
Si a esta opción no sigue ningún argumento más, entonces los
parámetros posicionales se anulan. Si no, los parámetros posicionales
se ponen con los valores dados por los
\fIarg\fPs, incluso si alguno de ellos comienza con un
.BR \- .
.TP 8
.B \-
Señala el final de las opciones, haciendo que el resto de \fIarg\fPs
se asignen a los parámetros posicionales. Las opciones
.B \-x
y
.B \-v
se desactivan.
Si no hay más \fIarg\fPs,
los parámetros posicionales permanecen sin cambios.
.PD
.PP
Las opciones están desactivadas de forma predeterminada a menos que se
diga otra cosa. Usar + en vez de \- hace que estas opciones se
desactiven. 
Las opciones también pueden darse como argumentos al llamar al shell.
El conjunto de opciones activadas puede examinarse en
.BR $\- .
El estado de retorno es siempre `verdad' a menos que se encuentre una
opción inválida.
.RE
.TP
\fBshift\fP [\fIn\fP]
Los parámetros posicionales desde \fIn\fP+1 ... se renombran a
.B $1
.B ...
Los parámetros representados por los números desde \fB$#\fP
hasta \fB$#\fP\-\fIn\fP+1 se anulan.
.I n
debe ser un número no negativo menor o igual a \fB$#\fP.
Si
.I n
es 0, no se cambia ningún parámetro.
Si
.I n 
no se da, se supone 1.
Si
.I n
es mayor que \fB$#\fP, los parámetros posicionales no se cambian.
El estado de retorno es mayor que cero si
.I n
es mayor que
.B $#
o menor que cero; en otro caso es cero.
.TP
\fBshopt\fP [\fB\-pqsu\fP] [\fB\-o\fP] [\fInombreopc\fP ...]
Cambia los valores de variables que controlan un comportamiento
determinado opcional del shell. Sin opciones, o con la opción
.BR \-p ,
se muestra una lista de todas las opciones disponibles, con una
indicación en cada una de si está activa o no.
La opción \fB\-p\fP hace que la salida se muestre de una forma tal
que pueda reutilizarse como entrada.
Otras opciones tienen los significados siguientes:
.RS
.PD 0
.TP
.B \-s
Activa (set) cada \fInombreopc\fP.
.TP
.B \-u
Desactiva (unset) cada \fInombreopc\fP.
.TP
.B \-q
Suprime la salida normal (modo silencioso); el estado de salida indica
si el \fInombreopc\fP está activado o no.
Si se dan varios argumentos \fInombreopc\fP con
.BR \-q ,
el estado de salida es cero si todos los \fInombreopcs\fP están
activados; distinto de cero en otro caso.
.TP
.B \-o
Restringe los valores de \fInombreopc\fP a aquéllos definidos para la opción
.B \-o
de la orden interna
.BR set .
.PD
.PP
Si se emplean
.B \-s
o
.B \-u
sin argumentos \fInombreopc\fP, la lista mostrada se limita a aquellas
opciones que están activadas o desactivadas, respectivamente.
A menos que se diga otra cosa, las opciones de \fBshopt\fP están
inactivas (unset) de forma predeterminada.
.PP
El estado de retorno cuando se listan opciones es cero si todos los 
\fInombreopcs\fP están activos, distinto de cero en otro caso. Cuando
se activan o desactivan opciones, el estado de salida es cero a menos
que un \fInombreopc\fP no sea una opción del shell válida.
.PP
La lista de las opciones de \fBshopt\fP es:
.if t .sp .5v
.if n .sp 1v
.PD 0
.TP 8
.B cdable_vars
Si está activa, un argumento de la orden interna
.B cd
que no sea un directorio, se supone el nombre de una variable cuyo
valor es el directorio al que hay que cambiarse.
.TP 8
.B cdspell
Si está activa, se corregirán pequeños errores que hubiera en la
escritura de un componente directorio de una orden
.BR cd .
Los errores que se buscan se refieren a caracteres transpuestos, un
carácter que falte, y un carácter que sobre.
Si se encuentra una corrección, se muestra el nombre de fichero
corregido y la orden procede.
Esta opción sólo se emplea en shells interactivos.
.TP 8
.B checkhash
Si está activa, \fBbash\fP comprueba que una orden encontrada en la
tabla de dispersión existe antes de intentar ejecutarlo. Si una orden
en la tabla de dispersión ya no existe, se realiza una búsqueda normal
en el PATH.
.TP 8
.B checkwinsize
Si está activa, \fBbash\fP comprueba el tamaño de ventana tras cada
orden y, si es necesario, actualiza los valores de
.SM
.B LINES
y
.SM
.BR COLUMNS .
.TP 8
.B cmdhist
Si está activa,
.B bash
intenta guardar todas las líneas de una orden de varias líneas en la
misma entrada de historia. Esto permite una re-edición fácil de dichas
órdenes.
.TP 8
.B dotglob
Si está activa, 
.B bash
incluye los nombres de ficheros que comiencen con un `.' en los
resultados de la expansión de nombres de caminos.
.TP 8
.B execfail
Si está activa, un shell no interactivo no acabará si no puede
ejecutar el fichero especificado como un argumento de la orden interna
.BR exec .
Un shell interactivo no acaba si
.B exec
falla.
.TP 8
.B expand_aliases
Si está activa, los alias se expanden como se describió arriba bajo
.SM
.BR ALIAS .
Esta opción está habilitada de forma predeterminada para shells interactivos.
.TP 8
.B extglob
Si está activa, se habilitan las características de concordancia de
patrones extendidas descritas más arriba en
\fBExpansión de nombres de camino\fP.
.TP 8
.B histappend
Si está activa, la lista de historia se añade al fichero nombrado
según el valor de la variable
.B HISTFILE
cuando el shell acaba, en vez de sobreescribir el fichero.
.TP 8
.B histreedit
Si está activa, y
.B readline
se está utilizando, se le da al usuario la oportunidad de re-editar
la sustitución de historia fallida.
.TP 8
.B histverify
Si está activa, y
.B readline
se está utilizando, los resultados de la sustitución de historia no se
pasan inmediatamente al analizador del shell. En vez de eso, la línea
resultante se carga en el búfer de edición de \fBreadline\fP,
permitiendo así una modificación posterior.
.TP 8
.B hostcomplete
Si está activa, y
.B readline
se está utilizando, \fBbash\fP intentará terminar de escribir un
nombre de computador anfitrión cuando se esté completando una palabra
que contenga una \fB@\fP (vea
.B Terminación
bajo
.SM
.B READLINE
arriba).
Esto está activado de forma predeterminada.
.TP 8
.B huponexit
Si está activa, \fBbash\fP enviará una señal
.SM
.B SIGHUP
a todos los trabajos cuando un shell de entrada interactivo finalice.
.TP 8
.B interactive_comments
Si está activa, permite a una palabra que empiece por
.B #
hacer que esa palabra y todos los caracteres restantes de esa línea no
sean tenidos en cuenta en un shell interactivo (vea
.SM
.B COMENTARIOS
arriba). Esta opción está habilitada por omisión.
.TP 8
.B lithist
Si está activa, y la opción
.B cmdhist
también lo está, las órdenes multi-línea se guardan en la historia con
saltos de línea empotrados en vez de emplear como separador el punto y
coma, donde sea posible.
.TP 8
.B mailwarn
Si está activa, y a un fichero donde \fBbash\fP está buscando correo
nuevo se ha accedido desde la última vez que se buscó, se muestra el
mensaje ``The mail in \fImailfile\fP has been read'', o su equivalente
en el idioma local, que en español sería ``El correo en \fIbuzón\fP ha
sido leído''.
.TP 8
.B nocaseglob
Si está activa,
.B bash
busca concordancias de nombres de ficheros sin importar mayúsculas o
minúsculas cuando realice la expansión de nombres de caminos (vea
.B Expansión de nombres de caminos
arriba).
.TP 8
.B nullglob
Si está activa,
.B bash
permite que los patrones que no concuerden con ningún fichero (vea
.B Expansión de nombres de caminos
arriba)
se expandan a una cadena vacía, en vez de a sí mismos. 
.TP 8
.B promptvars
Si está activa, las cadenas de caracteres que sirven de indicadores
están sujetas a expansión de variable y parámetro tras ser expandidas
como se describió en
.SM
.B INDICADORES
arriba.  Esta opción está activa de forma predeterminada.
.TP 8
.B shift_verbose
Si está activa, la orden interna
.B shift
muestra un mensaje de error cuando el número de shift excede al de
parámetros posicionales.
.TP 8
.B sourcepath
Si está activa, la orden interna
\fBsource\fP (\fB.\fP) emplea el valor de
.SM
.B PATH
para buscar el directorio que contenga al fichero suministrado como
argumento. Esta opción está activa por omisión.
.RE
.TP
\fBsuspend\fP [\fB\-f\fP]
Suspende la ejecución de este shell hasta que reciba una señal
.SM
.BR SIGCONT .
La opción
.B \-f
dice que no hay que protestar si éste es un shell de entrada;
simplemente suspenderlo de todas formas. El estado de retorno es 0 a
menos que el shell sea de entrada y la opción
.B \-f
no se haya dado, o si el control de trabajos no está habilitado.
.TP
.PD 0
\fBtest\fP \fIexpr\fP
.TP
\fB[\fP \fIexpr\fP \fB]\fP
Devuelve un estado de 0 ó 1 dependiendo de la evaluación de la
expresión condicional
.IR expr .
Cada operador y operando debe ser un argumento separado.
Las expresiones se componen de las primarias descritas más arriba bajo
.SM
.BR "EXPRESIONES CONDICIONALES" .
.if t .sp 0.5
.if n .sp 1
Las expresiones se pueden combinar mediante los operadores
siguientes, listados en orden decreciente de precedencia.
.RS
.PD 0
.TP
.B ! \fIexpr\fP
Verdad si
.I expr
es falsa.
.TP
.B ( \fIexpr\fP )
Devuelve el valor de \fIexpr\fP.
Esto puede emplearse para cambiar la precedencia normal de los operadores.
.TP
\fIexpr1\fP \-\fBa\fP \fIexpr2\fP
Verdad si tanto
.I expr1
como
.I expr2
son verdad.
.TP
\fIexpr1\fP \-\fBo\fP \fIexpr2\fP
Verdad si uno al menos de
.I expr1
o
.I expr2
es verdad.
.PD
.PP
\fBtest\fP y \fB[\fP evalúan expresiones condicionales según un
conjunto de reglas basadas en el número de argumentos.
.if t .sp 0.5
.if n .sp 1
.PD 0
.TP
0 argumentos
La expresión es falsa.
.TP
1 argumento
La expresión es verdad si y sólo si el argumento no está vacío.
.TP
2 argumentos
Si el primer argumento es \fB!\fP, la expresión es verdad si y sólo si
el segundo argumento es nulo.
Si el primer argumento es uno de los operadores condicionales monarios
listados arriba en
.SM
.BR "EXPRESIONES CONDICIONALES" ,
la expresión es verdad si el test monario es verdad.
Si el primer argumento no es un operador condicional monario válido,
la expresión es falsa.
.TP
3 argumentos
Si el segundo argumento es uno de los operadores condicionales
binarios listados arriba en
.SM
.BR "EXPRESIONES CONDICIONALES" ,
el resultado de la expresión es el resultado del test binario
empleando el primer y tercer argumentos como operandos.
Si el primer argumento es \fB!\fP, el valor es la negación del test de
dos argumentos empleando el segundo y tercer argumentos.
Si el primer argumento es exactamente \fB(\fP y el tercer argumento es
exactamente \fB)\fP, el resultado es el test de un argumento del
segundo argumento.
De otro modo, la expresión es falsa.
Los operadores \fB\-a\fP y \fB\-o\fP se consideran como operadores
binarios en este caso.
.TP
4 argumentos
Si el primer argumento es \fB!\fP, el resultado es la negación de la
expresión de tres argumentos compuesta por los argumentos restantes.
De otra forma, la expresión se analiza y evalúa de acuerdo con la
precedencia utilizando las reglas listadas arriba.
.TP
5 ó más argumentos
La expresión se analiza y evalúa de acuerdo con la precedencia usando
las reglas mencionadas arriba.
.RE
.PD
.TP
.B times
Muestra los tiempos acumulados de usuario y sistema para el shell y
para procesos ejecutados desde él. El estado de retorno es 0.
.TP
\fBtrap\fP [\fB\-lp\fP] [\fIarg\fP] [\fInombre-señal\fP ...]
La orden
.I arg
va a leerse y ejecutarse cuando el shell reciba la(s) señal(es)
especificada(s) por
.IR nombre-señal .
Si
.I arg
está ausente o es
.BR \- ,
todas las señales especificadas se reestablecen a sus valores
originales (los que tenían cuando se entró en el shell).
Si
.I arg
es la cadena vacía, la señal especificada por cada
.I nombre-señal
no se tiene en cuenta por parte del shell y de las órdenes que se
llamen desde él.
Si
.I arg
es
.B \-p
entonces se muestran las órdenes de las trampas asociadas con cada
.IR nombre-señal .
Si no se pasan argumentos o si sólo se da
.BR \-p ,
.B trap
muestra la lista de órdenes asociadas con cada número de señal.
Cada
.I nombre-señal
es o bien un nombre de señal de los definidos en <\fIsignal.h\fP>, 
o un número de señal.
Si un
.I nombre-señal
es
.SM
.B EXIT
(0), la orden
.I arg
se ejecuta cuando se sale del shell. Si un
.I nombre-señal
es
.SM
.BR DEBUG ,
la orden
.I arg
se ejecuta tras cada \fIorden simple\fP (vea
.SM
.B GRAMÁTICA DEL SHELL
arriba).
La opción
.B \-l
hace que el shell muestre una lista de nombres de señal y sus números
correspondientes. 
Las señales que no se tienen en cuenta ya cuando se entra en el shell
no pueden ser atrapadas ni restablecidas.
Las señales atrapadas se reestablecen a sus valores originales en un
proceso hijo cuando se crea.
El estado de retorno es `falso' si cualquier
.I nombre-señal
no es válido; de otro modo,
.B trap
devuelve `verdad'.
.TP
\fBtype\fP [\fB\-atp\fP] \fInombre\fP [\fInombre\fP ...]
Sin opciones,
indica cómo será interpretado cada
.I nombre
si se usa como un nombre de orden.
Si se emplea la opción
.BR \-t ,
.B type
muestra una de las siguientes cadenas de caracteres:
.IR alias ,
.IR keyword ,
.IR function ,
.IR builtin ,
o
.I file 
si
.I nombre
es respectivamente un alias, una palabra reservada del shell, una
función, una orden interna incorporada en el shell, o un fichero
ejecutable de disco.
Si el
.I nombre
no se encuentra, no se muestra nada, y se devuelve un estado de salida
de `falso'.
Si se emplea la opción
.BR \-p ,
.B type
devuelve o bien el nombre del fichero de disco que se ejecutaría si
se especificara
.I nombre
como un nombre de orden, o bien nada si \f(CWtype -t nombre\fR
no devolviera
.IR file .
Si una orden está en la tabla de dispersión,
.B \-p
muestra el valor de dicha tabla, no necesariamente el fichero que
aparezca primero en
.SM
.BR PATH .
Si se emplea la opción
.BR \-a ,
.B type
muestra todos los sitios que contengan un ejecutable llamado
.IR nombre .
Esto incluye alias y funciones, si y sólo si la opción
.B \-p
no se ha usado también.
La tabla de dispersión de las órdenes no se consulta cuando se emplea
.BR \-a .
.B type
devuelve `verdad' si cualquiera de los argumentos se encuentra,
`falso' si no se encuentra ninguno.
.TP
\fBulimit\fP [\fB\-SHacdflmnpstuv\fP [\fIlímite\fP]]
Proporciona control sobre los recursos disponibles para el shell y
para los procesos arrancados por él, en sistemas que permitan tal
control (Linux por ejemplo, y por supuesto). El valor de
.I límite
puede ser un número en la unidad especificada para el recurso, o el
valor 
.BR unlimited ,
o sea, ilimitado.
Las opciones \fB\-H\fP y \fB\-S\fP especifican que el límite para el
recurso dado va a ser duro o blando. Un límite duro es aquél que no
puede ser aumentado una vez puesto; un límite blando puede
incrementarse hasta el valor dado por el límite duro. Si no se
especifican ni \fB\-H\fP ni \fB\-S\fP, se establecen ambos límites.
Si
.I límite
se omite, se muestran los valores del límite blando del recurso, a
menos que se dé la opción \fB\-H\fP. Cuando se especifica más de un
recurso, se imprime el nombre del límite y la unidad antes del valor.
Otras opciones se interpretan como sigue:
.RS
.PD 0
.TP
.B \-a
Se informa de todos los límites actuales
.TP
.B \-c
El tamaño máximo de ficheros de volcados de memoria (core)
.TP
.B \-d
El tamaño máximo del segmento de datos de un proceso
.TP
.B \-f
El tamaño máximo de ficheros creados por el shell
.TP
.B \-l
El tamaño máximo que puede ser bloqueado en memoria
.TP
.B \-m
El tamaño del máximo conjunto residente (memoria)
.TP
.B \-n
EL número máximo de descriptores de ficheros abiertos (la mayoría de
sistemas no permiten establecer este valor)
.TP
.B \-p
El tamaño de una tubería en bloques de 512 B (esto puede no estar
establecido) 
.TP
.B \-s
El tamaño máximo de pila
.TP
.B \-t
La máxima cantidad de tiempo de CPU en segundos
.TP
.B \-u
El número máximo de procesos disponibles para un solo usuario
.TP
.B \-v
La máxima cantidad de memoria virtual disponible para el shell
.PD
.PP
Si se da
.IR límite ,
es el nuevo valor del recurso especificado (la opción
.B \-a
es sólo para mostrar los valores).
Si no se da ninguna opción, entonces
se supone
.BR \-f .
Los valores están en incrementos de 1024 B, excepto para
.BR \-t ,
que está en segundos,
.BR \-p ,
que está en unidades de bloques de 512 B, 
y
.B \-n
y
.BR \-u ,
que son valores adimensionales. El estado de retorno es 0 a menos que
se encuentre una opción inválida, se dé como \fIlímite\fP un argumento
no numérico distinto de \fBunlimited\fP, o bien ocurra un error
mientras se establece un nuevo límite.
.RE
.TP
\fBumask\fP [\fB\-p\fP] [\fB\-S\fP] [\fImodo\fP]
La máscara de creación de ficheros del usuario se establece a
.IR modo .
Si
.I modo
empieza con un dígito, se interpreta como un número octal; si no, se
interpreta como un modo simbólico similar al aceptado por 
.IR chmod (1).
Si
.I modo
se omite, o si se da la opción
.BR \-S ,
se muestra el valor actual de la máscara.
La opción
.B \-S
hace que la máscara se imprima en forma simbólica; la salida
predeterminada es como un número octal.
Si se da la opción
.B \-p
y
.I modo
se omite, la salida es de tal forma que puede reutilizarse como
entrada. El estado de retorno es 0 si el modo se cambió exitosamente o
si no se dio el argumento \fImodo\fP, y `falso' en otra circunstancia.
.TP
\fBunalias\fP [\-\fBa\fP] [\fInombre\fP ...]
Quita \fInombre\fPs de la lista de alias definidos. Si se da la opción
.BR \-a ,
se quitan todas las definiciones de alias. El estado de salida es
`verdad' a menos que un
.I nombre
dado no sea un alias definido.
.TP
\fBunset\fP [\-\fBfv\fP] [\fInombre\fP ...]
Para cada
.IR nombre ,
borra la variable o función correspondiente.
Si no se dan opciones, o se da la opción
.BR \-v ,
cada
.I nombre
se refiere a una variable del shell.
Las variables de lectura exclusiva no pueden borrarse.
Si se especifica
.BR \-f ,
cada
.I nombre
se refiere a una función del shell, y se borra la definición de la
función. 
Cada variable o función se quita del entorno pasado a órdenes
subsiguientes. 
Si se quita cualquiera de
.SM
.BR RANDOM ,
.SM
.BR SECONDS ,
.SM
.BR LINENO ,
.SM
.BR HISTCMD ,
o
.SM
.BR DIRSTACK ,
pierde su propiedad especial, incluso aunque más adelante se vuelva a
definir. El estado de salida es `verdad' a menos que
.I nombre
no exista o sea de lectura exclusiva.
.TP
\fBwait\fP [\fIn\fP]
Espera al proceso especificado y devuelve su estado de terminación.
.I n
puede ser un identificador de proceso (PID) o una especificación de
trabajo; si se da una espec. de trabajo, se espera a todos los
procesos en la tubería de ese trabajo. Si 
.I n
no se da, se espera a todos los procesos hijos activos actualmente, y
el estado de retorno es cero. Si
.I n
especifica un proceso o trabajo no existente, el estado de retorno es
127. De otro modo, el estado de retorno es el estado de salida del
último proceso o trabajo al que se esperó.
.\" bash_builtins
.if \n(zZ=1 .ig zZ
.SH "SHELL RESTRINGIDA"
.PP
Si
.B bash
se arranca con el nombre
.BR rbash ,
o se da la opción
.B \-r
en la llamada,
el shell se convierte en restringido.
Un shell restringido se emplea para establecer un ambiente más
controlado que el que el shell estándar proporciona.
Se comporta de forma idéntica a
.B bash
con la excepción de que lo siguiente no está permitido o no se realiza:  
.IP \(bu
cambiar de directorio con \fBcd\fP
.IP \(bu
establecer o anular los valores de
.B SHELL
o de
.B PATH
.IP \(bu
especificar nombres de órdenes que contengan
.B /
.IP \(bu
especificar un nombre de fichero que contenga al menos una
.B /
como un argumento de la orden
interna
.B .
(\fBsource\fP)
.IP \(bu
importar definiciones de funciones desde el entorno del shell en el arranque
.IP \(bu
analizar el valor de \fBSHELLOPTS\fP desde el entorno del shell en el arranque
.IP \(bu
redirigir la salida usando los operadores de redirección >, >|, <>, >&, &>, y >>
.IP \(bu
utilizar la orden interna
.B exec
para reemplazar el shell por otro programa
.IP \(bu
añadir o eliminar órdenes incorporadas con las opciones
.B \-f
o
.B \-d
de la orden interna
.BR enable .
.IP \(bu
dar la opción
.B \-p
a la orden interna
.BR command .
.IP \(bu
desactivar el modo restringido con
\fBset +r\fP o \fBset +o restricted\fP.
.PP
Estas restricciones entran en vigor después de que se lean los ficheros
de arranque que hubiera.
.PP
Cuando se ejecuta una orden que resulta ser un guión del shell (vea
.SM
.B "EJECUCIÓN DE ÓRDENES"
arriba),
.B rbash
desactiva todas las restricciones en el shell lanzado para ejecutar el
guión.
.SH "VÉASE TAMBIÉN"
.PD 0
.TP
\fIBash Features\fP (Características de Bash), Brian Fox & Chet Ramey
.TP
\fIThe Gnu Readline Library\fP (La Biblioteca Readline de GNU), Brian Fox & Chet Ramey 
.TP
\fIThe Gnu History Library\fP (La Biblioteca de Historia de GNU), Brian Fox & Chet Ramey 
.TP
\fIPortable Operating System Interface (POSIX) Part 2: Shell and Utilities\fP (Interfaz para Sistemas Operativos Transportables (POSIX) Parte 2: Shell y Utilidades), IEEE
.TP
\fIzsh\fP(1), \fIash\fP(1), \fIsh\fP(1), \fIksh\fP(1), \fIcsh\fP(1), \fItcsh\fP(1). 
.TP
\fIemacs\fP(1), \fIvi\fP(1)
.TP
\fIreadline\fP(3)
.PD
.SH FICHEROS
.PD 0
.TP
.FN /bin/bash
La imagen ejecutable de \fBbash\fP
.TP
.FN /etc/profile
El fichero de inicio general, leído en shells de entrada
.TP
.FN ~/.bash_profile
El fichero de inicio personal, leído para shells de entrada
.TP
.FN ~/.bashrc
El fichero individual de arranque para shells interactivos
.TP
.FN ~/.inputrc
El fichero de inicio individual de \fIreadline\fP
.PD
.SH AUTORES
Brian Fox, Free Software Foundation
.br
bfox@gnu.ai.MIT.Edu
.PP
Chet Ramey, Case Western Reserve University
.br
chet@ins.CWRU.Edu
.PP
Traducción al español: Gerardo Aburruzaga García, para el proyecto
PAMELI.
.br
Gerardo@CICA.es
.SH INFORMES DE FALLOS
Si Ud. encuentra un fallo en
.B bash,
debería informar de ello. Pero primero debería asegurarse de que
realmente es un fallo, y de que aparece en la última versión de
.B bash
que tenga.
.PP
Una vez que Ud. ha determinado que realmente existe un fallo, utilice
la orden
.I bashbug
para enviar el informe correspondiente.
Si Ud. ha encontrado cómo corregirlo, ¡se le anima a que nos mande
también la corrección!
Las sugerencias y los informes de fallos `filosóficos' se pueden
enviar por correo electrónico a \fIbug-bash@gnu.org\fP o se pueden
publicar en el grupo de discusiones de Usenet
.BR gnu.bash.bug .
.PP
TODOS los informes de fallos deben incluir:
.PP
.PD 0
.TP 20
El número de versión de \fBbash\fR
.TP
El tipo de computador (hardware) y el sistema operativo
.TP
El compilador que se empleó para compilarlo
.TP
Una descripción del comportamiento del fallo
.TP
Un corto guión o `receta' para reproducir el fallo
.PD
.PP
.I bashbug
inserta automáticamente los tres primeros puntos en la plantilla que
proporciona para escribir el informe del fallo.
.PP
Los comentarios e informes de fallos que conciernan a esta página de
manual deben dirigirse a
.IR chet@ins.CWRU.Edu .
.PP
Los relativos a la traducción de esta página deben dirigirse a
.I gerardo@cica.es
o discutirse en el marco del proyecto PAMELI; contacte con nosotros en
.IR http://elcano.dif.um.es/~piernas/manpages-es .
.SH FALLOS
.PP
Es demasiado grande y demasiado lento.
.PP
Hay algunas sutiles diferencias entre
.B bash
y versiones tradicionales del shell de Bourne
.BR sh ,
mayormente debidas a la especificación
.SM
.BR POSIX .
.PP
Los alias son confusos en algunos casos.
.PP
Las órdenes internas del shell y las funciones no son
interrumpibles/rearrancables. 
.PP
Las órdenes compuestas y las secuencias de órdenes de la forma 
`a ; b ; c' no se manejan de forma muy elegante cuando se intenta
suspender el proceso. Cuando un proceso es parado, el shell ejecuta
inmediatamente la siguiente orden de la secuencia. 
Para remediar esto es suficiente poner la secuencia de órdenes entre
paréntesis; así la forzamos a ejecutarse en un subshell, que puede
pararse como una unidad.
.PP
Las órdenes dentro de una sustitución de orden de tipo
\fB$(\fP...\fB)\fP no se analizan hasta que se intenta la
sustitución. Esto provocará un retraso en la aparición de mensajes
posibles de error hasta algún tiempo después de que se introduzca la orden.
.PP
Las variables de tipo vector no pueden (aún) exportarse.
.zZ
\"  LocalWords:  bash Shell
