<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><title>
Manual de Allegro: 24 Rutinas de música MIDI
</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
<!--
A.xref:link    {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:visited {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:hover   {color: blue; text-decoration: underline; background: rgb(255, 224, 150);}
A.xref:active  {color: red; text-decoration: none; background: rgb(255, 204, 50);}
blockquote.xref {border: medium solid rgb(255, 204, 51); color: black; background: rgb(255, 204, 50);}
blockquote.code {border: medium solid rgb(255, 204, 50); color: black; background: rgb(255, 255, 155);}
blockquote.text {border: medium solid rgb(175, 235, 255); color: black; background: rgb(210, 244, 255);}
-->
</style>
</head><body bgcolor=white text=black link="#0000ee" alink="#ff0000" vlink="#551a8b">
<h1><a name="24 Rutinas de música MIDI">24 Rutinas de música MIDI</a></h1>

<ul>
<li><a href="#destroy_midi">destroy_midi</a>
<li><a href="#load_ibk">load_ibk</a>
<li><a href="#load_midi">load_midi</a>
<li><a href="#load_midi_patches">load_midi_patches</a>
<li><a href="#lock_midi">lock_midi</a>
<li><a href="#midi_loop_end">midi_loop_end</a>
<li><a href="#midi_loop_start">midi_loop_start</a>
<li><a href="#midi_meta_callback">midi_meta_callback</a>
<li><a href="#midi_msg_callback">midi_msg_callback</a>
<li><a href="#midi_out">midi_out</a>
<li><a href="#midi_pause">midi_pause</a>
<li><a href="#midi_pos">midi_pos</a>
<li><a href="#midi_resume">midi_resume</a>
<li><a href="#midi_seek">midi_seek</a>
<li><a href="#midi_sysex_callback">midi_sysex_callback</a>
<li><a href="#play_looped_midi">play_looped_midi</a>
<li><a href="#play_midi">play_midi</a>
<li><a href="#stop_midi">stop_midi</a>
</ul>

<p><br>
<b>MIDI *<a name="load_midi">load_midi</a>(const char *filename);</b><br>
   Carga un fichero MIDI (maneja ambos formatos 0 y 1), devolviendo un
   puntero a la estructura MIDI, o NULL si hubo problemas.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#destroy_midi">destroy_midi</a>,
<a class="xref" href="#play_midi">play_midi</a>.</font></blockquote>
<b>void <a name="destroy_midi">destroy_midi</a>(MIDI *midi);</b><br>
   Destruye una estructura MIDI cuando ya no la necesite. Es seguro llamar
   esto incluso cuando el fichero MIDI está siendo reproducido, porque lo
   comprueba y detiene en caso de que esté activo.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#load_midi">load_midi</a>.</font></blockquote>
<b>void <a name="lock_midi">lock_midi</a>(MIDI *midi);</b><br>
   Bajo DOS, bloquea toda la memoria usada por un fichero MIDI. Normalmente
   no necesita llamar a esta función porque load_midi() lo hace por usted.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#load_midi">load_midi</a>.</font></blockquote>
<b>int <a name="play_midi">play_midi</a>(MIDI *midi, int loop);</b><br>
   Reproduce el fichero MIDI especificado, deteniendo cualquier música
   anterior. Si la variable loop está activada, los datos serán repetidos
   hasta que los sustituya con otra cosa, de otro modo se parará la música al
   final del fichero. Pasando un puntero NULL parará cualquier música que
   esté siendo reproducida. Devuelve distinto de cero si hubo problemas (esto
   puede ocurrir si un controlador wavetable cacheable no consigue cargar los
   samples requeridos, o al menos ocurrirá en el futuro cuando alguien
   escriba algunos controladores wavetable cacheables :-)


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="alleg022.html#install_sound">install_sound</a>,
<a class="xref" href="#load_midi">load_midi</a>,
<a class="xref" href="#play_looped_midi">play_looped_midi</a>,
<a class="xref" href="#stop_midi">stop_midi</a>,
<a class="xref" href="#midi_pause">midi_pause</a>,
<a class="xref" href="#midi_seek">midi_seek</a>,
<a class="xref" href="#midi_pos">midi_pos</a>,
<a class="xref" href="#midi_msg_callback">midi_msg_callback</a>.</font></blockquote>
<b>int <a name="play_looped_midi">play_looped_midi</a>(MIDI *midi, int loop_start, int loop_end);</b><br>
   Reproduce un fichero MIDI con una posición de bucle definida por el
   usuario. Cuando el reproductor llega al final del bucle o al final del
   fichero (loop_end puede ser -1 para repetir en EOF), volverá al principio
   del comienzo del bucle. Ambas posiciones son especificadas en el mismo
   formato de golpes de ritmo que la variable midi_pos.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#play_midi">play_midi</a>,
<a class="xref" href="#midi_loop_start">midi_loop_start</a>.</font></blockquote>
<b>void <a name="stop_midi">stop_midi</a>();</b><br>
   Para la música que esté siendo reproducida. Esto es lo mismo que llamar
   play_midi(NULL, FALSE).


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#play_midi">play_midi</a>,
<a class="xref" href="#midi_pause">midi_pause</a>.</font></blockquote>
<b>void <a name="midi_pause">midi_pause</a>();</b><br>
   Pone el reproductor MIDI en pausa.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#play_midi">play_midi</a>,
<a class="xref" href="#stop_midi">stop_midi</a>,
<a class="xref" href="#midi_resume">midi_resume</a>,
<a class="xref" href="#midi_seek">midi_seek</a>.</font></blockquote>
<b>void <a name="midi_resume">midi_resume</a>();</b><br>
   Continua la reproducción de un MIDI pausado.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#midi_pause">midi_pause</a>.</font></blockquote>
<b>int <a name="midi_seek">midi_seek</a>(int target);</b><br>
   Avanza hasta la posición especificada (midi_pos) en el fichero MIDI
   usado. Si el objetivo está antes en el fichero que el midi_pos actual,
   avanza desde el principio; de otro modo busca desde la posición actual.
   Devuelve cero si no lo ha conseguido, no-cero si llega al final del
   fichero (1 significa que paró la reproducción, 2 significa que volvió a
   reproducir desde el principio). Si la función se para porque llegó a EOF,
   midi_pos contendrá el valor negativo de la longitud del fichero MIDI.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#play_midi">play_midi</a>,
<a class="xref" href="#midi_pos">midi_pos</a>.</font></blockquote>
<b>void <a name="midi_out">midi_out</a>(unsigned char *data, int length);</b><br>
   Introduce un bloque de comandos MIDI en el reproductor en tiempo real,
   permitiéndole activar notas, tocar campanas, etc, sobre el fichero MIDI
   que esté siendo reproducido.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="alleg022.html#install_sound">install_sound</a>,
<a class="xref" href="#load_midi_patches">load_midi_patches</a>,
<a class="xref" href="alleg026.html#midi_recorder">midi_recorder</a>.</font></blockquote>
<b>int <a name="load_midi_patches">load_midi_patches</a>();</b><br>
   Fuerza al controlador MIDI a cargar un conjunto de patches completo para
   ser usados. Normalmente no deberá llamar esto, porque Allegro
   automáticamente carga todos los datos requeridos por el fichero MIDI
   seleccionado, pero debe llamar esto antes de mandar mensajes de cambio de
   programa vía comando midi_out(). Devuelve distinto de cero si ocurrió un
   fallo.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="alleg022.html#install_sound">install_sound</a>,
<a class="xref" href="#midi_out">midi_out</a>.</font></blockquote>
<b>extern volatile long <a name="midi_pos">midi_pos</a>;</b><br>
   Contiene la posición actual (número de beat) del fichero MIDI, o un
   número negativo si no se está reproduciendo ninguna música. Util para
   sincronizar animaciones con la música, y para comprobar si un fichero MIDI
   se ha acabado de reproducir.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#play_midi">play_midi</a>,
<a class="xref" href="#midi_msg_callback">midi_msg_callback</a>.</font></blockquote>
<b>extern long <a name="midi_loop_start">midi_loop_start</a>;</b><br>
<b>extern long <a name="midi_loop_end">midi_loop_end</a>;</b><br>
   Los puntos de comienzo y final del bucle, ajustados por la función
   play_looped_midi(). Estos pueden ser alterados mientras suena la música,
   pero debería estar seguro de ponerlos a valores sensatos (comienzo &lt;
   final). Si está cambiando ambos al mismo tiempo, asegúrese de alterarlos
   en el mismo orden en caso de que una interrupción midi ocurra entre sus
   dos cambios. Si los valores están a -1, representan el comienzo y final
   del fichero respectivamente.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#play_looped_midi">play_looped_midi</a>.</font></blockquote>
<b>extern void (*<a name="midi_msg_callback">midi_msg_callback</a>)(int msg, int byte1, int byte2);</b><br>
<b>extern void (*<a name="midi_meta_callback">midi_meta_callback</a>)(int type,</b>
<b>        const unsigned char *data, int length);</b><br>
<b>extern void (*<a name="midi_sysex_callback">midi_sysex_callback</a>)(const unsigned char *data,</b>
<b>        int length);</b><br>
   Funciones de enganche que permiten interceptar eventos MIDI del
   reproductor. Si se activan a cualquier cosa menos NULL, estas rutinas
   serán llamadas por cada mensaje MIDI, meta-evento, y bloque de datos
   exclusivo del sistema respectivamente. Estas funciones serán ejecutadas en
   un contexto de control de interrupción, por lo que todo el código y datos
   que usen debería estar bloqueado (locked), y no deben llamar funciones del
   sistema operativo. En general, simplemente use estas rutinas para activar
   algunas variables y responder a ellas más tarde en su código principal.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#play_midi">play_midi</a>.</font></blockquote>
<b>int <a name="load_ibk">load_ibk</a>(char *filename, int drums);</b><br>
   Lee una definición de un fichero patch .IBK usado por el controlador
   Adlib. Si los tambores están activados, lo cargará como un patch de
   percusión, de otro modo reemplazará el conjunto de instrumentos MIDI
   General. Puede llamar esto antes o después de iniciar el código de
   sonido, o simplemente puede activar las variables ibk_file e
   ibk_drum_file en el fichero de configuración para cargar los datos
   automáticamente. ¡Fíjese que esta función no tiene ningún efecto en
   otros controladores que no sean Adlib!




<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="alleg022.html#install_sound">install_sound</a>.</font></blockquote>
<hr><a href="allegro.html">Volver al Indice</a>

</body>
</html>
