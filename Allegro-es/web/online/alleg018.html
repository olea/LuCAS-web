<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><title>
Manual de Allegro: 18 Transparencias y dibujo con patrón
</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
<!--
A.xref:link    {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:visited {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:hover   {color: blue; text-decoration: underline; background: rgb(255, 224, 150);}
A.xref:active  {color: red; text-decoration: none; background: rgb(255, 204, 50);}
blockquote.xref {border: medium solid rgb(255, 204, 51); color: black; background: rgb(255, 204, 50);}
blockquote.code {border: medium solid rgb(255, 204, 50); color: black; background: rgb(255, 255, 155);}
blockquote.text {border: medium solid rgb(175, 235, 255); color: black; background: rgb(210, 244, 255);}
-->
</style>
</head><body bgcolor=white text=black link="#0000ee" alink="#ff0000" vlink="#551a8b">
<h1><a name="18 Transparencias y dibujo con patrón">18 Transparencias y dibujo con patrón</a></h1>

<ul>
<li><a href="#color_map">color_map</a>
<li><a href="#create_blender_table">create_blender_table</a>
<li><a href="#create_color_table">create_color_table</a>
<li><a href="#create_light_table">create_light_table</a>
<li><a href="#create_trans_table">create_trans_table</a>
<li><a href="#drawing_mode">drawing_mode</a>
<li><a href="#set_add_blender">set_add_blender</a>
<li><a href="#set_alpha_blender">set_alpha_blender</a>
<li><a href="#set_blender_mode">set_blender_mode</a>
<li><a href="#set_blender_mode_ex">set_blender_mode_ex</a>
<li><a href="#set_burn_blender">set_burn_blender</a>
<li><a href="#set_color_blender">set_color_blender</a>
<li><a href="#set_difference_blender">set_difference_blender</a>
<li><a href="#set_dissolve_blender">set_dissolve_blender</a>
<li><a href="#set_dodge_blender">set_dodge_blender</a>
<li><a href="#set_hue_blender">set_hue_blender</a>
<li><a href="#set_invert_blender">set_invert_blender</a>
<li><a href="#set_luminance_blender">set_luminance_blender</a>
<li><a href="#set_multiply_blender">set_multiply_blender</a>
<li><a href="#set_saturation_blender">set_saturation_blender</a>
<li><a href="#set_screen_blender">set_screen_blender</a>
<li><a href="#set_trans_blender">set_trans_blender</a>
<li><a href="#set_write_alpha_blender">set_write_alpha_blender</a>
<li><a href="#solid_mode">solid_mode</a>
<li><a href="#xor_mode">xor_mode</a>
</ul>

<p><br>
<b>void <a name="drawing_mode">drawing_mode</a>(int mode, BITMAP *pattern, int x_anchor, int y_anchor);</b><br>
   Ajusta el modo de dibujo gráfico. Esto sólo afecta a las rutinas
   geométricas como putpixel, lines, rectangles, circles, polygons,
   floodfill, etc, y no a la salida de texto, blits o dibujado de sprites.
   El modo debería ser uno de los siguientes valores.
<blockquote class="text"><pre>
      DRAW_MODE_SOLID               - por defecto, dibujado sólido
      DRAW_MODE_XOR                 - dibujado or-exclusivo
      DRAW_MODE_COPY_PATTERN        - rellenado con patrón multicolor
      DRAW_MODE_SOLID_PATTERN       - rellenado con patrón de un solo color
      DRAW_MODE_MASKED_PATTERN      - rellenado con patrón enmascarado
      DRAW_MODE_TRANS               - fundido de color translúcido
</pre></blockquote>
   En DRAW_MODE_XOR, los pixels son escritos en el bitmap con una operación
   or-exclusiva en vez de con la copia simple, por lo que dibujar la misma
   figura dos veces la borrará. Como esto requiere tanto leer como escribir
   en el bitmap de memoria, el dibujado xor es mucho más lento que el modo
   normal.

<p>
   Con los modos con patrón, usted indica un bitmap de patrón que será
   dibujado sobre la superficie de la figura. Allegro almacena un puntero a
   este bitmap en vez de una copia, por lo que no debe destruir el bitmap
   mientras sea usado como patrón. El ancho y alto del patrón debe ser un
   múltiplo de dos, pero pueden ser diferentes, es decir, un patrón de 64x16
   está bien, pero uno de 17x3 no. El patrón será repetido en una rejilla
   comenzando en el punto (x_anchor, y_anchor). Normalmente debería pasar
   cero para estos valores, lo que le dejará dibujar varias figuras y que
   sus patrones se junten en los bordes. Un alineamiento de cero puede sin
   embargo ser peculiar cuando mueva una figura con patrón por la pantalla,
   porque la figura se moverá, pero el patrón no, por lo que en algunas
   situaciones quizás le interese alterar las posiciones del ancla (anchor).

<p>
   Cuando selecciona DRAW_MODE_COPY_PATTERN, los pixels simplemente son
   copiados del bitmap de patrón al bitmap destino. Esto le permite usar
   patrones multicolor, y significa que el color que pase a la rutina de
   dibujado es ignorado. Este es el más rápido de los modos con patrón.

<p>
   En DRAW_MODE_SOLID_PATTERN, cada pixel del patrón es comparado con el
   color de máscara (cero en modos de 256 colores, rosa fucsia en modos
   truecolor). Si el pixel del patrón es sólido, un pixel del color que pasó
   a la rutina de dibujado es escrito en el bitmap destino, de otro modo
   escribe un cero. El patrón es por esto tratado como una máscara
   monocroma, que le permite usar el mismo patrón para dibujar diferentes
   figuras con colores diferentes, pero previene el uso de patrones
   multicolores.

<p>
   DRAW_MODE_MASKED_PATTERN es casi lo mismo que DRAW_MODE_SOLID_PATTERN,
   pero los pixels enmascarados son ignorados en vez de copiados como cero,
   por lo que el fondo se verá a través de los agujeros.

<p>
   En DRAW_MODE_TRANS, la tabla global color_map o las funciones de fundido
   se usan para sobreimprimir pixels encima de la imágen existente. Esta sólo
   debe usarse después de haber constuído la tabla de mapeo de color (para
   modos de 256 colores) o las funciones de fundido (para modos truecolor).
   Dado que debe leer y escribir en la memoria del bitmap, el dibujado
   transparente es muy lento si dibuja directamente en la memora de vídeo,
   así que siempre que sea posible debería dibujar en bitmaps de memoría.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#xor_mode">xor_mode</a>,
<a class="xref" href="#solid_mode">solid_mode</a>,
<a class="xref" href="#color_map">color_map</a>,
<a class="xref" href="#set_trans_blender">set_trans_blender</a>.</font></blockquote>
<b>void <a name="xor_mode">xor_mode</a>(int on);</b><br>
   Esto es un atajo para activar o desactivar el modo de dibujado xor.
   Llamar xor_mode(TRUE) es equivalente a drawing_mode (DRAW_MODE_XOR, NULL,
   0, 0); Llamar xor_mode(FALSE) es equivalente a
   drawing_mode (DRAW_MODE_SOLID, NULL, 0, 0);


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="solid_mode">solid_mode</a>();</b><br>
   Esto es un atajo para seleccionar el dibujado sólido. Es equivalente a
   llamar drawing_mode(DRAW_MODE_SOLID, NULL, 0, 0);


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<br><center><h2><a name="Transparencia en modos de 256 colores">Transparencia en modos de 256 colores</a></h2></center><p>
En modos de vídeo con paleta, la translucidez y la iluminación son
implementadas con una tabla precalculada de 64k, que contiene el resultado
de la combinación de cualquier color c1 con c2. Tiene que crear esta tabla
antes de usar cualquiera de las rutinas de iluminación o translucidez.
Dependiendo de cómo se crea tabla, será posible hacer un rango diferente de
efectos. Por ejemplo, la translucidez se puede implementar usando un color
intermedio entre c1 y c2 como resultado de su combinación. La iluminación se
consigue tratando uno de los colores como nivel de luz (0-255) en vez de
como color, y creando la tabla apropiadamente. Un rango de efectos
especializados es posible, si por ejemplo sustituye cualquier color con otro
color haciendo los colores individuales de origen o destino totalmente
sólidos o invisibles.

<p>
Las tablas de color pueden ser precalculadas con la utilidad colormap, o
generadas en tiempo real. La estructura COLOR_MAP se define así:
<blockquote class="code"><pre>
   typedef struct {
      unsigned char data[PAL_SIZE][PAL_SIZE];
   } COLOR_MAP;
</pre></blockquote>
<b>extern COLOR_MAP *<a name="color_map">color_map</a>;</b><br>
   Puntero global a una tabla de color. ¡Esto debe ser ajustado antes de usar
   cualquiera de las funciones de dibujado translúcido o iluminado en modos
   de 256 colores!


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#create_color_table">create_color_table</a>,
<a class="xref" href="#create_light_table">create_light_table</a>,
<a class="xref" href="#create_trans_table">create_trans_table</a>,
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="alleg013.html#draw_trans_sprite">draw_trans_sprite</a>,
<a class="xref" href="alleg013.html#draw_lit_sprite">draw_lit_sprite</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="create_light_table">create_light_table</a>(COLOR_MAP *table, const PALETTE pal,</b>
<b>                        int r, g, b, void (*callback)(int pos));</b><br>
   Llena la tabla de mapeo de color especificada con los datos precalculados
   necesarios para hacer efectos de translucidez con la paleta especificada.
   Cuando se combinan los colores c1 y c2 con esta tabla, c1 se trata como
   un nivel de luz desde 0 a 255. Con un nivel de luz de 255 la tabla
   devolverá el color c2 sin cambios, con un nivel de luz 0 devolverá el
   valor r,g,b que especifque a la función, y con niveles de luz intermedios
   devolverá un color intermedio. Los valores r,g y b están entre 0-63. Si
   la función callback no es NULL, se la llamará 256 veces durante el
   cálculo, permitiéndole mostrar un indicador de progreso.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#color_map">color_map</a>,
<a class="xref" href="#create_trans_table">create_trans_table</a>,
<a class="xref" href="#create_color_table">create_color_table</a>,
<a class="xref" href="#create_blender_table">create_blender_table</a>,
<a class="xref" href="alleg013.html#draw_lit_sprite">draw_lit_sprite</a>.</font></blockquote>
<b>void <a name="create_trans_table">create_trans_table</a>(COLOR_MAP *table, const PALETTE pal,</b>
<b>                        int r, g, b, void (*callback)(int pos));</b><br>
   Rellena la tabla de color especificada con los datos precalculados
   necesarios para hacer efectos de translucidez con la paleta especificada.
   Cuando se combinan los colores c1 y c2 en esta tabla, el resultado será un
   color intermedio entre los dos. Los valores r, g, b que especifique son la
   solidez de cada componente de color, desde 0 (totalmente transparente)
   hasta 255 (totalmente sólido). Para una solidez del 50%, pasa 128. Esta
   función trata el color origen #0 como un caso especial, dejando el destino
   sin cambiar siempre que se encuentre un pixel del color cero, para que los
   sprites con máscara puedan ser dibujados correctamente. Si la función
   callback no es NULL, será llamada 256 veces durante el cálculo,
   permitiéndole enseñar un indicador de progreso.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#color_map">color_map</a>,
<a class="xref" href="#create_light_table">create_light_table</a>,
<a class="xref" href="#create_color_table">create_color_table</a>,
<a class="xref" href="alleg013.html#draw_trans_sprite">draw_trans_sprite</a>.</font></blockquote>
<b>void <a name="create_color_table">create_color_table</a>(COLOR_MAP *table, const PALETTE pal,</b>
<b>                        void (*blend)(PALETTE pal, int x, int y, RGB *rgb),</b>
<b>                        void (*callback)(int pos));</b><br>
   Llena la tabla de mapeo de color con datos precalculados necesarios
   para poder hacer efectos propios con la paelta especificada, llamando a la
   función de fundido para determinar los resultados de cada combinación de
   color. A su rutina de fundido se le pasará un puntero a la paleta y los
   dos colores que van a ser combinados, y debería devolver el resultado
   deseado en una estructura RGB con formato 0-63. Entonces Allegro buscará
   en la paleta aquél color que mejor encaje con el que pidió, por lo que no
   importa si la paleta no tiene un color que encaje exactamente. Si la
   función callback no es NULL, se le llamará 256 veces durante el cálculo,
   permitiéndole que muestre un indicador de progreso.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#color_map">color_map</a>,
<a class="xref" href="#create_light_table">create_light_table</a>,
<a class="xref" href="#create_trans_table">create_trans_table</a>,
<a class="xref" href="#create_blender_table">create_blender_table</a>.</font></blockquote>
<b>void <a name="create_blender_table">create_blender_table</a>(COLOR_MAP *table, const PALETTE pal,</b>
<b>                          void (*callback)(int pos));</b><br>
   Llena la tabla de mapeo de color especificada con datos precalculados
   para hacer un equivalente "paletizado" de cualquiera de los modos de
   fundido truecolor que esté actualmente seleccionado. Después de llamar a
   set_trans_blender(), set_blender_mode() o cualquiera de las otras rutinas
   de modo de fundido, puede usar esta función para crear un tabla de mapeo
   de 8 bits que tendrá los mismos resultados que el modo de fundido de 24
   bits que tenga seleccionado.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#color_map">color_map</a>,
<a class="xref" href="#create_light_table">create_light_table</a>,
<a class="xref" href="#create_trans_table">create_trans_table</a>,
<a class="xref" href="#create_color_table">create_color_table</a>,
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#set_blender_mode">set_blender_mode</a>.</font></blockquote>
<br><center><h2><a name="Transparencia en truecolor">Transparencia en truecolor</a></h2></center><p>
En los modo de video truecolor, la translucidez y la iluminación están
implementadas por una función de fundido de la forma:
<blockquote class="code"><pre>
   unsigned long (*BLENDER_FUNC)(unsigned long x, y, n);
</pre></blockquote>
Esta rutina toma dos colores como parámetros, los descompone en sus
componenetes rojo, verde y azul, los combina acorde con el valor de
interpolación n, y entonces fusiona de nuevo el resultado en un solo valor
de color, que devuelve.

<p>
Como estas rutinas se pueden usar desde diferentes profundidades de color,
hay tres callbacks, una para usar con píxels de 15 bits (5.5.5), una para
píxels de 16 bits (5.6.5), y otra para píxels de 24 bits (8.8.8), que puede
compartirse entre el código de 24 y 32 bits dado que el empaquetamiento de
bits es el mismo.

<p><br>
<b>void <a name="set_trans_blender">set_trans_blender</a>(int r, int g, int b, int a);</b><br>
   Selecciona el conjunto de rutinas de fundido por defecto, que hacen una
   interpolación lineal simple entre los colores fuente y destino. Cuando se
   llama a una función de dibujo translúcido, el parámetro alfa ajustado por
   esta rutina se usa como factor de interpolación, que controla la solidez
   del dibujado (de 0 a 255). Cuando una función de dibujo iluminado de
   es llamada, el valor alfa se ignora, y se usa el color pasado a la
   función de sprite para seleccionar un nivel alfa. La rutina de fundido
   se usará para interpolar entre el color del sprite y los valores RGB que
   se le pasaron a esta función (en un rango de 0 a 255).


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#color_map">color_map</a>,
<a class="xref" href="alleg013.html#draw_trans_sprite">draw_trans_sprite</a>,
<a class="xref" href="alleg013.html#draw_lit_sprite">draw_lit_sprite</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>,
<a class="xref" href="#set_add_blender">set_add_blender</a>,
<a class="xref" href="#set_burn_blender">set_burn_blender</a>,
<a class="xref" href="#set_color_blender">set_color_blender</a>,
<a class="xref" href="#set_blender_mode">set_blender_mode</a>,
<a class="xref" href="#set_alpha_blender">set_alpha_blender</a>,
<a class="xref" href="#set_write_alpha_blender">set_write_alpha_blender</a>,
<a class="xref" href="#set_difference_blender">set_difference_blender</a>,
<a class="xref" href="#set_dissolve_blender">set_dissolve_blender</a>,
<a class="xref" href="#set_dodge_blender">set_dodge_blender</a>,
<a class="xref" href="#set_hue_blender">set_hue_blender</a>,
<a class="xref" href="#set_invert_blender">set_invert_blender</a>,
<a class="xref" href="#set_luminance_blender">set_luminance_blender</a>,
<a class="xref" href="#set_multiply_blender">set_multiply_blender</a>,
<a class="xref" href="#set_saturation_blender">set_saturation_blender</a>,
<a class="xref" href="#set_screen_blender">set_screen_blender</a>.</font></blockquote>
<b>void <a name="set_alpha_blender">set_alpha_blender</a>();</b><br>
   Activa el modo de fundido especial de canal-alfa, que se usa para dibujar
   sprites RGBA de 32 bits. Después de llamar a esta función, puede usar
   draw_trans_sprite() o draw_trans_rle_sprite() para dibujar una imagen
   de 32 bits en un otra hicolor o truecolor. Los valore alfa se tomarán
   directamente del gráfico origen, asíq ue puede variar la solidez de cada
   parte de la imagen. Sin embargo, no puede usar ninguna de las funciones
   normales de translucidez mientras este modo esté activo, así que debería
   volver a uno de los modos normales de fundido (p.ej. set_trans_blender())
   antes de dibujar otra cosa que no sean sprites en RGBA de 32 bits.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="alleg013.html#draw_trans_sprite">draw_trans_sprite</a>,
<a class="xref" href="alleg014.html#draw_trans_rle_sprite">draw_trans_rle_sprite</a>,
<a class="xref" href="#set_write_alpha_blender">set_write_alpha_blender</a>.</font></blockquote>
<b>void <a name="set_write_alpha_blender">set_write_alpha_blender</a>();</b><br>
   Activa el modo especial de edición de canal-alfa, que se usa para dibujar
   canales alfa encima de un sprite RGB existente, para transformarlo en una
   imagen en formato RGBA. Después de llamar a esta función, puede ajustar
   el modo de dibujo a DRAW_MODE_TRANS y entonces escribir valores de color
   (de 0 a 255) en una imágen de 32 bits. Esto dejará los valores de color
   igual, pero alterará el alfa con los valores que esté escribiendo. Después
   de activar este modo también puede usar draw_trans_sprite() para
   superponer una mascara alfa de 8 bits encima de un sprite existente de 32
   bits.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_alpha_blender">set_alpha_blender</a>,
<a class="xref" href="alleg013.html#draw_trans_sprite">draw_trans_sprite</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_add_blender">set_add_blender</a>(int r, int g, int b, int a);</b><br>
   Activa un modo de fundido de color para combinar píxels truecolor
   iluminados o translúcidos.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_burn_blender">set_burn_blender</a>(int r, int g, int b, int a);</b><br>
   Activa un modo de fundido "chamuscado" para combinar píxels truecolor
   iluminados o translúcidos. Aquí el brillo de los colores de la imagen
   origen reduce el brillo de la imagen destino, oscureciendola.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_color_blender">set_color_blender</a>(int r, int g, int b, int a);</b><br>
   Activa  un modo de fundido de color para combinar píxels truecolor
   iluminados o translúcidos. Aplica sólo el tono y saturación de la imagen
   origen a la imagen destino. La luminosidad de la imagen destino no queda
   afectada.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_difference_blender">set_difference_blender</a>(int r, int g, int b, int a);</b><br>
   Activa el modo de fundido por diferencia para combinar píxels truecolor
   translúcidos o iluminados. Esto crea una imágen que tiene colores
   calculados por la diferencia entre los colores fuente y destino.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_dissolve_blender">set_dissolve_blender</a>(int r, int g, int b, int a);</b><br>
   Activa un modo de fundido por disolución para combinar píxels truecolor
   translúcidos o iluminados. Aleatoriamente, reemplaza los colores de
   algunos píxels de la imagen destino con los correspondientes de la
   imágen origen. El número de pixels reeemplazados depende del valor alpha
   (cuanto más alto sea el valor, más pixels se reemplazarán; va pillando la
   idea :)


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_dodge_blender">set_dodge_blender</a>(int r, int g, int b, int a);</b><br>
   Activa un mode de fundido "trucado" para combinar píxels truecolor
   iluminados o translúcidos. La claridad de colores en la imágen origen
   ilumina los colores de la imagen destino. El mayor efecto se consigue con
   el blanco; el negro no tiene ningún efecto.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_hue_blender">set_hue_blender</a>(int r, int g, int b, int a);</b><br>
   Activa un modo de fundido por tono para combinar píxels truecolor
   iluminados o translúcidos. Éste aplica el tono del origen al destino.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_invert_blender">set_invert_blender</a>(int r, int g, int b, int a);</b><br>
   Activa el modo de fundido inverso para combinar píxels truecolor
   iluminados o translúcidos. Funde el color inverso (o negativo) del
   origen con el de destino.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_luminance_blender">set_luminance_blender</a>(int r, int g, int b, int a);</b><br>
   Activa el modo de fundido de iluminación para combinar píxels truecolor
   iluminados o translúcidos. Aplica la ilumincación del origen al destino.
   El color de la destinación no queda afectado.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_multiply_blender">set_multiply_blender</a>(int r, int g, int b, int a);</b><br>
   Activa un modo de fundido por multiplicación para combinar píxels
   truecolor iluminados o translúcidoz. Combina las imágenes origen y
   destino, multiplicando los coloroes para producir un color más oscuro.
   Si el color se multiplica por blanco no cambia; cuando se multiplica
   por negro se vuelve negro.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_saturation_blender">set_saturation_blender</a>(int r, int g, int b, int a);</b><br>
   Activa un modo de fundido de saturación para combinar píxels truecolor
   iluminados o translúcidos. Aplica la saturación del origen a la imagen
   destino.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_screen_blender">set_screen_blender</a>(int r, int g, int b, int a);</b><br>
   Activa un modo de fundido de pantalla para combinar píxels truecolor
   iluminados o translúcidos. Este modo de fundido ilumina el color de la
   imagen destino multiplicando el color inverso del origen con el color
   destino. Es más o menos el opuesto al modo de fundido por multiplicación.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>.</font></blockquote>
<b>void <a name="set_blender_mode">set_blender_mode</a>(BLENDER_FUNC b15, b16, b24, int r, g, b, a);</b><br>
   Especifíca un conjunto de rutinas propias de fundido en truecolor, que
   pueden ser usadas para implementar cualquier modo de interpolación que
   necesite. Esta función comparte un único fundido entre los modos de 24 y
   32 bits.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="alleg013.html#draw_lit_sprite">draw_lit_sprite</a>,
<a class="xref" href="#drawing_mode">drawing_mode</a>,
<a class="xref" href="#set_blender_mode_ex">set_blender_mode_ex</a>,
<a class="xref" href="#set_trans_blender">set_trans_blender</a>,
<a class="xref" href="#color_map">color_map</a>,
<a class="xref" href="alleg013.html#draw_trans_sprite">draw_trans_sprite</a>.</font></blockquote>
<b>void <a name="set_blender_mode_ex">set_blender_mode_ex</a>(BLENDER_FUNC b15, b16, b24, b32, b15x, b16x, b24x,</b>
<b>                         int r, g, b, a);</b><br>
   Como set_blender_mode(), pero le permite especificar un conjunto más
   completo de rutinas de fundido. Las rutinas b15, b16, b24 y b32 se
   usan cuando se vayan a dibujar píxels en destinos con el mismo formato,
   meintras que b15x, b16x y b24x las usan draw_trans_sprite() y
   draw_trans_rle_sprite cuando van adibujar imágenes RGBA en un destino
   que tiene otro formato. Estos fundidos se les pasará un parámetro x de
   32 bits, junto con un valor y de una profundidad diferente de color, y
   debe hacer algo sensible como respuesta.




<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_blender_mode">set_blender_mode</a>,
<a class="xref" href="#set_alpha_blender">set_alpha_blender</a>.</font></blockquote>
<hr><a href="allegro.html">Volver al Indice</a>

</body>
</html>
