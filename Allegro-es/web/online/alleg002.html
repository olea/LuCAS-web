<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><title>
Manual de Allegro: 02 Rutinas de configuración
</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
<!--
A.xref:link    {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:visited {color: blue; text-decoration: none; background: rgb(255, 204, 50);}
A.xref:hover   {color: blue; text-decoration: underline; background: rgb(255, 224, 150);}
A.xref:active  {color: red; text-decoration: none; background: rgb(255, 204, 50);}
blockquote.xref {border: medium solid rgb(255, 204, 51); color: black; background: rgb(255, 204, 50);}
blockquote.code {border: medium solid rgb(255, 204, 50); color: black; background: rgb(255, 255, 155);}
blockquote.text {border: medium solid rgb(175, 235, 255); color: black; background: rgb(210, 244, 255);}
-->
</style>
</head><body bgcolor=white text=black link="#0000ee" alink="#ff0000" vlink="#551a8b">
<h1><a name="02 Rutinas de configuración">02 Rutinas de configuración</a></h1>

<ul>
<li><a href="#config_is_hooked">config_is_hooked</a>
<li><a href="#flush_config_file">flush_config_file</a>
<li><a href="#get_config_argv">get_config_argv</a>
<li><a href="#get_config_float">get_config_float</a>
<li><a href="#get_config_hex">get_config_hex</a>
<li><a href="#get_config_id">get_config_id</a>
<li><a href="#get_config_int">get_config_int</a>
<li><a href="#get_config_string">get_config_string</a>
<li><a href="#get_config_text">get_config_text</a>
<li><a href="#hook_config_section">hook_config_section</a>
<li><a href="#override_config_data">override_config_data</a>
<li><a href="#override_config_file">override_config_file</a>
<li><a href="#pop_config_state">pop_config_state</a>
<li><a href="#push_config_state">push_config_state</a>
<li><a href="#reload_config_texts">reload_config_texts</a>
<li><a href="#set_config_data">set_config_data</a>
<li><a href="#set_config_file">set_config_file</a>
<li><a href="#set_config_float">set_config_float</a>
<li><a href="#set_config_hex">set_config_hex</a>
<li><a href="#set_config_id">set_config_id</a>
<li><a href="#set_config_int">set_config_int</a>
<li><a href="#set_config_string">set_config_string</a>
</ul>

<p>
Varias partes de Allegro, como las rutinas de sonido y la función
load_joystick_data, requieren cierta información de configuración. Estos
datos son almacenados en ficheros de texto como una colección de líneas
"variable=valor", junto con comentarios que empiezan con el caracter '#' y
acaban al fina de la línea. El fichero de configuración puede estar dividido
en secciones que empiezan con una línea "[nombresección]". Cada sección
tiene un nombre único, para prevenir conflictos con los nombres, pero la
variable que no esté en una sección determinada es considerada perteneciente
a todas simultáneamente.

<p>
Por defecto los datos de configuración se lee de un fichero llamado
allegro.cfg, que puede estar en el mismo directoria que el programa
ejecutable o en el directorio apuntado por la variable de entorno ALLEGRO.
En Unix también busca en ~/allegro.cfg, ~/.allegrorc, /etc/allegro.cfg, y
/etc/allegrorc, en ese orden; bajo BeOS sólo comprueba los dós últimos. Si
esto no te gusta puedes especificar cualquier nombre de fichero, o usar un
bloque binario de datos de configuracion proporcionado por tu programa (que,
por ejemplo, puede ser cargado desde un fichero de datos).

<p>
Puede almacenar cualquier información que quiera en el fichero de
configuración, junto con las variables estándar usadas por Allegro (mire
abajo).

<p><br>
<b>void <a name="set_config_file">set_config_file</a>(const char *filename);</b><br>
   Especifica el fichero de configuración que será usado por las siguientes
   rutinas de configuración. Si no llama esta función, Allegro usará el
   fichero allegro.cfg, mirando primero en el directorio de su programa y
   luego en el directorio apuntado por la variable de entorno ALLEGRO.

<p>
   ¡Todos los punteros devueltos por llamadas previas a get_config_string()
   y demás funciones similares son invalidados tras llamar a esta función!


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_config_data">set_config_data</a>,
<a class="xref" href="#override_config_file">override_config_file</a>,
<a class="xref" href="#push_config_state">push_config_state</a>,
<a class="xref" href="#Variables de configuración estándar">Variables de configuración estándar</a>,
<a class="xref" href="#set_config_string">set_config_string</a>,
<a class="xref" href="#get_config_string">get_config_string</a>.</font></blockquote>
<b>void <a name="set_config_data">set_config_data</a>(const char *data, int length);</b><br>
   Especifica un bloque de datos que será usados por las siguientes rutinas
   de configuración, que previamente ha cargado del disco (ejemplo: como
   parte de un formato propio más complicado, o desde un fichero de datos).
   Esta rutina hace una copia de la información, por lo que puede liberar
   los datos después de llamarla.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#override_config_data">override_config_data</a>,
<a class="xref" href="#push_config_state">push_config_state</a>,
<a class="xref" href="#Variables de configuración estándar">Variables de configuración estándar</a>,
<a class="xref" href="#set_config_string">set_config_string</a>,
<a class="xref" href="#get_config_string">get_config_string</a>.</font></blockquote>
<b>void <a name="override_config_file">override_config_file</a>(const char *filename);</b><br>
   Especifica un fichero que contiene una configuración de sobreescritura.
   Sus datos serán usados además de los parámetros del fichero de
   configuración principal, y si hay una misma variable en ambos ficheros,
   la del fichero de sobreescritura tendrá preferencia. Esto puede ser usado
   por las aplicaciones del programador que deben tener ciertos valores de
   configuración fijos, pero otros del fichero de configuración principal
   pueden ser modificados por el usuario. Por ejemplo, podría especificar
   una frecuencia de muestreo de sonido y un fichero de instrumentos IBK
   específicos, pero el usuario podría usar un fichero sound.cfg o
   allegro.cfg para especificar los ajustes de su tarjeta de sonido
   (puertos, valores IRQ, etc).


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#override_config_data">override_config_data</a>,
<a class="xref" href="#set_config_file">set_config_file</a>.</font></blockquote>
<b>void <a name="override_config_data">override_config_data</a>(const char *data, int length);</b><br>
   Versión de override_config_file() que usa un bloque de datos que ya ha
   sido cargado en memoria.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#override_config_file">override_config_file</a>,
<a class="xref" href="#set_config_data">set_config_data</a>.</font></blockquote>
<b>void <a name="push_config_state">push_config_state</a>();</b><br>
   Almacena el estado actual de configuración (nombre de fichero, valores de
   las variables, etc) en una pila interna, permitiéndole seleccionar otro
   fichero de configuración para después recuperar la configuración actual
   llamando pop_config_state(). Esta función está pensada para uso interno
   por otras funciones de la biblioteca, por ejemplo, cuando quiere
   especificar el fichero de configuración de la función
   save_joystick_data(), almacena la configuración actual antes de usar la
   del fichero especificado.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#pop_config_state">pop_config_state</a>,
<a class="xref" href="#set_config_file">set_config_file</a>.</font></blockquote>
<b>void <a name="pop_config_state">pop_config_state</a>();</b><br>
   Recupera el estado previo de la configuración almacenado por la función
   push_config_state() sobreescribiendo el código del fichero de
   configuración actual.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#push_config_state">push_config_state</a>.</font></blockquote>
<b>void <a name="flush_config_file">flush_config_file</a>();</b><br>
   Escribe el contenido del fichero de configuración actual al disco en caso
   de que haya cambiado desde que fue cargado o desde la última llamada a
   esta función.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#override_config_file">override_config_file</a>,
<a class="xref" href="#push_config_state">push_config_state</a>.</font></blockquote>
<b>void <a name="reload_config_texts">reload_config_texts</a>(const char *new_language);</b><br>
   Recarga las cadenas traducidas devueltas por get_config_text. Esto es
   útil para cambiar a otro lenguaje en su programa en tiempo de ejecución.
   Si quiere modificar manualmente la variable de configuración [system]
   language, o ha cambiado de ficheros de comfiguración, querrá pasar NULL
   para recargar el lenguaje que esté seleccionado actualmente. O puede
   pasar una cadena que contenga el código de dos letras del lenguaje al que
   desea cambiar, y la función modificará la variable language. Tras la
   llamada a esta función, los punteros previamente devueltos por
   get_config_text serán inválidos.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_config_text">get_config_text</a>,
<a class="xref" href="#get_config_string">get_config_string</a>,
<a class="xref" href="#Variables de configuración estándar">Variables de configuración estándar</a>.</font></blockquote>
<b>void <a name="hook_config_section">hook_config_section</a>(const char *section,</b>
<b>       int (*intgetter)(const char *name, int def),</b>
<b>       const char *(*stringgetter)(const char *name, char *def),</b>
<b>       void (*stringsetter)(const char *name, const char *value));</b><br>
   Toma control de la sección especificada del fichero de configuración,
   para que sus funciones de enganche sean usadas para manipularlo, en vez
   del acceso de disco normal. Si tanto las funciones getter como setter son
   NULL, un enganche presente será desenganchado. Las funciones enganchadas
   tienen la máxima prioridad. Si una sección está enganchada, la función de
   enganche siempre será llamada, por lo que puede enganchar una sección
   '#': incluso tengrá prioridad sobre la función verride_config_file().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#config_is_hooked">config_is_hooked</a>.</font></blockquote>
<b>int <a name="config_is_hooked">config_is_hooked</a>(const char *section);</b><br>
   Devuelve TRUE si la sección especificada está siendo enganchada.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#hook_config_section">hook_config_section</a>.</font></blockquote>
<b>char *<a name="get_config_string">get_config_string</a>(const char *section,</b>
<b>                         const char *name, const char *def);</b><br>
   Recupera la cadena de texto de la variable name del fichero de
   configuración actual. Si la variable mencionada no es encontrada o su
   entrada está vacía, el valor def es devuelto. El nombre de sección puede
   ser NULL para aceptar variables de cualquier parte del fichero, o puede
   ser usado para controlar en qué conjunto de parámetros (ejemplo: sonido o
   joystick) va a buscar la variable.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_config_hex">get_config_hex</a>,
<a class="xref" href="#get_config_int">get_config_int</a>,
<a class="xref" href="#get_config_id">get_config_id</a>,
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#set_config_string">set_config_string</a>,
<a class="xref" href="#get_config_argv">get_config_argv</a>,
<a class="xref" href="#get_config_float">get_config_float</a>.</font></blockquote>
<b>int <a name="get_config_int">get_config_int</a>(const char *section, const char *name, int def);</b><br>
   Lee un entero de la variable name del fichero de configuración actual.
   Lea el comentario de la función get_config_string().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_config_float">get_config_float</a>,
<a class="xref" href="#get_config_hex">get_config_hex</a>,
<a class="xref" href="#get_config_id">get_config_id</a>,
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#set_config_int">set_config_int</a>,
<a class="xref" href="#get_config_string">get_config_string</a>,
<a class="xref" href="#get_config_argv">get_config_argv</a>.</font></blockquote>
<b>int <a name="get_config_hex">get_config_hex</a>(const char *section, const char *name, int def);</b><br>
   Lee un entero de la variable name del fichero de configuración actual, en
   formato hexadecimal. Lea el comentario de la función get_config_string().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_config_float">get_config_float</a>,
<a class="xref" href="#get_config_int">get_config_int</a>,
<a class="xref" href="#get_config_id">get_config_id</a>,
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#set_config_hex">set_config_hex</a>,
<a class="xref" href="#get_config_string">get_config_string</a>,
<a class="xref" href="#get_config_argv">get_config_argv</a>.</font></blockquote>
<b>float <a name="get_config_float">get_config_float</a>(const char *section, const char *name, float def);</b><br>
   Lee un número en coma flotante de la variable name del fichero de
   configuración actual. Lea el comentario de la función
   get_config_string().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_config_hex">get_config_hex</a>,
<a class="xref" href="#get_config_int">get_config_int</a>,
<a class="xref" href="#get_config_id">get_config_id</a>,
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#set_config_float">set_config_float</a>,
<a class="xref" href="#get_config_string">get_config_string</a>,
<a class="xref" href="#get_config_argv">get_config_argv</a>.</font></blockquote>
<b>int <a name="get_config_id">get_config_id</a>(const char *section, const char *name, int def);</b><br>
   Lee una variable ID de 4 letras del fichero de configuración actual. Lea
   el comentario de la función get_config_string();


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_config_float">get_config_float</a>,
<a class="xref" href="#get_config_hex">get_config_hex</a>,
<a class="xref" href="#get_config_int">get_config_int</a>,
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#set_config_id">set_config_id</a>,
<a class="xref" href="#get_config_string">get_config_string</a>,
<a class="xref" href="#get_config_argv">get_config_argv</a>.</font></blockquote>
<b>char **<a name="get_config_argv">get_config_argv</a>(const char *section, const char *name, int *argc);</b><br>
   Lee una lista de tokens (palabras separadas por espacios) del fichero de
   configuración actual, devolviendo una lista de argumentos al estilo de
   argv, y ajustando argc al número de tokens (a diferencia de argc/argv,
   esta lista tiene como base el cero). Devuelve NULL y ajusta argc a cero
   si la variable no esta presente. La lista de tokens es almacenada en un
   buffer temporal que será sobreescrito por la siguiente llamada a
   get_config_argv(), por lo que no espere que los datos persistan allí.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_config_int">get_config_int</a>,
<a class="xref" href="#get_config_id">get_config_id</a>,
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#get_config_string">get_config_string</a>,
<a class="xref" href="#get_config_float">get_config_float</a>,
<a class="xref" href="#get_config_hex">get_config_hex</a>.</font></blockquote>
<b>char *<a name="get_config_text">get_config_text</a>(const char *msg);</b><br>
   Esta función es usada principalmente por código interno de la biblioteca,
   pero también puede serle útil a los programadores de aplicaciones. Usa el
   fichero language.dat o los ficheros XXtext.cfg (donde XX es el código del
   lenguaje) para mirar una versión traducida del parámetro en el lenguage
   actualmente seleccionado, devolviendo una traducción si ésta existe o una
   copia del parámetro si no hay otra cosa disponible. Esto es básicamente
   lo mismo que llamar get_config_string() con [language] como sección, msg
   como nombre de variable, y msg como como valor por defecto, pero tiene
   código especial añadido para manejar conversiones entre formatos Unicode.
   El parámetro msg siempre se pasa en ASCII, pero la cadena devuelta será
   convertida al formato de texto actual, reservando memoria siempre que sea
   necesario, por lo que puede asumir que el puntero devuelto persistirá,
   sin que tenga que reservar memoria manualmente para cada cadena.


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#get_config_string">get_config_string</a>,
<a class="xref" href="#reload_config_texts">reload_config_texts</a>,
<a class="xref" href="#Variables de configuración estándar">Variables de configuración estándar</a>.</font></blockquote>
<b>void <a name="set_config_string">set_config_string</a>(const char *section, const char *name,</b>
<b>                        const char *val);</b><br>
   Escribe una cadena en la variable name del fichero de configuración
   actual, sobreescribiendo cualquier valor previo, o borra la variable si
   val es NULL. El nombre de sección puede ser NULL para escribir la
   variable en la raíz del fichero, o puede ser usada para especificar la
   sección en la que desea insertar la variable. El fichero alterado será
   puesto en memoria cache, y no será escrito en disco hasta que llame
   allegro_exit(). Tenga en cuenta que sólo puede escribir en los ficheros
   de este modo, por lo que la función no tendrá efecto si el fichero de
   configuración actual fue especificado con set_config_data() en vez de con
   set_config_file().

<p>
   Como caso especial, las variables o nombres de sección que comienzan con
   el carácter '#' son tratadas especialmente y no serán leídas o escritas
   en disco. Los paquetes adicionales pueden usar esto para almacenar
   información de version y otra información de estado en el módulo de
   configuración, desde el cual puede ser leída con la función
   get_config_string().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#get_config_string">get_config_string</a>,
<a class="xref" href="#set_config_float">set_config_float</a>,
<a class="xref" href="#set_config_hex">set_config_hex</a>,
<a class="xref" href="#set_config_int">set_config_int</a>,
<a class="xref" href="#set_config_id">set_config_id</a>.</font></blockquote>
<b>void <a name="set_config_int">set_config_int</a>(const char *section, const char *name, int val);</b><br>
   Escribe un entero en una variable en el fichero de configuración actual.
   Lea el comentario de set_config_string().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#get_config_int">get_config_int</a>,
<a class="xref" href="#set_config_string">set_config_string</a>,
<a class="xref" href="#set_config_float">set_config_float</a>,
<a class="xref" href="#set_config_hex">set_config_hex</a>,
<a class="xref" href="#set_config_id">set_config_id</a>.</font></blockquote>
<b>void <a name="set_config_hex">set_config_hex</a>(const char *section, const char *name, int val);</b><br>
   Escribe un entero en una variable en el fichero de configuración actual,
   en formato hexadecimal. Lea el comentario de set_config_string().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#get_config_hex">get_config_hex</a>,
<a class="xref" href="#set_config_string">set_config_string</a>,
<a class="xref" href="#set_config_float">set_config_float</a>,
<a class="xref" href="#set_config_int">set_config_int</a>,
<a class="xref" href="#set_config_id">set_config_id</a>.</font></blockquote>
<b>void <a name="set_config_float">set_config_float</a>(const char *section, const char *name, float val);</b><br>
   Escribe un número en coma flotante en una variable en el fichero de
   configuración actual. Lea el comentario de set_config_string().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#get_config_float">get_config_float</a>,
<a class="xref" href="#set_config_string">set_config_string</a>,
<a class="xref" href="#set_config_hex">set_config_hex</a>,
<a class="xref" href="#set_config_int">set_config_int</a>,
<a class="xref" href="#set_config_id">set_config_id</a>.</font></blockquote>
<b>void <a name="set_config_id">set_config_id</a>(const char *section, const char *name, int val);</b><br>
   Escribe una variable ID de 4 letras en el fichero de configuración
   actual. Lea el comentario de la función set_config_string().


<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#get_config_id">get_config_id</a>,
<a class="xref" href="#set_config_string">set_config_string</a>,
<a class="xref" href="#set_config_float">set_config_float</a>,
<a class="xref" href="#set_config_hex">set_config_hex</a>,
<a class="xref" href="#set_config_int">set_config_int</a>.</font></blockquote>
<br><center><h2><a name="Variables de configuración estándar">Variables de configuración estándar</a></h2></center><p>
Allegro usa las siguientes variables estándar del fichero de configuración:
<ul><li>
[system]<br>
   Sección que contiene variables de propósito general, que son:
<ul><li>
system = x<br>
   Especifica que driver de sistema usar. Actualmente ésto sólo es útil en
   Linux, para escoger entre los modos XWindows ("XWIN") o consola ("LNXC").
<li>
keyboard = x<br>
   Especifica el mapa de teclado a usar. El parámetro es el nombre de un
   mapa de teclado producido por la utilidad keyconf, y puede ser un nombre
   de fichero normal o un nombre base como "us" o "uk". En este último caso,
   Allegro buscará primero un fichero de configuración independiente con ese
   nombre (ej: "uk.cfg") y después un objeto con ese nombre en el fichero
   keyboard.dat (ej: "UK_CFG"). El fichero de configuración o el fichero
   keyboard.dat pueden ser almacenados en el mismo directorio que su
   programa, o en una directorio apuntado por la variable de entorno
   ALLEGRO. Mire en el fichero keyboard.dat para ver los mapas de teclado
   disponibles.
<li>
language = x<br>
   Especifica que fichero de lenguaje se usará para los mensajes de error y
   otros trozos de texto de sistema. El parámetro es el nombre de un fichero
   de traducción, y puede ser o un path completo o un nombre "base" como "en"
   o "sp". Si es esto último Allegro buscará primero un fichero de
   cofiguración a parte, con un nombre con la forma "entext.cfg", y después
   por un objeto con ese nombre en el fichero language.dat (ej: "
   ENTEXT_CFG"). El fichero de configuración o el fichero language.dat pueden
   ser guardados en el mismo directorio que el programa o en el directorio
   apuntado por la variable de entorno ALLEGRO. Mire el fichero language.dat
   para saber que traducciones están disponibles actualmente.
<li>
menu_opening_delay = x<br>
   Ajusta el tiempo que tiene que pasar antes de que un menú se abra
   automáticamente. El tiempo se da en milisegundos (por defecto 300).
   Especificando -1 se desactivará la característica de auto-apertura.
<li>
dga_mouse = x<br>
   Sólo X: desactive para evitar un fallo en algunos servidores X en
   modo DGA, concerniente al ratón. Por defecto está activado; active el
   parche ajustando la variable a "0".
<li>
dga_centre = x<br>
   Sólo X: indica al controlador DGA de Allegro que centre la pantalla si
   la resolución actual es mayor que la del programa Allegro. Por defecto
   activada; desactívela ajustando la variable a "0".
<li>
dga_clear = x<br>
   Sólo X: indica al controlador DGA de Allegro limpiar la memoria de vídeo
   visible durante la inicialización. Por defecto activada; desactívela
   ajustando la variable a "0".
</ul><li>
[graphics]<br>
   Sección que contiene la configuración gráfica, usando las siguientes
   variables:
<ul><li>
gfx_card = x<br>
   Especifica el controlador gráfico a usar cuando el programa haga una
   petición GFX_AUTODETECT. Se pueden sugerir múltiples controladores
   posibles con líneas extra en la forma "gfx_card2 = x", "gfx_card3 = x",
   etc, o puede especificar diferentes controladores para cada modo y
   profundidad de color con variables tipo "gfx_card_24bpp = x",
   "gfx_card_640x480x16 = x", etc.
<li>
gfx_cardw = x<br>
   Especifica qué driver gráfico usar cuando el programa use
   GFX_AUTODETECT_WINDOWED. Esta variable funciona en lo demás exáctamente
   igual que gfx_card. Si no existe, Allegro usará la variable gfx_card.
<li>
vbeaf_driver = x<br>
   Sólo DOS y Linux: especifica dónde buscar el controlador VBE/AF
   (vbeaf.drv). Si esta variable no está activada, Allegro buscará en el
   directorio del programa, y luego pasaría a buscará en los sitios
   estándar (c:\ para DOS, /usr/local/lib, /usr/lib, /lib, y / para Linux, o
   el directorio especificado por la variable de entorno VBEAF_PATH).
<li>
framebuffer = x<br>
   Sólo para Linux: especifica el fichero de dispositivo que hay que usar con
   el controlador fbcon. Si esta variable no está activada, Allegro mirará en
   la variable de entorno FRAMEBUFFER. Por defecto se usará /dev/fb0.
</ul><li>
[mouse]<br>
   Sección que contiene la configuración del ratón, usando las siguientes
   variables:
<ul><li>
mouse = x<br>
   Tipos de driver para ratón. Los drivers disponibles para DOS son:<blockquote class="text"><pre>
      MICK - driver en modo mickey (normalmente el mejor)
      I33  - Driver para atender a la interrupción 0x33
      POLL - muestreo temporizado (para uso bajo NT)</pre></blockquote>
   Los drivers para la consola de Linux son:<blockquote class="text"><pre>
      MS   - Ratón série de Microsoft
      IMS  - Ratón série de Microsoft con extensión Intellimouse
      LPS2 - Ratón PS2
      LIPS - Ratón PS2 con extensión Intellimouse
      GPMD - repetidor de datos GPM (Protocolo Mouse Systems)</pre></blockquote>
<li>
num_buttons = x<br>
   Ajusta del número de botones de ratón vistos por Allegro. Normalmente no
   necesitará ajustar esta variable porque Allegro la autodetectará. Sólo
   podrá usarla para restringir el número de botones del ratón.
<li>
emulate_three = x<br>
   Especifica si hay que emular un tercer botón de ratón detectando
   pulsaciones simultáneas de los botones izquiedo y derecho (si o no). Por
   defecto activado (yes) si se dispone de un ratón de dos botones. En caso
   contrario, desactivado (no).
<li>
mouse_device = x<br>
   Sólo para Linux: especifica el nombre del archivo de dispositivo del
   ratón (ej: /dev/mouse).
<li>
mouse_accel_factor = x<br>
   Sólo Windows: especifica el factor de aceleración del ratón. Por defecto
   es 1. Modifíquelo a 0 para desactivar la aceleración. Un 2 acelerará el
   ratón el doble que un 1.
</ul><li>
[sound]<br>
   Sección que contiene la configuración de sonido, usando las siguientes
   variables:
<ul><li>
digi_card = x<br>
   Elige el controlador para reproducir samples.
<li>
midi_card = x<br>
   Elige el controlador para reproducir música MIDI.
<li>
digi_input_card = x<br>
   Determina el controlador de entrada de sonido digital.
<li>
midi_input_card = x<br>
   Determina el controlador de entrada para datos MIDI.
<li>
digi_voices = x<br>
   Especifica el número mínimo de voces que reservará el controlador de
   sonido digital. El número de voces posibles depende del controlador.
<li>
midi_voices = x<br>
   Especifica el número mínimo de voces que reservará el controlador de
   música MIDI. El número de voces posibles depende del controlador.
<li>
digi_volume = x<br>
   Ajusta el volumen de reproducción de sonidos, de 0 a 255.
<li>
midi_volume = x<br>
   Ajusta el volumen de reproducción de música midi, de 0 a 255.
<li>
quality = x<br>
   Controla la balanza calidad vs. rapidez del sonido del código de mezcla
   de samples. Esto puede ser cualquiera de los siguientes valores:<blockquote class="text"><pre>
      0 - mezcla rápida de datos 8 bit en buffers de 16 bits
      1 - mezcla verdadera de 16 bits (requiere una tarjeta de 16 bits
          estéreo)
      2 - mezcla 16 bits interpolada</pre></blockquote>
<li>
flip_pan = x<br>
   Ajustando esto entre 0 y 1 invierte la panoramización izquierda/derecha
   de los samples, que puede ser necesaria porque algunas tarjetas SB
   (incluyendo la mía :-) crean la imagen estéro al revés.
<li>
sound_freq = x<br>
   DOS, Unix y BeOS: ajusta la frecuencia de los samples. Con el controlador
   de la SB, los valores posibles son 11906 (cualquier SB), 16129 (cualquier
   SB), 22727 (SB 2.0 y superiores), y 45454 (sólo en SB 2.0 o SB16, no la SB
   Pro estéreo). Con el controlador de la ESS Audiodrive, los valores
   posibles son 11363, 17046, 22729, o 44194. Con la Ensoniq Soundscape, los
   valores posibles son 11025, 16000, 22050, o 48000. Con Windows Sound
   System, los valores posibles son 11025, 22050, 44100, o 48000. No se
   preocupe si establece un valor inexistente por error: Allegro lo
   redondeará automáticamente a la frecuencia más cercana soportada por su
   tarjeta de sonido.
<li>
sound_bits = x<br>
   Unix y BeOS: establece el número de bits deseados (8 o 16).
<li>
sound_stereo = x<br>
   Unix y BeOS: selecciona salida mono o estéreo (0 o 1 respectivamente).
<li>
sound_port = x<br>
   Sólo DOS: establece el puerto de la tarjeta de sonido (normalmente 220).
<li>
sound_dma = x<br>
   Sólo DOS: establece el canal DMA de la tarjeta de sonido (normalmente 1).
<li>
sound_irq = x<br>
   Sólo DOS: establece el canal IRQ de la tarjeta de sonido (normalmente 7).
<li>
fm_port = x<br>
   Determina el puerto del chip OPL (esto es normalmente 388).
<li>
mpu_port = x<br>
   Determina el puerto de la interfaz MIDI MPU-401 (esto es normalmente 330).
<li>
mpu_irq = x<br>
   Determina el IRQ del MPU-401 (esto es normalmente igual a sb_irq).
<li>
ibk_file = x<br>
   Especifica el nombre de un fichero .IBK que será usado para sustituir el
   conjunto estándar de instrumentos Adlib.
<li>
ibk_drum_file = x<br>
   Especifica el nombre de un fichero .IBK que será usado para sustituir el
   conjunto estándar de percusión Adlib.
<li>
oss_driver = x<br>
   Sólo Unix: establece el nombre del dispositivo OSS. Normalmente /dev/dsp o
   /dev/audio, pero podría ser un dispositivo particular (ej: /dev/dsp2).
<li>
oss_numfrags = x<br>
oss_fragsize = x<br>
   Sólo Unix: establece el número de fragmentos (buffers) del controlador OSS
   y el tamaño de cada buffer en samples. Los buffers son rellenados con
   datos durante la interrupción donde el intervalo entre las siguientes
   interrupciones no es menor que 10 ms. Si el hardware puede reproducir toda
   la información de los buffers en menos de 10 ms, entonces se oirán clicks,
   cuando el hardware haya reproducido todos los datos y la biblioteca
   todavía no ha preparado los nuevos datos. Por otra parte, si el hardware
   tarda mucho en reproducir los datos de los buffers, entonces habrá
   restrasos entre las acciones que provocan los sonidos y los propios
   sonidos.
<li>
oss_midi_driver = x<br>
   Sólo Unix: establece el nombre del dispositivo MIDI OSS. Normalmente
   /dev/sequencer.
<li>
oss_mixer_driver = x<br>
   Sólo Unix: establece el nombre del mezclador OSS. Normalmente /dev/mixer.
<li>
esd_server = x<br>
   Sólo Unix: indica dónde encontrar el servidor ESD (Enlightened Sound
   Daemon).
<li>
alsa_card = x<br>
alsa_pcmdevice = x<br>
   Sólo Unix: parámetros del sistema de sonido ALSA.
<li>
alsa_numfrags = x<br>
   Sólo Unix. número de fragmentos (buffers) del sistema de sonido ALSA.
<li>
alsa_fragsize = x<br>
   Sólo Unix: tamaño de cada fragmento ALSA, en samples.
<li>
alsa_rawmidi_card = x<br>
   Sólo Unix: para el controlador MIDI de ALSA.
<li>
alsa_rawmidi_device = x<br>
   Sólo Unix: para el controlador MIDI de ALSA.
<li>
alsa_input_card = x<br>
   Sólo Unix: para el controlador MIDI de ALSA.
<li>
alsa_rawmidi_input_device = x<br>
   Sólo Unix: para el controlador MIDI de ALSA.
<li>
be_midi_quality = x<br>
   Sólo BeOS: calidad del sintetizador de instrumentos MIDI. 0 usa baja
   calidad de samples de 8-bit a 11kHz, 1 usa samples de 16-bit a 22kHz.
<li>
be_midi_freq = x<br>
   Sólo BeOS: frecuencia de mezclado de samples MIDI en Hz. Puede ser
   11025, 22050 o 44100.
<li>
be_midi_interpolation = x<br>
   Sólo BeOS: especifica el método de interpolación de samples MIDI. 0 para
   no usar interpolación, es rápido pero de mala calidad; 1 hace una
   interpolación rápida con buen rendimiento, pero es algo más lento que lo
   anterior; 2 usa una interpolación lineal entre samples, que es el método
   más lento pero con el cual se obtiene la mejor calidad.
<li>
be_midi_reverb = x<br>
   Sólo BeOS: intensidad de reverberación, de 0 a 5. 0 la desactiva, un 5
   es el valor más fuerte.
<li>
patches = x<br>
   Especifica dónde encontrar el conjunto de samples para el controlador
   DIGMID. Esto puede ser un directorio al estilo Gravis conteniendo una
   colección de ficheros .pat y un índice default.cfg, o un fichero de datos
   producido por la utilidad pat2dat. Si esta variable no es especificada,
   Allegro buscará un fichero default.cfg o patches.dat en el directorio del
   programa, en el directorio apuntado por la variable de entorno ALLEGRO, y
   en un directorio estándar GUS apuntado por la variable de entorno
   ULTRASND.
</ul><li>
[midimap]<br>
   Si está usando los controladores de salida MIDI SB o MPU-401 con un
   sintetizador externo que no es compatible General MIDI, puede usar la
   sección midmap del fichero de configuración para especificar una tabla de
   mapa para convertir los números de los patches GM en sonidos apropiados
   de su sintetizador. Esto es una muestra real de indulgencia propia. Tengo
   un Yamaha TG500, que tiene algunos sonidos geniales pero no tiene
   conjunto de patches GM, y simplemente tenía que hacerlo funcionar de
   alguna manera...

   Esta sección consiste de una serie de líneas en la forma:
<ul><li>
p&lt;n&gt; = bank0 bank1 prog pitch<br>
   Con este comando, n es el número de programa GM a cambiar (1-128), bank0
   y bank1 son los dos bancos de mensajes de cambio a mandar a tu
   sintetizador (en controladores #0 y #32), prog es el mensaje de cambio de
   programa a tu sintetizador, y pitch es el número de semitonos a cambiar
   para todo lo que suene con ese sonido. Ajustando los números de cambio de
   banco a -1 hará que no sean mandados.

   Por ejemplo, la línea:

      p36 = 0 34 9 12

   especifica que cuando el programa 36 GM (que es un bajo) sea
   seleccionado, Allegro mandará un mensaje de cambio de banco #0 con el
   parámetro 0, un mensaje de cambio de banco #32 con el parámetro 34, un
   cambio de programa con el parámetro 9, y entonces lo subirá todo una
   octava.
</ul><li>
[joystick]<br>
   Sección que contiene la configuración del joystick, usando las siguientes
   variables:
<ul><li>
joytype = x<br>
   Especifica qué driver de joystick usar cuando el programa solicita usar
   JOY_TYPE_AUTODETECT.
<li>
joystick_device = x<br>
   Sólo BeOS: especifica el nombre del dispositivo joystick que será usado.
   Por defecto se usa el primer dispositivo encontrado.
<li>
throttle_axis = x<br>
   Sólo Linux: establece en qué eje está localizado el mando de gases. Esta
   variable será usada por cada joystick detectado. Si quiere especificar el
   eje de cada joystick individualmente, use variables con la forma
   throttle_axis_n, donde n sea el número del joystick.
</ul>
</ul>



<blockquote class="xref"><font size="-1" face="helvetica,verdana"><em><b>Relacionado con:</b></em>
<a class="xref" href="#set_config_file">set_config_file</a>,
<a class="xref" href="#set_config_string">set_config_string</a>,
<a class="xref" href="#get_config_string">get_config_string</a>.</font></blockquote>
<hr><a href="allegro.html">Volver al Indice</a>

</body>
</html>
